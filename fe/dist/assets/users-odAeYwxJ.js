const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      'assets/sheetUsers-BH1xEubn.js',
      'assets/index-CLga5zNi.js',
      'assets/index-BX2ep-3q.css',
      'assets/sheetUsers-CdWOBAR0.css',
    ]),
) => i.map((i) => d[i])
import {
  r as d,
  L as cS,
  l as rh,
  I as Fi,
  _ as xe,
  a as re,
  R as uS,
  b as Qg,
  c as Sa,
  d as Zt,
  g as dS,
  e as hS,
  w as bt,
  C as vu,
  f as $s,
  h as pe,
  i as qt,
  u as xo,
  j as Bt,
  k as $,
  s as gS,
  m as wa,
  n as Xg,
  S as fS,
  o as pS,
  p as Jg,
  q as ce,
  t as mS,
  v as vS,
  x as qa,
  y as Qa,
  z as Kt,
  K as un,
  A as CS,
  B as Jt,
  D as Ol,
  E as dn,
  F as de,
  G as SS,
  H as Cu,
  J as Vn,
  M as Cr,
  N as zs,
  O as wS,
  P as ai,
  Q as Z,
  T as tt,
  U as yS,
  V as Zg,
  W as ef,
  X as tf,
  Y as bS,
  Z as St,
  $ as RS,
  a0 as FS,
  a1 as li,
  a2 as Do,
  a3 as ES,
  a4 as ya,
  a5 as PS,
  a6 as xS,
  a7 as DS,
  a8 as Ts,
  a9 as MS,
  aa as IS,
  ab as Ns,
  ac as sf,
  ad as nf,
  ae as rf,
  af as of,
  ag as ho,
  ah as ba,
  ai as af,
  aj as Sr,
  ak as Gs,
  al as Su,
  am as TS,
  an as _n,
  ao as Wn,
  ap as AS,
  aq as OS,
  ar as LS,
  as as kS,
  at as HS,
  au as Ra,
  av as lf,
  aw as NS,
  ax as GS,
  ay as BS,
  az as VS,
  aA as Oe,
  aB as cf,
  aC as _S,
  aD as WS,
  aE as $S,
  aF as oh,
  aG as zS,
  aH as uf,
  aI as US,
} from './index-CLga5zNi.js'
const wu = (e, t) => {
  const i = d.useContext(cS),
    s = d.useMemo(() => {
      var r
      const o = t || rh[e],
        a = (r = i == null ? void 0 : i[e]) !== null && r !== void 0 ? r : {}
      return Object.assign(
        Object.assign({}, typeof o == 'function' ? o() : o),
        a || {},
      )
    }, [e, t, i]),
    n = d.useMemo(() => {
      const r = i == null ? void 0 : i.locale
      return i != null && i.exist && !r ? rh.locale : r
    }, [i])
  return [s, n]
}
var jS = {
    icon: {
      tag: 'svg',
      attrs: {
        'fill-rule': 'evenodd',
        viewBox: '64 64 896 896',
        focusable: 'false',
      },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z',
          },
        },
      ],
    },
    name: 'close-circle',
    theme: 'filled',
  },
  YS = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: jS }))
  },
  df = d.forwardRef(YS),
  KS = {
    icon: {
      tag: 'svg',
      attrs: {
        'fill-rule': 'evenodd',
        viewBox: '64 64 896 896',
        focusable: 'false',
      },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z',
          },
        },
      ],
    },
    name: 'close',
    theme: 'outlined',
  },
  qS = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: KS }))
  },
  hf = d.forwardRef(qS),
  QS = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`,
  XS = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`,
  JS = ''
    .concat(QS, ' ')
    .concat(XS)
    .split(/[\s\n]+/),
  ZS = 'aria-',
  ew = 'data-'
function ah(e, t) {
  return e.indexOf(t) === 0
}
function Bs(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    i
  t === !1
    ? (i = { aria: !0, data: !0, attr: !0 })
    : t === !0
      ? (i = { aria: !0 })
      : (i = re({}, t))
  var s = {}
  return (
    Object.keys(e).forEach(function (n) {
      ;((i.aria && (n === 'role' || ah(n, ZS))) ||
        (i.data && ah(n, ew)) ||
        (i.attr && JS.includes(n))) &&
        (s[n] = e[n])
    }),
    s
  )
}
var Mo = re({}, uS),
  tw = Mo.version,
  iw = Mo.render,
  sw = Mo.unmountComponentAtNode,
  Xa
try {
  var nw = Number((tw || '').split('.')[0])
  nw >= 18 && (Xa = Mo.createRoot)
} catch {}
function lh(e) {
  var t = Mo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  t && Zt(t) === 'object' && (t.usingClientEntryPoint = e)
}
var Fa = '__rc_react_root__'
function rw(e, t) {
  lh(!0)
  var i = t[Fa] || Xa(t)
  lh(!1), i.render(e), (t[Fa] = i)
}
function ow(e, t) {
  iw(e, t)
}
function aw(e, t) {
  if (Xa) {
    rw(e, t)
    return
  }
  ow(e, t)
}
function lw(e) {
  return Ec.apply(this, arguments)
}
function Ec() {
  return (
    (Ec = Qg(
      Sa().mark(function e(t) {
        return Sa().wrap(function (s) {
          for (;;)
            switch ((s.prev = s.next)) {
              case 0:
                return s.abrupt(
                  'return',
                  Promise.resolve().then(function () {
                    var n
                    ;(n = t[Fa]) === null || n === void 0 || n.unmount(),
                      delete t[Fa]
                  }),
                )
              case 1:
              case 'end':
                return s.stop()
            }
        }, e)
      }),
    )),
    Ec.apply(this, arguments)
  )
}
function cw(e) {
  sw(e)
}
function uw(e) {
  return Pc.apply(this, arguments)
}
function Pc() {
  return (
    (Pc = Qg(
      Sa().mark(function e(t) {
        return Sa().wrap(function (s) {
          for (;;)
            switch ((s.prev = s.next)) {
              case 0:
                if (Xa === void 0) {
                  s.next = 2
                  break
                }
                return s.abrupt('return', lw(t))
              case 2:
                cw(t)
              case 3:
              case 'end':
                return s.stop()
            }
        }, e)
      }),
    )),
    Pc.apply(this, arguments)
  )
}
const dw = (e) => {
    const { componentCls: t, colorPrimary: i } = e
    return {
      [t]: {
        position: 'absolute',
        background: 'transparent',
        pointerEvents: 'none',
        boxSizing: 'border-box',
        color: `var(--wave-color, ${i})`,
        boxShadow: '0 0 0 0 currentcolor',
        opacity: 0.2,
        '&.wave-motion-appear': {
          transition: [
            `box-shadow 0.4s ${e.motionEaseOutCirc}`,
            `opacity 2s ${e.motionEaseOutCirc}`,
          ].join(','),
          '&-active': { boxShadow: '0 0 0 6px currentcolor', opacity: 0 },
          '&.wave-quick': {
            transition: [
              `box-shadow ${e.motionDurationSlow} ${e.motionEaseInOut}`,
              `opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`,
            ].join(','),
          },
        },
      },
    }
  },
  hw = dS('Wave', (e) => [dw(e)]),
  gf = `${hS}-wave-target`
function Ll(e) {
  return (
    e &&
    e !== '#fff' &&
    e !== '#ffffff' &&
    e !== 'rgb(255, 255, 255)' &&
    e !== 'rgba(255, 255, 255, 1)' &&
    !/rgba\((?:\d*, ){3}0\)/.test(e) &&
    e !== 'transparent'
  )
}
function gw(e) {
  const {
    borderTopColor: t,
    borderColor: i,
    backgroundColor: s,
  } = getComputedStyle(e)
  return Ll(t) ? t : Ll(i) ? i : Ll(s) ? s : null
}
function kl(e) {
  return Number.isNaN(e) ? 0 : e
}
const fw = (e) => {
    const { className: t, target: i, component: s } = e,
      n = d.useRef(null),
      [r, o] = d.useState(null),
      [a, l] = d.useState([]),
      [c, u] = d.useState(0),
      [h, g] = d.useState(0),
      [f, p] = d.useState(0),
      [v, m] = d.useState(0),
      [C, w] = d.useState(!1),
      S = {
        left: c,
        top: h,
        width: f,
        height: v,
        borderRadius: a.map((R) => `${R}px`).join(' '),
      }
    r && (S['--wave-color'] = r)
    function y() {
      const R = getComputedStyle(i)
      o(gw(i))
      const b = R.position === 'static',
        { borderLeftWidth: x, borderTopWidth: D } = R
      u(b ? i.offsetLeft : kl(-parseFloat(x))),
        g(b ? i.offsetTop : kl(-parseFloat(D))),
        p(i.offsetWidth),
        m(i.offsetHeight)
      const {
        borderTopLeftRadius: O,
        borderTopRightRadius: M,
        borderBottomLeftRadius: L,
        borderBottomRightRadius: V,
      } = R
      l([O, M, V, L].map((A) => kl(parseFloat(A))))
    }
    if (
      (d.useEffect(() => {
        if (i) {
          const R = bt(() => {
            y(), w(!0)
          })
          let b
          return (
            typeof ResizeObserver < 'u' &&
              ((b = new ResizeObserver(y)), b.observe(i)),
            () => {
              bt.cancel(R), b == null || b.disconnect()
            }
          )
        }
      }, []),
      !C)
    )
      return null
    const F =
      (s === 'Checkbox' || s === 'Radio') &&
      (i == null ? void 0 : i.classList.contains(gf))
    return d.createElement(
      vu,
      {
        visible: !0,
        motionAppear: !0,
        motionName: 'wave-motion',
        motionDeadline: 5e3,
        onAppearEnd: (R, b) => {
          var x
          if (b.deadline || b.propertyName === 'opacity') {
            const D =
              (x = n.current) === null || x === void 0
                ? void 0
                : x.parentElement
            uw(D).then(() => {
              D == null || D.remove()
            })
          }
          return !1
        },
      },
      (R, b) => {
        let { className: x } = R
        return d.createElement('div', {
          ref: $s(n, b),
          className: pe(t, x, { 'wave-quick': F }),
          style: S,
        })
      },
    )
  },
  pw = (e, t) => {
    var i
    const { component: s } = t
    if (
      s === 'Checkbox' &&
      !(!((i = e.querySelector('input')) === null || i === void 0) && i.checked)
    )
      return
    const n = document.createElement('div')
    ;(n.style.position = 'absolute'),
      (n.style.left = '0px'),
      (n.style.top = '0px'),
      e == null || e.insertBefore(n, e == null ? void 0 : e.firstChild),
      aw(d.createElement(fw, Object.assign({}, t, { target: e })), n)
  },
  mw = (e, t, i) => {
    const { wave: s } = d.useContext(qt),
      [, n, r] = xo(),
      o = Bt((c) => {
        const u = e.current
        if ((s != null && s.disabled) || !u) return
        const h = u.querySelector(`.${gf}`) || u,
          { showEffect: g } = s || {}
        ;(g || pw)(h, {
          className: t,
          token: n,
          component: i,
          event: c,
          hashId: r,
        })
      }),
      a = d.useRef()
    return (c) => {
      bt.cancel(a.current),
        (a.current = bt(() => {
          o(c)
        }))
    }
  },
  ff = (e) => {
    const { children: t, disabled: i, component: s } = e,
      { getPrefixCls: n } = d.useContext(qt),
      r = d.useRef(null),
      o = n('wave'),
      [, a] = hw(o),
      l = mw(r, pe(o, a), s)
    if (
      ($.useEffect(() => {
        const u = r.current
        if (!u || u.nodeType !== 1 || i) return
        const h = (g) => {
          !Xg(g.target) ||
            !u.getAttribute ||
            u.getAttribute('disabled') ||
            u.disabled ||
            u.className.includes('disabled') ||
            u.className.includes('-leave') ||
            l(g)
        }
        return (
          u.addEventListener('click', h, !0),
          () => {
            u.removeEventListener('click', h, !0)
          }
        )
      }, [i]),
      !$.isValidElement(t))
    )
      return t ?? null
    const c = gS(t) ? $s(t.ref, r) : r
    return wa(t, { ref: c })
  },
  Us = (e) => {
    const t = $.useContext(fS)
    return $.useMemo(
      () =>
        e
          ? typeof e == 'string'
            ? (e ?? t)
            : e instanceof Function
              ? e(t)
              : t
          : t,
      [e, t],
    )
  }
var vw = function (e, t) {
  var i = {}
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) &&
      t.indexOf(s) < 0 &&
      (i[s] = e[s])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
      t.indexOf(s[n]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
        (i[s[n]] = e[s[n]])
  return i
}
const pf = d.createContext(void 0),
  Cw = (e) => {
    const { getPrefixCls: t, direction: i } = d.useContext(qt),
      { prefixCls: s, size: n, className: r } = e,
      o = vw(e, ['prefixCls', 'size', 'className']),
      a = t('btn-group', s),
      [, , l] = xo()
    let c = ''
    switch (n) {
      case 'large':
        c = 'lg'
        break
      case 'small':
        c = 'sm'
        break
    }
    const u = pe(a, { [`${a}-${c}`]: c, [`${a}-rtl`]: i === 'rtl' }, r, l)
    return d.createElement(
      pf.Provider,
      { value: n },
      d.createElement('div', Object.assign({}, o, { className: u })),
    )
  },
  ch = /^[\u4E00-\u9FA5]{2}$/,
  xc = ch.test.bind(ch)
function uh(e) {
  return typeof e == 'string'
}
function Hl(e) {
  return e === 'text' || e === 'link'
}
function Sw(e, t) {
  if (e == null) return
  const i = t ? ' ' : ''
  return typeof e != 'string' &&
    typeof e != 'number' &&
    uh(e.type) &&
    xc(e.props.children)
    ? wa(e, { children: e.props.children.split('').join(i) })
    : uh(e)
      ? xc(e)
        ? $.createElement('span', null, e.split('').join(i))
        : $.createElement('span', null, e)
      : pS(e)
        ? $.createElement('span', null, e)
        : e
}
function ww(e, t) {
  let i = !1
  const s = []
  return (
    $.Children.forEach(e, (n) => {
      const r = typeof n,
        o = r === 'string' || r === 'number'
      if (i && o) {
        const a = s.length - 1,
          l = s[a]
        s[a] = `${l}${n}`
      } else s.push(n)
      i = o
    }),
    $.Children.map(s, (n) => Sw(n, t))
  )
}
const mf = d.forwardRef((e, t) => {
    const { className: i, style: s, children: n, prefixCls: r } = e,
      o = pe(`${r}-icon`, i)
    return $.createElement('span', { ref: t, className: o, style: s }, n)
  }),
  dh = d.forwardRef((e, t) => {
    const { prefixCls: i, className: s, style: n, iconClassName: r } = e,
      o = pe(`${i}-loading-icon`, s)
    return $.createElement(
      mf,
      { prefixCls: i, className: o, style: n, ref: t },
      $.createElement(Jg, { className: r }),
    )
  }),
  Nl = () => ({ width: 0, opacity: 0, transform: 'scale(0)' }),
  Gl = (e) => ({ width: e.scrollWidth, opacity: 1, transform: 'scale(1)' }),
  yw = (e) => {
    const {
        prefixCls: t,
        loading: i,
        existIcon: s,
        className: n,
        style: r,
      } = e,
      o = !!i
    return s
      ? $.createElement(dh, { prefixCls: t, className: n, style: r })
      : $.createElement(
          vu,
          {
            visible: o,
            motionName: `${t}-loading-icon-motion`,
            motionLeave: o,
            removeOnLeave: !0,
            onAppearStart: Nl,
            onAppearActive: Gl,
            onEnterStart: Nl,
            onEnterActive: Gl,
            onLeaveStart: Gl,
            onLeaveActive: Nl,
          },
          (a, l) => {
            let { className: c, style: u } = a
            return $.createElement(dh, {
              prefixCls: t,
              className: n,
              style: Object.assign(Object.assign({}, r), u),
              ref: l,
              iconClassName: c,
            })
          },
        )
  },
  hh = (e, t) => ({
    [`> span, > ${e}`]: {
      '&:not(:last-child)': {
        [`&, & > ${e}`]: { '&:not(:disabled)': { borderInlineEndColor: t } },
      },
      '&:not(:first-child)': {
        [`&, & > ${e}`]: { '&:not(:disabled)': { borderInlineStartColor: t } },
      },
    },
  }),
  bw = (e) => {
    const {
      componentCls: t,
      fontSize: i,
      lineWidth: s,
      groupBorderColor: n,
      colorErrorHover: r,
    } = e
    return {
      [`${t}-group`]: [
        {
          position: 'relative',
          display: 'inline-flex',
          [`> span, > ${t}`]: {
            '&:not(:last-child)': {
              [`&, & > ${t}`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
              },
            },
            '&:not(:first-child)': {
              marginInlineStart: e.calc(s).mul(-1).equal(),
              [`&, & > ${t}`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0,
              },
            },
          },
          [t]: {
            position: 'relative',
            zIndex: 1,
            '&:hover, &:focus, &:active': { zIndex: 2 },
            '&[disabled]': { zIndex: 0 },
          },
          [`${t}-icon-only`]: { fontSize: i },
        },
        hh(`${t}-primary`, n),
        hh(`${t}-danger`, r),
      ],
    }
  },
  ri = Math.round
function Bl(e, t) {
  const i =
      e
        .replace(/^[^(]*\((.*)/, '$1')
        .replace(/\).*/, '')
        .match(/\d*\.?\d+%?/g) || [],
    s = i.map((n) => parseFloat(n))
  for (let n = 0; n < 3; n += 1) s[n] = t(s[n] || 0, i[n] || '', n)
  return i[3] ? (s[3] = i[3].includes('%') ? s[3] / 100 : s[3]) : (s[3] = 1), s
}
const gh = (e, t, i) => (i === 0 ? e : e / 100)
function $r(e, t) {
  const i = t || 255
  return e > i ? i : e < 0 ? 0 : e
}
class Ja {
  constructor(t) {
    ce(this, 'isValid', !0),
      ce(this, 'r', 0),
      ce(this, 'g', 0),
      ce(this, 'b', 0),
      ce(this, 'a', 1),
      ce(this, '_h', void 0),
      ce(this, '_s', void 0),
      ce(this, '_l', void 0),
      ce(this, '_v', void 0),
      ce(this, '_max', void 0),
      ce(this, '_min', void 0),
      ce(this, '_brightness', void 0)
    function i(s) {
      return s[0] in t && s[1] in t && s[2] in t
    }
    if (t)
      if (typeof t == 'string') {
        let n = function (r) {
          return s.startsWith(r)
        }
        const s = t.trim()
        ;/^#?[A-F\d]{3,8}$/i.test(s)
          ? this.fromHexString(s)
          : n('rgb')
            ? this.fromRgbString(s)
            : n('hsl')
              ? this.fromHslString(s)
              : (n('hsv') || n('hsb')) && this.fromHsvString(s)
      } else if (t instanceof Ja)
        (this.r = t.r),
          (this.g = t.g),
          (this.b = t.b),
          (this.a = t.a),
          (this._h = t._h),
          (this._s = t._s),
          (this._l = t._l),
          (this._v = t._v)
      else if (i('rgb'))
        (this.r = $r(t.r)),
          (this.g = $r(t.g)),
          (this.b = $r(t.b)),
          (this.a = typeof t.a == 'number' ? $r(t.a, 1) : 1)
      else if (i('hsl')) this.fromHsl(t)
      else if (i('hsv')) this.fromHsv(t)
      else
        throw new Error(
          '@ant-design/fast-color: unsupported input ' + JSON.stringify(t),
        )
  }
  setR(t) {
    return this._sc('r', t)
  }
  setG(t) {
    return this._sc('g', t)
  }
  setB(t) {
    return this._sc('b', t)
  }
  setA(t) {
    return this._sc('a', t, 1)
  }
  setHue(t) {
    const i = this.toHsv()
    return (i.h = t), this._c(i)
  }
  getLuminance() {
    function t(r) {
      const o = r / 255
      return o <= 0.03928 ? o / 12.92 : Math.pow((o + 0.055) / 1.055, 2.4)
    }
    const i = t(this.r),
      s = t(this.g),
      n = t(this.b)
    return 0.2126 * i + 0.7152 * s + 0.0722 * n
  }
  getHue() {
    if (typeof this._h > 'u') {
      const t = this.getMax() - this.getMin()
      t === 0
        ? (this._h = 0)
        : (this._h = ri(
            60 *
              (this.r === this.getMax()
                ? (this.g - this.b) / t + (this.g < this.b ? 6 : 0)
                : this.g === this.getMax()
                  ? (this.b - this.r) / t + 2
                  : (this.r - this.g) / t + 4),
          ))
    }
    return this._h
  }
  getSaturation() {
    if (typeof this._s > 'u') {
      const t = this.getMax() - this.getMin()
      t === 0 ? (this._s = 0) : (this._s = t / this.getMax())
    }
    return this._s
  }
  getLightness() {
    return (
      typeof this._l > 'u' && (this._l = (this.getMax() + this.getMin()) / 510),
      this._l
    )
  }
  getValue() {
    return typeof this._v > 'u' && (this._v = this.getMax() / 255), this._v
  }
  getBrightness() {
    return (
      typeof this._brightness > 'u' &&
        (this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1e3),
      this._brightness
    )
  }
  darken(t = 10) {
    const i = this.getHue(),
      s = this.getSaturation()
    let n = this.getLightness() - t / 100
    return n < 0 && (n = 0), this._c({ h: i, s, l: n, a: this.a })
  }
  lighten(t = 10) {
    const i = this.getHue(),
      s = this.getSaturation()
    let n = this.getLightness() + t / 100
    return n > 1 && (n = 1), this._c({ h: i, s, l: n, a: this.a })
  }
  mix(t, i = 50) {
    const s = this._c(t),
      n = i / 100,
      r = (a) => (s[a] - this[a]) * n + this[a],
      o = {
        r: ri(r('r')),
        g: ri(r('g')),
        b: ri(r('b')),
        a: ri(r('a') * 100) / 100,
      }
    return this._c(o)
  }
  tint(t = 10) {
    return this.mix({ r: 255, g: 255, b: 255, a: 1 }, t)
  }
  shade(t = 10) {
    return this.mix({ r: 0, g: 0, b: 0, a: 1 }, t)
  }
  onBackground(t) {
    const i = this._c(t),
      s = this.a + i.a * (1 - this.a),
      n = (r) => ri((this[r] * this.a + i[r] * i.a * (1 - this.a)) / s)
    return this._c({ r: n('r'), g: n('g'), b: n('b'), a: s })
  }
  isDark() {
    return this.getBrightness() < 128
  }
  isLight() {
    return this.getBrightness() >= 128
  }
  equals(t) {
    return this.r === t.r && this.g === t.g && this.b === t.b && this.a === t.a
  }
  clone() {
    return this._c(this)
  }
  toHexString() {
    let t = '#'
    const i = (this.r || 0).toString(16)
    t += i.length === 2 ? i : '0' + i
    const s = (this.g || 0).toString(16)
    t += s.length === 2 ? s : '0' + s
    const n = (this.b || 0).toString(16)
    if (
      ((t += n.length === 2 ? n : '0' + n),
      typeof this.a == 'number' && this.a >= 0 && this.a < 1)
    ) {
      const r = ri(this.a * 255).toString(16)
      t += r.length === 2 ? r : '0' + r
    }
    return t
  }
  toHsl() {
    return {
      h: this.getHue(),
      s: this.getSaturation(),
      l: this.getLightness(),
      a: this.a,
    }
  }
  toHslString() {
    const t = this.getHue(),
      i = ri(this.getSaturation() * 100),
      s = ri(this.getLightness() * 100)
    return this.a !== 1
      ? `hsla(${t},${i}%,${s}%,${this.a})`
      : `hsl(${t},${i}%,${s}%)`
  }
  toHsv() {
    return {
      h: this.getHue(),
      s: this.getSaturation(),
      v: this.getValue(),
      a: this.a,
    }
  }
  toRgb() {
    return { r: this.r, g: this.g, b: this.b, a: this.a }
  }
  toRgbString() {
    return this.a !== 1
      ? `rgba(${this.r},${this.g},${this.b},${this.a})`
      : `rgb(${this.r},${this.g},${this.b})`
  }
  toString() {
    return this.toRgbString()
  }
  _sc(t, i, s) {
    const n = this.clone()
    return (n[t] = $r(i, s)), n
  }
  _c(t) {
    return new this.constructor(t)
  }
  getMax() {
    return (
      typeof this._max > 'u' && (this._max = Math.max(this.r, this.g, this.b)),
      this._max
    )
  }
  getMin() {
    return (
      typeof this._min > 'u' && (this._min = Math.min(this.r, this.g, this.b)),
      this._min
    )
  }
  fromHexString(t) {
    const i = t.replace('#', '')
    function s(n, r) {
      return parseInt(i[n] + i[r || n], 16)
    }
    i.length < 6
      ? ((this.r = s(0)),
        (this.g = s(1)),
        (this.b = s(2)),
        (this.a = i[3] ? s(3) / 255 : 1))
      : ((this.r = s(0, 1)),
        (this.g = s(2, 3)),
        (this.b = s(4, 5)),
        (this.a = i[6] ? s(6, 7) / 255 : 1))
  }
  fromHsl({ h: t, s: i, l: s, a: n }) {
    if (
      ((this._h = t % 360),
      (this._s = i),
      (this._l = s),
      (this.a = typeof n == 'number' ? n : 1),
      i <= 0)
    ) {
      const g = ri(s * 255)
      ;(this.r = g), (this.g = g), (this.b = g)
    }
    let r = 0,
      o = 0,
      a = 0
    const l = t / 60,
      c = (1 - Math.abs(2 * s - 1)) * i,
      u = c * (1 - Math.abs((l % 2) - 1))
    l >= 0 && l < 1
      ? ((r = c), (o = u))
      : l >= 1 && l < 2
        ? ((r = u), (o = c))
        : l >= 2 && l < 3
          ? ((o = c), (a = u))
          : l >= 3 && l < 4
            ? ((o = u), (a = c))
            : l >= 4 && l < 5
              ? ((r = u), (a = c))
              : l >= 5 && l < 6 && ((r = c), (a = u))
    const h = s - c / 2
    ;(this.r = ri((r + h) * 255)),
      (this.g = ri((o + h) * 255)),
      (this.b = ri((a + h) * 255))
  }
  fromHsv({ h: t, s: i, v: s, a: n }) {
    ;(this._h = t % 360),
      (this._s = i),
      (this._v = s),
      (this.a = typeof n == 'number' ? n : 1)
    const r = ri(s * 255)
    if (((this.r = r), (this.g = r), (this.b = r), i <= 0)) return
    const o = t / 60,
      a = Math.floor(o),
      l = o - a,
      c = ri(s * (1 - i) * 255),
      u = ri(s * (1 - i * l) * 255),
      h = ri(s * (1 - i * (1 - l)) * 255)
    switch (a) {
      case 0:
        ;(this.g = h), (this.b = c)
        break
      case 1:
        ;(this.r = u), (this.b = c)
        break
      case 2:
        ;(this.r = c), (this.b = h)
        break
      case 3:
        ;(this.r = c), (this.g = u)
        break
      case 4:
        ;(this.r = h), (this.g = c)
        break
      case 5:
      default:
        ;(this.g = c), (this.b = u)
        break
    }
  }
  fromHsvString(t) {
    const i = Bl(t, gh)
    this.fromHsv({ h: i[0], s: i[1], v: i[2], a: i[3] })
  }
  fromHslString(t) {
    const i = Bl(t, gh)
    this.fromHsl({ h: i[0], s: i[1], l: i[2], a: i[3] })
  }
  fromRgbString(t) {
    const i = Bl(t, (s, n) => (n.includes('%') ? ri((s / 100) * 255) : s))
    ;(this.r = i[0]), (this.g = i[1]), (this.b = i[2]), (this.a = i[3])
  }
}
var Rw = ['b'],
  Fw = ['v'],
  Vl = function (t) {
    return Math.round(Number(t || 0))
  },
  Ew = function (t) {
    if (t instanceof Ja) return t
    if (t && Zt(t) === 'object' && 'h' in t && 'b' in t) {
      var i = t,
        s = i.b,
        n = Kt(i, Rw)
      return re(re({}, n), {}, { v: s })
    }
    return typeof t == 'string' && /hsb/.test(t) ? t.replace(/hsb/, 'hsv') : t
  },
  go = (function (e) {
    mS(i, e)
    var t = vS(i)
    function i(s) {
      return qa(this, i), t.call(this, Ew(s))
    }
    return (
      Qa(i, [
        {
          key: 'toHsbString',
          value: function () {
            var n = this.toHsb(),
              r = Vl(n.s * 100),
              o = Vl(n.b * 100),
              a = Vl(n.h),
              l = n.a,
              c = 'hsb('.concat(a, ', ').concat(r, '%, ').concat(o, '%)'),
              u = 'hsba('
                .concat(a, ', ')
                .concat(r, '%, ')
                .concat(o, '%, ')
                .concat(l.toFixed(l === 0 ? 0 : 2), ')')
            return l === 1 ? c : u
          },
        },
        {
          key: 'toHsb',
          value: function () {
            var n = this.toHsv(),
              r = n.v,
              o = Kt(n, Fw)
            return re(re({}, o), {}, { b: r, a: this.a })
          },
        },
      ]),
      i
    )
  })(Ja),
  Pw = function (t) {
    return t instanceof go ? t : new go(t)
  }
Pw('#1677ff')
const xw = (e, t) =>
    (e == null ? void 0 : e.replace(/[^\w/]/g, '').slice(0, t ? 8 : 6)) || '',
  Dw = (e, t) => (e ? xw(e, t) : '')
let Mw = (function () {
  function e(t) {
    qa(this, e)
    var i
    if (((this.cleared = !1), t instanceof e)) {
      ;(this.metaColor = t.metaColor.clone()),
        (this.colors =
          (i = t.colors) === null || i === void 0
            ? void 0
            : i.map((n) => ({ color: new e(n.color), percent: n.percent }))),
        (this.cleared = t.cleared)
      return
    }
    const s = Array.isArray(t)
    s && t.length
      ? ((this.colors = t.map((n) => {
          let { color: r, percent: o } = n
          return { color: new e(r), percent: o }
        })),
        (this.metaColor = new go(this.colors[0].color.metaColor)))
      : (this.metaColor = new go(s ? '' : t)),
      (!t || (s && !this.colors)) &&
        ((this.metaColor = this.metaColor.setA(0)), (this.cleared = !0))
  }
  return Qa(e, [
    {
      key: 'toHsb',
      value: function () {
        return this.metaColor.toHsb()
      },
    },
    {
      key: 'toHsbString',
      value: function () {
        return this.metaColor.toHsbString()
      },
    },
    {
      key: 'toHex',
      value: function () {
        return Dw(this.toHexString(), this.metaColor.a < 1)
      },
    },
    {
      key: 'toHexString',
      value: function () {
        return this.metaColor.toHexString()
      },
    },
    {
      key: 'toRgb',
      value: function () {
        return this.metaColor.toRgb()
      },
    },
    {
      key: 'toRgbString',
      value: function () {
        return this.metaColor.toRgbString()
      },
    },
    {
      key: 'isGradient',
      value: function () {
        return !!this.colors && !this.cleared
      },
    },
    {
      key: 'getColors',
      value: function () {
        return this.colors || [{ color: this, percent: 0 }]
      },
    },
    {
      key: 'toCssString',
      value: function () {
        const { colors: i } = this
        return i
          ? `linear-gradient(90deg, ${i.map((n) => `${n.color.toRgbString()} ${n.percent}%`).join(', ')})`
          : this.metaColor.toRgbString()
      },
    },
    {
      key: 'equals',
      value: function (i) {
        return !i || this.isGradient() !== i.isGradient()
          ? !1
          : this.isGradient()
            ? this.colors.length === i.colors.length &&
              this.colors.every((s, n) => {
                const r = i.colors[n]
                return s.percent === r.percent && s.color.equals(r.color)
              })
            : this.toHexString() === i.toHexString()
      },
    },
  ])
})()
const Iw = new un('antMoveDownIn', {
    '0%': {
      transform: 'translate3d(0, 100%, 0)',
      transformOrigin: '0 0',
      opacity: 0,
    },
    '100%': {
      transform: 'translate3d(0, 0, 0)',
      transformOrigin: '0 0',
      opacity: 1,
    },
  }),
  Tw = new un('antMoveDownOut', {
    '0%': {
      transform: 'translate3d(0, 0, 0)',
      transformOrigin: '0 0',
      opacity: 1,
    },
    '100%': {
      transform: 'translate3d(0, 100%, 0)',
      transformOrigin: '0 0',
      opacity: 0,
    },
  }),
  Aw = new un('antMoveLeftIn', {
    '0%': {
      transform: 'translate3d(-100%, 0, 0)',
      transformOrigin: '0 0',
      opacity: 0,
    },
    '100%': {
      transform: 'translate3d(0, 0, 0)',
      transformOrigin: '0 0',
      opacity: 1,
    },
  }),
  Ow = new un('antMoveLeftOut', {
    '0%': {
      transform: 'translate3d(0, 0, 0)',
      transformOrigin: '0 0',
      opacity: 1,
    },
    '100%': {
      transform: 'translate3d(-100%, 0, 0)',
      transformOrigin: '0 0',
      opacity: 0,
    },
  }),
  Lw = new un('antMoveRightIn', {
    '0%': {
      transform: 'translate3d(100%, 0, 0)',
      transformOrigin: '0 0',
      opacity: 0,
    },
    '100%': {
      transform: 'translate3d(0, 0, 0)',
      transformOrigin: '0 0',
      opacity: 1,
    },
  }),
  kw = new un('antMoveRightOut', {
    '0%': {
      transform: 'translate3d(0, 0, 0)',
      transformOrigin: '0 0',
      opacity: 1,
    },
    '100%': {
      transform: 'translate3d(100%, 0, 0)',
      transformOrigin: '0 0',
      opacity: 0,
    },
  }),
  Hw = new un('antMoveUpIn', {
    '0%': {
      transform: 'translate3d(0, -100%, 0)',
      transformOrigin: '0 0',
      opacity: 0,
    },
    '100%': {
      transform: 'translate3d(0, 0, 0)',
      transformOrigin: '0 0',
      opacity: 1,
    },
  }),
  Nw = new un('antMoveUpOut', {
    '0%': {
      transform: 'translate3d(0, 0, 0)',
      transformOrigin: '0 0',
      opacity: 1,
    },
    '100%': {
      transform: 'translate3d(0, -100%, 0)',
      transformOrigin: '0 0',
      opacity: 0,
    },
  }),
  Gw = {
    'move-up': { inKeyframes: Hw, outKeyframes: Nw },
    'move-down': { inKeyframes: Iw, outKeyframes: Tw },
    'move-left': { inKeyframes: Aw, outKeyframes: Ow },
    'move-right': { inKeyframes: Lw, outKeyframes: kw },
  },
  Ea = (e, t) => {
    const { antCls: i } = e,
      s = `${i}-${t}`,
      { inKeyframes: n, outKeyframes: r } = Gw[t]
    return [
      CS(s, n, r, e.motionDurationMid),
      {
        [`
        ${s}-enter,
        ${s}-appear
      `]: { opacity: 0, animationTimingFunction: e.motionEaseOutCirc },
        [`${s}-leave`]: { animationTimingFunction: e.motionEaseInOutCirc },
      },
    ]
  },
  Bw = (e, t) => {
    const { r: i, g: s, b: n, a: r } = e.toRgb(),
      o = new go(e.toRgbString()).onBackground(t).toHsv()
    return r <= 0.5 ? o.v > 0.5 : i * 0.299 + s * 0.587 + n * 0.114 > 192
  },
  vf = (e) => {
    const { paddingInline: t, onlyIconSize: i, paddingBlock: s } = e
    return Jt(e, {
      buttonPaddingHorizontal: t,
      buttonPaddingVertical: s,
      buttonIconOnlyFontSize: i,
    })
  },
  Cf = (e) => {
    var t, i, s, n, r, o
    const a = (t = e.contentFontSize) !== null && t !== void 0 ? t : e.fontSize,
      l = (i = e.contentFontSizeSM) !== null && i !== void 0 ? i : e.fontSize,
      c = (s = e.contentFontSizeLG) !== null && s !== void 0 ? s : e.fontSizeLG,
      u = (n = e.contentLineHeight) !== null && n !== void 0 ? n : Ol(a),
      h = (r = e.contentLineHeightSM) !== null && r !== void 0 ? r : Ol(l),
      g = (o = e.contentLineHeightLG) !== null && o !== void 0 ? o : Ol(c),
      f = Bw(new Mw(e.colorBgSolid), '#fff') ? '#000' : '#fff'
    return {
      fontWeight: 400,
      defaultShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlTmpOutline}`,
      primaryShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlOutline}`,
      dangerShadow: `0 ${e.controlOutlineWidth}px 0 ${e.colorErrorOutline}`,
      primaryColor: e.colorTextLightSolid,
      dangerColor: e.colorTextLightSolid,
      borderColorDisabled: e.colorBorder,
      defaultGhostColor: e.colorBgContainer,
      ghostBg: 'transparent',
      defaultGhostBorderColor: e.colorBgContainer,
      paddingInline: e.paddingContentHorizontal - e.lineWidth,
      paddingInlineLG: e.paddingContentHorizontal - e.lineWidth,
      paddingInlineSM: 8 - e.lineWidth,
      onlyIconSize: e.fontSizeLG,
      onlyIconSizeSM: e.fontSizeLG - 2,
      onlyIconSizeLG: e.fontSizeLG + 2,
      groupBorderColor: e.colorPrimaryHover,
      linkHoverBg: 'transparent',
      textTextColor: e.colorText,
      textTextHoverColor: e.colorText,
      textTextActiveColor: e.colorText,
      textHoverBg: e.colorFillTertiary,
      defaultColor: e.colorText,
      defaultBg: e.colorBgContainer,
      defaultBorderColor: e.colorBorder,
      defaultBorderColorDisabled: e.colorBorder,
      defaultHoverBg: e.colorBgContainer,
      defaultHoverColor: e.colorPrimaryHover,
      defaultHoverBorderColor: e.colorPrimaryHover,
      defaultActiveBg: e.colorBgContainer,
      defaultActiveColor: e.colorPrimaryActive,
      defaultActiveBorderColor: e.colorPrimaryActive,
      solidTextColor: f,
      contentFontSize: a,
      contentFontSizeSM: l,
      contentFontSizeLG: c,
      contentLineHeight: u,
      contentLineHeightSM: h,
      contentLineHeightLG: g,
      paddingBlock: Math.max((e.controlHeight - a * u) / 2 - e.lineWidth, 0),
      paddingBlockSM: Math.max(
        (e.controlHeightSM - l * h) / 2 - e.lineWidth,
        0,
      ),
      paddingBlockLG: Math.max(
        (e.controlHeightLG - c * g) / 2 - e.lineWidth,
        0,
      ),
    }
  },
  Vw = (e) => {
    const { componentCls: t, iconCls: i, fontWeight: s } = e
    return {
      [t]: {
        outline: 'none',
        position: 'relative',
        display: 'inline-flex',
        gap: e.marginXS,
        alignItems: 'center',
        justifyContent: 'center',
        fontWeight: s,
        whiteSpace: 'nowrap',
        textAlign: 'center',
        backgroundImage: 'none',
        background: 'transparent',
        border: `${de(e.lineWidth)} ${e.lineType} transparent`,
        cursor: 'pointer',
        transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
        userSelect: 'none',
        touchAction: 'manipulation',
        color: e.colorText,
        '&:disabled > *': { pointerEvents: 'none' },
        '> span': { display: 'inline-block' },
        [`${t}-icon`]: { lineHeight: 1 },
        '> a': { color: 'currentColor' },
        '&:not(:disabled)': Object.assign({}, SS(e)),
        [`&${t}-two-chinese-chars::first-letter`]: { letterSpacing: '0.34em' },
        [`&${t}-two-chinese-chars > *:not(${i})`]: {
          marginInlineEnd: '-0.34em',
          letterSpacing: '0.34em',
        },
        '&-icon-end': { flexDirection: 'row-reverse' },
      },
    }
  },
  Sf = (e, t, i) => ({
    [`&:not(:disabled):not(${e}-disabled)`]: { '&:hover': t, '&:active': i },
  }),
  _w = (e) => ({
    minWidth: e.controlHeight,
    paddingInlineStart: 0,
    paddingInlineEnd: 0,
    borderRadius: '50%',
  }),
  Ww = (e) => ({
    borderRadius: e.controlHeight,
    paddingInlineStart: e.calc(e.controlHeight).div(2).equal(),
    paddingInlineEnd: e.calc(e.controlHeight).div(2).equal(),
  }),
  $w = (e) => ({
    cursor: 'not-allowed',
    borderColor: e.borderColorDisabled,
    color: e.colorTextDisabled,
    background: e.colorBgContainerDisabled,
    boxShadow: 'none',
  }),
  yu = (e, t, i, s, n, r, o, a) => ({
    [`&${e}-background-ghost`]: Object.assign(
      Object.assign(
        {
          color: i || void 0,
          background: t,
          borderColor: s || void 0,
          boxShadow: 'none',
        },
        Sf(
          e,
          Object.assign({ background: t }, o),
          Object.assign({ background: t }, a),
        ),
      ),
      {
        '&:disabled': {
          cursor: 'not-allowed',
          color: n || void 0,
          borderColor: r || void 0,
        },
      },
    ),
  }),
  zw = (e) => ({
    [`&:disabled, &${e.componentCls}-disabled`]: Object.assign({}, $w(e)),
  }),
  Uw = (e) => ({
    [`&:disabled, &${e.componentCls}-disabled`]: {
      cursor: 'not-allowed',
      color: e.colorTextDisabled,
    },
  }),
  Za = (e, t, i, s) => {
    const r = s && ['link', 'text'].includes(s) ? Uw : zw
    return Object.assign(Object.assign({}, r(e)), Sf(e.componentCls, t, i))
  },
  bu = (e, t, i, s, n) => ({
    [`&${e.componentCls}-variant-solid`]: Object.assign(
      { color: t, background: i },
      Za(e, s, n),
    ),
  }),
  Ru = (e, t, i, s, n) => ({
    [`&${e.componentCls}-variant-outlined, &${e.componentCls}-variant-dashed`]:
      Object.assign({ borderColor: t, background: i }, Za(e, s, n)),
  }),
  Fu = (e) => ({
    [`&${e.componentCls}-variant-dashed`]: { borderStyle: 'dashed' },
  }),
  Eu = (e, t, i, s) => ({
    [`&${e.componentCls}-variant-filled`]: Object.assign(
      { boxShadow: 'none', background: t },
      Za(e, i, s),
    ),
  }),
  hr = (e, t, i, s, n) => ({
    [`&${e.componentCls}-variant-${i}`]: Object.assign(
      { color: t, boxShadow: 'none' },
      Za(e, s, n, i),
    ),
  }),
  jw = (e) =>
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              { color: e.defaultColor, boxShadow: e.defaultShadow },
              bu(
                e,
                e.solidTextColor,
                e.colorBgSolid,
                { background: e.colorBgSolidHover },
                { background: e.colorBgSolidActive },
              ),
            ),
            Fu(e),
          ),
          Eu(
            e,
            e.colorFillTertiary,
            { background: e.colorFillSecondary },
            { background: e.colorFill },
          ),
        ),
        hr(
          e,
          e.textTextColor,
          'link',
          { color: e.colorLinkHover, background: e.linkHoverBg },
          { color: e.colorLinkActive },
        ),
      ),
      yu(
        e.componentCls,
        e.ghostBg,
        e.defaultGhostColor,
        e.defaultGhostBorderColor,
        e.colorTextDisabled,
        e.colorBorder,
      ),
    ),
  Yw = (e) =>
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              { color: e.colorPrimary, boxShadow: e.primaryShadow },
              Ru(
                e,
                e.colorPrimary,
                e.colorBgContainer,
                {
                  color: e.colorPrimaryTextHover,
                  borderColor: e.colorPrimaryHover,
                  background: e.colorBgContainer,
                },
                {
                  color: e.colorPrimaryTextActive,
                  borderColor: e.colorPrimaryActive,
                  background: e.colorBgContainer,
                },
              ),
            ),
            Fu(e),
          ),
          Eu(
            e,
            e.colorPrimaryBg,
            { background: e.colorPrimaryBgHover },
            { background: e.colorPrimaryBorder },
          ),
        ),
        hr(
          e,
          e.colorLink,
          'text',
          { color: e.colorPrimaryTextHover, background: e.colorPrimaryBg },
          { color: e.colorPrimaryTextActive, background: e.colorPrimaryBorder },
        ),
      ),
      yu(
        e.componentCls,
        e.ghostBg,
        e.colorPrimary,
        e.colorPrimary,
        e.colorTextDisabled,
        e.colorBorder,
        { color: e.colorPrimaryHover, borderColor: e.colorPrimaryHover },
        { color: e.colorPrimaryActive, borderColor: e.colorPrimaryActive },
      ),
    ),
  Kw = (e) =>
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  { color: e.colorError, boxShadow: e.dangerShadow },
                  bu(
                    e,
                    e.dangerColor,
                    e.colorError,
                    { background: e.colorErrorHover },
                    { background: e.colorErrorActive },
                  ),
                ),
                Ru(
                  e,
                  e.colorError,
                  e.colorBgContainer,
                  {
                    color: e.colorErrorHover,
                    borderColor: e.colorErrorBorderHover,
                  },
                  {
                    color: e.colorErrorActive,
                    borderColor: e.colorErrorActive,
                  },
                ),
              ),
              Fu(e),
            ),
            Eu(
              e,
              e.colorErrorBg,
              { background: e.colorErrorBgFilledHover },
              { background: e.colorErrorBgActive },
            ),
          ),
          hr(
            e,
            e.colorError,
            'text',
            { color: e.colorErrorHover, background: e.colorErrorBg },
            { color: e.colorErrorHover, background: e.colorErrorBgActive },
          ),
        ),
        hr(
          e,
          e.colorError,
          'link',
          { color: e.colorErrorHover },
          { color: e.colorErrorActive },
        ),
      ),
      yu(
        e.componentCls,
        e.ghostBg,
        e.colorError,
        e.colorError,
        e.colorTextDisabled,
        e.colorBorder,
        { color: e.colorErrorHover, borderColor: e.colorErrorHover },
        { color: e.colorErrorActive, borderColor: e.colorErrorActive },
      ),
    ),
  qw = (e) => {
    const { componentCls: t } = e
    return {
      [`${t}-color-default`]: jw(e),
      [`${t}-color-primary`]: Yw(e),
      [`${t}-color-dangerous`]: Kw(e),
    }
  },
  Qw = (e) =>
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            {},
            Ru(
              e,
              e.defaultBorderColor,
              e.defaultBg,
              {
                color: e.defaultHoverColor,
                borderColor: e.defaultHoverBorderColor,
                background: e.defaultHoverBg,
              },
              {
                color: e.defaultActiveColor,
                borderColor: e.defaultActiveBorderColor,
                background: e.defaultActiveBg,
              },
            ),
          ),
          hr(
            e,
            e.textTextColor,
            'text',
            { color: e.textTextHoverColor, background: e.textHoverBg },
            { color: e.textTextActiveColor, background: e.colorBgTextActive },
          ),
        ),
        bu(
          e,
          e.primaryColor,
          e.colorPrimary,
          { background: e.colorPrimaryHover, color: e.primaryColor },
          { background: e.colorPrimaryActive, color: e.primaryColor },
        ),
      ),
      hr(
        e,
        e.colorLink,
        'link',
        { color: e.colorLinkHover, background: e.linkHoverBg },
        { color: e.colorLinkActive },
      ),
    ),
  Pu = function (e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ''
    const {
        componentCls: i,
        controlHeight: s,
        fontSize: n,
        lineHeight: r,
        borderRadius: o,
        buttonPaddingHorizontal: a,
        iconCls: l,
        buttonPaddingVertical: c,
      } = e,
      u = `${i}-icon-only`
    return [
      {
        [t]: {
          fontSize: n,
          lineHeight: r,
          height: s,
          padding: `${de(c)} ${de(a)}`,
          borderRadius: o,
          [`&${u}`]: {
            width: s,
            paddingInline: 0,
            [`&${i}-compact-item`]: { flex: 'none' },
            [`&${i}-round`]: { width: 'auto' },
            [l]: { fontSize: e.buttonIconOnlyFontSize },
          },
          [`&${i}-loading`]: { opacity: e.opacityLoading, cursor: 'default' },
          [`${i}-loading-icon`]: {
            transition: `width ${e.motionDurationSlow} ${e.motionEaseInOut}, opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`,
          },
        },
      },
      { [`${i}${i}-circle${t}`]: _w(e) },
      { [`${i}${i}-round${t}`]: Ww(e) },
    ]
  },
  Xw = (e) => {
    const t = Jt(e, {
      fontSize: e.contentFontSize,
      lineHeight: e.contentLineHeight,
    })
    return Pu(t, e.componentCls)
  },
  Jw = (e) => {
    const t = Jt(e, {
      controlHeight: e.controlHeightSM,
      fontSize: e.contentFontSizeSM,
      lineHeight: e.contentLineHeightSM,
      padding: e.paddingXS,
      buttonPaddingHorizontal: e.paddingInlineSM,
      buttonPaddingVertical: e.paddingBlockSM,
      borderRadius: e.borderRadiusSM,
      buttonIconOnlyFontSize: e.onlyIconSizeSM,
    })
    return Pu(t, `${e.componentCls}-sm`)
  },
  Zw = (e) => {
    const t = Jt(e, {
      controlHeight: e.controlHeightLG,
      fontSize: e.contentFontSizeLG,
      lineHeight: e.contentLineHeightLG,
      buttonPaddingHorizontal: e.paddingInlineLG,
      buttonPaddingVertical: e.paddingBlockLG,
      borderRadius: e.borderRadiusLG,
      buttonIconOnlyFontSize: e.onlyIconSizeLG,
    })
    return Pu(t, `${e.componentCls}-lg`)
  },
  ey = (e) => {
    const { componentCls: t } = e
    return { [t]: { [`&${t}-block`]: { width: '100%' } } }
  },
  ty = dn(
    'Button',
    (e) => {
      const t = vf(e)
      return [Vw(t), Xw(t), Jw(t), Zw(t), ey(t), qw(t), Qw(t), bw(t)]
    },
    Cf,
    {
      unitless: {
        fontWeight: !0,
        contentLineHeight: !0,
        contentLineHeightSM: !0,
        contentLineHeightLG: !0,
      },
    },
  )
function iy(e, t, i) {
  const { focusElCls: s, focus: n, borderElCls: r } = i,
    o = r ? '> *' : '',
    a = ['hover', n ? 'focus' : null, 'active']
      .filter(Boolean)
      .map((l) => `&:${l} ${o}`)
      .join(',')
  return {
    [`&-item:not(${t}-last-item)`]: {
      marginInlineEnd: e.calc(e.lineWidth).mul(-1).equal(),
    },
    '&-item': Object.assign(
      Object.assign(
        { [a]: { zIndex: 2 } },
        s ? { [`&${s}`]: { zIndex: 2 } } : {},
      ),
      { [`&[disabled] ${o}`]: { zIndex: 0 } },
    ),
  }
}
function sy(e, t, i) {
  const { borderElCls: s } = i,
    n = s ? `> ${s}` : ''
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item) ${n}`]: {
      borderRadius: 0,
    },
    [`&-item:not(${t}-last-item)${t}-first-item`]: {
      [`& ${n}, &${e}-sm ${n}, &${e}-lg ${n}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
      },
    },
    [`&-item:not(${t}-first-item)${t}-last-item`]: {
      [`& ${n}, &${e}-sm ${n}, &${e}-lg ${n}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
      },
    },
  }
}
function el(e) {
  let t =
    arguments.length > 1 && arguments[1] !== void 0
      ? arguments[1]
      : { focus: !0 }
  const { componentCls: i } = e,
    s = `${i}-compact`
  return { [s]: Object.assign(Object.assign({}, iy(e, s, t)), sy(i, s, t)) }
}
function ny(e, t) {
  return {
    [`&-item:not(${t}-last-item)`]: {
      marginBottom: e.calc(e.lineWidth).mul(-1).equal(),
    },
    '&-item': {
      '&:hover,&:focus,&:active': { zIndex: 2 },
      '&[disabled]': { zIndex: 0 },
    },
  }
}
function ry(e, t) {
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item)`]: { borderRadius: 0 },
    [`&-item${t}-first-item:not(${t}-last-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0,
      },
    },
    [`&-item${t}-last-item:not(${t}-first-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0,
      },
    },
  }
}
function oy(e) {
  const t = `${e.componentCls}-compact-vertical`
  return {
    [t]: Object.assign(Object.assign({}, ny(e, t)), ry(e.componentCls, t)),
  }
}
const ay = (e) => {
    const { componentCls: t, calc: i } = e
    return {
      [t]: {
        [`&-compact-item${t}-primary`]: {
          [`&:not([disabled]) + ${t}-compact-item${t}-primary:not([disabled])`]:
            {
              position: 'relative',
              '&:before': {
                position: 'absolute',
                top: i(e.lineWidth).mul(-1).equal(),
                insetInlineStart: i(e.lineWidth).mul(-1).equal(),
                display: 'inline-block',
                width: e.lineWidth,
                height: `calc(100% + ${de(e.lineWidth)} * 2)`,
                backgroundColor: e.colorPrimaryHover,
                content: '""',
              },
            },
        },
        '&-compact-vertical-item': {
          [`&${t}-primary`]: {
            [`&:not([disabled]) + ${t}-compact-vertical-item${t}-primary:not([disabled])`]:
              {
                position: 'relative',
                '&:before': {
                  position: 'absolute',
                  top: i(e.lineWidth).mul(-1).equal(),
                  insetInlineStart: i(e.lineWidth).mul(-1).equal(),
                  display: 'inline-block',
                  width: `calc(100% + ${de(e.lineWidth)} * 2)`,
                  height: e.lineWidth,
                  backgroundColor: e.colorPrimaryHover,
                  content: '""',
                },
              },
          },
        },
      },
    }
  },
  ly = Cu(
    ['Button', 'compact'],
    (e) => {
      const t = vf(e)
      return [el(t), oy(t), ay(t)]
    },
    Cf,
  )
var cy = function (e, t) {
  var i = {}
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) &&
      t.indexOf(s) < 0 &&
      (i[s] = e[s])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
      t.indexOf(s[n]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
        (i[s[n]] = e[s[n]])
  return i
}
function uy(e) {
  if (typeof e == 'object' && e) {
    let t = e == null ? void 0 : e.delay
    return (
      (t = !Number.isNaN(t) && typeof t == 'number' ? t : 0),
      { loading: t <= 0, delay: t }
    )
  }
  return { loading: !!e, delay: 0 }
}
const dy = {
    default: ['default', 'outlined'],
    primary: ['primary', 'solid'],
    dashed: ['default', 'dashed'],
    link: ['primary', 'link'],
    text: ['default', 'text'],
  },
  hy = $.forwardRef((e, t) => {
    var i, s, n
    const {
        loading: r = !1,
        prefixCls: o,
        color: a,
        variant: l,
        type: c,
        danger: u = !1,
        shape: h = 'default',
        size: g,
        styles: f,
        disabled: p,
        className: v,
        rootClassName: m,
        children: C,
        icon: w,
        iconPosition: S = 'start',
        ghost: y = !1,
        block: F = !1,
        htmlType: R = 'button',
        classNames: b,
        style: x = {},
        autoInsertSpace: D,
      } = e,
      O = cy(e, [
        'loading',
        'prefixCls',
        'color',
        'variant',
        'type',
        'danger',
        'shape',
        'size',
        'styles',
        'disabled',
        'className',
        'rootClassName',
        'children',
        'icon',
        'iconPosition',
        'ghost',
        'block',
        'htmlType',
        'classNames',
        'style',
        'autoInsertSpace',
      ]),
      M = c || 'default',
      [L, V] = d.useMemo(() => {
        if (a && l) return [a, l]
        const ke = dy[M] || []
        return u ? ['danger', ke[1]] : ke
      }, [c, a, l, u]),
      I = L === 'danger' ? 'dangerous' : L,
      { getPrefixCls: P, direction: k, button: E } = d.useContext(qt),
      N =
        (i = D ?? (E == null ? void 0 : E.autoInsertSpace)) !== null &&
        i !== void 0
          ? i
          : !0,
      T = P('btn', o),
      [G, H, _] = ty(T),
      B = d.useContext(Vn),
      z = p ?? B,
      Q = d.useContext(pf),
      J = d.useMemo(() => uy(r), [r]),
      [se, ie] = d.useState(J.loading),
      [U, W] = d.useState(!1),
      K = $s(t, d.createRef()),
      q = d.Children.count(C) === 1 && !w && !Hl(V)
    d.useEffect(() => {
      let ke = null
      J.delay > 0
        ? (ke = setTimeout(() => {
            ;(ke = null), ie(!0)
          }, J.delay))
        : ie(J.loading)
      function Xe() {
        ke && (clearTimeout(ke), (ke = null))
      }
      return Xe
    }, [J]),
      d.useEffect(() => {
        if (!K || !K.current || !N) return
        const ke = K.current.textContent
        q && xc(ke) ? U || W(!0) : U && W(!1)
      }, [K])
    const ne = (ke) => {
        const { onClick: Xe } = e
        if (se || z) {
          ke.preventDefault()
          return
        }
        Xe == null || Xe(ke)
      },
      { compactSize: oe, compactItemClassnames: le } = Cr(T, k),
      me = { large: 'lg', small: 'sm', middle: void 0 },
      ye = Us((ke) => {
        var Xe, Ye
        return (Ye = (Xe = g ?? oe) !== null && Xe !== void 0 ? Xe : Q) !==
          null && Ye !== void 0
          ? Ye
          : ke
      }),
      Me = (ye && me[ye]) || '',
      He = se ? 'loading' : w,
      $e = zs(O, ['navigate']),
      Fe = pe(
        T,
        H,
        _,
        {
          [`${T}-${h}`]: h !== 'default' && h,
          [`${T}-${M}`]: M,
          [`${T}-dangerous`]: u,
          [`${T}-color-${I}`]: I,
          [`${T}-variant-${V}`]: V,
          [`${T}-${Me}`]: Me,
          [`${T}-icon-only`]: !C && C !== 0 && !!He,
          [`${T}-background-ghost`]: y && !Hl(V),
          [`${T}-loading`]: se,
          [`${T}-two-chinese-chars`]: U && N && !se,
          [`${T}-block`]: F,
          [`${T}-rtl`]: k === 'rtl',
          [`${T}-icon-end`]: S === 'end',
        },
        le,
        v,
        m,
        E == null ? void 0 : E.className,
      ),
      ve = Object.assign(Object.assign({}, E == null ? void 0 : E.style), x),
      Be = pe(
        b == null ? void 0 : b.icon,
        (s = E == null ? void 0 : E.classNames) === null || s === void 0
          ? void 0
          : s.icon,
      ),
      Se = Object.assign(
        Object.assign({}, (f == null ? void 0 : f.icon) || {}),
        ((n = E == null ? void 0 : E.styles) === null || n === void 0
          ? void 0
          : n.icon) || {},
      ),
      we =
        w && !se
          ? $.createElement(mf, { prefixCls: T, className: Be, style: Se }, w)
          : $.createElement(yw, { existIcon: !!w, prefixCls: T, loading: se }),
      ze = C || C === 0 ? ww(C, q && N) : null
    if ($e.href !== void 0)
      return G(
        $.createElement(
          'a',
          Object.assign({}, $e, {
            className: pe(Fe, { [`${T}-disabled`]: z }),
            href: z ? void 0 : $e.href,
            style: ve,
            onClick: ne,
            ref: K,
            tabIndex: z ? -1 : 0,
          }),
          we,
          ze,
        ),
      )
    let Ue = $.createElement(
      'button',
      Object.assign({}, O, {
        type: R,
        className: Fe,
        style: ve,
        onClick: ne,
        disabled: z,
        ref: K,
      }),
      we,
      ze,
      !!le && $.createElement(ly, { key: 'compact', prefixCls: T }),
    )
    return (
      Hl(V) ||
        (Ue = $.createElement(ff, { component: 'Button', disabled: se }, Ue)),
      G(Ue)
    )
  }),
  Ds = hy
Ds.Group = Cw
Ds.__ANT_BUTTON = !0
function fh(e) {
  if (e) return { closable: e.closable, closeIcon: e.closeIcon }
}
function ph(e) {
  const { closable: t, closeIcon: i } = e || {}
  return $.useMemo(() => {
    if (!t && (t === !1 || i === !1 || i === null)) return !1
    if (t === void 0 && i === void 0) return null
    let s = { closeIcon: typeof i != 'boolean' && i !== null ? i : void 0 }
    return (
      t && typeof t == 'object' && (s = Object.assign(Object.assign({}, s), t)),
      s
    )
  }, [t, i])
}
function mh() {
  const e = {}
  for (var t = arguments.length, i = new Array(t), s = 0; s < t; s++)
    i[s] = arguments[s]
  return (
    i.forEach((n) => {
      n &&
        Object.keys(n).forEach((r) => {
          n[r] !== void 0 && (e[r] = n[r])
        })
    }),
    e
  )
}
const gy = {}
function fy(e, t) {
  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : gy
  const s = ph(e),
    n = ph(t),
    r = typeof s != 'boolean' ? !!(s != null && s.disabled) : !1,
    o = $.useMemo(
      () => Object.assign({ closeIcon: $.createElement(hf, null) }, i),
      [i],
    ),
    a = $.useMemo(
      () =>
        s === !1
          ? !1
          : s
            ? mh(o, n, s)
            : n === !1
              ? !1
              : n
                ? mh(o, n)
                : o.closable
                  ? o
                  : !1,
      [s, n, o],
    )
  return $.useMemo(() => {
    if (a === !1) return [!1, null, r]
    const { closeIconRender: l } = o,
      { closeIcon: c } = a
    let u = c
    if (u != null) {
      l && (u = l(c))
      const h = Bs(a, !0)
      Object.keys(h).length &&
        (u = $.isValidElement(u)
          ? $.cloneElement(u, h)
          : $.createElement('span', Object.assign({}, h), u))
    }
    return [!0, u, r]
  }, [a, o])
}
function py(e) {
  return (t) =>
    d.createElement(
      wS,
      { theme: { token: { motion: !1, zIndexPopupBase: 0 } } },
      d.createElement(e, Object.assign({}, t)),
    )
}
const xu = (e, t, i, s) =>
  py((r) => {
    const { prefixCls: o, style: a } = r,
      l = d.useRef(null),
      [c, u] = d.useState(0),
      [h, g] = d.useState(0),
      [f, p] = ai(!1, { value: r.open }),
      { getPrefixCls: v } = d.useContext(qt),
      m = v(t || 'select', o)
    d.useEffect(() => {
      if ((p(!0), typeof ResizeObserver < 'u')) {
        const S = new ResizeObserver((F) => {
            const R = F[0].target
            u(R.offsetHeight + 8), g(R.offsetWidth)
          }),
          y = setInterval(() => {
            var F
            const R = i ? `.${i(m)}` : `.${m}-dropdown`,
              b =
                (F = l.current) === null || F === void 0
                  ? void 0
                  : F.querySelector(R)
            b && (clearInterval(y), S.observe(b))
          }, 10)
        return () => {
          clearInterval(y), S.disconnect()
        }
      }
    }, [])
    let C = Object.assign(Object.assign({}, r), {
      style: Object.assign(Object.assign({}, a), { margin: 0 }),
      open: f,
      visible: f,
      getPopupContainer: () => l.current,
    })
    s && (C = s(C))
    const w = { paddingBottom: c, position: 'relative', minWidth: h }
    return d.createElement(
      'div',
      { ref: l, style: w },
      d.createElement(e, Object.assign({}, C)),
    )
  })
var tl = function (t) {
    var i = t.className,
      s = t.customizeIcon,
      n = t.customizeIconProps,
      r = t.children,
      o = t.onMouseDown,
      a = t.onClick,
      l = typeof s == 'function' ? s(n) : s
    return d.createElement(
      'span',
      {
        className: i,
        onMouseDown: function (u) {
          u.preventDefault(), o == null || o(u)
        },
        style: { userSelect: 'none', WebkitUserSelect: 'none' },
        unselectable: 'on',
        onClick: a,
        'aria-hidden': !0,
      },
      l !== void 0
        ? l
        : d.createElement(
            'span',
            {
              className: pe(
                i.split(/\s+/).map(function (c) {
                  return ''.concat(c, '-icon')
                }),
              ),
            },
            r,
          ),
    )
  },
  my = function (t, i, s, n, r) {
    var o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1,
      a = arguments.length > 6 ? arguments[6] : void 0,
      l = arguments.length > 7 ? arguments[7] : void 0,
      c = $.useMemo(
        function () {
          if (Zt(n) === 'object') return n.clearIcon
          if (r) return r
        },
        [n, r],
      ),
      u = $.useMemo(
        function () {
          return !!(
            !o &&
            n &&
            (s.length || a) &&
            !(l === 'combobox' && a === '')
          )
        },
        [n, o, s.length, a, l],
      )
    return {
      allowClear: u,
      clearIcon: $.createElement(
        tl,
        { className: ''.concat(t, '-clear'), onMouseDown: i, customizeIcon: c },
        '',
      ),
    }
  },
  wf = d.createContext(null)
function vy() {
  return d.useContext(wf)
}
function Cy() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10,
    t = d.useState(!1),
    i = Z(t, 2),
    s = i[0],
    n = i[1],
    r = d.useRef(null),
    o = function () {
      window.clearTimeout(r.current)
    }
  d.useEffect(function () {
    return o
  }, [])
  var a = function (c, u) {
    o(),
      (r.current = window.setTimeout(function () {
        n(c), u && u()
      }, e))
  }
  return [s, a, o]
}
function yf() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250,
    t = d.useRef(null),
    i = d.useRef(null)
  d.useEffect(function () {
    return function () {
      window.clearTimeout(i.current)
    }
  }, [])
  function s(n) {
    ;(n || t.current === null) && (t.current = n),
      window.clearTimeout(i.current),
      (i.current = window.setTimeout(function () {
        t.current = null
      }, e))
  }
  return [
    function () {
      return t.current
    },
    s,
  ]
}
function Sy(e, t, i, s) {
  var n = d.useRef(null)
  ;(n.current = { open: t, triggerOpen: i, customizedTrigger: s }),
    d.useEffect(function () {
      function r(o) {
        var a
        if (
          !((a = n.current) !== null && a !== void 0 && a.customizedTrigger)
        ) {
          var l = o.target
          l.shadowRoot && o.composed && (l = o.composedPath()[0] || l),
            n.current.open &&
              e()
                .filter(function (c) {
                  return c
                })
                .every(function (c) {
                  return !c.contains(l) && c !== l
                }) &&
              n.current.triggerOpen(!1)
        }
      }
      return (
        window.addEventListener('mousedown', r),
        function () {
          return window.removeEventListener('mousedown', r)
        }
      )
    }, [])
}
function wy(e) {
  return ![
    tt.ESC,
    tt.SHIFT,
    tt.BACKSPACE,
    tt.TAB,
    tt.WIN_KEY,
    tt.ALT,
    tt.META,
    tt.WIN_KEY_RIGHT,
    tt.CTRL,
    tt.SEMICOLON,
    tt.EQUALS,
    tt.CAPS_LOCK,
    tt.CONTEXT_MENU,
    tt.F1,
    tt.F2,
    tt.F3,
    tt.F4,
    tt.F5,
    tt.F6,
    tt.F7,
    tt.F8,
    tt.F9,
    tt.F10,
    tt.F11,
    tt.F12,
  ].includes(e)
}
var yy = function (t, i) {
    var s,
      n = t.prefixCls,
      r = t.id,
      o = t.inputElement,
      a = t.disabled,
      l = t.tabIndex,
      c = t.autoFocus,
      u = t.autoComplete,
      h = t.editable,
      g = t.activeDescendantId,
      f = t.value,
      p = t.maxLength,
      v = t.onKeyDown,
      m = t.onMouseDown,
      C = t.onChange,
      w = t.onPaste,
      S = t.onCompositionStart,
      y = t.onCompositionEnd,
      F = t.open,
      R = t.attrs,
      b = o || d.createElement('input', null),
      x = b,
      D = x.ref,
      O = x.props,
      M = O.onKeyDown,
      L = O.onChange,
      V = O.onMouseDown,
      A = O.onCompositionStart,
      I = O.onCompositionEnd,
      P = O.style
    return (
      yS(!('maxLength' in b.props)),
      (b = d.cloneElement(
        b,
        re(
          re(
            re({ type: 'search' }, O),
            {},
            {
              id: r,
              ref: $s(i, D),
              disabled: a,
              tabIndex: l,
              autoComplete: u || 'off',
              autoFocus: c,
              className: pe(
                ''.concat(n, '-selection-search-input'),
                (s = b) === null ||
                  s === void 0 ||
                  (s = s.props) === null ||
                  s === void 0
                  ? void 0
                  : s.className,
              ),
              role: 'combobox',
              'aria-expanded': F || !1,
              'aria-haspopup': 'listbox',
              'aria-owns': ''.concat(r, '_list'),
              'aria-autocomplete': 'list',
              'aria-controls': ''.concat(r, '_list'),
              'aria-activedescendant': F ? g : void 0,
            },
            R,
          ),
          {},
          {
            value: h ? f : '',
            maxLength: p,
            readOnly: !h,
            unselectable: h ? null : 'on',
            style: re(re({}, P), {}, { opacity: h ? null : 0 }),
            onKeyDown: function (E) {
              v(E), M && M(E)
            },
            onMouseDown: function (E) {
              m(E), V && V(E)
            },
            onChange: function (E) {
              C(E), L && L(E)
            },
            onCompositionStart: function (E) {
              S(E), A && A(E)
            },
            onCompositionEnd: function (E) {
              y(E), I && I(E)
            },
            onPaste: w,
          },
        ),
      )),
      b
    )
  },
  bf = d.forwardRef(yy)
function Rf(e) {
  return Array.isArray(e) ? e : e !== void 0 ? [e] : []
}
var by =
    typeof window < 'u' && window.document && window.document.documentElement,
  Ry = by
function Fy(e) {
  return e != null
}
function Ey(e) {
  return !e && e !== 0
}
function vh(e) {
  return ['string', 'number'].includes(Zt(e))
}
function Ff(e) {
  var t = void 0
  return (
    e &&
      (vh(e.title)
        ? (t = e.title.toString())
        : vh(e.label) && (t = e.label.toString())),
    t
  )
}
function Py(e, t) {
  Ry ? d.useLayoutEffect(e, t) : d.useEffect(e, t)
}
function xy(e) {
  var t
  return (t = e.key) !== null && t !== void 0 ? t : e.value
}
var Ch = function (t) {
    t.preventDefault(), t.stopPropagation()
  },
  Dy = function (t) {
    var i = t.id,
      s = t.prefixCls,
      n = t.values,
      r = t.open,
      o = t.searchValue,
      a = t.autoClearSearchValue,
      l = t.inputRef,
      c = t.placeholder,
      u = t.disabled,
      h = t.mode,
      g = t.showSearch,
      f = t.autoFocus,
      p = t.autoComplete,
      v = t.activeDescendantId,
      m = t.tabIndex,
      C = t.removeIcon,
      w = t.maxTagCount,
      S = t.maxTagTextLength,
      y = t.maxTagPlaceholder,
      F =
        y === void 0
          ? function (K) {
              return '+ '.concat(K.length, ' ...')
            }
          : y,
      R = t.tagRender,
      b = t.onToggleOpen,
      x = t.onRemove,
      D = t.onInputChange,
      O = t.onInputPaste,
      M = t.onInputKeyDown,
      L = t.onInputMouseDown,
      V = t.onInputCompositionStart,
      A = t.onInputCompositionEnd,
      I = d.useRef(null),
      P = d.useState(0),
      k = Z(P, 2),
      E = k[0],
      N = k[1],
      T = d.useState(!1),
      G = Z(T, 2),
      H = G[0],
      _ = G[1],
      B = ''.concat(s, '-selection'),
      z = r || (h === 'multiple' && a === !1) || h === 'tags' ? o : '',
      Q = h === 'tags' || (h === 'multiple' && a === !1) || (g && (r || H))
    Py(
      function () {
        N(I.current.scrollWidth)
      },
      [z],
    )
    var J = function (q, ne, oe, le, me) {
        return d.createElement(
          'span',
          {
            title: Ff(q),
            className: pe(
              ''.concat(B, '-item'),
              ce({}, ''.concat(B, '-item-disabled'), oe),
            ),
          },
          d.createElement(
            'span',
            { className: ''.concat(B, '-item-content') },
            ne,
          ),
          le &&
            d.createElement(
              tl,
              {
                className: ''.concat(B, '-item-remove'),
                onMouseDown: Ch,
                onClick: me,
                customizeIcon: C,
              },
              '',
            ),
        )
      },
      se = function (q, ne, oe, le, me, ye) {
        var Me = function ($e) {
          Ch($e), b(!r)
        }
        return d.createElement(
          'span',
          { onMouseDown: Me },
          R({
            label: ne,
            value: q,
            disabled: oe,
            closable: le,
            onClose: me,
            isMaxTag: !!ye,
          }),
        )
      },
      ie = function (q) {
        var ne = q.disabled,
          oe = q.label,
          le = q.value,
          me = !u && !ne,
          ye = oe
        if (
          typeof S == 'number' &&
          (typeof oe == 'string' || typeof oe == 'number')
        ) {
          var Me = String(ye)
          Me.length > S && (ye = ''.concat(Me.slice(0, S), '...'))
        }
        var He = function (Fe) {
          Fe && Fe.stopPropagation(), x(q)
        }
        return typeof R == 'function'
          ? se(le, ye, ne, me, He)
          : J(q, ye, ne, me, He)
      },
      U = function (q) {
        var ne = typeof F == 'function' ? F(q) : F
        return typeof R == 'function'
          ? se(void 0, ne, !1, !1, void 0, !0)
          : J({ title: ne }, ne, !1)
      },
      W = d.createElement(
        'div',
        {
          className: ''.concat(B, '-search'),
          style: { width: E },
          onFocus: function () {
            _(!0)
          },
          onBlur: function () {
            _(!1)
          },
        },
        d.createElement(bf, {
          ref: l,
          open: r,
          prefixCls: s,
          id: i,
          inputElement: null,
          disabled: u,
          autoFocus: f,
          autoComplete: p,
          editable: Q,
          activeDescendantId: v,
          value: z,
          onKeyDown: M,
          onMouseDown: L,
          onChange: D,
          onPaste: O,
          onCompositionStart: V,
          onCompositionEnd: A,
          tabIndex: m,
          attrs: Bs(t, !0),
        }),
        d.createElement(
          'span',
          {
            ref: I,
            className: ''.concat(B, '-search-mirror'),
            'aria-hidden': !0,
          },
          z,
          '',
        ),
      ),
      j = d.createElement(Zg, {
        prefixCls: ''.concat(B, '-overflow'),
        data: n,
        renderItem: ie,
        renderRest: U,
        suffix: W,
        itemKey: xy,
        maxCount: w,
      })
    return d.createElement(
      d.Fragment,
      null,
      j,
      !n.length &&
        !z &&
        d.createElement('span', { className: ''.concat(B, '-placeholder') }, c),
    )
  },
  My = function (t) {
    var i = t.inputElement,
      s = t.prefixCls,
      n = t.id,
      r = t.inputRef,
      o = t.disabled,
      a = t.autoFocus,
      l = t.autoComplete,
      c = t.activeDescendantId,
      u = t.mode,
      h = t.open,
      g = t.values,
      f = t.placeholder,
      p = t.tabIndex,
      v = t.showSearch,
      m = t.searchValue,
      C = t.activeValue,
      w = t.maxLength,
      S = t.onInputKeyDown,
      y = t.onInputMouseDown,
      F = t.onInputChange,
      R = t.onInputPaste,
      b = t.onInputCompositionStart,
      x = t.onInputCompositionEnd,
      D = t.title,
      O = d.useState(!1),
      M = Z(O, 2),
      L = M[0],
      V = M[1],
      A = u === 'combobox',
      I = A || v,
      P = g[0],
      k = m || ''
    A && C && !L && (k = C),
      d.useEffect(
        function () {
          A && V(!1)
        },
        [A, C],
      )
    var E = u !== 'combobox' && !h && !v ? !1 : !!k,
      N = D === void 0 ? Ff(P) : D,
      T = d.useMemo(
        function () {
          return P
            ? null
            : d.createElement(
                'span',
                {
                  className: ''.concat(s, '-selection-placeholder'),
                  style: E ? { visibility: 'hidden' } : void 0,
                },
                f,
              )
        },
        [P, E, f, s],
      )
    return d.createElement(
      d.Fragment,
      null,
      d.createElement(
        'span',
        { className: ''.concat(s, '-selection-search') },
        d.createElement(bf, {
          ref: r,
          prefixCls: s,
          id: n,
          open: h,
          inputElement: i,
          disabled: o,
          autoFocus: a,
          autoComplete: l,
          editable: I,
          activeDescendantId: c,
          value: k,
          onKeyDown: S,
          onMouseDown: y,
          onChange: function (H) {
            V(!0), F(H)
          },
          onPaste: R,
          onCompositionStart: b,
          onCompositionEnd: x,
          tabIndex: p,
          attrs: Bs(t, !0),
          maxLength: A ? w : void 0,
        }),
      ),
      !A && P
        ? d.createElement(
            'span',
            {
              className: ''.concat(s, '-selection-item'),
              title: N,
              style: E ? { visibility: 'hidden' } : void 0,
            },
            P.label,
          )
        : null,
      T,
    )
  },
  Iy = function (t, i) {
    var s = d.useRef(null),
      n = d.useRef(!1),
      r = t.prefixCls,
      o = t.open,
      a = t.mode,
      l = t.showSearch,
      c = t.tokenWithEnter,
      u = t.disabled,
      h = t.autoClearSearchValue,
      g = t.onSearch,
      f = t.onSearchSubmit,
      p = t.onToggleOpen,
      v = t.onInputKeyDown,
      m = t.domRef
    d.useImperativeHandle(i, function () {
      return {
        focus: function (E) {
          s.current.focus(E)
        },
        blur: function () {
          s.current.blur()
        },
      }
    })
    var C = yf(0),
      w = Z(C, 2),
      S = w[0],
      y = w[1],
      F = function (E) {
        var N = E.which
        ;(N === tt.UP || N === tt.DOWN) && E.preventDefault(),
          v && v(E),
          N === tt.ENTER &&
            a === 'tags' &&
            !n.current &&
            !o &&
            (f == null || f(E.target.value)),
          wy(N) && p(!0)
      },
      R = function () {
        y(!0)
      },
      b = d.useRef(null),
      x = function (E) {
        g(E, !0, n.current) !== !1 && p(!0)
      },
      D = function () {
        n.current = !0
      },
      O = function (E) {
        ;(n.current = !1), a !== 'combobox' && x(E.target.value)
      },
      M = function (E) {
        var N = E.target.value
        if (c && b.current && /[\r\n]/.test(b.current)) {
          var T = b.current
            .replace(/[\r\n]+$/, '')
            .replace(/\r\n/g, ' ')
            .replace(/[\r\n]/g, ' ')
          N = N.replace(T, b.current)
        }
        ;(b.current = null), x(N)
      },
      L = function (E) {
        var N = E.clipboardData,
          T = N == null ? void 0 : N.getData('text')
        b.current = T || ''
      },
      V = function (E) {
        var N = E.target
        if (N !== s.current) {
          var T = document.body.style.msTouchAction !== void 0
          T
            ? setTimeout(function () {
                s.current.focus()
              })
            : s.current.focus()
        }
      },
      A = function (E) {
        var N = S()
        E.target !== s.current &&
          !N &&
          !(a === 'combobox' && u) &&
          E.preventDefault(),
          ((a !== 'combobox' && (!l || !N)) || !o) &&
            (o && h !== !1 && g('', !0, !1), p())
      },
      I = {
        inputRef: s,
        onInputKeyDown: F,
        onInputMouseDown: R,
        onInputChange: M,
        onInputPaste: L,
        onInputCompositionStart: D,
        onInputCompositionEnd: O,
      },
      P =
        a === 'multiple' || a === 'tags'
          ? d.createElement(Dy, xe({}, t, I))
          : d.createElement(My, xe({}, t, I))
    return d.createElement(
      'div',
      {
        ref: m,
        className: ''.concat(r, '-selector'),
        onClick: V,
        onMouseDown: A,
      },
      P,
    )
  },
  Ty = d.forwardRef(Iy),
  Ay = [
    'prefixCls',
    'disabled',
    'visible',
    'children',
    'popupElement',
    'animation',
    'transitionName',
    'dropdownStyle',
    'dropdownClassName',
    'direction',
    'placement',
    'builtinPlacements',
    'dropdownMatchSelectWidth',
    'dropdownRender',
    'dropdownAlign',
    'getPopupContainer',
    'empty',
    'getTriggerDOMNode',
    'onPopupVisibleChange',
    'onPopupMouseEnter',
  ],
  Oy = function (t) {
    var i = t === !0 ? 0 : 1
    return {
      bottomLeft: {
        points: ['tl', 'bl'],
        offset: [0, 4],
        overflow: { adjustX: i, adjustY: 1 },
        htmlRegion: 'scroll',
      },
      bottomRight: {
        points: ['tr', 'br'],
        offset: [0, 4],
        overflow: { adjustX: i, adjustY: 1 },
        htmlRegion: 'scroll',
      },
      topLeft: {
        points: ['bl', 'tl'],
        offset: [0, -4],
        overflow: { adjustX: i, adjustY: 1 },
        htmlRegion: 'scroll',
      },
      topRight: {
        points: ['br', 'tr'],
        offset: [0, -4],
        overflow: { adjustX: i, adjustY: 1 },
        htmlRegion: 'scroll',
      },
    }
  },
  Ly = function (t, i) {
    var s = t.prefixCls
    t.disabled
    var n = t.visible,
      r = t.children,
      o = t.popupElement,
      a = t.animation,
      l = t.transitionName,
      c = t.dropdownStyle,
      u = t.dropdownClassName,
      h = t.direction,
      g = h === void 0 ? 'ltr' : h,
      f = t.placement,
      p = t.builtinPlacements,
      v = t.dropdownMatchSelectWidth,
      m = t.dropdownRender,
      C = t.dropdownAlign,
      w = t.getPopupContainer,
      S = t.empty,
      y = t.getTriggerDOMNode,
      F = t.onPopupVisibleChange,
      R = t.onPopupMouseEnter,
      b = Kt(t, Ay),
      x = ''.concat(s, '-dropdown'),
      D = o
    m && (D = m(o))
    var O = d.useMemo(
        function () {
          return p || Oy(v)
        },
        [p, v],
      ),
      M = a ? ''.concat(x, '-').concat(a) : l,
      L = typeof v == 'number',
      V = d.useMemo(
        function () {
          return L ? null : v === !1 ? 'minWidth' : 'width'
        },
        [v, L],
      ),
      A = c
    L && (A = re(re({}, A), {}, { width: v }))
    var I = d.useRef(null)
    return (
      d.useImperativeHandle(i, function () {
        return {
          getPopupElement: function () {
            var k
            return (k = I.current) === null || k === void 0
              ? void 0
              : k.popupElement
          },
        }
      }),
      d.createElement(
        ef,
        xe({}, b, {
          showAction: F ? ['click'] : [],
          hideAction: F ? ['click'] : [],
          popupPlacement: f || (g === 'rtl' ? 'bottomRight' : 'bottomLeft'),
          builtinPlacements: O,
          prefixCls: x,
          popupTransitionName: M,
          popup: d.createElement('div', { onMouseEnter: R }, D),
          ref: I,
          stretch: V,
          popupAlign: C,
          popupVisible: n,
          getPopupContainer: w,
          popupClassName: pe(u, ce({}, ''.concat(x, '-empty'), S)),
          popupStyle: A,
          getTriggerDOMNode: y,
          onPopupVisibleChange: F,
        }),
        r,
      )
    )
  },
  ky = d.forwardRef(Ly)
function Sh(e, t) {
  var i = e.key,
    s
  return (
    'value' in e && (s = e.value),
    i ?? (s !== void 0 ? s : 'rc-index-key-'.concat(t))
  )
}
function Dc(e) {
  return typeof e < 'u' && !Number.isNaN(e)
}
function Ef(e, t) {
  var i = e || {},
    s = i.label,
    n = i.value,
    r = i.options,
    o = i.groupLabel,
    a = s || (t ? 'children' : 'label')
  return {
    label: a,
    value: n || 'value',
    options: r || 'options',
    groupLabel: o || a,
  }
}
function Hy(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    i = t.fieldNames,
    s = t.childrenAsData,
    n = [],
    r = Ef(i, !1),
    o = r.label,
    a = r.value,
    l = r.options,
    c = r.groupLabel
  function u(h, g) {
    Array.isArray(h) &&
      h.forEach(function (f) {
        if (g || !(l in f)) {
          var p = f[a]
          n.push({
            key: Sh(f, n.length),
            groupOption: g,
            data: f,
            label: f[o],
            value: p,
          })
        } else {
          var v = f[c]
          v === void 0 && s && (v = f.label),
            n.push({ key: Sh(f, n.length), group: !0, data: f, label: v }),
            u(f[l], !0)
        }
      })
  }
  return u(e, !1), n
}
function Mc(e) {
  var t = re({}, e)
  return (
    'props' in t ||
      Object.defineProperty(t, 'props', {
        get: function () {
          return (
            tf(
              !1,
              'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.',
            ),
            t
          )
        },
      }),
    t
  )
}
var Ny = function (t, i, s) {
    if (!i || !i.length) return null
    var n = !1,
      r = function a(l, c) {
        var u = bS(c),
          h = u[0],
          g = u.slice(1)
        if (!h) return [l]
        var f = l.split(h)
        return (
          (n = n || f.length > 1),
          f
            .reduce(function (p, v) {
              return [].concat(St(p), St(a(v, g)))
            }, [])
            .filter(Boolean)
        )
      },
      o = r(t, i)
    return n ? (typeof s < 'u' ? o.slice(0, s) : o) : null
  },
  Du = d.createContext(null)
function Gy(e) {
  var t = e.visible,
    i = e.values
  if (!t) return null
  var s = 50
  return d.createElement(
    'span',
    {
      'aria-live': 'polite',
      style: {
        width: 0,
        height: 0,
        position: 'absolute',
        overflow: 'hidden',
        opacity: 0,
      },
    },
    ''.concat(
      i
        .slice(0, s)
        .map(function (n) {
          var r = n.label,
            o = n.value
          return ['number', 'string'].includes(Zt(r)) ? r : o
        })
        .join(', '),
    ),
    i.length > s ? ', ...' : null,
  )
}
var By = [
    'id',
    'prefixCls',
    'className',
    'showSearch',
    'tagRender',
    'direction',
    'omitDomProps',
    'displayValues',
    'onDisplayValuesChange',
    'emptyOptions',
    'notFoundContent',
    'onClear',
    'mode',
    'disabled',
    'loading',
    'getInputElement',
    'getRawInputElement',
    'open',
    'defaultOpen',
    'onDropdownVisibleChange',
    'activeValue',
    'onActiveValueChange',
    'activeDescendantId',
    'searchValue',
    'autoClearSearchValue',
    'onSearch',
    'onSearchSplit',
    'tokenSeparators',
    'allowClear',
    'suffixIcon',
    'clearIcon',
    'OptionList',
    'animation',
    'transitionName',
    'dropdownStyle',
    'dropdownClassName',
    'dropdownMatchSelectWidth',
    'dropdownRender',
    'dropdownAlign',
    'placement',
    'builtinPlacements',
    'getPopupContainer',
    'showAction',
    'onFocus',
    'onBlur',
    'onKeyUp',
    'onKeyDown',
    'onMouseDown',
  ],
  Vy = [
    'value',
    'onChange',
    'removeIcon',
    'placeholder',
    'autoFocus',
    'maxTagCount',
    'maxTagTextLength',
    'maxTagPlaceholder',
    'choiceTransitionName',
    'onInputKeyDown',
    'onPopupScroll',
    'tabIndex',
  ],
  Ic = function (t) {
    return t === 'tags' || t === 'multiple'
  },
  _y = d.forwardRef(function (e, t) {
    var i,
      s = e.id,
      n = e.prefixCls,
      r = e.className,
      o = e.showSearch,
      a = e.tagRender,
      l = e.direction,
      c = e.omitDomProps,
      u = e.displayValues,
      h = e.onDisplayValuesChange,
      g = e.emptyOptions,
      f = e.notFoundContent,
      p = f === void 0 ? 'Not Found' : f,
      v = e.onClear,
      m = e.mode,
      C = e.disabled,
      w = e.loading,
      S = e.getInputElement,
      y = e.getRawInputElement,
      F = e.open,
      R = e.defaultOpen,
      b = e.onDropdownVisibleChange,
      x = e.activeValue,
      D = e.onActiveValueChange,
      O = e.activeDescendantId,
      M = e.searchValue,
      L = e.autoClearSearchValue,
      V = e.onSearch,
      A = e.onSearchSplit,
      I = e.tokenSeparators,
      P = e.allowClear,
      k = e.suffixIcon,
      E = e.clearIcon,
      N = e.OptionList,
      T = e.animation,
      G = e.transitionName,
      H = e.dropdownStyle,
      _ = e.dropdownClassName,
      B = e.dropdownMatchSelectWidth,
      z = e.dropdownRender,
      Q = e.dropdownAlign,
      J = e.placement,
      se = e.builtinPlacements,
      ie = e.getPopupContainer,
      U = e.showAction,
      W = U === void 0 ? [] : U,
      j = e.onFocus,
      K = e.onBlur,
      q = e.onKeyUp,
      ne = e.onKeyDown,
      oe = e.onMouseDown,
      le = Kt(e, By),
      me = Ic(m),
      ye = (o !== void 0 ? o : me) || m === 'combobox',
      Me = re({}, le)
    Vy.forEach(function (st) {
      delete Me[st]
    }),
      c == null ||
        c.forEach(function (st) {
          delete Me[st]
        })
    var He = d.useState(!1),
      $e = Z(He, 2),
      Fe = $e[0],
      ve = $e[1]
    d.useEffect(function () {
      ve(RS())
    }, [])
    var Be = d.useRef(null),
      Se = d.useRef(null),
      we = d.useRef(null),
      ze = d.useRef(null),
      Ue = d.useRef(null),
      ke = d.useRef(!1),
      Xe = Cy(),
      Ye = Z(Xe, 3),
      ge = Ye[0],
      ae = Ye[1],
      be = Ye[2]
    d.useImperativeHandle(t, function () {
      var st, Ke
      return {
        focus: (st = ze.current) === null || st === void 0 ? void 0 : st.focus,
        blur: (Ke = ze.current) === null || Ke === void 0 ? void 0 : Ke.blur,
        scrollTo: function (si) {
          var At
          return (At = Ue.current) === null || At === void 0
            ? void 0
            : At.scrollTo(si)
        },
        nativeElement: Be.current || Se.current,
      }
    })
    var De = d.useMemo(
        function () {
          var st
          if (m !== 'combobox') return M
          var Ke = (st = u[0]) === null || st === void 0 ? void 0 : st.value
          return typeof Ke == 'string' || typeof Ke == 'number'
            ? String(Ke)
            : ''
        },
        [M, m, u],
      ),
      fe = (m === 'combobox' && typeof S == 'function' && S()) || null,
      Ce = typeof y == 'function' && y(),
      at = FS(
        Se,
        Ce == null || (i = Ce.props) === null || i === void 0 ? void 0 : i.ref,
      ),
      vt = d.useState(!1),
      pt = Z(vt, 2),
      $t = pt[0],
      zt = pt[1]
    li(function () {
      zt(!0)
    }, [])
    var Mt = ai(!1, { defaultValue: R, value: F }),
      Ut = Z(Mt, 2),
      Rt = Ut[0],
      oi = Ut[1],
      Ct = $t ? Rt : !1,
      ui = !p && g
    ;(C || (ui && Ct && m === 'combobox')) && (Ct = !1)
    var jt = ui ? !1 : Ct,
      kt = d.useCallback(
        function (st) {
          var Ke = st !== void 0 ? st : !Ct
          C || (oi(Ke), Ct !== Ke && (b == null || b(Ke)))
        },
        [C, Ct, oi, b],
      ),
      _e = d.useMemo(
        function () {
          return (I || []).some(function (st) {
            return [
              `
`,
              `\r
`,
            ].includes(st)
          })
        },
        [I],
      ),
      Ne = d.useContext(Du) || {},
      Ie = Ne.maxCount,
      We = Ne.rawValues,
      it = function (Ke, ii, si) {
        if (!(me && Dc(Ie) && (We == null ? void 0 : We.size) >= Ie)) {
          var At = !0,
            Ae = Ke
          D == null || D(null)
          var Ge = Ny(Ke, I, Dc(Ie) ? Ie - We.size : void 0),
            Et = si ? null : Ge
          return (
            m !== 'combobox' &&
              Et &&
              ((Ae = ''), A == null || A(Et), kt(!1), (At = !1)),
            V && De !== Ae && V(Ae, { source: ii ? 'typing' : 'effect' }),
            At
          )
        }
      },
      mt = function (Ke) {
        !Ke || !Ke.trim() || V(Ke, { source: 'submit' })
      }
    d.useEffect(
      function () {
        !Ct && !me && m !== 'combobox' && it('', !1, !1)
      },
      [Ct],
    ),
      d.useEffect(
        function () {
          Rt && C && oi(!1), C && !ke.current && ae(!1)
        },
        [C],
      )
    var ei = yf(),
      ti = Z(ei, 2),
      Ei = ti[0],
      Ft = ti[1],
      Tt = d.useRef(!1),
      di = function (Ke) {
        var ii = Ei(),
          si = Ke.key,
          At = si === 'Enter'
        if (
          (At && (m !== 'combobox' && Ke.preventDefault(), Ct || kt(!0)),
          Ft(!!De),
          si === 'Backspace' && !ii && me && !De && u.length)
        ) {
          for (
            var Ae = St(u), Ge = null, Et = Ae.length - 1;
            Et >= 0;
            Et -= 1
          ) {
            var ni = Ae[Et]
            if (!ni.disabled) {
              Ae.splice(Et, 1), (Ge = ni)
              break
            }
          }
          Ge && h(Ae, { type: 'remove', values: [Ge] })
        }
        for (
          var Yi = arguments.length,
            Fs = new Array(Yi > 1 ? Yi - 1 : 0),
            Zn = 1;
          Zn < Yi;
          Zn++
        )
          Fs[Zn - 1] = arguments[Zn]
        if (Ct && (!At || !Tt.current)) {
          var et
          ;(et = Ue.current) === null ||
            et === void 0 ||
            et.onKeyDown.apply(et, [Ke].concat(Fs))
        }
        At && (Tt.current = !0), ne == null || ne.apply(void 0, [Ke].concat(Fs))
      },
      Ai = function (Ke) {
        for (
          var ii = arguments.length,
            si = new Array(ii > 1 ? ii - 1 : 0),
            At = 1;
          At < ii;
          At++
        )
          si[At - 1] = arguments[At]
        if (Ct) {
          var Ae
          ;(Ae = Ue.current) === null ||
            Ae === void 0 ||
            Ae.onKeyUp.apply(Ae, [Ke].concat(si))
        }
        Ke.key === 'Enter' && (Tt.current = !1),
          q == null || q.apply(void 0, [Ke].concat(si))
      },
      ys = function (Ke) {
        var ii = u.filter(function (si) {
          return si !== Ke
        })
        h(ii, { type: 'remove', values: [Ke] })
      },
      Te = d.useRef(!1),
      Ee = function () {
        ae(!0),
          C ||
            (j && !Te.current && j.apply(void 0, arguments),
            W.includes('focus') && kt(!0)),
          (Te.current = !0)
      },
      Je = function () {
        ;(ke.current = !0),
          ae(!1, function () {
            ;(Te.current = !1), (ke.current = !1), kt(!1)
          }),
          !C &&
            (De &&
              (m === 'tags'
                ? V(De, { source: 'submit' })
                : m === 'multiple' && V('', { source: 'blur' })),
            K && K.apply(void 0, arguments))
      },
      ut = []
    d.useEffect(function () {
      return function () {
        ut.forEach(function (st) {
          return clearTimeout(st)
        }),
          ut.splice(0, ut.length)
      }
    }, [])
    var Ht = function (Ke) {
        var ii,
          si = Ke.target,
          At =
            (ii = we.current) === null || ii === void 0
              ? void 0
              : ii.getPopupElement()
        if (At && At.contains(si)) {
          var Ae = setTimeout(function () {
            var Yi = ut.indexOf(Ae)
            if (
              (Yi !== -1 && ut.splice(Yi, 1),
              be(),
              !Fe && !At.contains(document.activeElement))
            ) {
              var Fs
              ;(Fs = ze.current) === null || Fs === void 0 || Fs.focus()
            }
          })
          ut.push(Ae)
        }
        for (
          var Ge = arguments.length,
            Et = new Array(Ge > 1 ? Ge - 1 : 0),
            ni = 1;
          ni < Ge;
          ni++
        )
          Et[ni - 1] = arguments[ni]
        oe == null || oe.apply(void 0, [Ke].concat(Et))
      },
      vi = d.useState({}),
      hi = Z(vi, 2),
      bs = hi[1]
    function qs() {
      bs({})
    }
    var Rs
    Ce &&
      (Rs = function (Ke) {
        kt(Ke)
      }),
      Sy(
        function () {
          var st
          return [
            Be.current,
            (st = we.current) === null || st === void 0
              ? void 0
              : st.getPopupElement(),
          ]
        },
        jt,
        kt,
        !!Ce,
      )
    var os = d.useMemo(
        function () {
          return re(
            re({}, e),
            {},
            {
              notFoundContent: p,
              open: Ct,
              triggerOpen: jt,
              id: s,
              showSearch: ye,
              multiple: me,
              toggleOpen: kt,
            },
          )
        },
        [e, p, jt, Ct, s, ye, me, kt],
      ),
      pn = !!k || w,
      Qn
    pn &&
      (Qn = d.createElement(tl, {
        className: pe(
          ''.concat(n, '-arrow'),
          ce({}, ''.concat(n, '-arrow-loading'), w),
        ),
        customizeIcon: k,
        customizeIconProps: {
          loading: w,
          searchValue: De,
          open: Ct,
          focused: ge,
          showSearch: ye,
        },
      }))
    var Gr = function () {
        var Ke
        v == null || v(),
          (Ke = ze.current) === null || Ke === void 0 || Ke.focus(),
          h([], { type: 'clear', values: u }),
          it('', !1, !1)
      },
      Xn = my(n, Gr, u, P, E, C, De, m),
      Br = Xn.allowClear,
      Vr = Xn.clearIcon,
      _r = d.createElement(N, { ref: Ue }),
      Wr = pe(
        n,
        r,
        ce(
          ce(
            ce(
              ce(
                ce(
                  ce(
                    ce(
                      ce(
                        ce(
                          ce({}, ''.concat(n, '-focused'), ge),
                          ''.concat(n, '-multiple'),
                          me,
                        ),
                        ''.concat(n, '-single'),
                        !me,
                      ),
                      ''.concat(n, '-allow-clear'),
                      P,
                    ),
                    ''.concat(n, '-show-arrow'),
                    pn,
                  ),
                  ''.concat(n, '-disabled'),
                  C,
                ),
                ''.concat(n, '-loading'),
                w,
              ),
              ''.concat(n, '-open'),
              Ct,
            ),
            ''.concat(n, '-customize-input'),
            fe,
          ),
          ''.concat(n, '-show-search'),
          ye,
        ),
      ),
      Jn = d.createElement(
        ky,
        {
          ref: we,
          disabled: C,
          prefixCls: n,
          visible: jt,
          popupElement: _r,
          animation: T,
          transitionName: G,
          dropdownStyle: H,
          dropdownClassName: _,
          direction: l,
          dropdownMatchSelectWidth: B,
          dropdownRender: z,
          dropdownAlign: Q,
          placement: J,
          builtinPlacements: se,
          getPopupContainer: ie,
          empty: g,
          getTriggerDOMNode: function (Ke) {
            return Se.current || Ke
          },
          onPopupVisibleChange: Rs,
          onPopupMouseEnter: qs,
        },
        Ce
          ? d.cloneElement(Ce, { ref: at })
          : d.createElement(
              Ty,
              xe({}, e, {
                domRef: Se,
                prefixCls: n,
                inputElement: fe,
                ref: ze,
                id: s,
                showSearch: ye,
                autoClearSearchValue: L,
                mode: m,
                activeDescendantId: O,
                tagRender: a,
                values: u,
                open: Ct,
                onToggleOpen: kt,
                activeValue: x,
                searchValue: De,
                onSearch: it,
                onSearchSubmit: mt,
                onRemove: ys,
                tokenWithEnter: _e,
              }),
            ),
      ),
      mn
    return (
      Ce
        ? (mn = Jn)
        : (mn = d.createElement(
            'div',
            xe({ className: Wr }, Me, {
              ref: Be,
              onMouseDown: Ht,
              onKeyDown: di,
              onKeyUp: Ai,
              onFocus: Ee,
              onBlur: Je,
            }),
            d.createElement(Gy, { visible: ge && !Ct, values: u }),
            Jn,
            Qn,
            Br && Vr,
          )),
      d.createElement(wf.Provider, { value: os }, mn)
    )
  }),
  Mu = function () {
    return null
  }
Mu.isSelectOptGroup = !0
var Iu = function () {
  return null
}
Iu.isSelectOption = !0
var Pf = d.forwardRef(function (e, t) {
  var i = e.height,
    s = e.offsetY,
    n = e.offsetX,
    r = e.children,
    o = e.prefixCls,
    a = e.onInnerResize,
    l = e.innerProps,
    c = e.rtl,
    u = e.extra,
    h = {},
    g = { display: 'flex', flexDirection: 'column' }
  return (
    s !== void 0 &&
      ((h = { height: i, position: 'relative', overflow: 'hidden' }),
      (g = re(
        re({}, g),
        {},
        ce(
          ce(
            ce(
              ce(
                ce(
                  { transform: 'translateY('.concat(s, 'px)') },
                  c ? 'marginRight' : 'marginLeft',
                  -n,
                ),
                'position',
                'absolute',
              ),
              'left',
              0,
            ),
            'right',
            0,
          ),
          'top',
          0,
        ),
      ))),
    d.createElement(
      'div',
      { style: h },
      d.createElement(
        Do,
        {
          onResize: function (p) {
            var v = p.offsetHeight
            v && a && a()
          },
        },
        d.createElement(
          'div',
          xe(
            {
              style: g,
              className: pe(ce({}, ''.concat(o, '-holder-inner'), o)),
              ref: t,
            },
            l,
          ),
          r,
          u,
        ),
      ),
    )
  )
})
Pf.displayName = 'Filler'
function Wy(e) {
  var t = e.children,
    i = e.setRef,
    s = d.useCallback(function (n) {
      i(n)
    }, [])
  return d.cloneElement(t, { ref: s })
}
function $y(e, t, i, s, n, r, o, a) {
  var l = a.getKey
  return e.slice(t, i + 1).map(function (c, u) {
    var h = t + u,
      g = o(c, h, { style: { width: s }, offsetX: n }),
      f = l(c)
    return d.createElement(
      Wy,
      {
        key: f,
        setRef: function (v) {
          return r(c, v)
        },
      },
      g,
    )
  })
}
function zy(e, t, i) {
  var s = e.length,
    n = t.length,
    r,
    o
  if (s === 0 && n === 0) return null
  s < n ? ((r = e), (o = t)) : ((r = t), (o = e))
  var a = { __EMPTY_ITEM__: !0 }
  function l(p) {
    return p !== void 0 ? i(p) : a
  }
  for (var c = null, u = Math.abs(s - n) !== 1, h = 0; h < o.length; h += 1) {
    var g = l(r[h]),
      f = l(o[h])
    if (g !== f) {
      ;(c = h), (u = u || g !== l(o[h + 1]))
      break
    }
  }
  return c === null ? null : { index: c, multiple: u }
}
function Uy(e, t, i) {
  var s = d.useState(e),
    n = Z(s, 2),
    r = n[0],
    o = n[1],
    a = d.useState(null),
    l = Z(a, 2),
    c = l[0],
    u = l[1]
  return (
    d.useEffect(
      function () {
        var h = zy(r || [], e || [], t)
        ;(h == null ? void 0 : h.index) !== void 0 && u(e[h.index]), o(e)
      },
      [e],
    ),
    [c]
  )
}
var wh =
  (typeof navigator > 'u' ? 'undefined' : Zt(navigator)) === 'object' &&
  /Firefox/i.test(navigator.userAgent)
const xf = function (e, t, i, s) {
  var n = d.useRef(!1),
    r = d.useRef(null)
  function o() {
    clearTimeout(r.current),
      (n.current = !0),
      (r.current = setTimeout(function () {
        n.current = !1
      }, 50))
  }
  var a = d.useRef({ top: e, bottom: t, left: i, right: s })
  return (
    (a.current.top = e),
    (a.current.bottom = t),
    (a.current.left = i),
    (a.current.right = s),
    function (l, c) {
      var u =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
        h = l
          ? (c < 0 && a.current.left) || (c > 0 && a.current.right)
          : (c < 0 && a.current.top) || (c > 0 && a.current.bottom)
      return (
        u && h
          ? (clearTimeout(r.current), (n.current = !1))
          : (!h || n.current) && o(),
        !n.current && h
      )
    }
  )
}
function jy(e, t, i, s, n, r, o) {
  var a = d.useRef(0),
    l = d.useRef(null),
    c = d.useRef(null),
    u = d.useRef(!1),
    h = xf(t, i, s, n)
  function g(w, S) {
    if ((bt.cancel(l.current), !h(!1, S))) {
      var y = w
      if (!y._virtualHandled) y._virtualHandled = !0
      else return
      ;(a.current += S),
        (c.current = S),
        wh || y.preventDefault(),
        (l.current = bt(function () {
          var F = u.current ? 10 : 1
          o(a.current * F, !1), (a.current = 0)
        }))
    }
  }
  function f(w, S) {
    o(S, !0), wh || w.preventDefault()
  }
  var p = d.useRef(null),
    v = d.useRef(null)
  function m(w) {
    if (e) {
      bt.cancel(v.current),
        (v.current = bt(function () {
          p.current = null
        }, 2))
      var S = w.deltaX,
        y = w.deltaY,
        F = w.shiftKey,
        R = S,
        b = y
      ;(p.current === 'sx' || (!p.current && F && y && !S)) &&
        ((R = y), (b = 0), (p.current = 'sx'))
      var x = Math.abs(R),
        D = Math.abs(b)
      p.current === null && (p.current = r && x > D ? 'x' : 'y'),
        p.current === 'y' ? g(w, b) : f(w, R)
    }
  }
  function C(w) {
    e && (u.current = w.detail === c.current)
  }
  return [m, C]
}
function Yy(e, t, i, s) {
  var n = d.useMemo(
      function () {
        return [new Map(), []]
      },
      [e, i.id, s],
    ),
    r = Z(n, 2),
    o = r[0],
    a = r[1],
    l = function (u) {
      var h =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : u,
        g = o.get(u),
        f = o.get(h)
      if (g === void 0 || f === void 0)
        for (var p = e.length, v = a.length; v < p; v += 1) {
          var m,
            C = e[v],
            w = t(C)
          o.set(w, v)
          var S = (m = i.get(w)) !== null && m !== void 0 ? m : s
          if (
            ((a[v] = (a[v - 1] || 0) + S),
            w === u && (g = v),
            w === h && (f = v),
            g !== void 0 && f !== void 0)
          )
            break
        }
      return { top: a[g - 1] || 0, bottom: a[f] }
    }
  return l
}
var Ky = (function () {
  function e() {
    qa(this, e),
      ce(this, 'maps', void 0),
      ce(this, 'id', 0),
      (this.maps = Object.create(null))
  }
  return (
    Qa(e, [
      {
        key: 'set',
        value: function (i, s) {
          ;(this.maps[i] = s), (this.id += 1)
        },
      },
      {
        key: 'get',
        value: function (i) {
          return this.maps[i]
        },
      },
    ]),
    e
  )
})()
function qy(e, t, i) {
  var s = d.useState(0),
    n = Z(s, 2),
    r = n[0],
    o = n[1],
    a = d.useRef(new Map()),
    l = d.useRef(new Ky()),
    c = d.useRef()
  function u() {
    bt.cancel(c.current)
  }
  function h() {
    var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1
    u()
    var p = function () {
      a.current.forEach(function (m, C) {
        if (m && m.offsetParent) {
          var w = ES(m),
            S = w.offsetHeight
          l.current.get(C) !== S && l.current.set(C, w.offsetHeight)
        }
      }),
        o(function (m) {
          return m + 1
        })
    }
    f ? p() : (c.current = bt(p))
  }
  function g(f, p) {
    var v = e(f)
    a.current.get(v), p ? (a.current.set(v, p), h()) : a.current.delete(v)
  }
  return (
    d.useEffect(function () {
      return u
    }, []),
    [g, h, l.current, r]
  )
}
var yh = 14 / 15
function Qy(e, t, i) {
  var s = d.useRef(!1),
    n = d.useRef(0),
    r = d.useRef(0),
    o = d.useRef(null),
    a = d.useRef(null),
    l,
    c = function (f) {
      if (s.current) {
        var p = Math.ceil(f.touches[0].pageX),
          v = Math.ceil(f.touches[0].pageY),
          m = n.current - p,
          C = r.current - v,
          w = Math.abs(m) > Math.abs(C)
        w ? (n.current = p) : (r.current = v)
        var S = i(w, w ? m : C, !1, f)
        S && f.preventDefault(),
          clearInterval(a.current),
          S &&
            (a.current = setInterval(function () {
              w ? (m *= yh) : (C *= yh)
              var y = Math.floor(w ? m : C)
              ;(!i(w, y, !0) || Math.abs(y) <= 0.1) && clearInterval(a.current)
            }, 16))
      }
    },
    u = function () {
      ;(s.current = !1), l()
    },
    h = function (f) {
      l(),
        f.touches.length === 1 &&
          !s.current &&
          ((s.current = !0),
          (n.current = Math.ceil(f.touches[0].pageX)),
          (r.current = Math.ceil(f.touches[0].pageY)),
          (o.current = f.target),
          o.current.addEventListener('touchmove', c, { passive: !1 }),
          o.current.addEventListener('touchend', u, { passive: !0 }))
    }
  ;(l = function () {
    o.current &&
      (o.current.removeEventListener('touchmove', c),
      o.current.removeEventListener('touchend', u))
  }),
    li(
      function () {
        return (
          e && t.current.addEventListener('touchstart', h, { passive: !0 }),
          function () {
            var g
            ;(g = t.current) === null ||
              g === void 0 ||
              g.removeEventListener('touchstart', h),
              l(),
              clearInterval(a.current)
          }
        )
      },
      [e],
    )
}
var Xy = 10
function Jy(e, t, i, s, n, r, o, a) {
  var l = d.useRef(),
    c = d.useState(null),
    u = Z(c, 2),
    h = u[0],
    g = u[1]
  return (
    li(
      function () {
        if (h && h.times < Xy) {
          if (!e.current) {
            g(function (N) {
              return re({}, N)
            })
            return
          }
          r()
          var f = h.targetAlign,
            p = h.originAlign,
            v = h.index,
            m = h.offset,
            C = e.current.clientHeight,
            w = !1,
            S = f,
            y = null
          if (C) {
            for (
              var F = f || p,
                R = 0,
                b = 0,
                x = 0,
                D = Math.min(t.length - 1, v),
                O = 0;
              O <= D;
              O += 1
            ) {
              var M = n(t[O])
              b = R
              var L = i.get(M)
              ;(x = b + (L === void 0 ? s : L)), (R = x)
            }
            for (var V = F === 'top' ? m : C - m, A = D; A >= 0; A -= 1) {
              var I = n(t[A]),
                P = i.get(I)
              if (P === void 0) {
                w = !0
                break
              }
              if (((V -= P), V <= 0)) break
            }
            switch (F) {
              case 'top':
                y = b - m
                break
              case 'bottom':
                y = x - C + m
                break
              default: {
                var k = e.current.scrollTop,
                  E = k + C
                b < k ? (S = 'top') : x > E && (S = 'bottom')
              }
            }
            y !== null && o(y), y !== h.lastTop && (w = !0)
          }
          w &&
            g(
              re(
                re({}, h),
                {},
                { times: h.times + 1, targetAlign: S, lastTop: y },
              ),
            )
        }
      },
      [h, e.current],
    ),
    function (f) {
      if (f == null) {
        a()
        return
      }
      if ((bt.cancel(l.current), typeof f == 'number')) o(f)
      else if (f && Zt(f) === 'object') {
        var p,
          v = f.align
        'index' in f
          ? (p = f.index)
          : (p = t.findIndex(function (w) {
              return n(w) === f.key
            }))
        var m = f.offset,
          C = m === void 0 ? 0 : m
        g({ times: 0, index: p, offset: C, originAlign: v })
      }
    }
  )
}
function bh(e, t) {
  var i = 'touches' in e ? e.touches[0] : e
  return i[t ? 'pageX' : 'pageY']
}
var Rh = d.forwardRef(function (e, t) {
    var i = e.prefixCls,
      s = e.rtl,
      n = e.scrollOffset,
      r = e.scrollRange,
      o = e.onStartMove,
      a = e.onStopMove,
      l = e.onScroll,
      c = e.horizontal,
      u = e.spinSize,
      h = e.containerSize,
      g = e.style,
      f = e.thumbStyle,
      p = d.useState(!1),
      v = Z(p, 2),
      m = v[0],
      C = v[1],
      w = d.useState(null),
      S = Z(w, 2),
      y = S[0],
      F = S[1],
      R = d.useState(null),
      b = Z(R, 2),
      x = b[0],
      D = b[1],
      O = !s,
      M = d.useRef(),
      L = d.useRef(),
      V = d.useState(!1),
      A = Z(V, 2),
      I = A[0],
      P = A[1],
      k = d.useRef(),
      E = function () {
        clearTimeout(k.current),
          P(!0),
          (k.current = setTimeout(function () {
            P(!1)
          }, 3e3))
      },
      N = r - h || 0,
      T = h - u || 0,
      G = d.useMemo(
        function () {
          if (n === 0 || N === 0) return 0
          var U = n / N
          return U * T
        },
        [n, N, T],
      ),
      H = function (W) {
        W.stopPropagation(), W.preventDefault()
      },
      _ = d.useRef({ top: G, dragging: m, pageY: y, startTop: x })
    _.current = { top: G, dragging: m, pageY: y, startTop: x }
    var B = function (W) {
      C(!0),
        F(bh(W, c)),
        D(_.current.top),
        o(),
        W.stopPropagation(),
        W.preventDefault()
    }
    d.useEffect(function () {
      var U = function (q) {
          q.preventDefault()
        },
        W = M.current,
        j = L.current
      return (
        W.addEventListener('touchstart', U, { passive: !1 }),
        j.addEventListener('touchstart', B, { passive: !1 }),
        function () {
          W.removeEventListener('touchstart', U),
            j.removeEventListener('touchstart', B)
        }
      )
    }, [])
    var z = d.useRef()
    z.current = N
    var Q = d.useRef()
    ;(Q.current = T),
      d.useEffect(
        function () {
          if (m) {
            var U,
              W = function (q) {
                var ne = _.current,
                  oe = ne.dragging,
                  le = ne.pageY,
                  me = ne.startTop
                bt.cancel(U)
                var ye = M.current.getBoundingClientRect(),
                  Me = h / (c ? ye.width : ye.height)
                if (oe) {
                  var He = (bh(q, c) - le) * Me,
                    $e = me
                  !O && c ? ($e -= He) : ($e += He)
                  var Fe = z.current,
                    ve = Q.current,
                    Be = ve ? $e / ve : 0,
                    Se = Math.ceil(Be * Fe)
                  ;(Se = Math.max(Se, 0)),
                    (Se = Math.min(Se, Fe)),
                    (U = bt(function () {
                      l(Se, c)
                    }))
                }
              },
              j = function () {
                C(!1), a()
              }
            return (
              window.addEventListener('mousemove', W, { passive: !0 }),
              window.addEventListener('touchmove', W, { passive: !0 }),
              window.addEventListener('mouseup', j, { passive: !0 }),
              window.addEventListener('touchend', j, { passive: !0 }),
              function () {
                window.removeEventListener('mousemove', W),
                  window.removeEventListener('touchmove', W),
                  window.removeEventListener('mouseup', j),
                  window.removeEventListener('touchend', j),
                  bt.cancel(U)
              }
            )
          }
        },
        [m],
      ),
      d.useEffect(
        function () {
          return (
            E(),
            function () {
              clearTimeout(k.current)
            }
          )
        },
        [n],
      ),
      d.useImperativeHandle(t, function () {
        return { delayHidden: E }
      })
    var J = ''.concat(i, '-scrollbar'),
      se = { position: 'absolute', visibility: I ? null : 'hidden' },
      ie = {
        position: 'absolute',
        background: 'rgba(0, 0, 0, 0.5)',
        borderRadius: 99,
        cursor: 'pointer',
        userSelect: 'none',
      }
    return (
      c
        ? ((se.height = 8),
          (se.left = 0),
          (se.right = 0),
          (se.bottom = 0),
          (ie.height = '100%'),
          (ie.width = u),
          O ? (ie.left = G) : (ie.right = G))
        : ((se.width = 8),
          (se.top = 0),
          (se.bottom = 0),
          O ? (se.right = 0) : (se.left = 0),
          (ie.width = '100%'),
          (ie.height = u),
          (ie.top = G)),
      d.createElement(
        'div',
        {
          ref: M,
          className: pe(
            J,
            ce(
              ce(
                ce({}, ''.concat(J, '-horizontal'), c),
                ''.concat(J, '-vertical'),
                !c,
              ),
              ''.concat(J, '-visible'),
              I,
            ),
          ),
          style: re(re({}, se), g),
          onMouseDown: H,
          onMouseMove: E,
        },
        d.createElement('div', {
          ref: L,
          className: pe(
            ''.concat(J, '-thumb'),
            ce({}, ''.concat(J, '-thumb-moving'), m),
          ),
          style: re(re({}, ie), f),
          onMouseDown: B,
        }),
      )
    )
  }),
  Zy = 20
function Fh() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0,
    t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
    i = (e / t) * e
  return isNaN(i) && (i = 0), (i = Math.max(i, Zy)), Math.floor(i)
}
var eb = [
    'prefixCls',
    'className',
    'height',
    'itemHeight',
    'fullHeight',
    'style',
    'data',
    'children',
    'itemKey',
    'virtual',
    'direction',
    'scrollWidth',
    'component',
    'onScroll',
    'onVirtualScroll',
    'onVisibleChange',
    'innerProps',
    'extraRender',
    'styles',
  ],
  tb = [],
  ib = { overflowY: 'auto', overflowAnchor: 'none' }
function sb(e, t) {
  var i = e.prefixCls,
    s = i === void 0 ? 'rc-virtual-list' : i,
    n = e.className,
    r = e.height,
    o = e.itemHeight,
    a = e.fullHeight,
    l = a === void 0 ? !0 : a,
    c = e.style,
    u = e.data,
    h = e.children,
    g = e.itemKey,
    f = e.virtual,
    p = e.direction,
    v = e.scrollWidth,
    m = e.component,
    C = m === void 0 ? 'div' : m,
    w = e.onScroll,
    S = e.onVirtualScroll,
    y = e.onVisibleChange,
    F = e.innerProps,
    R = e.extraRender,
    b = e.styles,
    x = Kt(e, eb),
    D = d.useCallback(
      function (Te) {
        return typeof g == 'function' ? g(Te) : Te == null ? void 0 : Te[g]
      },
      [g],
    ),
    O = qy(D),
    M = Z(O, 4),
    L = M[0],
    V = M[1],
    A = M[2],
    I = M[3],
    P = !!(f !== !1 && r && o),
    k = d.useMemo(
      function () {
        return Object.values(A.maps).reduce(function (Te, Ee) {
          return Te + Ee
        }, 0)
      },
      [A.id, A.maps],
    ),
    E = P && u && (Math.max(o * u.length, k) > r || !!v),
    N = p === 'rtl',
    T = pe(s, ce({}, ''.concat(s, '-rtl'), N), n),
    G = u || tb,
    H = d.useRef(),
    _ = d.useRef(),
    B = d.useRef(),
    z = d.useState(0),
    Q = Z(z, 2),
    J = Q[0],
    se = Q[1],
    ie = d.useState(0),
    U = Z(ie, 2),
    W = U[0],
    j = U[1],
    K = d.useState(!1),
    q = Z(K, 2),
    ne = q[0],
    oe = q[1],
    le = function () {
      oe(!0)
    },
    me = function () {
      oe(!1)
    },
    ye = { getKey: D }
  function Me(Te) {
    se(function (Ee) {
      var Je
      typeof Te == 'function' ? (Je = Te(Ee)) : (Je = Te)
      var ut = $t(Je)
      return (H.current.scrollTop = ut), ut
    })
  }
  var He = d.useRef({ start: 0, end: G.length }),
    $e = d.useRef(),
    Fe = Uy(G, D),
    ve = Z(Fe, 1),
    Be = ve[0]
  $e.current = Be
  var Se = d.useMemo(
      function () {
        if (!P)
          return {
            scrollHeight: void 0,
            start: 0,
            end: G.length - 1,
            offset: void 0,
          }
        if (!E) {
          var Te
          return {
            scrollHeight:
              ((Te = _.current) === null || Te === void 0
                ? void 0
                : Te.offsetHeight) || 0,
            start: 0,
            end: G.length - 1,
            offset: void 0,
          }
        }
        for (var Ee = 0, Je, ut, Ht, vi = G.length, hi = 0; hi < vi; hi += 1) {
          var bs = G[hi],
            qs = D(bs),
            Rs = A.get(qs),
            os = Ee + (Rs === void 0 ? o : Rs)
          os >= J && Je === void 0 && ((Je = hi), (ut = Ee)),
            os > J + r && Ht === void 0 && (Ht = hi),
            (Ee = os)
        }
        return (
          Je === void 0 && ((Je = 0), (ut = 0), (Ht = Math.ceil(r / o))),
          Ht === void 0 && (Ht = G.length - 1),
          (Ht = Math.min(Ht + 1, G.length - 1)),
          { scrollHeight: Ee, start: Je, end: Ht, offset: ut }
        )
      },
      [E, P, J, G, I, r],
    ),
    we = Se.scrollHeight,
    ze = Se.start,
    Ue = Se.end,
    ke = Se.offset
  ;(He.current.start = ze), (He.current.end = Ue)
  var Xe = d.useState({ width: 0, height: r }),
    Ye = Z(Xe, 2),
    ge = Ye[0],
    ae = Ye[1],
    be = function (Ee) {
      ae({ width: Ee.offsetWidth, height: Ee.offsetHeight })
    },
    De = d.useRef(),
    fe = d.useRef(),
    Ce = d.useMemo(
      function () {
        return Fh(ge.width, v)
      },
      [ge.width, v],
    ),
    at = d.useMemo(
      function () {
        return Fh(ge.height, we)
      },
      [ge.height, we],
    ),
    vt = we - r,
    pt = d.useRef(vt)
  pt.current = vt
  function $t(Te) {
    var Ee = Te
    return (
      Number.isNaN(pt.current) || (Ee = Math.min(Ee, pt.current)),
      (Ee = Math.max(Ee, 0)),
      Ee
    )
  }
  var zt = J <= 0,
    Mt = J >= vt,
    Ut = W <= 0,
    Rt = W >= v,
    oi = xf(zt, Mt, Ut, Rt),
    Ct = function () {
      return { x: N ? -W : W, y: J }
    },
    ui = d.useRef(Ct()),
    jt = Bt(function (Te) {
      if (S) {
        var Ee = re(re({}, Ct()), Te)
        ;(ui.current.x !== Ee.x || ui.current.y !== Ee.y) &&
          (S(Ee), (ui.current = Ee))
      }
    })
  function kt(Te, Ee) {
    var Je = Te
    Ee
      ? (ya.flushSync(function () {
          j(Je)
        }),
        jt())
      : Me(Je)
  }
  function _e(Te) {
    var Ee = Te.currentTarget.scrollTop
    Ee !== J && Me(Ee), w == null || w(Te), jt()
  }
  var Ne = function (Ee) {
      var Je = Ee,
        ut = v ? v - ge.width : 0
      return (Je = Math.max(Je, 0)), (Je = Math.min(Je, ut)), Je
    },
    Ie = Bt(function (Te, Ee) {
      Ee
        ? (ya.flushSync(function () {
            j(function (Je) {
              var ut = Je + (N ? -Te : Te)
              return Ne(ut)
            })
          }),
          jt())
        : Me(function (Je) {
            var ut = Je + Te
            return ut
          })
    }),
    We = jy(P, zt, Mt, Ut, Rt, !!v, Ie),
    it = Z(We, 2),
    mt = it[0],
    ei = it[1]
  Qy(P, H, function (Te, Ee, Je, ut) {
    var Ht = ut
    return oi(Te, Ee, Je)
      ? !1
      : !Ht || !Ht._virtualHandled
        ? (Ht && (Ht._virtualHandled = !0),
          mt({
            preventDefault: function () {},
            deltaX: Te ? Ee : 0,
            deltaY: Te ? 0 : Ee,
          }),
          !0)
        : !1
  }),
    li(
      function () {
        function Te(Je) {
          var ut = zt && Je.detail < 0,
            Ht = Mt && Je.detail > 0
          P && !ut && !Ht && Je.preventDefault()
        }
        var Ee = H.current
        return (
          Ee.addEventListener('wheel', mt, { passive: !1 }),
          Ee.addEventListener('DOMMouseScroll', ei, { passive: !0 }),
          Ee.addEventListener('MozMousePixelScroll', Te, { passive: !1 }),
          function () {
            Ee.removeEventListener('wheel', mt),
              Ee.removeEventListener('DOMMouseScroll', ei),
              Ee.removeEventListener('MozMousePixelScroll', Te)
          }
        )
      },
      [P, zt, Mt],
    ),
    li(
      function () {
        if (v) {
          var Te = Ne(W)
          j(Te), jt({ x: Te })
        }
      },
      [ge.width, v],
    )
  var ti = function () {
      var Ee, Je
      ;(Ee = De.current) === null || Ee === void 0 || Ee.delayHidden(),
        (Je = fe.current) === null || Je === void 0 || Je.delayHidden()
    },
    Ei = Jy(
      H,
      G,
      A,
      o,
      D,
      function () {
        return V(!0)
      },
      Me,
      ti,
    )
  d.useImperativeHandle(t, function () {
    return {
      nativeElement: B.current,
      getScrollInfo: Ct,
      scrollTo: function (Ee) {
        function Je(ut) {
          return ut && Zt(ut) === 'object' && ('left' in ut || 'top' in ut)
        }
        Je(Ee) ? (Ee.left !== void 0 && j(Ne(Ee.left)), Ei(Ee.top)) : Ei(Ee)
      },
    }
  }),
    li(
      function () {
        if (y) {
          var Te = G.slice(ze, Ue + 1)
          y(Te, G)
        }
      },
      [ze, Ue, G],
    )
  var Ft = Yy(G, D, A, o),
    Tt =
      R == null
        ? void 0
        : R({
            start: ze,
            end: Ue,
            virtual: E,
            offsetX: W,
            offsetY: ke,
            rtl: N,
            getSize: Ft,
          }),
    di = $y(G, ze, Ue, v, W, L, h, ye),
    Ai = null
  r &&
    ((Ai = re(ce({}, l ? 'height' : 'maxHeight', r), ib)),
    P &&
      ((Ai.overflowY = 'hidden'),
      v && (Ai.overflowX = 'hidden'),
      ne && (Ai.pointerEvents = 'none')))
  var ys = {}
  return (
    N && (ys.dir = 'rtl'),
    d.createElement(
      'div',
      xe(
        {
          ref: B,
          style: re(re({}, c), {}, { position: 'relative' }),
          className: T,
        },
        ys,
        x,
      ),
      d.createElement(
        Do,
        { onResize: be },
        d.createElement(
          C,
          {
            className: ''.concat(s, '-holder'),
            style: Ai,
            ref: H,
            onScroll: _e,
            onMouseEnter: ti,
          },
          d.createElement(
            Pf,
            {
              prefixCls: s,
              height: we,
              offsetX: W,
              offsetY: ke,
              scrollWidth: v,
              onInnerResize: V,
              ref: _,
              innerProps: F,
              rtl: N,
              extra: Tt,
            },
            di,
          ),
        ),
      ),
      E &&
        we > r &&
        d.createElement(Rh, {
          ref: De,
          prefixCls: s,
          scrollOffset: J,
          scrollRange: we,
          rtl: N,
          onScroll: kt,
          onStartMove: le,
          onStopMove: me,
          spinSize: at,
          containerSize: ge.height,
          style: b == null ? void 0 : b.verticalScrollBar,
          thumbStyle: b == null ? void 0 : b.verticalScrollBarThumb,
        }),
      E &&
        v > ge.width &&
        d.createElement(Rh, {
          ref: fe,
          prefixCls: s,
          scrollOffset: W,
          scrollRange: v,
          rtl: N,
          onScroll: kt,
          onStartMove: le,
          onStopMove: me,
          spinSize: Ce,
          containerSize: ge.width,
          horizontal: !0,
          style: b == null ? void 0 : b.horizontalScrollBar,
          thumbStyle: b == null ? void 0 : b.horizontalScrollBarThumb,
        }),
    )
  )
}
var Df = d.forwardRef(sb)
Df.displayName = 'List'
function nb() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion)
}
var rb = ['disabled', 'title', 'children', 'style', 'className']
function Eh(e) {
  return typeof e == 'string' || typeof e == 'number'
}
var ob = function (t, i) {
    var s = vy(),
      n = s.prefixCls,
      r = s.id,
      o = s.open,
      a = s.multiple,
      l = s.mode,
      c = s.searchValue,
      u = s.toggleOpen,
      h = s.notFoundContent,
      g = s.onPopupScroll,
      f = d.useContext(Du),
      p = f.maxCount,
      v = f.flattenOptions,
      m = f.onActiveValue,
      C = f.defaultActiveFirstOption,
      w = f.onSelect,
      S = f.menuItemSelectedIcon,
      y = f.rawValues,
      F = f.fieldNames,
      R = f.virtual,
      b = f.direction,
      x = f.listHeight,
      D = f.listItemHeight,
      O = f.optionRender,
      M = ''.concat(n, '-item'),
      L = PS(
        function () {
          return v
        },
        [o, v],
        function (U, W) {
          return W[0] && U[1] !== W[1]
        },
      ),
      V = d.useRef(null),
      A = d.useMemo(
        function () {
          return a && Dc(p) && (y == null ? void 0 : y.size) >= p
        },
        [a, p, y == null ? void 0 : y.size],
      ),
      I = function (W) {
        W.preventDefault()
      },
      P = function (W) {
        var j
        ;(j = V.current) === null ||
          j === void 0 ||
          j.scrollTo(typeof W == 'number' ? { index: W } : W)
      },
      k = function (W) {
        for (
          var j =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : 1,
            K = L.length,
            q = 0;
          q < K;
          q += 1
        ) {
          var ne = (W + q * j + K) % K,
            oe = L[ne] || {},
            le = oe.group,
            me = oe.data
          if (!le && !(me != null && me.disabled) && !A) return ne
        }
        return -1
      },
      E = d.useState(function () {
        return k(0)
      }),
      N = Z(E, 2),
      T = N[0],
      G = N[1],
      H = function (W) {
        var j =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
        G(W)
        var K = { source: j ? 'keyboard' : 'mouse' },
          q = L[W]
        if (!q) {
          m(null, -1, K)
          return
        }
        m(q.value, W, K)
      }
    d.useEffect(
      function () {
        H(C !== !1 ? k(0) : -1)
      },
      [L.length, c],
    )
    var _ = d.useCallback(
      function (U) {
        return y.has(U) && l !== 'combobox'
      },
      [l, St(y).toString(), y.size],
    )
    d.useEffect(
      function () {
        var U = setTimeout(function () {
          if (!a && o && y.size === 1) {
            var j = Array.from(y)[0],
              K = L.findIndex(function (q) {
                var ne = q.data
                return ne.value === j
              })
            K !== -1 && (H(K), P(K))
          }
        })
        if (o) {
          var W
          ;(W = V.current) === null || W === void 0 || W.scrollTo(void 0)
        }
        return function () {
          return clearTimeout(U)
        }
      },
      [o, c],
    )
    var B = function (W) {
      W !== void 0 && w(W, { selected: !y.has(W) }), a || u(!1)
    }
    if (
      (d.useImperativeHandle(i, function () {
        return {
          onKeyDown: function (W) {
            var j = W.which,
              K = W.ctrlKey
            switch (j) {
              case tt.N:
              case tt.P:
              case tt.UP:
              case tt.DOWN: {
                var q = 0
                if (
                  (j === tt.UP
                    ? (q = -1)
                    : j === tt.DOWN
                      ? (q = 1)
                      : nb() &&
                        K &&
                        (j === tt.N ? (q = 1) : j === tt.P && (q = -1)),
                  q !== 0)
                ) {
                  var ne = k(T + q, q)
                  P(ne), H(ne, !0)
                }
                break
              }
              case tt.ENTER: {
                var oe,
                  le = L[T]
                le &&
                !(
                  le != null &&
                  (oe = le.data) !== null &&
                  oe !== void 0 &&
                  oe.disabled
                ) &&
                !A
                  ? B(le.value)
                  : B(void 0),
                  o && W.preventDefault()
                break
              }
              case tt.ESC:
                u(!1), o && W.stopPropagation()
            }
          },
          onKeyUp: function () {},
          scrollTo: function (W) {
            P(W)
          },
        }
      }),
      L.length === 0)
    )
      return d.createElement(
        'div',
        {
          role: 'listbox',
          id: ''.concat(r, '_list'),
          className: ''.concat(M, '-empty'),
          onMouseDown: I,
        },
        h,
      )
    var z = Object.keys(F).map(function (U) {
        return F[U]
      }),
      Q = function (W) {
        return W.label
      }
    function J(U, W) {
      var j = U.group
      return {
        role: j ? 'presentation' : 'option',
        id: ''.concat(r, '_list_').concat(W),
      }
    }
    var se = function (W) {
        var j = L[W]
        if (!j) return null
        var K = j.data || {},
          q = K.value,
          ne = j.group,
          oe = Bs(K, !0),
          le = Q(j)
        return j
          ? d.createElement(
              'div',
              xe(
                { 'aria-label': typeof le == 'string' && !ne ? le : null },
                oe,
                { key: W },
                J(j, W),
                { 'aria-selected': _(q) },
              ),
              q,
            )
          : null
      },
      ie = { role: 'listbox', id: ''.concat(r, '_list') }
    return d.createElement(
      d.Fragment,
      null,
      R &&
        d.createElement(
          'div',
          xe({}, ie, { style: { height: 0, width: 0, overflow: 'hidden' } }),
          se(T - 1),
          se(T),
          se(T + 1),
        ),
      d.createElement(
        Df,
        {
          itemKey: 'key',
          ref: V,
          data: L,
          height: x,
          itemHeight: D,
          fullHeight: !1,
          onMouseDown: I,
          onScroll: g,
          virtual: R,
          direction: b,
          innerProps: R ? null : ie,
        },
        function (U, W) {
          var j = U.group,
            K = U.groupOption,
            q = U.data,
            ne = U.label,
            oe = U.value,
            le = q.key
          if (j) {
            var me,
              ye =
                (me = q.title) !== null && me !== void 0
                  ? me
                  : Eh(ne)
                    ? ne.toString()
                    : void 0
            return d.createElement(
              'div',
              {
                className: pe(M, ''.concat(M, '-group'), q.className),
                title: ye,
              },
              ne !== void 0 ? ne : le,
            )
          }
          var Me = q.disabled,
            He = q.title
          q.children
          var $e = q.style,
            Fe = q.className,
            ve = Kt(q, rb),
            Be = zs(ve, z),
            Se = _(oe),
            we = Me || (!Se && A),
            ze = ''.concat(M, '-option'),
            Ue = pe(
              M,
              ze,
              Fe,
              ce(
                ce(
                  ce(
                    ce({}, ''.concat(ze, '-grouped'), K),
                    ''.concat(ze, '-active'),
                    T === W && !we,
                  ),
                  ''.concat(ze, '-disabled'),
                  we,
                ),
                ''.concat(ze, '-selected'),
                Se,
              ),
            ),
            ke = Q(U),
            Xe = !S || typeof S == 'function' || Se,
            Ye = typeof ke == 'number' ? ke : ke || oe,
            ge = Eh(Ye) ? Ye.toString() : void 0
          return (
            He !== void 0 && (ge = He),
            d.createElement(
              'div',
              xe({}, Bs(Be), R ? {} : J(U, W), {
                'aria-selected': Se,
                className: Ue,
                title: ge,
                onMouseMove: function () {
                  T === W || we || H(W)
                },
                onClick: function () {
                  we || B(oe)
                },
                style: $e,
              }),
              d.createElement(
                'div',
                { className: ''.concat(ze, '-content') },
                typeof O == 'function' ? O(U, { index: W }) : Ye,
              ),
              d.isValidElement(S) || Se,
              Xe &&
                d.createElement(
                  tl,
                  {
                    className: ''.concat(M, '-option-state'),
                    customizeIcon: S,
                    customizeIconProps: {
                      value: oe,
                      disabled: we,
                      isSelected: Se,
                    },
                  },
                  Se ? '' : null,
                ),
            )
          )
        },
      ),
    )
  },
  ab = d.forwardRef(ob)
const lb = function (e, t) {
  var i = d.useRef({ values: new Map(), options: new Map() }),
    s = d.useMemo(
      function () {
        var r = i.current,
          o = r.values,
          a = r.options,
          l = e.map(function (h) {
            if (h.label === void 0) {
              var g
              return re(
                re({}, h),
                {},
                {
                  label:
                    (g = o.get(h.value)) === null || g === void 0
                      ? void 0
                      : g.label,
                },
              )
            }
            return h
          }),
          c = new Map(),
          u = new Map()
        return (
          l.forEach(function (h) {
            c.set(h.value, h), u.set(h.value, t.get(h.value) || a.get(h.value))
          }),
          (i.current.values = c),
          (i.current.options = u),
          l
        )
      },
      [e, t],
    ),
    n = d.useCallback(
      function (r) {
        return t.get(r) || i.current.options.get(r)
      },
      [t],
    )
  return [s, n]
}
function _l(e, t) {
  return Rf(e).join('').toUpperCase().includes(t)
}
const cb = function (e, t, i, s, n) {
  return d.useMemo(
    function () {
      if (!i || s === !1) return e
      var r = t.options,
        o = t.label,
        a = t.value,
        l = [],
        c = typeof s == 'function',
        u = i.toUpperCase(),
        h = c
          ? s
          : function (f, p) {
              return n
                ? _l(p[n], u)
                : p[r]
                  ? _l(p[o !== 'children' ? o : 'label'], u)
                  : _l(p[a], u)
            },
        g = c
          ? function (f) {
              return Mc(f)
            }
          : function (f) {
              return f
            }
      return (
        e.forEach(function (f) {
          if (f[r]) {
            var p = h(i, g(f))
            if (p) l.push(f)
            else {
              var v = f[r].filter(function (m) {
                return h(i, g(m))
              })
              v.length && l.push(re(re({}, f), {}, ce({}, r, v)))
            }
            return
          }
          h(i, g(f)) && l.push(f)
        }),
        l
      )
    },
    [e, s, n, i, t],
  )
}
var Ph = 0,
  ub = xS()
function db() {
  var e
  return ub ? ((e = Ph), (Ph += 1)) : (e = 'TEST_OR_SSR'), e
}
function hb(e) {
  var t = d.useState(),
    i = Z(t, 2),
    s = i[0],
    n = i[1]
  return (
    d.useEffect(function () {
      n('rc_select_'.concat(db()))
    }, []),
    e || s
  )
}
var gb = ['children', 'value'],
  fb = ['children']
function pb(e) {
  var t = e,
    i = t.key,
    s = t.props,
    n = s.children,
    r = s.value,
    o = Kt(s, gb)
  return re({ key: i, value: r !== void 0 ? r : i, children: n }, o)
}
function Mf(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
  return DS(e)
    .map(function (i, s) {
      if (!d.isValidElement(i) || !i.type) return null
      var n = i,
        r = n.type.isSelectOptGroup,
        o = n.key,
        a = n.props,
        l = a.children,
        c = Kt(a, fb)
      return t || !r
        ? pb(i)
        : re(
            re(
              {
                key: '__RC_SELECT_GRP__'.concat(o === null ? s : o, '__'),
                label: o,
              },
              c,
            ),
            {},
            { options: Mf(l) },
          )
    })
    .filter(function (i) {
      return i
    })
}
var mb = function (t, i, s, n, r) {
  return d.useMemo(
    function () {
      var o = t,
        a = !t
      a && (o = Mf(i))
      var l = new Map(),
        c = new Map(),
        u = function (f, p, v) {
          v && typeof v == 'string' && f.set(p[v], p)
        },
        h = function g(f) {
          for (
            var p =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : !1,
              v = 0;
            v < f.length;
            v += 1
          ) {
            var m = f[v]
            !m[s.options] || p
              ? (l.set(m[s.value], m), u(c, m, s.label), u(c, m, n), u(c, m, r))
              : g(m[s.options], !0)
          }
        }
      return h(o), { options: o, valueOptions: l, labelOptions: c }
    },
    [t, i, s, n, r],
  )
}
function xh(e) {
  var t = d.useRef()
  t.current = e
  var i = d.useCallback(function () {
    return t.current.apply(t, arguments)
  }, [])
  return i
}
var vb = [
    'id',
    'mode',
    'prefixCls',
    'backfill',
    'fieldNames',
    'inputValue',
    'searchValue',
    'onSearch',
    'autoClearSearchValue',
    'onSelect',
    'onDeselect',
    'dropdownMatchSelectWidth',
    'filterOption',
    'filterSort',
    'optionFilterProp',
    'optionLabelProp',
    'options',
    'optionRender',
    'children',
    'defaultActiveFirstOption',
    'menuItemSelectedIcon',
    'virtual',
    'direction',
    'listHeight',
    'listItemHeight',
    'labelRender',
    'value',
    'defaultValue',
    'labelInValue',
    'onChange',
    'maxCount',
  ],
  Cb = ['inputValue']
function Sb(e) {
  return !e || Zt(e) !== 'object'
}
var wb = d.forwardRef(function (e, t) {
    var i = e.id,
      s = e.mode,
      n = e.prefixCls,
      r = n === void 0 ? 'rc-select' : n,
      o = e.backfill,
      a = e.fieldNames,
      l = e.inputValue,
      c = e.searchValue,
      u = e.onSearch,
      h = e.autoClearSearchValue,
      g = h === void 0 ? !0 : h,
      f = e.onSelect,
      p = e.onDeselect,
      v = e.dropdownMatchSelectWidth,
      m = v === void 0 ? !0 : v,
      C = e.filterOption,
      w = e.filterSort,
      S = e.optionFilterProp,
      y = e.optionLabelProp,
      F = e.options,
      R = e.optionRender,
      b = e.children,
      x = e.defaultActiveFirstOption,
      D = e.menuItemSelectedIcon,
      O = e.virtual,
      M = e.direction,
      L = e.listHeight,
      V = L === void 0 ? 200 : L,
      A = e.listItemHeight,
      I = A === void 0 ? 20 : A,
      P = e.labelRender,
      k = e.value,
      E = e.defaultValue,
      N = e.labelInValue,
      T = e.onChange,
      G = e.maxCount,
      H = Kt(e, vb),
      _ = hb(i),
      B = Ic(s),
      z = !!(!F && b),
      Q = d.useMemo(
        function () {
          return C === void 0 && s === 'combobox' ? !1 : C
        },
        [C, s],
      ),
      J = d.useMemo(
        function () {
          return Ef(a, z)
        },
        [JSON.stringify(a), z],
      ),
      se = ai('', {
        value: c !== void 0 ? c : l,
        postState: function (Ne) {
          return Ne || ''
        },
      }),
      ie = Z(se, 2),
      U = ie[0],
      W = ie[1],
      j = mb(F, b, J, S, y),
      K = j.valueOptions,
      q = j.labelOptions,
      ne = j.options,
      oe = d.useCallback(
        function (_e) {
          var Ne = Rf(_e)
          return Ne.map(function (Ie) {
            var We, it, mt, ei, ti
            if (Sb(Ie)) We = Ie
            else {
              var Ei
              ;(mt = Ie.key),
                (it = Ie.label),
                (We = (Ei = Ie.value) !== null && Ei !== void 0 ? Ei : mt)
            }
            var Ft = K.get(We)
            if (Ft) {
              var Tt
              it === void 0 && (it = Ft == null ? void 0 : Ft[y || J.label]),
                mt === void 0 &&
                  (mt =
                    (Tt = Ft == null ? void 0 : Ft.key) !== null &&
                    Tt !== void 0
                      ? Tt
                      : We),
                (ei = Ft == null ? void 0 : Ft.disabled),
                (ti = Ft == null ? void 0 : Ft.title)
            }
            return { label: it, value: We, key: mt, disabled: ei, title: ti }
          })
        },
        [J, y, K],
      ),
      le = ai(E, { value: k }),
      me = Z(le, 2),
      ye = me[0],
      Me = me[1],
      He = d.useMemo(
        function () {
          var _e,
            Ne = B && ye === null ? [] : ye,
            Ie = oe(Ne)
          return s === 'combobox' &&
            Ey((_e = Ie[0]) === null || _e === void 0 ? void 0 : _e.value)
            ? []
            : Ie
        },
        [ye, oe, s, B],
      ),
      $e = lb(He, K),
      Fe = Z($e, 2),
      ve = Fe[0],
      Be = Fe[1],
      Se = d.useMemo(
        function () {
          if (!s && ve.length === 1) {
            var _e = ve[0]
            if (_e.value === null && (_e.label === null || _e.label === void 0))
              return []
          }
          return ve.map(function (Ne) {
            var Ie
            return re(
              re({}, Ne),
              {},
              {
                label:
                  (Ie = typeof P == 'function' ? P(Ne) : Ne.label) !== null &&
                  Ie !== void 0
                    ? Ie
                    : Ne.value,
              },
            )
          })
        },
        [s, ve, P],
      ),
      we = d.useMemo(
        function () {
          return new Set(
            ve.map(function (_e) {
              return _e.value
            }),
          )
        },
        [ve],
      )
    d.useEffect(
      function () {
        if (s === 'combobox') {
          var _e,
            Ne = (_e = ve[0]) === null || _e === void 0 ? void 0 : _e.value
          W(Fy(Ne) ? String(Ne) : '')
        }
      },
      [ve],
    )
    var ze = xh(function (_e, Ne) {
        var Ie = Ne ?? _e
        return ce(ce({}, J.value, _e), J.label, Ie)
      }),
      Ue = d.useMemo(
        function () {
          if (s !== 'tags') return ne
          var _e = St(ne),
            Ne = function (We) {
              return K.has(We)
            }
          return (
            St(ve)
              .sort(function (Ie, We) {
                return Ie.value < We.value ? -1 : 1
              })
              .forEach(function (Ie) {
                var We = Ie.value
                Ne(We) || _e.push(ze(We, Ie.label))
              }),
            _e
          )
        },
        [ze, ne, K, ve, s],
      ),
      ke = cb(Ue, J, U, Q, S),
      Xe = d.useMemo(
        function () {
          return s !== 'tags' ||
            !U ||
            ke.some(function (_e) {
              return _e[S || 'value'] === U
            }) ||
            ke.some(function (_e) {
              return _e[J.value] === U
            })
            ? ke
            : [ze(U)].concat(St(ke))
        },
        [ze, S, s, ke, U, J],
      ),
      Ye = function _e(Ne) {
        var Ie = St(Ne).sort(function (We, it) {
          return w(We, it, { searchValue: U })
        })
        return Ie.map(function (We) {
          return Array.isArray(We.options)
            ? re(
                re({}, We),
                {},
                {
                  options: We.options.length > 0 ? _e(We.options) : We.options,
                },
              )
            : We
        })
      },
      ge = d.useMemo(
        function () {
          return w ? Ye(Xe) : Xe
        },
        [Xe, w, U],
      ),
      ae = d.useMemo(
        function () {
          return Hy(ge, { fieldNames: J, childrenAsData: z })
        },
        [ge, J, z],
      ),
      be = function (Ne) {
        var Ie = oe(Ne)
        if (
          (Me(Ie),
          T &&
            (Ie.length !== ve.length ||
              Ie.some(function (mt, ei) {
                var ti
                return (
                  ((ti = ve[ei]) === null || ti === void 0
                    ? void 0
                    : ti.value) !== (mt == null ? void 0 : mt.value)
                )
              })))
        ) {
          var We = N
              ? Ie
              : Ie.map(function (mt) {
                  return mt.value
                }),
            it = Ie.map(function (mt) {
              return Mc(Be(mt.value))
            })
          T(B ? We : We[0], B ? it : it[0])
        }
      },
      De = d.useState(null),
      fe = Z(De, 2),
      Ce = fe[0],
      at = fe[1],
      vt = d.useState(0),
      pt = Z(vt, 2),
      $t = pt[0],
      zt = pt[1],
      Mt = x !== void 0 ? x : s !== 'combobox',
      Ut = d.useCallback(
        function (_e, Ne) {
          var Ie =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : {},
            We = Ie.source,
            it = We === void 0 ? 'keyboard' : We
          zt(Ne),
            o &&
              s === 'combobox' &&
              _e !== null &&
              it === 'keyboard' &&
              at(String(_e))
        },
        [o, s],
      ),
      Rt = function (Ne, Ie, We) {
        var it = function () {
          var Te,
            Ee = Be(Ne)
          return [
            N
              ? {
                  label: Ee == null ? void 0 : Ee[J.label],
                  value: Ne,
                  key:
                    (Te = Ee == null ? void 0 : Ee.key) !== null &&
                    Te !== void 0
                      ? Te
                      : Ne,
                }
              : Ne,
            Mc(Ee),
          ]
        }
        if (Ie && f) {
          var mt = it(),
            ei = Z(mt, 2),
            ti = ei[0],
            Ei = ei[1]
          f(ti, Ei)
        } else if (!Ie && p && We !== 'clear') {
          var Ft = it(),
            Tt = Z(Ft, 2),
            di = Tt[0],
            Ai = Tt[1]
          p(di, Ai)
        }
      },
      oi = xh(function (_e, Ne) {
        var Ie,
          We = B ? Ne.selected : !0
        We
          ? (Ie = B ? [].concat(St(ve), [_e]) : [_e])
          : (Ie = ve.filter(function (it) {
              return it.value !== _e
            })),
          be(Ie),
          Rt(_e, We),
          s === 'combobox' ? at('') : (!Ic || g) && (W(''), at(''))
      }),
      Ct = function (Ne, Ie) {
        be(Ne)
        var We = Ie.type,
          it = Ie.values
        ;(We === 'remove' || We === 'clear') &&
          it.forEach(function (mt) {
            Rt(mt.value, !1, We)
          })
      },
      ui = function (Ne, Ie) {
        if ((W(Ne), at(null), Ie.source === 'submit')) {
          var We = (Ne || '').trim()
          if (We) {
            var it = Array.from(new Set([].concat(St(we), [We])))
            be(it), Rt(We, !0), W('')
          }
          return
        }
        Ie.source !== 'blur' && (s === 'combobox' && be(Ne), u == null || u(Ne))
      },
      jt = function (Ne) {
        var Ie = Ne
        s !== 'tags' &&
          (Ie = Ne.map(function (it) {
            var mt = q.get(it)
            return mt == null ? void 0 : mt.value
          }).filter(function (it) {
            return it !== void 0
          }))
        var We = Array.from(new Set([].concat(St(we), St(Ie))))
        be(We),
          We.forEach(function (it) {
            Rt(it, !0)
          })
      },
      kt = d.useMemo(
        function () {
          var _e = O !== !1 && m !== !1
          return re(
            re({}, j),
            {},
            {
              flattenOptions: ae,
              onActiveValue: Ut,
              defaultActiveFirstOption: Mt,
              onSelect: oi,
              menuItemSelectedIcon: D,
              rawValues: we,
              fieldNames: J,
              virtual: _e,
              direction: M,
              listHeight: V,
              listItemHeight: I,
              childrenAsData: z,
              maxCount: G,
              optionRender: R,
            },
          )
        },
        [G, j, ae, Ut, Mt, oi, D, we, J, O, m, M, V, I, z, R],
      )
    return d.createElement(
      Du.Provider,
      { value: kt },
      d.createElement(
        _y,
        xe({}, H, {
          id: _,
          prefixCls: r,
          ref: t,
          omitDomProps: Cb,
          mode: s,
          displayValues: Se,
          onDisplayValuesChange: Ct,
          direction: M,
          searchValue: U,
          onSearch: ui,
          autoClearSearchValue: g,
          onSearchSplit: jt,
          dropdownMatchSelectWidth: m,
          OptionList: ab,
          emptyOptions: !ae.length,
          activeValue: Ce,
          activeDescendantId: ''.concat(_, '_list_').concat($t),
        }),
      ),
    )
  }),
  Tu = wb
Tu.Option = Iu
Tu.OptGroup = Mu
function gr(e, t, i) {
  return pe({
    [`${e}-status-success`]: t === 'success',
    [`${e}-status-warning`]: t === 'warning',
    [`${e}-status-error`]: t === 'error',
    [`${e}-status-validating`]: t === 'validating',
    [`${e}-has-feedback`]: i,
  })
}
const wr = (e, t) => t || e,
  yb = () => {
    const [, e] = xo(),
      i = new Ts(e.colorBgBase).toHsl().l < 0.5 ? { opacity: 0.65 } : {}
    return d.createElement(
      'svg',
      {
        style: i,
        width: '184',
        height: '152',
        viewBox: '0 0 184 152',
        xmlns: 'http://www.w3.org/2000/svg',
      },
      d.createElement('title', null, 'empty image'),
      d.createElement(
        'g',
        { fill: 'none', fillRule: 'evenodd' },
        d.createElement(
          'g',
          { transform: 'translate(24 31.67)' },
          d.createElement('ellipse', {
            fillOpacity: '.8',
            fill: '#F5F5F7',
            cx: '67.797',
            cy: '106.89',
            rx: '67.797',
            ry: '12.668',
          }),
          d.createElement('path', {
            d: 'M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z',
            fill: '#AEB8C2',
          }),
          d.createElement('path', {
            d: 'M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z',
            fill: 'url(#linearGradient-1)',
            transform: 'translate(13.56)',
          }),
          d.createElement('path', {
            d: 'M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z',
            fill: '#F5F5F7',
          }),
          d.createElement('path', {
            d: 'M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z',
            fill: '#DCE0E6',
          }),
        ),
        d.createElement('path', {
          d: 'M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z',
          fill: '#DCE0E6',
        }),
        d.createElement(
          'g',
          { transform: 'translate(149.65 15.383)', fill: '#FFF' },
          d.createElement('ellipse', {
            cx: '20.654',
            cy: '3.167',
            rx: '2.849',
            ry: '2.815',
          }),
          d.createElement('path', {
            d: 'M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z',
          }),
        ),
      ),
    )
  },
  bb = () => {
    const [, e] = xo(),
      {
        colorFill: t,
        colorFillTertiary: i,
        colorFillQuaternary: s,
        colorBgContainer: n,
      } = e,
      {
        borderColor: r,
        shadowColor: o,
        contentColor: a,
      } = d.useMemo(
        () => ({
          borderColor: new Ts(t).onBackground(n).toHexShortString(),
          shadowColor: new Ts(i).onBackground(n).toHexShortString(),
          contentColor: new Ts(s).onBackground(n).toHexShortString(),
        }),
        [t, i, s, n],
      )
    return d.createElement(
      'svg',
      {
        width: '64',
        height: '41',
        viewBox: '0 0 64 41',
        xmlns: 'http://www.w3.org/2000/svg',
      },
      d.createElement('title', null, 'Simple Empty'),
      d.createElement(
        'g',
        { transform: 'translate(0 1)', fill: 'none', fillRule: 'evenodd' },
        d.createElement('ellipse', {
          fill: o,
          cx: '32',
          cy: '33',
          rx: '32',
          ry: '7',
        }),
        d.createElement(
          'g',
          { fillRule: 'nonzero', stroke: r },
          d.createElement('path', {
            d: 'M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z',
          }),
          d.createElement('path', {
            d: 'M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z',
            fill: a,
          }),
        ),
      ),
    )
  },
  Rb = (e) => {
    const {
      componentCls: t,
      margin: i,
      marginXS: s,
      marginXL: n,
      fontSize: r,
      lineHeight: o,
    } = e
    return {
      [t]: {
        marginInline: s,
        fontSize: r,
        lineHeight: o,
        textAlign: 'center',
        [`${t}-image`]: {
          height: e.emptyImgHeight,
          marginBottom: s,
          opacity: e.opacityImage,
          img: { height: '100%' },
          svg: { maxWidth: '100%', height: '100%', margin: 'auto' },
        },
        [`${t}-description`]: { color: e.colorTextDescription },
        [`${t}-footer`]: { marginTop: i },
        '&-normal': {
          marginBlock: n,
          color: e.colorTextDescription,
          [`${t}-description`]: { color: e.colorTextDescription },
          [`${t}-image`]: { height: e.emptyImgHeightMD },
        },
        '&-small': {
          marginBlock: s,
          color: e.colorTextDescription,
          [`${t}-image`]: { height: e.emptyImgHeightSM },
        },
      },
    }
  },
  Fb = dn('Empty', (e) => {
    const { componentCls: t, controlHeightLG: i, calc: s } = e,
      n = Jt(e, {
        emptyImgCls: `${t}-img`,
        emptyImgHeight: s(i).mul(2.5).equal(),
        emptyImgHeightMD: i,
        emptyImgHeightSM: s(i).mul(0.875).equal(),
      })
    return [Rb(n)]
  })
var Eb = function (e, t) {
  var i = {}
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) &&
      t.indexOf(s) < 0 &&
      (i[s] = e[s])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
      t.indexOf(s[n]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
        (i[s[n]] = e[s[n]])
  return i
}
const If = d.createElement(yb, null),
  Tf = d.createElement(bb, null),
  yn = (e) => {
    var {
        className: t,
        rootClassName: i,
        prefixCls: s,
        image: n = If,
        description: r,
        children: o,
        imageStyle: a,
        style: l,
      } = e,
      c = Eb(e, [
        'className',
        'rootClassName',
        'prefixCls',
        'image',
        'description',
        'children',
        'imageStyle',
        'style',
      ])
    const { getPrefixCls: u, direction: h, empty: g } = d.useContext(qt),
      f = u('empty', s),
      [p, v, m] = Fb(f),
      [C] = wu('Empty'),
      w = typeof r < 'u' ? r : C == null ? void 0 : C.description,
      S = typeof w == 'string' ? w : 'empty'
    let y = null
    return (
      typeof n == 'string'
        ? (y = d.createElement('img', { alt: S, src: n }))
        : (y = n),
      p(
        d.createElement(
          'div',
          Object.assign(
            {
              className: pe(
                v,
                m,
                f,
                g == null ? void 0 : g.className,
                { [`${f}-normal`]: n === Tf, [`${f}-rtl`]: h === 'rtl' },
                t,
                i,
              ),
              style: Object.assign(
                Object.assign({}, g == null ? void 0 : g.style),
                l,
              ),
            },
            c,
          ),
          d.createElement('div', { className: `${f}-image`, style: a }, y),
          w && d.createElement('div', { className: `${f}-description` }, w),
          o && d.createElement('div', { className: `${f}-footer` }, o),
        ),
      )
    )
  }
yn.PRESENTED_IMAGE_DEFAULT = If
yn.PRESENTED_IMAGE_SIMPLE = Tf
const Pb = (e) => {
    const { componentName: t } = e,
      { getPrefixCls: i } = d.useContext(qt),
      s = i('empty')
    switch (t) {
      case 'Table':
      case 'List':
        return $.createElement(yn, { image: yn.PRESENTED_IMAGE_SIMPLE })
      case 'Select':
      case 'TreeSelect':
      case 'Cascader':
      case 'Transfer':
      case 'Mentions':
        return $.createElement(yn, {
          image: yn.PRESENTED_IMAGE_SIMPLE,
          className: `${s}-small`,
        })
      case 'Table.filter':
        return null
      default:
        return $.createElement(yn, null)
    }
  },
  Io = function (e, t) {
    let i =
      arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0
    var s, n
    const { variant: r, [e]: o } = d.useContext(qt),
      a = d.useContext(MS),
      l = o == null ? void 0 : o.variant
    let c
    typeof t < 'u'
      ? (c = t)
      : i === !1
        ? (c = 'borderless')
        : (c =
            (n = (s = a ?? l) !== null && s !== void 0 ? s : r) !== null &&
            n !== void 0
              ? n
              : 'outlined')
    const u = IS.includes(c)
    return [c, u]
  },
  xb = (e) => {
    const i = {
      overflow: { adjustX: !0, adjustY: !0, shiftY: !0 },
      htmlRegion: e === 'scroll' ? 'scroll' : 'visible',
      dynamicInset: !0,
    }
    return {
      bottomLeft: Object.assign(Object.assign({}, i), {
        points: ['tl', 'bl'],
        offset: [0, 4],
      }),
      bottomRight: Object.assign(Object.assign({}, i), {
        points: ['tr', 'br'],
        offset: [0, 4],
      }),
      topLeft: Object.assign(Object.assign({}, i), {
        points: ['bl', 'tl'],
        offset: [0, -4],
      }),
      topRight: Object.assign(Object.assign({}, i), {
        points: ['br', 'tr'],
        offset: [0, -4],
      }),
    }
  }
function Db(e, t) {
  return e || xb(t)
}
const Dh = (e) => {
    const {
      optionHeight: t,
      optionFontSize: i,
      optionLineHeight: s,
      optionPadding: n,
    } = e
    return {
      position: 'relative',
      display: 'block',
      minHeight: t,
      padding: n,
      color: e.colorText,
      fontWeight: 'normal',
      fontSize: i,
      lineHeight: s,
      boxSizing: 'border-box',
    }
  },
  Mb = (e) => {
    const { antCls: t, componentCls: i } = e,
      s = `${i}-item`,
      n = `&${t}-slide-up-enter${t}-slide-up-enter-active`,
      r = `&${t}-slide-up-appear${t}-slide-up-appear-active`,
      o = `&${t}-slide-up-leave${t}-slide-up-leave-active`,
      a = `${i}-dropdown-placement-`
    return [
      {
        [`${i}-dropdown`]: Object.assign(Object.assign({}, Ns(e)), {
          position: 'absolute',
          top: -9999,
          zIndex: e.zIndexPopup,
          boxSizing: 'border-box',
          padding: e.paddingXXS,
          overflow: 'hidden',
          fontSize: e.fontSize,
          fontVariant: 'initial',
          backgroundColor: e.colorBgElevated,
          borderRadius: e.borderRadiusLG,
          outline: 'none',
          boxShadow: e.boxShadowSecondary,
          [`
          ${n}${a}bottomLeft,
          ${r}${a}bottomLeft
        `]: { animationName: sf },
          [`
          ${n}${a}topLeft,
          ${r}${a}topLeft,
          ${n}${a}topRight,
          ${r}${a}topRight
        `]: { animationName: nf },
          [`${o}${a}bottomLeft`]: { animationName: rf },
          [`
          ${o}${a}topLeft,
          ${o}${a}topRight
        `]: { animationName: of },
          '&-hidden': { display: 'none' },
          [s]: Object.assign(Object.assign({}, Dh(e)), {
            cursor: 'pointer',
            transition: `background ${e.motionDurationSlow} ease`,
            borderRadius: e.borderRadiusSM,
            '&-group': {
              color: e.colorTextDescription,
              fontSize: e.fontSizeSM,
              cursor: 'default',
            },
            '&-option': {
              display: 'flex',
              '&-content': Object.assign({ flex: 'auto' }, ho),
              '&-state': {
                flex: 'none',
                display: 'flex',
                alignItems: 'center',
              },
              [`&-active:not(${s}-option-disabled)`]: {
                backgroundColor: e.optionActiveBg,
              },
              [`&-selected:not(${s}-option-disabled)`]: {
                color: e.optionSelectedColor,
                fontWeight: e.optionSelectedFontWeight,
                backgroundColor: e.optionSelectedBg,
                [`${s}-option-state`]: { color: e.colorPrimary },
                [`&:has(+ ${s}-option-selected:not(${s}-option-disabled))`]: {
                  borderEndStartRadius: 0,
                  borderEndEndRadius: 0,
                  [`& + ${s}-option-selected:not(${s}-option-disabled)`]: {
                    borderStartStartRadius: 0,
                    borderStartEndRadius: 0,
                  },
                },
              },
              '&-disabled': {
                [`&${s}-option-selected`]: {
                  backgroundColor: e.colorBgContainerDisabled,
                },
                color: e.colorTextDisabled,
                cursor: 'not-allowed',
              },
              '&-grouped': {
                paddingInlineStart: e
                  .calc(e.controlPaddingHorizontal)
                  .mul(2)
                  .equal(),
              },
            },
            '&-empty': Object.assign(Object.assign({}, Dh(e)), {
              color: e.colorTextDisabled,
            }),
          }),
          '&-rtl': { direction: 'rtl' },
        }),
      },
      ba(e, 'slide-up'),
      ba(e, 'slide-down'),
      Ea(e, 'move-up'),
      Ea(e, 'move-down'),
    ]
  },
  Af = (e) => {
    const {
        multipleSelectItemHeight: t,
        paddingXXS: i,
        lineWidth: s,
        INTERNAL_FIXED_ITEM_MARGIN: n,
      } = e,
      r = e.max(e.calc(i).sub(s).equal(), 0),
      o = e.max(e.calc(r).sub(n).equal(), 0)
    return {
      basePadding: r,
      containerPadding: o,
      itemHeight: de(t),
      itemLineHeight: de(e.calc(t).sub(e.calc(e.lineWidth).mul(2)).equal()),
    }
  },
  Ib = (e) => {
    const { multipleSelectItemHeight: t, selectHeight: i, lineWidth: s } = e
    return e.calc(i).sub(t).div(2).sub(s).equal()
  },
  Of = (e) => {
    const {
      componentCls: t,
      iconCls: i,
      borderRadiusSM: s,
      motionDurationSlow: n,
      paddingXS: r,
      multipleItemColorDisabled: o,
      multipleItemBorderColorDisabled: a,
      colorIcon: l,
      colorIconHover: c,
      INTERNAL_FIXED_ITEM_MARGIN: u,
    } = e
    return {
      [`${t}-selection-overflow`]: {
        position: 'relative',
        display: 'flex',
        flex: 'auto',
        flexWrap: 'wrap',
        maxWidth: '100%',
        '&-item': {
          flex: 'none',
          alignSelf: 'center',
          maxWidth: '100%',
          display: 'inline-flex',
        },
        [`${t}-selection-item`]: {
          display: 'flex',
          alignSelf: 'center',
          flex: 'none',
          boxSizing: 'border-box',
          maxWidth: '100%',
          marginBlock: u,
          borderRadius: s,
          cursor: 'default',
          transition: `font-size ${n}, line-height ${n}, height ${n}`,
          marginInlineEnd: e.calc(u).mul(2).equal(),
          paddingInlineStart: r,
          paddingInlineEnd: e.calc(r).div(2).equal(),
          [`${t}-disabled&`]: {
            color: o,
            borderColor: a,
            cursor: 'not-allowed',
          },
          '&-content': {
            display: 'inline-block',
            marginInlineEnd: e.calc(r).div(2).equal(),
            overflow: 'hidden',
            whiteSpace: 'pre',
            textOverflow: 'ellipsis',
          },
          '&-remove': Object.assign(Object.assign({}, af()), {
            display: 'inline-flex',
            alignItems: 'center',
            color: l,
            fontWeight: 'bold',
            fontSize: 10,
            lineHeight: 'inherit',
            cursor: 'pointer',
            [`> ${i}`]: { verticalAlign: '-0.2em' },
            '&:hover': { color: c },
          }),
        },
      },
    }
  },
  Tb = (e, t) => {
    const { componentCls: i, INTERNAL_FIXED_ITEM_MARGIN: s } = e,
      n = `${i}-selection-overflow`,
      r = e.multipleSelectItemHeight,
      o = Ib(e),
      a = t ? `${i}-${t}` : '',
      l = Af(e)
    return {
      [`${i}-multiple${a}`]: Object.assign(Object.assign({}, Of(e)), {
        [`${i}-selector`]: {
          display: 'flex',
          flexWrap: 'wrap',
          alignItems: 'center',
          height: '100%',
          paddingInline: l.basePadding,
          paddingBlock: l.containerPadding,
          borderRadius: e.borderRadius,
          [`${i}-disabled&`]: {
            background: e.multipleSelectorBgDisabled,
            cursor: 'not-allowed',
          },
          '&:after': {
            display: 'inline-block',
            width: 0,
            margin: `${de(s)} 0`,
            lineHeight: de(r),
            visibility: 'hidden',
            content: '"\\a0"',
          },
        },
        [`${i}-selection-item`]: {
          height: l.itemHeight,
          lineHeight: de(l.itemLineHeight),
        },
        [`${n}-item + ${n}-item`]: {
          [`${i}-selection-search`]: { marginInlineStart: 0 },
        },
        [`${n}-item-suffix`]: { height: '100%' },
        [`${i}-selection-search`]: {
          display: 'inline-flex',
          position: 'relative',
          maxWidth: '100%',
          marginInlineStart: e
            .calc(e.inputPaddingHorizontalBase)
            .sub(o)
            .equal(),
          '\n          &-input,\n          &-mirror\n        ': {
            height: r,
            fontFamily: e.fontFamily,
            lineHeight: de(r),
            transition: `all ${e.motionDurationSlow}`,
          },
          '&-input': { width: '100%', minWidth: 4.1 },
          '&-mirror': {
            position: 'absolute',
            top: 0,
            insetInlineStart: 0,
            insetInlineEnd: 'auto',
            zIndex: 999,
            whiteSpace: 'pre',
            visibility: 'hidden',
          },
        },
        [`${i}-selection-placeholder`]: {
          position: 'absolute',
          top: '50%',
          insetInlineStart: e.inputPaddingHorizontalBase,
          insetInlineEnd: e.inputPaddingHorizontalBase,
          transform: 'translateY(-50%)',
          transition: `all ${e.motionDurationSlow}`,
        },
      }),
    }
  }
function Wl(e, t) {
  const { componentCls: i } = e,
    s = t ? `${i}-${t}` : '',
    n = {
      [`${i}-multiple${s}`]: {
        fontSize: e.fontSize,
        [`${i}-selector`]: { [`${i}-show-search&`]: { cursor: 'text' } },
        [`
        &${i}-show-arrow ${i}-selector,
        &${i}-allow-clear ${i}-selector
      `]: {
          paddingInlineEnd: e
            .calc(e.fontSizeIcon)
            .add(e.controlPaddingHorizontal)
            .equal(),
        },
      },
    }
  return [Tb(e, t), n]
}
const Ab = (e) => {
  const { componentCls: t } = e,
    i = Jt(e, {
      selectHeight: e.controlHeightSM,
      multipleSelectItemHeight: e.multipleItemHeightSM,
      borderRadius: e.borderRadiusSM,
      borderRadiusSM: e.borderRadiusXS,
    }),
    s = Jt(e, {
      fontSize: e.fontSizeLG,
      selectHeight: e.controlHeightLG,
      multipleSelectItemHeight: e.multipleItemHeightLG,
      borderRadius: e.borderRadiusLG,
      borderRadiusSM: e.borderRadius,
    })
  return [
    Wl(e),
    Wl(i, 'sm'),
    {
      [`${t}-multiple${t}-sm`]: {
        [`${t}-selection-placeholder`]: {
          insetInline: e
            .calc(e.controlPaddingHorizontalSM)
            .sub(e.lineWidth)
            .equal(),
        },
        [`${t}-selection-search`]: { marginInlineStart: 2 },
      },
    },
    Wl(s, 'lg'),
  ]
}
function $l(e, t) {
  const {
      componentCls: i,
      inputPaddingHorizontalBase: s,
      borderRadius: n,
      fontSizeIcon: r,
    } = e,
    o = e.calc(e.controlHeight).sub(e.calc(e.lineWidth).mul(2)).equal(),
    a = e.calc(s).add(r).equal(),
    l = t ? `${i}-${t}` : ''
  return {
    [`${i}-single${l}`]: {
      fontSize: e.fontSize,
      height: e.controlHeight,
      [`${i}-selector`]: Object.assign(Object.assign({}, Ns(e, !0)), {
        display: 'flex',
        borderRadius: n,
        [`${i}-selection-search`]: {
          position: 'absolute',
          top: 0,
          insetInlineStart: s,
          insetInlineEnd: de(a),
          bottom: 0,
          '&-input': { width: '100%', WebkitAppearance: 'textfield' },
        },
        [`
          ${i}-selection-item,
          ${i}-selection-placeholder
        `]: {
          padding: 0,
          lineHeight: de(o),
          transition: `all ${e.motionDurationSlow}, visibility 0s`,
          alignSelf: 'center',
        },
        [`${i}-selection-placeholder`]: {
          transition: 'none',
          pointerEvents: 'none',
        },
        [[
          '&:after',
          `${i}-selection-item:empty:after`,
          `${i}-selection-placeholder:empty:after`,
        ].join(',')]: {
          display: 'inline-block',
          width: 0,
          visibility: 'hidden',
          content: '"\\a0"',
        },
      }),
      [`
        &${i}-show-arrow ${i}-selection-item,
        &${i}-show-arrow ${i}-selection-placeholder
      `]: { paddingInlineEnd: e.showArrowPaddingInlineEnd },
      [`&${i}-open ${i}-selection-item`]: { color: e.colorTextPlaceholder },
      [`&:not(${i}-customize-input)`]: {
        [`${i}-selector`]: {
          width: '100%',
          height: '100%',
          padding: `0 ${de(s)}`,
          [`${i}-selection-search-input`]: { height: o },
          '&:after': { lineHeight: de(o) },
        },
      },
      [`&${i}-customize-input`]: {
        [`${i}-selector`]: {
          '&:after': { display: 'none' },
          [`${i}-selection-search`]: { position: 'static', width: '100%' },
          [`${i}-selection-placeholder`]: {
            position: 'absolute',
            insetInlineStart: 0,
            insetInlineEnd: 0,
            padding: `0 ${de(s)}`,
            '&:after': { display: 'none' },
          },
        },
      },
    },
  }
}
function Ob(e) {
  const { componentCls: t } = e,
    i = e.calc(e.controlPaddingHorizontalSM).sub(e.lineWidth).equal()
  return [
    $l(e),
    $l(
      Jt(e, {
        controlHeight: e.controlHeightSM,
        borderRadius: e.borderRadiusSM,
      }),
      'sm',
    ),
    {
      [`${t}-single${t}-sm`]: {
        [`&:not(${t}-customize-input)`]: {
          [`${t}-selection-search`]: { insetInlineStart: i, insetInlineEnd: i },
          [`${t}-selector`]: { padding: `0 ${de(i)}` },
          [`&${t}-show-arrow ${t}-selection-search`]: {
            insetInlineEnd: e.calc(i).add(e.calc(e.fontSize).mul(1.5)).equal(),
          },
          [`
            &${t}-show-arrow ${t}-selection-item,
            &${t}-show-arrow ${t}-selection-placeholder
          `]: { paddingInlineEnd: e.calc(e.fontSize).mul(1.5).equal() },
        },
      },
    },
    $l(
      Jt(e, {
        controlHeight: e.singleItemHeightLG,
        fontSize: e.fontSizeLG,
        borderRadius: e.borderRadiusLG,
      }),
      'lg',
    ),
  ]
}
const Lb = (e) => {
    const {
        fontSize: t,
        lineHeight: i,
        lineWidth: s,
        controlHeight: n,
        controlHeightSM: r,
        controlHeightLG: o,
        paddingXXS: a,
        controlPaddingHorizontal: l,
        zIndexPopupBase: c,
        colorText: u,
        fontWeightStrong: h,
        controlItemBgActive: g,
        controlItemBgHover: f,
        colorBgContainer: p,
        colorFillSecondary: v,
        colorBgContainerDisabled: m,
        colorTextDisabled: C,
        colorPrimaryHover: w,
        colorPrimary: S,
        controlOutline: y,
      } = e,
      F = a * 2,
      R = s * 2,
      b = Math.min(n - F, n - R),
      x = Math.min(r - F, r - R),
      D = Math.min(o - F, o - R)
    return {
      INTERNAL_FIXED_ITEM_MARGIN: Math.floor(a / 2),
      zIndexPopup: c + 50,
      optionSelectedColor: u,
      optionSelectedFontWeight: h,
      optionSelectedBg: g,
      optionActiveBg: f,
      optionPadding: `${(n - t * i) / 2}px ${l}px`,
      optionFontSize: t,
      optionLineHeight: i,
      optionHeight: n,
      selectorBg: p,
      clearBg: p,
      singleItemHeightLG: o,
      multipleItemBg: v,
      multipleItemBorderColor: 'transparent',
      multipleItemHeight: b,
      multipleItemHeightSM: x,
      multipleItemHeightLG: D,
      multipleSelectorBgDisabled: m,
      multipleItemColorDisabled: C,
      multipleItemBorderColorDisabled: 'transparent',
      showArrowPaddingInlineEnd: Math.ceil(e.fontSize * 1.25),
      hoverBorderColor: w,
      activeBorderColor: S,
      activeOutlineColor: y,
    }
  },
  Lf = (e, t) => {
    const { componentCls: i, antCls: s, controlOutlineWidth: n } = e
    return {
      [`&:not(${i}-customize-input) ${i}-selector`]: {
        border: `${de(e.lineWidth)} ${e.lineType} ${t.borderColor}`,
        background: e.selectorBg,
      },
      [`&:not(${i}-disabled):not(${i}-customize-input):not(${s}-pagination-size-changer)`]:
        {
          [`&:hover ${i}-selector`]: { borderColor: t.hoverBorderHover },
          [`${i}-focused& ${i}-selector`]: {
            borderColor: t.activeBorderColor,
            boxShadow: `0 0 0 ${de(n)} ${t.activeOutlineColor}`,
            outline: 0,
          },
        },
    }
  },
  Mh = (e, t) => ({
    [`&${e.componentCls}-status-${t.status}`]: Object.assign({}, Lf(e, t)),
  }),
  kb = (e) => ({
    '&-outlined': Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            {},
            Lf(e, {
              borderColor: e.colorBorder,
              hoverBorderHover: e.hoverBorderColor,
              activeBorderColor: e.activeBorderColor,
              activeOutlineColor: e.activeOutlineColor,
            }),
          ),
          Mh(e, {
            status: 'error',
            borderColor: e.colorError,
            hoverBorderHover: e.colorErrorHover,
            activeBorderColor: e.colorError,
            activeOutlineColor: e.colorErrorOutline,
          }),
        ),
        Mh(e, {
          status: 'warning',
          borderColor: e.colorWarning,
          hoverBorderHover: e.colorWarningHover,
          activeBorderColor: e.colorWarning,
          activeOutlineColor: e.colorWarningOutline,
        }),
      ),
      {
        [`&${e.componentCls}-disabled`]: {
          [`&:not(${e.componentCls}-customize-input) ${e.componentCls}-selector`]:
            {
              background: e.colorBgContainerDisabled,
              color: e.colorTextDisabled,
            },
        },
        [`&${e.componentCls}-multiple ${e.componentCls}-selection-item`]: {
          background: e.multipleItemBg,
          border: `${de(e.lineWidth)} ${e.lineType} ${e.multipleItemBorderColor}`,
        },
      },
    ),
  }),
  kf = (e, t) => {
    const { componentCls: i, antCls: s } = e
    return {
      [`&:not(${i}-customize-input) ${i}-selector`]: {
        background: t.bg,
        border: `${de(e.lineWidth)} ${e.lineType} transparent`,
        color: t.color,
      },
      [`&:not(${i}-disabled):not(${i}-customize-input):not(${s}-pagination-size-changer)`]:
        {
          [`&:hover ${i}-selector`]: { background: t.hoverBg },
          [`${i}-focused& ${i}-selector`]: {
            background: e.selectorBg,
            borderColor: t.activeBorderColor,
            outline: 0,
          },
        },
    }
  },
  Ih = (e, t) => ({
    [`&${e.componentCls}-status-${t.status}`]: Object.assign({}, kf(e, t)),
  }),
  Hb = (e) => ({
    '&-filled': Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            {},
            kf(e, {
              bg: e.colorFillTertiary,
              hoverBg: e.colorFillSecondary,
              activeBorderColor: e.activeBorderColor,
              color: e.colorText,
            }),
          ),
          Ih(e, {
            status: 'error',
            bg: e.colorErrorBg,
            hoverBg: e.colorErrorBgHover,
            activeBorderColor: e.colorError,
            color: e.colorError,
          }),
        ),
        Ih(e, {
          status: 'warning',
          bg: e.colorWarningBg,
          hoverBg: e.colorWarningBgHover,
          activeBorderColor: e.colorWarning,
          color: e.colorWarning,
        }),
      ),
      {
        [`&${e.componentCls}-disabled`]: {
          [`&:not(${e.componentCls}-customize-input) ${e.componentCls}-selector`]:
            {
              borderColor: e.colorBorder,
              background: e.colorBgContainerDisabled,
              color: e.colorTextDisabled,
            },
        },
        [`&${e.componentCls}-multiple ${e.componentCls}-selection-item`]: {
          background: e.colorBgContainer,
          border: `${de(e.lineWidth)} ${e.lineType} ${e.colorSplit}`,
        },
      },
    ),
  }),
  Nb = (e) => ({
    '&-borderless': {
      [`${e.componentCls}-selector`]: {
        background: 'transparent',
        borderColor: 'transparent',
      },
      [`&${e.componentCls}-disabled`]: {
        [`&:not(${e.componentCls}-customize-input) ${e.componentCls}-selector`]:
          { color: e.colorTextDisabled },
      },
      [`&${e.componentCls}-multiple ${e.componentCls}-selection-item`]: {
        background: e.multipleItemBg,
        border: `${de(e.lineWidth)} ${e.lineType} ${e.multipleItemBorderColor}`,
      },
      [`&${e.componentCls}-status-error`]: {
        [`${e.componentCls}-selection-item`]: { color: e.colorError },
      },
      [`&${e.componentCls}-status-warning`]: {
        [`${e.componentCls}-selection-item`]: { color: e.colorWarning },
      },
    },
  }),
  Gb = (e) => ({
    [e.componentCls]: Object.assign(
      Object.assign(Object.assign({}, kb(e)), Hb(e)),
      Nb(e),
    ),
  }),
  Bb = (e) => {
    const { componentCls: t } = e
    return {
      position: 'relative',
      transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
      input: { cursor: 'pointer' },
      [`${t}-show-search&`]: {
        cursor: 'text',
        input: { cursor: 'auto', color: 'inherit', height: '100%' },
      },
      [`${t}-disabled&`]: {
        cursor: 'not-allowed',
        input: { cursor: 'not-allowed' },
      },
    }
  },
  Vb = (e) => {
    const { componentCls: t } = e
    return {
      [`${t}-selection-search-input`]: {
        margin: 0,
        padding: 0,
        background: 'transparent',
        border: 'none',
        outline: 'none',
        appearance: 'none',
        fontFamily: 'inherit',
        '&::-webkit-search-cancel-button': {
          display: 'none',
          '-webkit-appearance': 'none',
        },
      },
    }
  },
  _b = (e) => {
    const {
      antCls: t,
      componentCls: i,
      inputPaddingHorizontalBase: s,
      iconCls: n,
    } = e
    return {
      [i]: Object.assign(Object.assign({}, Ns(e)), {
        position: 'relative',
        display: 'inline-block',
        cursor: 'pointer',
        [`&:not(${i}-customize-input) ${i}-selector`]: Object.assign(
          Object.assign({}, Bb(e)),
          Vb(e),
        ),
        [`${i}-selection-item`]: Object.assign(
          Object.assign(
            {
              flex: 1,
              fontWeight: 'normal',
              position: 'relative',
              userSelect: 'none',
            },
            ho,
          ),
          { [`> ${t}-typography`]: { display: 'inline' } },
        ),
        [`${i}-selection-placeholder`]: Object.assign(Object.assign({}, ho), {
          flex: 1,
          color: e.colorTextPlaceholder,
          pointerEvents: 'none',
        }),
        [`${i}-arrow`]: Object.assign(Object.assign({}, af()), {
          position: 'absolute',
          top: '50%',
          insetInlineStart: 'auto',
          insetInlineEnd: s,
          height: e.fontSizeIcon,
          marginTop: e.calc(e.fontSizeIcon).mul(-1).div(2).equal(),
          color: e.colorTextQuaternary,
          fontSize: e.fontSizeIcon,
          lineHeight: 1,
          textAlign: 'center',
          pointerEvents: 'none',
          display: 'flex',
          alignItems: 'center',
          transition: `opacity ${e.motionDurationSlow} ease`,
          [n]: {
            verticalAlign: 'top',
            transition: `transform ${e.motionDurationSlow}`,
            '> svg': { verticalAlign: 'top' },
            [`&:not(${i}-suffix)`]: { pointerEvents: 'auto' },
          },
          [`${i}-disabled &`]: { cursor: 'not-allowed' },
          '> *:not(:last-child)': { marginInlineEnd: 8 },
        }),
        [`${i}-clear`]: {
          position: 'absolute',
          top: '50%',
          insetInlineStart: 'auto',
          insetInlineEnd: s,
          zIndex: 1,
          display: 'inline-block',
          width: e.fontSizeIcon,
          height: e.fontSizeIcon,
          marginTop: e.calc(e.fontSizeIcon).mul(-1).div(2).equal(),
          color: e.colorTextQuaternary,
          fontSize: e.fontSizeIcon,
          fontStyle: 'normal',
          lineHeight: 1,
          textAlign: 'center',
          textTransform: 'none',
          cursor: 'pointer',
          opacity: 0,
          transition: `color ${e.motionDurationMid} ease, opacity ${e.motionDurationSlow} ease`,
          textRendering: 'auto',
          '&:before': { display: 'block' },
          '&:hover': { color: e.colorTextTertiary },
        },
        [`&:hover ${i}-clear`]: {
          opacity: 1,
          background: e.colorBgBase,
          borderRadius: '50%',
        },
      }),
      [`${i}-has-feedback`]: {
        [`${i}-clear`]: {
          insetInlineEnd: e.calc(s).add(e.fontSize).add(e.paddingXS).equal(),
        },
      },
    }
  },
  Wb = (e) => {
    const { componentCls: t } = e
    return [
      { [t]: { [`&${t}-in-form-item`]: { width: '100%' } } },
      _b(e),
      Ob(e),
      Ab(e),
      Mb(e),
      { [`${t}-rtl`]: { direction: 'rtl' } },
      el(e, { borderElCls: `${t}-selector`, focusElCls: `${t}-focused` }),
    ]
  },
  $b = dn(
    'Select',
    (e, t) => {
      let { rootPrefixCls: i } = t
      const s = Jt(e, {
        rootPrefixCls: i,
        inputPaddingHorizontalBase: e.calc(e.paddingSM).sub(1).equal(),
        multipleSelectItemHeight: e.multipleItemHeight,
        selectHeight: e.controlHeight,
      })
      return [Wb(s), Gb(s)]
    },
    Lb,
    { unitless: { optionLineHeight: !0, optionSelectedFontWeight: !0 } },
  )
var zb = {
    icon: {
      tag: 'svg',
      attrs: { viewBox: '64 64 896 896', focusable: 'false' },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z',
          },
        },
      ],
    },
    name: 'check',
    theme: 'outlined',
  },
  Ub = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: zb }))
  },
  jb = d.forwardRef(Ub),
  Yb = {
    icon: {
      tag: 'svg',
      attrs: { viewBox: '64 64 896 896', focusable: 'false' },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z',
          },
        },
      ],
    },
    name: 'down',
    theme: 'outlined',
  },
  Kb = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: Yb }))
  },
  qb = d.forwardRef(Kb),
  Qb = {
    icon: {
      tag: 'svg',
      attrs: { viewBox: '64 64 896 896', focusable: 'false' },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z',
          },
        },
      ],
    },
    name: 'search',
    theme: 'outlined',
  },
  Xb = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: Qb }))
  },
  Au = d.forwardRef(Xb)
function Hf(e) {
  let {
    suffixIcon: t,
    clearIcon: i,
    menuItemSelectedIcon: s,
    removeIcon: n,
    loading: r,
    multiple: o,
    hasFeedback: a,
    prefixCls: l,
    showSuffixIcon: c,
    feedbackIcon: u,
    showArrow: h,
    componentName: g,
  } = e
  const f = i ?? d.createElement(df, null),
    p = (w) =>
      t === null && !a && !h
        ? null
        : d.createElement(d.Fragment, null, c !== !1 && w, a && u)
  let v = null
  if (t !== void 0) v = p(t)
  else if (r) v = p(d.createElement(Jg, { spin: !0 }))
  else {
    const w = `${l}-suffix`
    v = (S) => {
      let { open: y, showSearch: F } = S
      return p(
        y && F
          ? d.createElement(Au, { className: w })
          : d.createElement(qb, { className: w }),
      )
    }
  }
  let m = null
  s !== void 0 ? (m = s) : o ? (m = d.createElement(jb, null)) : (m = null)
  let C = null
  return (
    n !== void 0 ? (C = n) : (C = d.createElement(hf, null)),
    { clearIcon: f, suffixIcon: v, itemIcon: m, removeIcon: C }
  )
}
function Jb(e, t) {
  return t !== void 0 ? t : e !== null
}
var Zb = function (e, t) {
  var i = {}
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) &&
      t.indexOf(s) < 0 &&
      (i[s] = e[s])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
      t.indexOf(s[n]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
        (i[s[n]] = e[s[n]])
  return i
}
const Nf = 'SECRET_COMBOBOX_MODE_DO_NOT_USE',
  eR = (e, t) => {
    var i
    const {
        prefixCls: s,
        bordered: n,
        className: r,
        rootClassName: o,
        getPopupContainer: a,
        popupClassName: l,
        dropdownClassName: c,
        listHeight: u = 256,
        placement: h,
        listItemHeight: g,
        size: f,
        disabled: p,
        notFoundContent: v,
        status: m,
        builtinPlacements: C,
        dropdownMatchSelectWidth: w,
        popupMatchSelectWidth: S,
        direction: y,
        style: F,
        allowClear: R,
        variant: b,
        dropdownStyle: x,
        transitionName: D,
        tagRender: O,
        maxCount: M,
      } = e,
      L = Zb(e, [
        'prefixCls',
        'bordered',
        'className',
        'rootClassName',
        'getPopupContainer',
        'popupClassName',
        'dropdownClassName',
        'listHeight',
        'placement',
        'listItemHeight',
        'size',
        'disabled',
        'notFoundContent',
        'status',
        'builtinPlacements',
        'dropdownMatchSelectWidth',
        'popupMatchSelectWidth',
        'direction',
        'style',
        'allowClear',
        'variant',
        'dropdownStyle',
        'transitionName',
        'tagRender',
        'maxCount',
      ]),
      {
        getPopupContainer: V,
        getPrefixCls: A,
        renderEmpty: I,
        direction: P,
        virtual: k,
        popupMatchSelectWidth: E,
        popupOverflow: N,
        select: T,
      } = d.useContext(qt),
      [, G] = xo(),
      H = g ?? (G == null ? void 0 : G.controlHeight),
      _ = A('select', s),
      B = A(),
      z = y ?? P,
      { compactSize: Q, compactItemClassnames: J } = Cr(_, z),
      [se, ie] = Io('select', b, n),
      U = Sr(_),
      [W, j, K] = $b(_, U),
      q = d.useMemo(() => {
        const { mode: fe } = e
        if (fe !== 'combobox') return fe === Nf ? 'combobox' : fe
      }, [e.mode]),
      ne = q === 'multiple' || q === 'tags',
      oe = Jb(e.suffixIcon, e.showArrow),
      le = (i = S ?? w) !== null && i !== void 0 ? i : E,
      {
        status: me,
        hasFeedback: ye,
        isFormItemInput: Me,
        feedbackIcon: He,
      } = d.useContext(Gs),
      $e = wr(me, m)
    let Fe
    v !== void 0
      ? (Fe = v)
      : q === 'combobox'
        ? (Fe = null)
        : (Fe =
            (I == null ? void 0 : I('Select')) ||
            d.createElement(Pb, { componentName: 'Select' }))
    const {
        suffixIcon: ve,
        itemIcon: Be,
        removeIcon: Se,
        clearIcon: we,
      } = Hf(
        Object.assign(Object.assign({}, L), {
          multiple: ne,
          hasFeedback: ye,
          feedbackIcon: He,
          showSuffixIcon: oe,
          prefixCls: _,
          componentName: 'Select',
        }),
      ),
      ze = R === !0 ? { clearIcon: we } : R,
      Ue = zs(L, ['suffixIcon', 'itemIcon']),
      ke = pe(l || c, { [`${_}-dropdown-${z}`]: z === 'rtl' }, o, K, U, j),
      Xe = Us((fe) => {
        var Ce
        return (Ce = f ?? Q) !== null && Ce !== void 0 ? Ce : fe
      }),
      Ye = d.useContext(Vn),
      ge = p ?? Ye,
      ae = pe(
        {
          [`${_}-lg`]: Xe === 'large',
          [`${_}-sm`]: Xe === 'small',
          [`${_}-rtl`]: z === 'rtl',
          [`${_}-${se}`]: ie,
          [`${_}-in-form-item`]: Me,
        },
        gr(_, $e, ye),
        J,
        T == null ? void 0 : T.className,
        r,
        o,
        K,
        U,
        j,
      ),
      be = d.useMemo(
        () => (h !== void 0 ? h : z === 'rtl' ? 'bottomRight' : 'bottomLeft'),
        [h, z],
      ),
      [De] = Su('SelectLike', x == null ? void 0 : x.zIndex)
    return W(
      d.createElement(
        Tu,
        Object.assign(
          { ref: t, virtual: k, showSearch: T == null ? void 0 : T.showSearch },
          Ue,
          {
            style: Object.assign(
              Object.assign({}, T == null ? void 0 : T.style),
              F,
            ),
            dropdownMatchSelectWidth: le,
            transitionName: TS(B, 'slide-up', D),
            builtinPlacements: Db(C, N),
            listHeight: u,
            listItemHeight: H,
            mode: q,
            prefixCls: _,
            placement: be,
            direction: z,
            suffixIcon: ve,
            menuItemSelectedIcon: Be,
            removeIcon: Se,
            allowClear: ze,
            notFoundContent: Fe,
            className: ae,
            getPopupContainer: a || V,
            dropdownClassName: ke,
            disabled: ge,
            dropdownStyle: Object.assign(Object.assign({}, x), { zIndex: De }),
            maxCount: ne ? M : void 0,
            tagRender: ne ? O : void 0,
          },
        ),
      ),
    )
  },
  yr = d.forwardRef(eR),
  tR = xu(yr)
yr.SECRET_COMBOBOX_MODE_DO_NOT_USE = Nf
yr.Option = Iu
yr.OptGroup = Mu
yr._InternalPanelDoNotUseOrYouWillBeFired = tR
var Gf = { exports: {} }
;(function (e, t) {
  ;(function (i, s) {
    e.exports = s()
  })(_n, function () {
    var i = 1e3,
      s = 6e4,
      n = 36e5,
      r = 'millisecond',
      o = 'second',
      a = 'minute',
      l = 'hour',
      c = 'day',
      u = 'week',
      h = 'month',
      g = 'quarter',
      f = 'year',
      p = 'date',
      v = 'Invalid Date',
      m =
        /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
      C =
        /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
      w = {
        name: 'en',
        weekdays:
          'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        months:
          'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_',
          ),
        ordinal: function (A) {
          var I = ['th', 'st', 'nd', 'rd'],
            P = A % 100
          return '[' + A + (I[(P - 20) % 10] || I[P] || I[0]) + ']'
        },
      },
      S = function (A, I, P) {
        var k = String(A)
        return !k || k.length >= I
          ? A
          : '' + Array(I + 1 - k.length).join(P) + A
      },
      y = {
        s: S,
        z: function (A) {
          var I = -A.utcOffset(),
            P = Math.abs(I),
            k = Math.floor(P / 60),
            E = P % 60
          return (I <= 0 ? '+' : '-') + S(k, 2, '0') + ':' + S(E, 2, '0')
        },
        m: function A(I, P) {
          if (I.date() < P.date()) return -A(P, I)
          var k = 12 * (P.year() - I.year()) + (P.month() - I.month()),
            E = I.clone().add(k, h),
            N = P - E < 0,
            T = I.clone().add(k + (N ? -1 : 1), h)
          return +(-(k + (P - E) / (N ? E - T : T - E)) || 0)
        },
        a: function (A) {
          return A < 0 ? Math.ceil(A) || 0 : Math.floor(A)
        },
        p: function (A) {
          return (
            { M: h, y: f, w: u, d: c, D: p, h: l, m: a, s: o, ms: r, Q: g }[
              A
            ] ||
            String(A || '')
              .toLowerCase()
              .replace(/s$/, '')
          )
        },
        u: function (A) {
          return A === void 0
        },
      },
      F = 'en',
      R = {}
    R[F] = w
    var b = '$isDayjsObject',
      x = function (A) {
        return A instanceof L || !(!A || !A[b])
      },
      D = function A(I, P, k) {
        var E
        if (!I) return F
        if (typeof I == 'string') {
          var N = I.toLowerCase()
          R[N] && (E = N), P && ((R[N] = P), (E = N))
          var T = I.split('-')
          if (!E && T.length > 1) return A(T[0])
        } else {
          var G = I.name
          ;(R[G] = I), (E = G)
        }
        return !k && E && (F = E), E || (!k && F)
      },
      O = function (A, I) {
        if (x(A)) return A.clone()
        var P = typeof I == 'object' ? I : {}
        return (P.date = A), (P.args = arguments), new L(P)
      },
      M = y
    ;(M.l = D),
      (M.i = x),
      (M.w = function (A, I) {
        return O(A, { locale: I.$L, utc: I.$u, x: I.$x, $offset: I.$offset })
      })
    var L = (function () {
        function A(P) {
          ;(this.$L = D(P.locale, null, !0)),
            this.parse(P),
            (this.$x = this.$x || P.x || {}),
            (this[b] = !0)
        }
        var I = A.prototype
        return (
          (I.parse = function (P) {
            ;(this.$d = (function (k) {
              var E = k.date,
                N = k.utc
              if (E === null) return new Date(NaN)
              if (M.u(E)) return new Date()
              if (E instanceof Date) return new Date(E)
              if (typeof E == 'string' && !/Z$/i.test(E)) {
                var T = E.match(m)
                if (T) {
                  var G = T[2] - 1 || 0,
                    H = (T[7] || '0').substring(0, 3)
                  return N
                    ? new Date(
                        Date.UTC(
                          T[1],
                          G,
                          T[3] || 1,
                          T[4] || 0,
                          T[5] || 0,
                          T[6] || 0,
                          H,
                        ),
                      )
                    : new Date(
                        T[1],
                        G,
                        T[3] || 1,
                        T[4] || 0,
                        T[5] || 0,
                        T[6] || 0,
                        H,
                      )
                }
              }
              return new Date(E)
            })(P)),
              this.init()
          }),
          (I.init = function () {
            var P = this.$d
            ;(this.$y = P.getFullYear()),
              (this.$M = P.getMonth()),
              (this.$D = P.getDate()),
              (this.$W = P.getDay()),
              (this.$H = P.getHours()),
              (this.$m = P.getMinutes()),
              (this.$s = P.getSeconds()),
              (this.$ms = P.getMilliseconds())
          }),
          (I.$utils = function () {
            return M
          }),
          (I.isValid = function () {
            return this.$d.toString() !== v
          }),
          (I.isSame = function (P, k) {
            var E = O(P)
            return this.startOf(k) <= E && E <= this.endOf(k)
          }),
          (I.isAfter = function (P, k) {
            return O(P) < this.startOf(k)
          }),
          (I.isBefore = function (P, k) {
            return this.endOf(k) < O(P)
          }),
          (I.$g = function (P, k, E) {
            return M.u(P) ? this[k] : this.set(E, P)
          }),
          (I.unix = function () {
            return Math.floor(this.valueOf() / 1e3)
          }),
          (I.valueOf = function () {
            return this.$d.getTime()
          }),
          (I.startOf = function (P, k) {
            var E = this,
              N = !!M.u(k) || k,
              T = M.p(P),
              G = function (ie, U) {
                var W = M.w(
                  E.$u ? Date.UTC(E.$y, U, ie) : new Date(E.$y, U, ie),
                  E,
                )
                return N ? W : W.endOf(c)
              },
              H = function (ie, U) {
                return M.w(
                  E.toDate()[ie].apply(
                    E.toDate('s'),
                    (N ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(U),
                  ),
                  E,
                )
              },
              _ = this.$W,
              B = this.$M,
              z = this.$D,
              Q = 'set' + (this.$u ? 'UTC' : '')
            switch (T) {
              case f:
                return N ? G(1, 0) : G(31, 11)
              case h:
                return N ? G(1, B) : G(0, B + 1)
              case u:
                var J = this.$locale().weekStart || 0,
                  se = (_ < J ? _ + 7 : _) - J
                return G(N ? z - se : z + (6 - se), B)
              case c:
              case p:
                return H(Q + 'Hours', 0)
              case l:
                return H(Q + 'Minutes', 1)
              case a:
                return H(Q + 'Seconds', 2)
              case o:
                return H(Q + 'Milliseconds', 3)
              default:
                return this.clone()
            }
          }),
          (I.endOf = function (P) {
            return this.startOf(P, !1)
          }),
          (I.$set = function (P, k) {
            var E,
              N = M.p(P),
              T = 'set' + (this.$u ? 'UTC' : ''),
              G = ((E = {}),
              (E[c] = T + 'Date'),
              (E[p] = T + 'Date'),
              (E[h] = T + 'Month'),
              (E[f] = T + 'FullYear'),
              (E[l] = T + 'Hours'),
              (E[a] = T + 'Minutes'),
              (E[o] = T + 'Seconds'),
              (E[r] = T + 'Milliseconds'),
              E)[N],
              H = N === c ? this.$D + (k - this.$W) : k
            if (N === h || N === f) {
              var _ = this.clone().set(p, 1)
              _.$d[G](H),
                _.init(),
                (this.$d = _.set(p, Math.min(this.$D, _.daysInMonth())).$d)
            } else G && this.$d[G](H)
            return this.init(), this
          }),
          (I.set = function (P, k) {
            return this.clone().$set(P, k)
          }),
          (I.get = function (P) {
            return this[M.p(P)]()
          }),
          (I.add = function (P, k) {
            var E,
              N = this
            P = Number(P)
            var T = M.p(k),
              G = function (B) {
                var z = O(N)
                return M.w(z.date(z.date() + Math.round(B * P)), N)
              }
            if (T === h) return this.set(h, this.$M + P)
            if (T === f) return this.set(f, this.$y + P)
            if (T === c) return G(1)
            if (T === u) return G(7)
            var H = ((E = {}), (E[a] = s), (E[l] = n), (E[o] = i), E)[T] || 1,
              _ = this.$d.getTime() + P * H
            return M.w(_, this)
          }),
          (I.subtract = function (P, k) {
            return this.add(-1 * P, k)
          }),
          (I.format = function (P) {
            var k = this,
              E = this.$locale()
            if (!this.isValid()) return E.invalidDate || v
            var N = P || 'YYYY-MM-DDTHH:mm:ssZ',
              T = M.z(this),
              G = this.$H,
              H = this.$m,
              _ = this.$M,
              B = E.weekdays,
              z = E.months,
              Q = E.meridiem,
              J = function (U, W, j, K) {
                return (U && (U[W] || U(k, N))) || j[W].slice(0, K)
              },
              se = function (U) {
                return M.s(G % 12 || 12, U, '0')
              },
              ie =
                Q ||
                function (U, W, j) {
                  var K = U < 12 ? 'AM' : 'PM'
                  return j ? K.toLowerCase() : K
                }
            return N.replace(C, function (U, W) {
              return (
                W ||
                (function (j) {
                  switch (j) {
                    case 'YY':
                      return String(k.$y).slice(-2)
                    case 'YYYY':
                      return M.s(k.$y, 4, '0')
                    case 'M':
                      return _ + 1
                    case 'MM':
                      return M.s(_ + 1, 2, '0')
                    case 'MMM':
                      return J(E.monthsShort, _, z, 3)
                    case 'MMMM':
                      return J(z, _)
                    case 'D':
                      return k.$D
                    case 'DD':
                      return M.s(k.$D, 2, '0')
                    case 'd':
                      return String(k.$W)
                    case 'dd':
                      return J(E.weekdaysMin, k.$W, B, 2)
                    case 'ddd':
                      return J(E.weekdaysShort, k.$W, B, 3)
                    case 'dddd':
                      return B[k.$W]
                    case 'H':
                      return String(G)
                    case 'HH':
                      return M.s(G, 2, '0')
                    case 'h':
                      return se(1)
                    case 'hh':
                      return se(2)
                    case 'a':
                      return ie(G, H, !0)
                    case 'A':
                      return ie(G, H, !1)
                    case 'm':
                      return String(H)
                    case 'mm':
                      return M.s(H, 2, '0')
                    case 's':
                      return String(k.$s)
                    case 'ss':
                      return M.s(k.$s, 2, '0')
                    case 'SSS':
                      return M.s(k.$ms, 3, '0')
                    case 'Z':
                      return T
                  }
                  return null
                })(U) ||
                T.replace(':', '')
              )
            })
          }),
          (I.utcOffset = function () {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
          }),
          (I.diff = function (P, k, E) {
            var N,
              T = this,
              G = M.p(k),
              H = O(P),
              _ = (H.utcOffset() - this.utcOffset()) * s,
              B = this - H,
              z = function () {
                return M.m(T, H)
              }
            switch (G) {
              case f:
                N = z() / 12
                break
              case h:
                N = z()
                break
              case g:
                N = z() / 3
                break
              case u:
                N = (B - _) / 6048e5
                break
              case c:
                N = (B - _) / 864e5
                break
              case l:
                N = B / n
                break
              case a:
                N = B / s
                break
              case o:
                N = B / i
                break
              default:
                N = B
            }
            return E ? N : M.a(N)
          }),
          (I.daysInMonth = function () {
            return this.endOf(h).$D
          }),
          (I.$locale = function () {
            return R[this.$L]
          }),
          (I.locale = function (P, k) {
            if (!P) return this.$L
            var E = this.clone(),
              N = D(P, k, !0)
            return N && (E.$L = N), E
          }),
          (I.clone = function () {
            return M.w(this.$d, this)
          }),
          (I.toDate = function () {
            return new Date(this.valueOf())
          }),
          (I.toJSON = function () {
            return this.isValid() ? this.toISOString() : null
          }),
          (I.toISOString = function () {
            return this.$d.toISOString()
          }),
          (I.toString = function () {
            return this.$d.toUTCString()
          }),
          A
        )
      })(),
      V = L.prototype
    return (
      (O.prototype = V),
      [
        ['$ms', r],
        ['$s', o],
        ['$m', a],
        ['$H', l],
        ['$W', c],
        ['$M', h],
        ['$y', f],
        ['$D', p],
      ].forEach(function (A) {
        V[A[1]] = function (I) {
          return this.$g(I, A[0], A[1])
        }
      }),
      (O.extend = function (A, I) {
        return A.$i || (A(I, L, O), (A.$i = !0)), O
      }),
      (O.locale = D),
      (O.isDayjs = x),
      (O.unix = function (A) {
        return O(1e3 * A)
      }),
      (O.en = R[F]),
      (O.Ls = R),
      (O.p = {}),
      O
    )
  })
})(Gf)
var iR = Gf.exports
const Di = Wn(iR)
var Bf = { exports: {} }
;(function (e, t) {
  ;(function (i, s) {
    e.exports = s()
  })(_n, function () {
    return function (i, s) {
      s.prototype.weekday = function (n) {
        var r = this.$locale().weekStart || 0,
          o = this.$W,
          a = (o < r ? o + 7 : o) - r
        return this.$utils().u(n) ? a : this.subtract(a, 'day').add(n, 'day')
      }
    }
  })
})(Bf)
var sR = Bf.exports
const nR = Wn(sR)
var Vf = { exports: {} }
;(function (e, t) {
  ;(function (i, s) {
    e.exports = s()
  })(_n, function () {
    return function (i, s, n) {
      var r = s.prototype,
        o = function (h) {
          return h && (h.indexOf ? h : h.s)
        },
        a = function (h, g, f, p, v) {
          var m = h.name ? h : h.$locale(),
            C = o(m[g]),
            w = o(m[f]),
            S =
              C ||
              w.map(function (F) {
                return F.slice(0, p)
              })
          if (!v) return S
          var y = m.weekStart
          return S.map(function (F, R) {
            return S[(R + (y || 0)) % 7]
          })
        },
        l = function () {
          return n.Ls[n.locale()]
        },
        c = function (h, g) {
          return (
            h.formats[g] ||
            (function (f) {
              return f.replace(
                /(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,
                function (p, v, m) {
                  return v || m.slice(1)
                },
              )
            })(h.formats[g.toUpperCase()])
          )
        },
        u = function () {
          var h = this
          return {
            months: function (g) {
              return g ? g.format('MMMM') : a(h, 'months')
            },
            monthsShort: function (g) {
              return g ? g.format('MMM') : a(h, 'monthsShort', 'months', 3)
            },
            firstDayOfWeek: function () {
              return h.$locale().weekStart || 0
            },
            weekdays: function (g) {
              return g ? g.format('dddd') : a(h, 'weekdays')
            },
            weekdaysMin: function (g) {
              return g ? g.format('dd') : a(h, 'weekdaysMin', 'weekdays', 2)
            },
            weekdaysShort: function (g) {
              return g ? g.format('ddd') : a(h, 'weekdaysShort', 'weekdays', 3)
            },
            longDateFormat: function (g) {
              return c(h.$locale(), g)
            },
            meridiem: this.$locale().meridiem,
            ordinal: this.$locale().ordinal,
          }
        }
      ;(r.localeData = function () {
        return u.bind(this)()
      }),
        (n.localeData = function () {
          var h = l()
          return {
            firstDayOfWeek: function () {
              return h.weekStart || 0
            },
            weekdays: function () {
              return n.weekdays()
            },
            weekdaysShort: function () {
              return n.weekdaysShort()
            },
            weekdaysMin: function () {
              return n.weekdaysMin()
            },
            months: function () {
              return n.months()
            },
            monthsShort: function () {
              return n.monthsShort()
            },
            longDateFormat: function (g) {
              return c(h, g)
            },
            meridiem: h.meridiem,
            ordinal: h.ordinal,
          }
        }),
        (n.months = function () {
          return a(l(), 'months')
        }),
        (n.monthsShort = function () {
          return a(l(), 'monthsShort', 'months', 3)
        }),
        (n.weekdays = function (h) {
          return a(l(), 'weekdays', null, null, h)
        }),
        (n.weekdaysShort = function (h) {
          return a(l(), 'weekdaysShort', 'weekdays', 3, h)
        }),
        (n.weekdaysMin = function (h) {
          return a(l(), 'weekdaysMin', 'weekdays', 2, h)
        })
    }
  })
})(Vf)
var rR = Vf.exports
const oR = Wn(rR)
var _f = { exports: {} }
;(function (e, t) {
  ;(function (i, s) {
    e.exports = s()
  })(_n, function () {
    var i = 'week',
      s = 'year'
    return function (n, r, o) {
      var a = r.prototype
      ;(a.week = function (l) {
        if ((l === void 0 && (l = null), l !== null))
          return this.add(7 * (l - this.week()), 'day')
        var c = this.$locale().yearStart || 1
        if (this.month() === 11 && this.date() > 25) {
          var u = o(this).startOf(s).add(1, s).date(c),
            h = o(this).endOf(i)
          if (u.isBefore(h)) return 1
        }
        var g = o(this)
            .startOf(s)
            .date(c)
            .startOf(i)
            .subtract(1, 'millisecond'),
          f = this.diff(g, i, !0)
        return f < 0 ? o(this).startOf('week').week() : Math.ceil(f)
      }),
        (a.weeks = function (l) {
          return l === void 0 && (l = null), this.week(l)
        })
    }
  })
})(_f)
var aR = _f.exports
const lR = Wn(aR)
var Wf = { exports: {} }
;(function (e, t) {
  ;(function (i, s) {
    e.exports = s()
  })(_n, function () {
    return function (i, s) {
      s.prototype.weekYear = function () {
        var n = this.month(),
          r = this.week(),
          o = this.year()
        return r === 1 && n === 11 ? o + 1 : n === 0 && r >= 52 ? o - 1 : o
      }
    }
  })
})(Wf)
var cR = Wf.exports
const uR = Wn(cR)
var $f = { exports: {} }
;(function (e, t) {
  ;(function (i, s) {
    e.exports = s()
  })(_n, function () {
    return function (i, s) {
      var n = s.prototype,
        r = n.format
      n.format = function (o) {
        var a = this,
          l = this.$locale()
        if (!this.isValid()) return r.bind(this)(o)
        var c = this.$utils(),
          u = (o || 'YYYY-MM-DDTHH:mm:ssZ').replace(
            /\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,
            function (h) {
              switch (h) {
                case 'Q':
                  return Math.ceil((a.$M + 1) / 3)
                case 'Do':
                  return l.ordinal(a.$D)
                case 'gggg':
                  return a.weekYear()
                case 'GGGG':
                  return a.isoWeekYear()
                case 'wo':
                  return l.ordinal(a.week(), 'W')
                case 'w':
                case 'ww':
                  return c.s(a.week(), h === 'w' ? 1 : 2, '0')
                case 'W':
                case 'WW':
                  return c.s(a.isoWeek(), h === 'W' ? 1 : 2, '0')
                case 'k':
                case 'kk':
                  return c.s(
                    String(a.$H === 0 ? 24 : a.$H),
                    h === 'k' ? 1 : 2,
                    '0',
                  )
                case 'X':
                  return Math.floor(a.$d.getTime() / 1e3)
                case 'x':
                  return a.$d.getTime()
                case 'z':
                  return '[' + a.offsetName() + ']'
                case 'zzz':
                  return '[' + a.offsetName('long') + ']'
                default:
                  return h
              }
            },
          )
        return r.bind(this)(u)
      }
    }
  })
})($f)
var dR = $f.exports
const hR = Wn(dR)
var zf = { exports: {} }
;(function (e, t) {
  ;(function (i, s) {
    e.exports = s()
  })(_n, function () {
    var i = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A',
      },
      s =
        /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
      n = /\d/,
      r = /\d\d/,
      o = /\d\d?/,
      a = /\d*[^-_:/,()\s\d]+/,
      l = {},
      c = function (m) {
        return (m = +m) + (m > 68 ? 1900 : 2e3)
      },
      u = function (m) {
        return function (C) {
          this[m] = +C
        }
      },
      h = [
        /[+-]\d\d:?(\d\d)?|Z/,
        function (m) {
          ;(this.zone || (this.zone = {})).offset = (function (C) {
            if (!C || C === 'Z') return 0
            var w = C.match(/([+-]|\d\d)/g),
              S = 60 * w[1] + (+w[2] || 0)
            return S === 0 ? 0 : w[0] === '+' ? -S : S
          })(m)
        },
      ],
      g = function (m) {
        var C = l[m]
        return C && (C.indexOf ? C : C.s.concat(C.f))
      },
      f = function (m, C) {
        var w,
          S = l.meridiem
        if (S) {
          for (var y = 1; y <= 24; y += 1)
            if (m.indexOf(S(y, 0, C)) > -1) {
              w = y > 12
              break
            }
        } else w = m === (C ? 'pm' : 'PM')
        return w
      },
      p = {
        A: [
          a,
          function (m) {
            this.afternoon = f(m, !1)
          },
        ],
        a: [
          a,
          function (m) {
            this.afternoon = f(m, !0)
          },
        ],
        Q: [
          n,
          function (m) {
            this.month = 3 * (m - 1) + 1
          },
        ],
        S: [
          n,
          function (m) {
            this.milliseconds = 100 * +m
          },
        ],
        SS: [
          r,
          function (m) {
            this.milliseconds = 10 * +m
          },
        ],
        SSS: [
          /\d{3}/,
          function (m) {
            this.milliseconds = +m
          },
        ],
        s: [o, u('seconds')],
        ss: [o, u('seconds')],
        m: [o, u('minutes')],
        mm: [o, u('minutes')],
        H: [o, u('hours')],
        h: [o, u('hours')],
        HH: [o, u('hours')],
        hh: [o, u('hours')],
        D: [o, u('day')],
        DD: [r, u('day')],
        Do: [
          a,
          function (m) {
            var C = l.ordinal,
              w = m.match(/\d+/)
            if (((this.day = w[0]), C))
              for (var S = 1; S <= 31; S += 1)
                C(S).replace(/\[|\]/g, '') === m && (this.day = S)
          },
        ],
        w: [o, u('week')],
        ww: [r, u('week')],
        M: [o, u('month')],
        MM: [r, u('month')],
        MMM: [
          a,
          function (m) {
            var C = g('months'),
              w =
                (
                  g('monthsShort') ||
                  C.map(function (S) {
                    return S.slice(0, 3)
                  })
                ).indexOf(m) + 1
            if (w < 1) throw new Error()
            this.month = w % 12 || w
          },
        ],
        MMMM: [
          a,
          function (m) {
            var C = g('months').indexOf(m) + 1
            if (C < 1) throw new Error()
            this.month = C % 12 || C
          },
        ],
        Y: [/[+-]?\d+/, u('year')],
        YY: [
          r,
          function (m) {
            this.year = c(m)
          },
        ],
        YYYY: [/\d{4}/, u('year')],
        Z: h,
        ZZ: h,
      }
    function v(m) {
      var C, w
      ;(C = m), (w = l && l.formats)
      for (
        var S = (m = C.replace(
            /(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,
            function (O, M, L) {
              var V = L && L.toUpperCase()
              return (
                M ||
                w[L] ||
                i[L] ||
                w[V].replace(
                  /(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,
                  function (A, I, P) {
                    return I || P.slice(1)
                  },
                )
              )
            },
          )).match(s),
          y = S.length,
          F = 0;
        F < y;
        F += 1
      ) {
        var R = S[F],
          b = p[R],
          x = b && b[0],
          D = b && b[1]
        S[F] = D ? { regex: x, parser: D } : R.replace(/^\[|\]$/g, '')
      }
      return function (O) {
        for (var M = {}, L = 0, V = 0; L < y; L += 1) {
          var A = S[L]
          if (typeof A == 'string') V += A.length
          else {
            var I = A.regex,
              P = A.parser,
              k = O.slice(V),
              E = I.exec(k)[0]
            P.call(M, E), (O = O.replace(E, ''))
          }
        }
        return (
          (function (N) {
            var T = N.afternoon
            if (T !== void 0) {
              var G = N.hours
              T ? G < 12 && (N.hours += 12) : G === 12 && (N.hours = 0),
                delete N.afternoon
            }
          })(M),
          M
        )
      }
    }
    return function (m, C, w) {
      ;(w.p.customParseFormat = !0),
        m && m.parseTwoDigitYear && (c = m.parseTwoDigitYear)
      var S = C.prototype,
        y = S.parse
      S.parse = function (F) {
        var R = F.date,
          b = F.utc,
          x = F.args
        this.$u = b
        var D = x[1]
        if (typeof D == 'string') {
          var O = x[2] === !0,
            M = x[3] === !0,
            L = O || M,
            V = x[2]
          M && (V = x[2]),
            (l = this.$locale()),
            !O && V && (l = w.Ls[V]),
            (this.$d = (function (k, E, N, T) {
              try {
                if (['x', 'X'].indexOf(E) > -1)
                  return new Date((E === 'X' ? 1e3 : 1) * k)
                var G = v(E)(k),
                  H = G.year,
                  _ = G.month,
                  B = G.day,
                  z = G.hours,
                  Q = G.minutes,
                  J = G.seconds,
                  se = G.milliseconds,
                  ie = G.zone,
                  U = G.week,
                  W = new Date(),
                  j = B || (H || _ ? 1 : W.getDate()),
                  K = H || W.getFullYear(),
                  q = 0
                ;(H && !_) || (q = _ > 0 ? _ - 1 : W.getMonth())
                var ne,
                  oe = z || 0,
                  le = Q || 0,
                  me = J || 0,
                  ye = se || 0
                return ie
                  ? new Date(
                      Date.UTC(K, q, j, oe, le, me, ye + 60 * ie.offset * 1e3),
                    )
                  : N
                    ? new Date(Date.UTC(K, q, j, oe, le, me, ye))
                    : ((ne = new Date(K, q, j, oe, le, me, ye)),
                      U && (ne = T(ne).week(U).toDate()),
                      ne)
              } catch {
                return new Date('')
              }
            })(R, D, b, w)),
            this.init(),
            V && V !== !0 && (this.$L = this.locale(V).$L),
            L && R != this.format(D) && (this.$d = new Date('')),
            (l = {})
        } else if (D instanceof Array)
          for (var A = D.length, I = 1; I <= A; I += 1) {
            x[1] = D[I - 1]
            var P = w.apply(this, x)
            if (P.isValid()) {
              ;(this.$d = P.$d), (this.$L = P.$L), this.init()
              break
            }
            I === A && (this.$d = new Date(''))
          }
        else y.call(this, F)
      }
    }
  })
})(zf)
var gR = zf.exports
const fR = Wn(gR)
Di.extend(fR)
Di.extend(hR)
Di.extend(nR)
Di.extend(oR)
Di.extend(lR)
Di.extend(uR)
Di.extend(function (e, t) {
  var i = t.prototype,
    s = i.format
  i.format = function (r) {
    var o = (r || '').replace('Wo', 'wo')
    return s.bind(this)(o)
  }
})
var pR = {
    bn_BD: 'bn-bd',
    by_BY: 'be',
    en_GB: 'en-gb',
    en_US: 'en',
    fr_BE: 'fr',
    fr_CA: 'fr-ca',
    hy_AM: 'hy-am',
    kmr_IQ: 'ku',
    nl_BE: 'nl-be',
    pt_BR: 'pt-br',
    zh_CN: 'zh-cn',
    zh_HK: 'zh-hk',
    zh_TW: 'zh-tw',
  },
  vn = function (t) {
    var i = pR[t]
    return i || t.split('_')[0]
  },
  Th = function () {
    AS(!1, 'Not match any format. Please help to fire a issue about this.')
  },
  mR = {
    getNow: function () {
      var t = Di()
      return typeof t.tz == 'function' ? t.tz() : t
    },
    getFixedDate: function (t) {
      return Di(t, ['YYYY-M-DD', 'YYYY-MM-DD'])
    },
    getEndDate: function (t) {
      return t.endOf('month')
    },
    getWeekDay: function (t) {
      var i = t.locale('en')
      return i.weekday() + i.localeData().firstDayOfWeek()
    },
    getYear: function (t) {
      return t.year()
    },
    getMonth: function (t) {
      return t.month()
    },
    getDate: function (t) {
      return t.date()
    },
    getHour: function (t) {
      return t.hour()
    },
    getMinute: function (t) {
      return t.minute()
    },
    getSecond: function (t) {
      return t.second()
    },
    getMillisecond: function (t) {
      return t.millisecond()
    },
    addYear: function (t, i) {
      return t.add(i, 'year')
    },
    addMonth: function (t, i) {
      return t.add(i, 'month')
    },
    addDate: function (t, i) {
      return t.add(i, 'day')
    },
    setYear: function (t, i) {
      return t.year(i)
    },
    setMonth: function (t, i) {
      return t.month(i)
    },
    setDate: function (t, i) {
      return t.date(i)
    },
    setHour: function (t, i) {
      return t.hour(i)
    },
    setMinute: function (t, i) {
      return t.minute(i)
    },
    setSecond: function (t, i) {
      return t.second(i)
    },
    setMillisecond: function (t, i) {
      return t.millisecond(i)
    },
    isAfter: function (t, i) {
      return t.isAfter(i)
    },
    isValidate: function (t) {
      return t.isValid()
    },
    locale: {
      getWeekFirstDay: function (t) {
        return Di().locale(vn(t)).localeData().firstDayOfWeek()
      },
      getWeekFirstDate: function (t, i) {
        return i.locale(vn(t)).weekday(0)
      },
      getWeek: function (t, i) {
        return i.locale(vn(t)).week()
      },
      getShortWeekDays: function (t) {
        return Di().locale(vn(t)).localeData().weekdaysMin()
      },
      getShortMonths: function (t) {
        return Di().locale(vn(t)).localeData().monthsShort()
      },
      format: function (t, i, s) {
        return i.locale(vn(t)).format(s)
      },
      parse: function (t, i, s) {
        for (var n = vn(t), r = 0; r < s.length; r += 1) {
          var o = s[r],
            a = i
          if (o.includes('wo') || o.includes('Wo')) {
            for (
              var l = a.split('-')[0],
                c = a.split('-')[1],
                u = Di(l, 'YYYY').startOf('year').locale(n),
                h = 0;
              h <= 52;
              h += 1
            ) {
              var g = u.add(h, 'week')
              if (g.format('Wo') === c) return g
            }
            return Th(), null
          }
          var f = Di(a, o, !0).locale(n)
          if (f.isValid()) return f
        }
        return i && Th(), null
      },
    },
  }
function il(e, t) {
  return e !== void 0 ? e : t ? 'bottomRight' : 'bottomLeft'
}
function Uf(e, t) {
  var i = il(e, t),
    s = i == null ? void 0 : i.toLowerCase().endsWith('right'),
    n = s ? 'insetInlineEnd' : 'insetInlineStart'
  return (
    t &&
      (n = ['insetInlineStart', 'insetInlineEnd'].find(function (r) {
        return r !== n
      })),
    n
  )
}
var ss = d.createContext(null),
  vR = {
    bottomLeft: {
      points: ['tl', 'bl'],
      offset: [0, 4],
      overflow: { adjustX: 1, adjustY: 1 },
    },
    bottomRight: {
      points: ['tr', 'br'],
      offset: [0, 4],
      overflow: { adjustX: 1, adjustY: 1 },
    },
    topLeft: {
      points: ['bl', 'tl'],
      offset: [0, -4],
      overflow: { adjustX: 0, adjustY: 1 },
    },
    topRight: {
      points: ['br', 'tr'],
      offset: [0, -4],
      overflow: { adjustX: 0, adjustY: 1 },
    },
  }
function jf(e) {
  var t = e.popupElement,
    i = e.popupStyle,
    s = e.popupClassName,
    n = e.popupAlign,
    r = e.transitionName,
    o = e.getPopupContainer,
    a = e.children,
    l = e.range,
    c = e.placement,
    u = e.builtinPlacements,
    h = u === void 0 ? vR : u,
    g = e.direction,
    f = e.visible,
    p = e.onClose,
    v = d.useContext(ss),
    m = v.prefixCls,
    C = ''.concat(m, '-dropdown'),
    w = il(c, g === 'rtl')
  return d.createElement(
    ef,
    {
      showAction: [],
      hideAction: ['click'],
      popupPlacement: w,
      builtinPlacements: h,
      prefixCls: C,
      popupTransitionName: r,
      popup: t,
      popupAlign: n,
      popupVisible: f,
      popupClassName: pe(
        s,
        ce(
          ce({}, ''.concat(C, '-range'), l),
          ''.concat(C, '-rtl'),
          g === 'rtl',
        ),
      ),
      popupStyle: i,
      stretch: 'minWidth',
      getPopupContainer: o,
      onPopupVisibleChange: function (y) {
        y || p()
      },
    },
    a,
  )
}
function Ou(e, t) {
  for (
    var i =
        arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : '0',
      s = String(e);
    s.length < t;

  )
    s = ''.concat(i).concat(s)
  return s
}
function $n(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e]
}
function so(e, t, i) {
  var s = St(e)
  return (s[t] = i), s
}
function sl(e, t) {
  var i = {},
    s = t || Object.keys(e)
  return (
    s.forEach(function (n) {
      e[n] !== void 0 && (i[n] = e[n])
    }),
    i
  )
}
function Yf(e, t, i) {
  if (i) return i
  switch (e) {
    case 'time':
      return t.fieldTimeFormat
    case 'datetime':
      return t.fieldDateTimeFormat
    case 'month':
      return t.fieldMonthFormat
    case 'year':
      return t.fieldYearFormat
    case 'quarter':
      return t.fieldQuarterFormat
    case 'week':
      return t.fieldWeekFormat
    default:
      return t.fieldDateFormat
  }
}
function Kf(e, t, i) {
  var s = i !== void 0 ? i : t[t.length - 1],
    n = t.find(function (r) {
      return e[r]
    })
  return s !== n ? e[n] : void 0
}
function qf(e) {
  return sl(e, [
    'placement',
    'builtinPlacements',
    'popupAlign',
    'getPopupContainer',
    'transitionName',
    'direction',
  ])
}
function Lu(e, t, i, s) {
  var n = d.useMemo(
      function () {
        return (
          e ||
          function (o, a) {
            var l = o
            return t && a.type === 'date'
              ? t(l, a.today)
              : i && a.type === 'month'
                ? i(l, a.locale)
                : a.originNode
          }
        )
      },
      [e, i, t],
    ),
    r = d.useCallback(
      function (o, a) {
        return n(o, re(re({}, a), {}, { range: s }))
      },
      [n, s],
    )
  return r
}
function Qf(e, t) {
  var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [],
    s = d.useState([!1, !1]),
    n = Z(s, 2),
    r = n[0],
    o = n[1],
    a = function (u, h) {
      o(function (g) {
        return so(g, h, u)
      })
    },
    l = d.useMemo(
      function () {
        return r.map(function (c, u) {
          if (c) return !0
          var h = e[u]
          return h ? !!((!i[u] && !h) || (h && t(h, { activeIndex: u }))) : !1
        })
      },
      [e, r, t, i],
    )
  return [l, a]
}
function Xf(e, t, i, s, n) {
  var r = '',
    o = []
  return (
    e && o.push(n ? 'hh' : 'HH'),
    t && o.push('mm'),
    i && o.push('ss'),
    (r = o.join(':')),
    s && (r += '.SSS'),
    n && (r += ' A'),
    r
  )
}
function CR(e, t, i, s, n, r) {
  var o = e.fieldDateTimeFormat,
    a = e.fieldDateFormat,
    l = e.fieldTimeFormat,
    c = e.fieldMonthFormat,
    u = e.fieldYearFormat,
    h = e.fieldWeekFormat,
    g = e.fieldQuarterFormat,
    f = e.yearFormat,
    p = e.cellYearFormat,
    v = e.cellQuarterFormat,
    m = e.dayFormat,
    C = e.cellDateFormat,
    w = Xf(t, i, s, n, r)
  return re(
    re({}, e),
    {},
    {
      fieldDateTimeFormat: o || 'YYYY-MM-DD '.concat(w),
      fieldDateFormat: a || 'YYYY-MM-DD',
      fieldTimeFormat: l || w,
      fieldMonthFormat: c || 'YYYY-MM',
      fieldYearFormat: u || 'YYYY',
      fieldWeekFormat: h || 'gggg-wo',
      fieldQuarterFormat: g || 'YYYY-[Q]Q',
      yearFormat: f || 'YYYY',
      cellYearFormat: p || 'YYYY',
      cellQuarterFormat: v || '[Q]Q',
      cellDateFormat: C || m || 'D',
    },
  )
}
function Jf(e, t) {
  var i = t.showHour,
    s = t.showMinute,
    n = t.showSecond,
    r = t.showMillisecond,
    o = t.use12Hours
  return $.useMemo(
    function () {
      return CR(e, i, s, n, r, o)
    },
    [e, i, s, n, r, o],
  )
}
function zr(e, t, i) {
  return (
    i ??
    t.some(function (s) {
      return e.includes(s)
    })
  )
}
var SR = [
  'showNow',
  'showHour',
  'showMinute',
  'showSecond',
  'showMillisecond',
  'use12Hours',
  'hourStep',
  'minuteStep',
  'secondStep',
  'millisecondStep',
  'hideDisabledOptions',
  'defaultValue',
  'disabledHours',
  'disabledMinutes',
  'disabledSeconds',
  'disabledMilliseconds',
  'disabledTime',
  'changeOnScroll',
  'defaultOpenValue',
]
function wR(e) {
  var t = sl(e, SR),
    i = e.format,
    s = e.picker,
    n = null
  return (
    i &&
      ((n = i),
      Array.isArray(n) && (n = n[0]),
      (n = Zt(n) === 'object' ? n.format : n)),
    s === 'time' && (t.format = n),
    [t, n]
  )
}
function yR(e) {
  return e && typeof e == 'string'
}
function Zf(e, t, i, s) {
  return [e, t, i, s].some(function (n) {
    return n !== void 0
  })
}
function ep(e, t, i, s, n) {
  var r = t,
    o = i,
    a = s
  if (!e && !r && !o && !a && !n) (r = !0), (o = !0), (a = !0)
  else if (e) {
    var l,
      c,
      u,
      h = [r, o, a].some(function (p) {
        return p === !1
      }),
      g = [r, o, a].some(function (p) {
        return p === !0
      }),
      f = h ? !0 : !g
    ;(r = (l = r) !== null && l !== void 0 ? l : f),
      (o = (c = o) !== null && c !== void 0 ? c : f),
      (a = (u = a) !== null && u !== void 0 ? u : f)
  }
  return [r, o, a, n]
}
function tp(e) {
  var t = e.showTime,
    i = wR(e),
    s = Z(i, 2),
    n = s[0],
    r = s[1],
    o = t && Zt(t) === 'object' ? t : {},
    a = re(
      re({ defaultOpenValue: o.defaultOpenValue || o.defaultValue }, n),
      o,
    ),
    l = a.showMillisecond,
    c = a.showHour,
    u = a.showMinute,
    h = a.showSecond,
    g = Zf(c, u, h, l),
    f = ep(g, c, u, h, l),
    p = Z(f, 3)
  return (
    (c = p[0]),
    (u = p[1]),
    (h = p[2]),
    [
      a,
      re(
        re({}, a),
        {},
        { showHour: c, showMinute: u, showSecond: h, showMillisecond: l },
      ),
      a.format,
      r,
    ]
  )
}
function ip(e, t, i, s, n) {
  var r = e === 'time'
  if (e === 'datetime' || r) {
    for (
      var o = s, a = Yf(e, n, null), l = a, c = [t, i], u = 0;
      u < c.length;
      u += 1
    ) {
      var h = $n(c[u])[0]
      if (yR(h)) {
        l = h
        break
      }
    }
    var g = o.showHour,
      f = o.showMinute,
      p = o.showSecond,
      v = o.showMillisecond,
      m = o.use12Hours,
      C = zr(l, ['a', 'A', 'LT', 'LLL', 'LTS'], m),
      w = Zf(g, f, p, v)
    w ||
      ((g = zr(l, ['H', 'h', 'k', 'LT', 'LLL'])),
      (f = zr(l, ['m', 'LT', 'LLL'])),
      (p = zr(l, ['s', 'LTS'])),
      (v = zr(l, ['SSS'])))
    var S = ep(w, g, f, p, v),
      y = Z(S, 3)
    ;(g = y[0]), (f = y[1]), (p = y[2])
    var F = t || Xf(g, f, p, v, C)
    return re(
      re({}, o),
      {},
      {
        format: F,
        showHour: g,
        showMinute: f,
        showSecond: p,
        showMillisecond: v,
        use12Hours: C,
      },
    )
  }
  return null
}
function bR(e, t, i) {
  if (t === !1) return null
  var s = t && Zt(t) === 'object' ? t : {}
  return (
    s.clearIcon ||
    i ||
    d.createElement('span', { className: ''.concat(e, '-clear-btn') })
  )
}
var zl = 7
function hn(e, t, i) {
  return (!e && !t) || e === t ? !0 : !e || !t ? !1 : i()
}
function Tc(e, t, i) {
  return hn(t, i, function () {
    var s = Math.floor(e.getYear(t) / 10),
      n = Math.floor(e.getYear(i) / 10)
    return s === n
  })
}
function kn(e, t, i) {
  return hn(t, i, function () {
    return e.getYear(t) === e.getYear(i)
  })
}
function Ah(e, t) {
  var i = Math.floor(e.getMonth(t) / 3)
  return i + 1
}
function RR(e, t, i) {
  return hn(t, i, function () {
    return kn(e, t, i) && Ah(e, t) === Ah(e, i)
  })
}
function ku(e, t, i) {
  return hn(t, i, function () {
    return kn(e, t, i) && e.getMonth(t) === e.getMonth(i)
  })
}
function Hu(e, t, i) {
  return hn(t, i, function () {
    return kn(e, t, i) && ku(e, t, i) && e.getDate(t) === e.getDate(i)
  })
}
function sp(e, t, i) {
  return hn(t, i, function () {
    return (
      e.getHour(t) === e.getHour(i) &&
      e.getMinute(t) === e.getMinute(i) &&
      e.getSecond(t) === e.getSecond(i)
    )
  })
}
function np(e, t, i) {
  return hn(t, i, function () {
    return (
      Hu(e, t, i) && sp(e, t, i) && e.getMillisecond(t) === e.getMillisecond(i)
    )
  })
}
function Zr(e, t, i, s) {
  return hn(i, s, function () {
    var n = e.locale.getWeekFirstDate(t, i),
      r = e.locale.getWeekFirstDate(t, s)
    return kn(e, n, r) && e.locale.getWeek(t, i) === e.locale.getWeek(t, s)
  })
}
function fi(e, t, i, s, n) {
  switch (n) {
    case 'date':
      return Hu(e, i, s)
    case 'week':
      return Zr(e, t.locale, i, s)
    case 'month':
      return ku(e, i, s)
    case 'quarter':
      return RR(e, i, s)
    case 'year':
      return kn(e, i, s)
    case 'decade':
      return Tc(e, i, s)
    case 'time':
      return sp(e, i, s)
    default:
      return np(e, i, s)
  }
}
function nl(e, t, i, s) {
  return !t || !i || !s ? !1 : e.isAfter(s, t) && e.isAfter(i, s)
}
function zo(e, t, i, s, n) {
  return fi(e, t, i, s, n) ? !0 : e.isAfter(i, s)
}
function FR(e, t, i) {
  var s = t.locale.getWeekFirstDay(e),
    n = t.setDate(i, 1),
    r = t.getWeekDay(n),
    o = t.addDate(n, s - r)
  return (
    t.getMonth(o) === t.getMonth(i) &&
      t.getDate(o) > 1 &&
      (o = t.addDate(o, -7)),
    o
  )
}
function Qt(e, t) {
  var i = t.generateConfig,
    s = t.locale,
    n = t.format
  return e
    ? typeof n == 'function'
      ? n(e)
      : i.locale.format(s.locale, e, n)
    : ''
}
function Pa(e, t, i) {
  var s = t,
    n = ['getHour', 'getMinute', 'getSecond', 'getMillisecond'],
    r = ['setHour', 'setMinute', 'setSecond', 'setMillisecond']
  return (
    r.forEach(function (o, a) {
      i ? (s = e[o](s, e[n[a]](i))) : (s = e[o](s, 0))
    }),
    s
  )
}
function ER(e, t, i, s, n) {
  var r = Bt(function (o, a) {
    return !!(
      (i && i(o, a)) ||
      (s && e.isAfter(s, o) && !fi(e, t, s, o, a.type)) ||
      (n && e.isAfter(o, n) && !fi(e, t, n, o, a.type))
    )
  })
  return r
}
function PR(e, t, i) {
  return d.useMemo(
    function () {
      var s = Yf(e, t, i),
        n = $n(s),
        r = n[0],
        o = Zt(r) === 'object' && r.type === 'mask' ? r.format : null
      return [
        n.map(function (a) {
          return typeof a == 'string' || typeof a == 'function' ? a : a.format
        }),
        o,
      ]
    },
    [e, t, i],
  )
}
function xR(e, t, i) {
  return typeof e[0] == 'function' || i ? !0 : t
}
function DR(e, t, i, s) {
  var n = Bt(function (r, o) {
    var a = re({ type: t }, o)
    if ((delete a.activeIndex, !e.isValidate(r) || (i && i(r, a)))) return !0
    if ((t === 'date' || t === 'time') && s) {
      var l,
        c = o && o.activeIndex === 1 ? 'end' : 'start',
        u =
          ((l = s.disabledTime) === null || l === void 0
            ? void 0
            : l.call(s, r, c, { from: a.from })) || {},
        h = u.disabledHours,
        g = u.disabledMinutes,
        f = u.disabledSeconds,
        p = u.disabledMilliseconds,
        v = s.disabledHours,
        m = s.disabledMinutes,
        C = s.disabledSeconds,
        w = h || v,
        S = g || m,
        y = f || C,
        F = e.getHour(r),
        R = e.getMinute(r),
        b = e.getSecond(r),
        x = e.getMillisecond(r)
      if (
        (w && w().includes(F)) ||
        (S && S(F).includes(R)) ||
        (y && y(F, R).includes(b)) ||
        (p && p(F, R, b).includes(x))
      )
        return !0
    }
    return !1
  })
  return n
}
function Uo(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    i = d.useMemo(
      function () {
        var s = e && $n(e)
        return t && s && (s[1] = s[1] || s[0]), s
      },
      [e, t],
    )
  return i
}
function rp(e, t) {
  var i = e.generateConfig,
    s = e.locale,
    n = e.picker,
    r = n === void 0 ? 'date' : n,
    o = e.prefixCls,
    a = o === void 0 ? 'rc-picker' : o,
    l = e.styles,
    c = l === void 0 ? {} : l,
    u = e.classNames,
    h = u === void 0 ? {} : u,
    g = e.order,
    f = g === void 0 ? !0 : g,
    p = e.components,
    v = p === void 0 ? {} : p,
    m = e.inputRender,
    C = e.allowClear,
    w = e.clearIcon,
    S = e.needConfirm,
    y = e.multiple,
    F = e.format,
    R = e.inputReadOnly,
    b = e.disabledDate,
    x = e.minDate,
    D = e.maxDate,
    O = e.showTime,
    M = e.value,
    L = e.defaultValue,
    V = e.pickerValue,
    A = e.defaultPickerValue,
    I = Uo(M),
    P = Uo(L),
    k = Uo(V),
    E = Uo(A),
    N = r === 'date' && O ? 'datetime' : r,
    T = N === 'time' || N === 'datetime',
    G = T || y,
    H = S ?? T,
    _ = tp(e),
    B = Z(_, 4),
    z = B[0],
    Q = B[1],
    J = B[2],
    se = B[3],
    ie = Jf(s, Q),
    U = d.useMemo(
      function () {
        return ip(N, J, se, z, ie)
      },
      [N, J, se, z, ie],
    ),
    W = d.useMemo(
      function () {
        return re(
          re({}, e),
          {},
          {
            prefixCls: a,
            locale: ie,
            picker: r,
            styles: c,
            classNames: h,
            order: f,
            components: re({ input: m }, v),
            clearIcon: bR(a, C, w),
            showTime: U,
            value: I,
            defaultValue: P,
            pickerValue: k,
            defaultPickerValue: E,
          },
          t == null ? void 0 : t(),
        )
      },
      [e],
    ),
    j = PR(N, ie, F),
    K = Z(j, 2),
    q = K[0],
    ne = K[1],
    oe = xR(q, R, y),
    le = ER(i, s, b, x, D),
    me = DR(i, r, le, U),
    ye = d.useMemo(
      function () {
        return re(
          re({}, W),
          {},
          { needConfirm: H, inputReadOnly: oe, disabledDate: le },
        )
      },
      [W, H, oe, le],
    )
  return [ye, N, G, q, ne, me]
}
function MR(e, t, i) {
  var s = ai(t, { value: e }),
    n = Z(s, 2),
    r = n[0],
    o = n[1],
    a = $.useRef(e),
    l = $.useRef(),
    c = function () {
      bt.cancel(l.current)
    },
    u = Bt(function () {
      o(a.current), i && r !== a.current && i(a.current)
    }),
    h = Bt(function (g, f) {
      c(), (a.current = g), g || f ? u() : (l.current = bt(u))
    })
  return (
    $.useEffect(function () {
      return c
    }, []),
    [r, h]
  )
}
function op(e, t) {
  var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [],
    s = arguments.length > 3 ? arguments[3] : void 0,
    n = i.every(function (u) {
      return u
    })
      ? !1
      : e,
    r = MR(n, t || !1, s),
    o = Z(r, 2),
    a = o[0],
    l = o[1]
  function c(u) {
    var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
    ;(!h.inherit || a) && l(u, h.force)
  }
  return [a, c]
}
function ap(e) {
  var t = d.useRef()
  return (
    d.useImperativeHandle(e, function () {
      var i
      return {
        nativeElement:
          (i = t.current) === null || i === void 0 ? void 0 : i.nativeElement,
        focus: function (n) {
          var r
          ;(r = t.current) === null || r === void 0 || r.focus(n)
        },
        blur: function () {
          var n
          ;(n = t.current) === null || n === void 0 || n.blur()
        },
      }
    }),
    t
  )
}
function lp(e, t) {
  return d.useMemo(
    function () {
      return (
        e ||
        (t
          ? (tf(!1, '`ranges` is deprecated. Please use `presets` instead.'),
            Object.entries(t).map(function (i) {
              var s = Z(i, 2),
                n = s[0],
                r = s[1]
              return { label: n, value: r }
            }))
          : [])
      )
    },
    [e, t],
  )
}
function Nu(e, t) {
  var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1,
    s = d.useRef(t)
  ;(s.current = t),
    OS(
      function () {
        if (e) s.current(e)
        else {
          var n = bt(function () {
            s.current(e)
          }, i)
          return function () {
            bt.cancel(n)
          }
        }
      },
      [e],
    )
}
function cp(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
    i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
    s = d.useState(0),
    n = Z(s, 2),
    r = n[0],
    o = n[1],
    a = d.useState(!1),
    l = Z(a, 2),
    c = l[0],
    u = l[1],
    h = d.useRef([]),
    g = d.useRef(null),
    f = function (C) {
      u(C)
    },
    p = function (C) {
      return C && (g.current = C), g.current
    },
    v = function (C) {
      var w = h.current,
        S = new Set(
          w.filter(function (F) {
            return C[F] || t[F]
          }),
        ),
        y = w[w.length - 1] === 0 ? 1 : 0
      return S.size >= 2 || e[y] ? null : y
    }
  return (
    Nu(c || i, function () {
      c || (h.current = [])
    }),
    d.useEffect(
      function () {
        c && h.current.push(r)
      },
      [c, r],
    ),
    [c, f, p, r, o, v, h.current]
  )
}
function IR(e, t, i, s, n, r) {
  var o = i[i.length - 1],
    a = function (c, u) {
      var h = Z(e, 2),
        g = h[0],
        f = h[1],
        p = re(re({}, u), {}, { from: Kf(e, i) })
      return (o === 1 &&
        t[0] &&
        g &&
        !fi(s, n, g, c, p.type) &&
        s.isAfter(g, c)) ||
        (o === 0 && t[1] && f && !fi(s, n, f, c, p.type) && s.isAfter(c, f))
        ? !0
        : r == null
          ? void 0
          : r(c, p)
    }
  return a
}
function eo(e, t, i, s) {
  switch (t) {
    case 'date':
    case 'week':
      return e.addMonth(i, s)
    case 'month':
    case 'quarter':
      return e.addYear(i, s)
    case 'year':
      return e.addYear(i, s * 10)
    case 'decade':
      return e.addYear(i, s * 100)
    default:
      return i
  }
}
var Ul = []
function up(e, t, i, s, n, r, o, a) {
  var l = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : Ul,
    c = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : Ul,
    u = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : Ul,
    h = arguments.length > 11 ? arguments[11] : void 0,
    g = arguments.length > 12 ? arguments[12] : void 0,
    f = arguments.length > 13 ? arguments[13] : void 0,
    p = o === 'time',
    v = r || 0,
    m = function (k) {
      var E = e.getNow()
      return p && (E = Pa(e, E)), l[k] || i[k] || E
    },
    C = Z(c, 2),
    w = C[0],
    S = C[1],
    y = ai(
      function () {
        return m(0)
      },
      { value: w },
    ),
    F = Z(y, 2),
    R = F[0],
    b = F[1],
    x = ai(
      function () {
        return m(1)
      },
      { value: S },
    ),
    D = Z(x, 2),
    O = D[0],
    M = D[1],
    L = d.useMemo(
      function () {
        var P = [R, O][v]
        return p ? P : Pa(e, P, u[v])
      },
      [p, R, O, v, e, u],
    ),
    V = function (k) {
      var E =
          arguments.length > 1 && arguments[1] !== void 0
            ? arguments[1]
            : 'panel',
        N = [b, M][v]
      N(k)
      var T = [R, O]
      ;(T[v] = k),
        h &&
          (!fi(e, t, R, T[0], o) || !fi(e, t, O, T[1], o)) &&
          h(T, { source: E, range: v === 1 ? 'end' : 'start', mode: s })
    },
    A = function (k, E) {
      if (a) {
        var N = {
            date: 'month',
            week: 'month',
            month: 'year',
            quarter: 'year',
          },
          T = N[o]
        if (T && !fi(e, t, k, E, T)) return eo(e, o, E, -1)
        if (o === 'year' && k) {
          var G = Math.floor(e.getYear(k) / 10),
            H = Math.floor(e.getYear(E) / 10)
          if (G !== H) return eo(e, o, E, -1)
        }
      }
      return E
    },
    I = d.useRef(null)
  return (
    li(
      function () {
        if (n && !l[v]) {
          var P = p ? null : e.getNow()
          if (
            (I.current !== null && I.current !== v
              ? (P = [R, O][v ^ 1])
              : i[v]
                ? (P = v === 0 ? i[0] : A(i[0], i[1]))
                : i[v ^ 1] && (P = i[v ^ 1]),
            P)
          ) {
            g && e.isAfter(g, P) && (P = g)
            var k = a ? eo(e, o, P, 1) : P
            f && e.isAfter(k, f) && (P = a ? eo(e, o, f, -1) : f), V(P, 'reset')
          }
        }
      },
      [n, v, i[v]],
    ),
    d.useEffect(
      function () {
        n ? (I.current = v) : (I.current = null)
      },
      [n, v],
    ),
    li(
      function () {
        n && l && l[v] && V(l[v], 'reset')
      },
      [n, v],
    ),
    [L, V]
  )
}
function dp(e, t) {
  var i = d.useRef(e),
    s = d.useState({}),
    n = Z(s, 2),
    r = n[1],
    o = function (c) {
      return c && t !== void 0 ? t : i.current
    },
    a = function (c) {
      ;(i.current = c), r({})
    }
  return [o, a, o(!0)]
}
var TR = []
function hp(e, t, i) {
  var s = function (o) {
      return o.map(function (a) {
        return Qt(a, { generateConfig: e, locale: t, format: i[0] })
      })
    },
    n = function (o, a) {
      for (var l = Math.max(o.length, a.length), c = -1, u = 0; u < l; u += 1) {
        var h = o[u] || null,
          g = a[u] || null
        if (h !== g && !np(e, h, g)) {
          c = u
          break
        }
      }
      return [c < 0, c !== 0]
    }
  return [s, n]
}
function gp(e, t) {
  return St(e).sort(function (i, s) {
    return t.isAfter(i, s) ? 1 : -1
  })
}
function AR(e) {
  var t = dp(e),
    i = Z(t, 2),
    s = i[0],
    n = i[1],
    r = Bt(function () {
      n(e)
    })
  return (
    d.useEffect(
      function () {
        r()
      },
      [e],
    ),
    [s, n]
  )
}
function fp(e, t, i, s, n, r, o, a, l) {
  var c = ai(r, { value: o }),
    u = Z(c, 2),
    h = u[0],
    g = u[1],
    f = h || TR,
    p = AR(f),
    v = Z(p, 2),
    m = v[0],
    C = v[1],
    w = hp(e, t, i),
    S = Z(w, 2),
    y = S[0],
    F = S[1],
    R = Bt(function (x) {
      var D = St(x)
      if (s) for (var O = 0; O < 2; O += 1) D[O] = D[O] || null
      else
        n &&
          (D = gp(
            D.filter(function (P) {
              return P
            }),
            e,
          ))
      var M = F(m(), D),
        L = Z(M, 2),
        V = L[0],
        A = L[1]
      if (!V && (C(D), a)) {
        var I = y(D)
        a(D, I, { range: A ? 'end' : 'start' })
      }
    }),
    b = function () {
      l && l(m())
    }
  return [f, g, m, R, b]
}
function pp(e, t, i, s, n, r, o, a, l, c) {
  var u = e.generateConfig,
    h = e.locale,
    g = e.picker,
    f = e.onChange,
    p = e.allowEmpty,
    v = e.order,
    m = r.some(function (V) {
      return V
    })
      ? !1
      : v,
    C = hp(u, h, o),
    w = Z(C, 2),
    S = w[0],
    y = w[1],
    F = dp(t),
    R = Z(F, 2),
    b = R[0],
    x = R[1],
    D = Bt(function () {
      x(t)
    })
  d.useEffect(
    function () {
      D()
    },
    [t],
  )
  var O = Bt(function (V) {
      var A = V === null,
        I = St(V || b())
      if (A)
        for (var P = Math.max(r.length, I.length), k = 0; k < P; k += 1)
          r[k] || (I[k] = null)
      m && I[0] && I[1] && (I = gp(I, u)), n(I)
      var E = I,
        N = Z(E, 2),
        T = N[0],
        G = N[1],
        H = !T,
        _ = !G,
        B = p ? (!H || p[0]) && (!_ || p[1]) : !0,
        z = !v || H || _ || fi(u, h, T, G, g) || u.isAfter(G, T),
        Q =
          (!T || !c(T, { activeIndex: 0 })) &&
          (!G || !c(G, { from: T, activeIndex: 1 })),
        J = A || (B && z && Q)
      if (J) {
        i(I)
        var se = y(I, t),
          ie = Z(se, 1),
          U = ie[0]
        f &&
          !U &&
          f(
            A &&
              I.every(function (W) {
                return !W
              })
              ? null
              : I,
            S(I),
          )
      }
      return J
    }),
    M = Bt(function (V, A) {
      var I = so(b(), V, s()[V])
      x(I), A && O()
    }),
    L = !a && !l
  return (
    Nu(
      !L,
      function () {
        L && (O(), n(t), D())
      },
      2,
    ),
    [M, O]
  )
}
function mp(e, t, i, s, n) {
  return t !== 'date' && t !== 'time'
    ? !1
    : i !== void 0
      ? i
      : s !== void 0
        ? s
        : !n && (e === 'date' || e === 'time')
}
function OR(e, t, i, s, n, r) {
  var o = e
  function a(h, g, f) {
    var p = r[h](o),
      v = f.find(function (S) {
        return S.value === p
      })
    if (!v || v.disabled) {
      var m = f.filter(function (S) {
          return !S.disabled
        }),
        C = St(m).reverse(),
        w =
          C.find(function (S) {
            return S.value <= p
          }) || m[0]
      w && ((p = w.value), (o = r[g](o, p)))
    }
    return p
  }
  var l = a('getHour', 'setHour', t()),
    c = a('getMinute', 'setMinute', i(l)),
    u = a('getSecond', 'setSecond', s(l, c))
  return a('getMillisecond', 'setMillisecond', n(l, c, u)), o
}
function jo() {
  return []
}
function Yo(e, t) {
  for (
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1,
      s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,
      n = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [],
      r = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 2,
      o = [],
      a = i >= 1 ? i | 0 : 1,
      l = e;
    l <= t;
    l += a
  ) {
    var c = n.includes(l)
    ;(!c || !s) && o.push({ label: Ou(l, r), value: l, disabled: c })
  }
  return o
}
function Gu(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    i = arguments.length > 2 ? arguments[2] : void 0,
    s = t || {},
    n = s.use12Hours,
    r = s.hourStep,
    o = r === void 0 ? 1 : r,
    a = s.minuteStep,
    l = a === void 0 ? 1 : a,
    c = s.secondStep,
    u = c === void 0 ? 1 : c,
    h = s.millisecondStep,
    g = h === void 0 ? 100 : h,
    f = s.hideDisabledOptions,
    p = s.disabledTime,
    v = s.disabledHours,
    m = s.disabledMinutes,
    C = s.disabledSeconds,
    w = d.useMemo(
      function () {
        return i || e.getNow()
      },
      [i, e],
    ),
    S = d.useCallback(
      function (E) {
        var N = (p == null ? void 0 : p(E)) || {}
        return [
          N.disabledHours || v || jo,
          N.disabledMinutes || m || jo,
          N.disabledSeconds || C || jo,
          N.disabledMilliseconds || jo,
        ]
      },
      [p, v, m, C],
    ),
    y = d.useMemo(
      function () {
        return S(w)
      },
      [w, S],
    ),
    F = Z(y, 4),
    R = F[0],
    b = F[1],
    x = F[2],
    D = F[3],
    O = d.useCallback(
      function (E, N, T, G) {
        var H = Yo(0, 23, o, f, E()),
          _ = n
            ? H.map(function (J) {
                return re(re({}, J), {}, { label: Ou(J.value % 12 || 12, 2) })
              })
            : H,
          B = function (se) {
            return Yo(0, 59, l, f, N(se))
          },
          z = function (se, ie) {
            return Yo(0, 59, u, f, T(se, ie))
          },
          Q = function (se, ie, U) {
            return Yo(0, 999, g, f, G(se, ie, U), 3)
          }
        return [_, B, z, Q]
      },
      [f, o, n, g, l, u],
    ),
    M = d.useMemo(
      function () {
        return O(R, b, x, D)
      },
      [O, R, b, x, D],
    ),
    L = Z(M, 4),
    V = L[0],
    A = L[1],
    I = L[2],
    P = L[3],
    k = function (N, T) {
      var G = function () {
          return V
        },
        H = A,
        _ = I,
        B = P
      if (T) {
        var z = S(T),
          Q = Z(z, 4),
          J = Q[0],
          se = Q[1],
          ie = Q[2],
          U = Q[3],
          W = O(J, se, ie, U),
          j = Z(W, 4),
          K = j[0],
          q = j[1],
          ne = j[2],
          oe = j[3]
        ;(G = function () {
          return K
        }),
          (H = q),
          (_ = ne),
          (B = oe)
      }
      var le = OR(N, G, H, _, B, e)
      return le
    }
  return [k, V, A, I, P]
}
function LR(e) {
  var t = e.mode,
    i = e.internalMode,
    s = e.renderExtraFooter,
    n = e.showNow,
    r = e.showTime,
    o = e.onSubmit,
    a = e.onNow,
    l = e.invalid,
    c = e.needConfirm,
    u = e.generateConfig,
    h = e.disabledDate,
    g = d.useContext(ss),
    f = g.prefixCls,
    p = g.locale,
    v = g.button,
    m = v === void 0 ? 'button' : v,
    C = u.getNow(),
    w = Gu(u, r, C),
    S = Z(w, 1),
    y = S[0],
    F = s == null ? void 0 : s(t),
    R = h(C, { type: t }),
    b = function () {
      if (!R) {
        var A = y(C)
        a(A)
      }
    },
    x = ''.concat(f, '-now'),
    D = ''.concat(x, '-btn'),
    O =
      n &&
      d.createElement(
        'li',
        { className: x },
        d.createElement(
          'a',
          {
            className: pe(D, R && ''.concat(D, '-disabled')),
            'aria-disabled': R,
            onClick: b,
          },
          i === 'date' ? p.today : p.now,
        ),
      ),
    M =
      c &&
      d.createElement(
        'li',
        { className: ''.concat(f, '-ok') },
        d.createElement(m, { disabled: l, onClick: o }, p.ok),
      ),
    L =
      (O || M) &&
      d.createElement('ul', { className: ''.concat(f, '-ranges') }, O, M)
  return !F && !L
    ? null
    : d.createElement(
        'div',
        { className: ''.concat(f, '-footer') },
        F &&
          d.createElement(
            'div',
            { className: ''.concat(f, '-footer-extra') },
            F,
          ),
        L,
      )
}
function vp(e, t, i) {
  function s(n, r) {
    var o = n.findIndex(function (l) {
      return fi(e, t, l, r, i)
    })
    if (o === -1) return [].concat(St(n), [r])
    var a = St(n)
    return a.splice(o, 1), a
  }
  return s
}
var zn = d.createContext(null)
function rl() {
  return d.useContext(zn)
}
function br(e, t) {
  var i = e.prefixCls,
    s = e.generateConfig,
    n = e.locale,
    r = e.disabledDate,
    o = e.minDate,
    a = e.maxDate,
    l = e.cellRender,
    c = e.hoverValue,
    u = e.hoverRangeValue,
    h = e.onHover,
    g = e.values,
    f = e.pickerValue,
    p = e.onSelect,
    v = e.prevIcon,
    m = e.nextIcon,
    C = e.superPrevIcon,
    w = e.superNextIcon,
    S = s.getNow(),
    y = {
      now: S,
      values: g,
      pickerValue: f,
      prefixCls: i,
      disabledDate: r,
      minDate: o,
      maxDate: a,
      cellRender: l,
      hoverValue: c,
      hoverRangeValue: u,
      onHover: h,
      locale: n,
      generateConfig: s,
      onSelect: p,
      panelType: t,
      prevIcon: v,
      nextIcon: m,
      superPrevIcon: C,
      superNextIcon: w,
    }
  return [y, S]
}
var rn = d.createContext({})
function To(e) {
  for (
    var t = e.rowNum,
      i = e.colNum,
      s = e.baseDate,
      n = e.getCellDate,
      r = e.prefixColumn,
      o = e.rowClassName,
      a = e.titleFormat,
      l = e.getCellText,
      c = e.getCellClassName,
      u = e.headerCells,
      h = e.cellSelection,
      g = h === void 0 ? !0 : h,
      f = e.disabledDate,
      p = rl(),
      v = p.prefixCls,
      m = p.panelType,
      C = p.now,
      w = p.disabledDate,
      S = p.cellRender,
      y = p.onHover,
      F = p.hoverValue,
      R = p.hoverRangeValue,
      b = p.generateConfig,
      x = p.values,
      D = p.locale,
      O = p.onSelect,
      M = f || w,
      L = ''.concat(v, '-cell'),
      V = d.useContext(rn),
      A = V.onCellDblClick,
      I = function (_) {
        return x.some(function (B) {
          return B && fi(b, D, _, B, m)
        })
      },
      P = [],
      k = 0;
    k < t;
    k += 1
  ) {
    for (
      var E = [],
        N = void 0,
        T = function () {
          var _ = k * i + G,
            B = n(s, _),
            z = M == null ? void 0 : M(B, { type: m })
          G === 0 && ((N = B), r && E.push(r(N)))
          var Q = !1,
            J = !1,
            se = !1
          if (g && R) {
            var ie = Z(R, 2),
              U = ie[0],
              W = ie[1]
            ;(Q = nl(b, U, W, B)),
              (J = fi(b, D, B, U, m)),
              (se = fi(b, D, B, W, m))
          }
          var j = a
              ? Qt(B, { locale: D, format: a, generateConfig: b })
              : void 0,
            K = d.createElement(
              'div',
              { className: ''.concat(L, '-inner') },
              l(B),
            )
          E.push(
            d.createElement(
              'td',
              {
                key: G,
                title: j,
                className: pe(
                  L,
                  re(
                    ce(
                      ce(
                        ce(
                          ce(
                            ce(
                              ce({}, ''.concat(L, '-disabled'), z),
                              ''.concat(L, '-hover'),
                              (F || []).some(function (q) {
                                return fi(b, D, B, q, m)
                              }),
                            ),
                            ''.concat(L, '-in-range'),
                            Q && !J && !se,
                          ),
                          ''.concat(L, '-range-start'),
                          J,
                        ),
                        ''.concat(L, '-range-end'),
                        se,
                      ),
                      ''.concat(v, '-cell-selected'),
                      !R && m !== 'week' && I(B),
                    ),
                    c(B),
                  ),
                ),
                onClick: function () {
                  z || O(B)
                },
                onDoubleClick: function () {
                  !z && A && A()
                },
                onMouseEnter: function () {
                  z || y == null || y(B)
                },
                onMouseLeave: function () {
                  z || y == null || y(null)
                },
              },
              S
                ? S(B, {
                    prefixCls: v,
                    originNode: K,
                    today: C,
                    type: m,
                    locale: D,
                  })
                : K,
            ),
          )
        },
        G = 0;
      G < i;
      G += 1
    )
      T()
    P.push(
      d.createElement(
        'tr',
        { key: k, className: o == null ? void 0 : o(N) },
        E,
      ),
    )
  }
  return d.createElement(
    'div',
    { className: ''.concat(v, '-body') },
    d.createElement(
      'table',
      { className: ''.concat(v, '-content') },
      u && d.createElement('thead', null, d.createElement('tr', null, u)),
      d.createElement('tbody', null, P),
    ),
  )
}
var Ko = { visibility: 'hidden' }
function Rr(e) {
  var t = e.offset,
    i = e.superOffset,
    s = e.onChange,
    n = e.getStart,
    r = e.getEnd,
    o = e.children,
    a = rl(),
    l = a.prefixCls,
    c = a.prevIcon,
    u = c === void 0 ? '' : c,
    h = a.nextIcon,
    g = h === void 0 ? '' : h,
    f = a.superPrevIcon,
    p = f === void 0 ? '' : f,
    v = a.superNextIcon,
    m = v === void 0 ? '' : v,
    C = a.minDate,
    w = a.maxDate,
    S = a.generateConfig,
    y = a.locale,
    F = a.pickerValue,
    R = a.panelType,
    b = ''.concat(l, '-header'),
    x = d.useContext(rn),
    D = x.hidePrev,
    O = x.hideNext,
    M = x.hideHeader,
    L = d.useMemo(
      function () {
        if (!C || !t || !r) return !1
        var H = r(t(-1, F))
        return !zo(S, y, H, C, R)
      },
      [C, t, F, r, S, y, R],
    ),
    V = d.useMemo(
      function () {
        if (!C || !i || !r) return !1
        var H = r(i(-1, F))
        return !zo(S, y, H, C, R)
      },
      [C, i, F, r, S, y, R],
    ),
    A = d.useMemo(
      function () {
        if (!w || !t || !n) return !1
        var H = n(t(1, F))
        return !zo(S, y, w, H, R)
      },
      [w, t, F, n, S, y, R],
    ),
    I = d.useMemo(
      function () {
        if (!w || !i || !n) return !1
        var H = n(i(1, F))
        return !zo(S, y, w, H, R)
      },
      [w, i, F, n, S, y, R],
    ),
    P = function (_) {
      t && s(t(_, F))
    },
    k = function (_) {
      i && s(i(_, F))
    }
  if (M) return null
  var E = ''.concat(b, '-prev-btn'),
    N = ''.concat(b, '-next-btn'),
    T = ''.concat(b, '-super-prev-btn'),
    G = ''.concat(b, '-super-next-btn')
  return d.createElement(
    'div',
    { className: b },
    i &&
      d.createElement(
        'button',
        {
          type: 'button',
          'aria-label': 'super-prev-year',
          onClick: function () {
            return k(-1)
          },
          tabIndex: -1,
          className: pe(T, V && ''.concat(T, '-disabled')),
          disabled: V,
          style: D ? Ko : {},
        },
        p,
      ),
    t &&
      d.createElement(
        'button',
        {
          type: 'button',
          'aria-label': 'prev-year',
          onClick: function () {
            return P(-1)
          },
          tabIndex: -1,
          className: pe(E, L && ''.concat(E, '-disabled')),
          disabled: L,
          style: D ? Ko : {},
        },
        u,
      ),
    d.createElement('div', { className: ''.concat(b, '-view') }, o),
    t &&
      d.createElement(
        'button',
        {
          type: 'button',
          'aria-label': 'next-year',
          onClick: function () {
            return P(1)
          },
          tabIndex: -1,
          className: pe(N, A && ''.concat(N, '-disabled')),
          disabled: A,
          style: O ? Ko : {},
        },
        g,
      ),
    i &&
      d.createElement(
        'button',
        {
          type: 'button',
          'aria-label': 'super-next-year',
          onClick: function () {
            return k(1)
          },
          tabIndex: -1,
          className: pe(G, I && ''.concat(G, '-disabled')),
          disabled: I,
          style: O ? Ko : {},
        },
        m,
      ),
  )
}
function ol(e) {
  var t = e.prefixCls,
    i = e.panelName,
    s = i === void 0 ? 'date' : i,
    n = e.locale,
    r = e.generateConfig,
    o = e.pickerValue,
    a = e.onPickerValueChange,
    l = e.onModeChange,
    c = e.mode,
    u = c === void 0 ? 'date' : c,
    h = e.disabledDate,
    g = e.onSelect,
    f = e.onHover,
    p = e.showWeek,
    v = ''.concat(t, '-').concat(s, '-panel'),
    m = ''.concat(t, '-cell'),
    C = u === 'week',
    w = br(e, u),
    S = Z(w, 2),
    y = S[0],
    F = S[1],
    R = r.locale.getWeekFirstDay(n.locale),
    b = r.setDate(o, 1),
    x = FR(n.locale, r, b),
    D = r.getMonth(o),
    O = p === void 0 ? C : p,
    M = O
      ? function (H) {
          var _ = h == null ? void 0 : h(H, { type: 'week' })
          return d.createElement(
            'td',
            {
              key: 'week',
              className: pe(
                m,
                ''.concat(m, '-week'),
                ce({}, ''.concat(m, '-disabled'), _),
              ),
              onClick: function () {
                _ || g(H)
              },
              onMouseEnter: function () {
                _ || f == null || f(H)
              },
              onMouseLeave: function () {
                _ || f == null || f(null)
              },
            },
            d.createElement(
              'div',
              { className: ''.concat(m, '-inner') },
              r.locale.getWeek(n.locale, H),
            ),
          )
        }
      : null,
    L = [],
    V =
      n.shortWeekDays ||
      (r.locale.getShortWeekDays ? r.locale.getShortWeekDays(n.locale) : [])
  M &&
    L.push(d.createElement('th', { key: 'empty', 'aria-label': 'empty cell' }))
  for (var A = 0; A < zl; A += 1)
    L.push(d.createElement('th', { key: A }, V[(A + R) % zl]))
  var I = function (_, B) {
      return r.addDate(_, B)
    },
    P = function (_) {
      return Qt(_, { locale: n, format: n.cellDateFormat, generateConfig: r })
    },
    k = function (_) {
      var B = ce(
        ce({}, ''.concat(t, '-cell-in-view'), ku(r, _, o)),
        ''.concat(t, '-cell-today'),
        Hu(r, _, F),
      )
      return B
    },
    E =
      n.shortMonths ||
      (r.locale.getShortMonths ? r.locale.getShortMonths(n.locale) : []),
    N = d.createElement(
      'button',
      {
        type: 'button',
        'aria-label': 'year panel',
        key: 'year',
        onClick: function () {
          l('year', o)
        },
        tabIndex: -1,
        className: ''.concat(t, '-year-btn'),
      },
      Qt(o, { locale: n, format: n.yearFormat, generateConfig: r }),
    ),
    T = d.createElement(
      'button',
      {
        type: 'button',
        'aria-label': 'month panel',
        key: 'month',
        onClick: function () {
          l('month', o)
        },
        tabIndex: -1,
        className: ''.concat(t, '-month-btn'),
      },
      n.monthFormat
        ? Qt(o, { locale: n, format: n.monthFormat, generateConfig: r })
        : E[D],
    ),
    G = n.monthBeforeYear ? [T, N] : [N, T]
  return d.createElement(
    zn.Provider,
    { value: y },
    d.createElement(
      'div',
      { className: pe(v, p && ''.concat(v, '-show-week')) },
      d.createElement(
        Rr,
        {
          offset: function (_) {
            return r.addMonth(o, _)
          },
          superOffset: function (_) {
            return r.addYear(o, _)
          },
          onChange: a,
          getStart: function (_) {
            return r.setDate(_, 1)
          },
          getEnd: function (_) {
            var B = r.setDate(_, 1)
            return (B = r.addMonth(B, 1)), r.addDate(B, -1)
          },
        },
        G,
      ),
      d.createElement(
        To,
        xe({ titleFormat: n.fieldDateFormat }, e, {
          colNum: zl,
          rowNum: 6,
          baseDate: x,
          headerCells: L,
          getCellDate: I,
          getCellText: P,
          getCellClassName: k,
          prefixColumn: M,
          cellSelection: !C,
        }),
      ),
    ),
  )
}
var kR = 1 / 3
function HR(e, t) {
  var i = d.useRef(!1),
    s = d.useRef(null),
    n = d.useRef(null),
    r = function () {
      return i.current
    },
    o = function () {
      bt.cancel(s.current), (i.current = !1)
    },
    a = d.useRef(),
    l = function () {
      var h = e.current
      if (((n.current = null), (a.current = 0), h)) {
        var g = h.querySelector('[data-value="'.concat(t, '"]')),
          f = h.querySelector('li'),
          p = function v() {
            o(), (i.current = !0), (a.current += 1)
            var m = h.scrollTop,
              C = f.offsetTop,
              w = g.offsetTop,
              S = w - C
            if ((w === 0 && g !== f) || !Xg(h)) {
              a.current <= 5 && (s.current = bt(v))
              return
            }
            var y = m + (S - m) * kR,
              F = Math.abs(S - y)
            if (n.current !== null && n.current < F) {
              o()
              return
            }
            if (((n.current = F), F <= 1)) {
              ;(h.scrollTop = S), o()
              return
            }
            ;(h.scrollTop = y), (s.current = bt(v))
          }
        g && f && p()
      }
    },
    c = Bt(l)
  return [c, o, r]
}
var NR = 300
function Ur(e) {
  var t = e.units,
    i = e.value,
    s = e.optionalValue,
    n = e.type,
    r = e.onChange,
    o = e.onHover,
    a = e.onDblClick,
    l = e.changeOnScroll,
    c = rl(),
    u = c.prefixCls,
    h = c.cellRender,
    g = c.now,
    f = c.locale,
    p = ''.concat(u, '-time-panel'),
    v = ''.concat(u, '-time-panel-cell'),
    m = d.useRef(null),
    C = d.useRef(),
    w = function () {
      clearTimeout(C.current)
    },
    S = HR(m, i ?? s),
    y = Z(S, 3),
    F = y[0],
    R = y[1],
    b = y[2]
  li(
    function () {
      return (
        F(),
        w(),
        function () {
          R(), w()
        }
      )
    },
    [i, s, t],
  )
  var x = function (M) {
      w()
      var L = M.target
      !b() &&
        l &&
        (C.current = setTimeout(function () {
          var V = m.current,
            A = V.querySelector('li').offsetTop,
            I = Array.from(V.querySelectorAll('li')),
            P = I.map(function (G) {
              return G.offsetTop - A
            }),
            k = P.map(function (G, H) {
              return t[H].disabled
                ? Number.MAX_SAFE_INTEGER
                : Math.abs(G - L.scrollTop)
            }),
            E = Math.min.apply(Math, St(k)),
            N = k.findIndex(function (G) {
              return G === E
            }),
            T = t[N]
          T && !T.disabled && r(T.value)
        }, NR))
    },
    D = ''.concat(p, '-column')
  return d.createElement(
    'ul',
    { className: D, ref: m, 'data-type': n, onScroll: x },
    t.map(function (O) {
      var M = O.label,
        L = O.value,
        V = O.disabled,
        A = d.createElement('div', { className: ''.concat(v, '-inner') }, M)
      return d.createElement(
        'li',
        {
          key: L,
          className: pe(
            v,
            ce(
              ce({}, ''.concat(v, '-selected'), i === L),
              ''.concat(v, '-disabled'),
              V,
            ),
          ),
          onClick: function () {
            V || r(L)
          },
          onDoubleClick: function () {
            !V && a && a()
          },
          onMouseEnter: function () {
            o(L)
          },
          onMouseLeave: function () {
            o(null)
          },
          'data-value': L,
        },
        h
          ? h(L, {
              prefixCls: u,
              originNode: A,
              today: g,
              type: 'time',
              subType: n,
              locale: f,
            })
          : A,
      )
    }),
  )
}
function Qs(e) {
  return e < 12
}
function GR(e) {
  var t = e.showHour,
    i = e.showMinute,
    s = e.showSecond,
    n = e.showMillisecond,
    r = e.use12Hours,
    o = e.changeOnScroll,
    a = rl(),
    l = a.prefixCls,
    c = a.values,
    u = a.generateConfig,
    h = a.locale,
    g = a.onSelect,
    f = a.onHover,
    p = f === void 0 ? function () {} : f,
    v = a.pickerValue,
    m = (c == null ? void 0 : c[0]) || null,
    C = d.useContext(rn),
    w = C.onCellDblClick,
    S = Gu(u, e, m),
    y = Z(S, 5),
    F = y[0],
    R = y[1],
    b = y[2],
    x = y[3],
    D = y[4],
    O = function (Ce) {
      var at = m && u[Ce](m),
        vt = v && u[Ce](v)
      return [at, vt]
    },
    M = O('getHour'),
    L = Z(M, 2),
    V = L[0],
    A = L[1],
    I = O('getMinute'),
    P = Z(I, 2),
    k = P[0],
    E = P[1],
    N = O('getSecond'),
    T = Z(N, 2),
    G = T[0],
    H = T[1],
    _ = O('getMillisecond'),
    B = Z(_, 2),
    z = B[0],
    Q = B[1],
    J = V === null ? null : Qs(V) ? 'am' : 'pm',
    se = d.useMemo(
      function () {
        return r
          ? Qs(V)
            ? R.filter(function (fe) {
                return Qs(fe.value)
              })
            : R.filter(function (fe) {
                return !Qs(fe.value)
              })
          : R
      },
      [V, R, r],
    ),
    ie = function (Ce, at) {
      var vt,
        pt = Ce.filter(function ($t) {
          return !$t.disabled
        })
      return (
        at ??
        (pt == null || (vt = pt[0]) === null || vt === void 0
          ? void 0
          : vt.value)
      )
    },
    U = ie(R, V),
    W = d.useMemo(
      function () {
        return b(U)
      },
      [b, U],
    ),
    j = ie(W, k),
    K = d.useMemo(
      function () {
        return x(U, j)
      },
      [x, U, j],
    ),
    q = ie(K, G),
    ne = d.useMemo(
      function () {
        return D(U, j, q)
      },
      [D, U, j, q],
    ),
    oe = ie(ne, z),
    le = d.useMemo(
      function () {
        if (!r) return []
        var fe = u.getNow(),
          Ce = u.setHour(fe, 6),
          at = u.setHour(fe, 18),
          vt = function ($t, zt) {
            var Mt = h.cellMeridiemFormat
            return Mt
              ? Qt($t, { generateConfig: u, locale: h, format: Mt })
              : zt
          }
        return [
          {
            label: vt(Ce, 'AM'),
            value: 'am',
            disabled: R.every(function (pt) {
              return pt.disabled || !Qs(pt.value)
            }),
          },
          {
            label: vt(at, 'PM'),
            value: 'pm',
            disabled: R.every(function (pt) {
              return pt.disabled || Qs(pt.value)
            }),
          },
        ]
      },
      [R, r, u, h],
    ),
    me = function (Ce) {
      var at = F(Ce)
      g(at)
    },
    ye = d.useMemo(
      function () {
        var fe = m || v || u.getNow(),
          Ce = function (vt) {
            return vt != null
          }
        return (
          Ce(V)
            ? ((fe = u.setHour(fe, V)),
              (fe = u.setMinute(fe, k)),
              (fe = u.setSecond(fe, G)),
              (fe = u.setMillisecond(fe, z)))
            : Ce(A)
              ? ((fe = u.setHour(fe, A)),
                (fe = u.setMinute(fe, E)),
                (fe = u.setSecond(fe, H)),
                (fe = u.setMillisecond(fe, Q)))
              : Ce(U) &&
                ((fe = u.setHour(fe, U)),
                (fe = u.setMinute(fe, j)),
                (fe = u.setSecond(fe, q)),
                (fe = u.setMillisecond(fe, oe))),
          fe
        )
      },
      [m, v, V, k, G, z, U, j, q, oe, A, E, H, Q, u],
    ),
    Me = function (Ce, at) {
      return Ce === null ? null : u[at](ye, Ce)
    },
    He = function (Ce) {
      return Me(Ce, 'setHour')
    },
    $e = function (Ce) {
      return Me(Ce, 'setMinute')
    },
    Fe = function (Ce) {
      return Me(Ce, 'setSecond')
    },
    ve = function (Ce) {
      return Me(Ce, 'setMillisecond')
    },
    Be = function (Ce) {
      return Ce === null
        ? null
        : Ce === 'am' && !Qs(V)
          ? u.setHour(ye, V - 12)
          : Ce === 'pm' && Qs(V)
            ? u.setHour(ye, V + 12)
            : ye
    },
    Se = function (Ce) {
      me(He(Ce))
    },
    we = function (Ce) {
      me($e(Ce))
    },
    ze = function (Ce) {
      me(Fe(Ce))
    },
    Ue = function (Ce) {
      me(ve(Ce))
    },
    ke = function (Ce) {
      me(Be(Ce))
    },
    Xe = function (Ce) {
      p(He(Ce))
    },
    Ye = function (Ce) {
      p($e(Ce))
    },
    ge = function (Ce) {
      p(Fe(Ce))
    },
    ae = function (Ce) {
      p(ve(Ce))
    },
    be = function (Ce) {
      p(Be(Ce))
    },
    De = { onDblClick: w, changeOnScroll: o }
  return d.createElement(
    'div',
    { className: ''.concat(l, '-content') },
    t &&
      d.createElement(
        Ur,
        xe(
          {
            units: se,
            value: V,
            optionalValue: A,
            type: 'hour',
            onChange: Se,
            onHover: Xe,
          },
          De,
        ),
      ),
    i &&
      d.createElement(
        Ur,
        xe(
          {
            units: W,
            value: k,
            optionalValue: E,
            type: 'minute',
            onChange: we,
            onHover: Ye,
          },
          De,
        ),
      ),
    s &&
      d.createElement(
        Ur,
        xe(
          {
            units: K,
            value: G,
            optionalValue: H,
            type: 'second',
            onChange: ze,
            onHover: ge,
          },
          De,
        ),
      ),
    n &&
      d.createElement(
        Ur,
        xe(
          {
            units: ne,
            value: z,
            optionalValue: Q,
            type: 'millisecond',
            onChange: Ue,
            onHover: ae,
          },
          De,
        ),
      ),
    r &&
      d.createElement(
        Ur,
        xe(
          { units: le, value: J, type: 'meridiem', onChange: ke, onHover: be },
          De,
        ),
      ),
  )
}
function Cp(e) {
  var t = e.prefixCls,
    i = e.value,
    s = e.locale,
    n = e.generateConfig,
    r = e.showTime,
    o = r || {},
    a = o.format,
    l = ''.concat(t, '-time-panel'),
    c = br(e, 'time'),
    u = Z(c, 1),
    h = u[0]
  return d.createElement(
    zn.Provider,
    { value: h },
    d.createElement(
      'div',
      { className: pe(l) },
      d.createElement(
        Rr,
        null,
        i ? Qt(i, { locale: s, format: a, generateConfig: n }) : '',
      ),
      d.createElement(GR, r),
    ),
  )
}
function BR(e) {
  var t = e.prefixCls,
    i = e.generateConfig,
    s = e.showTime,
    n = e.onSelect,
    r = e.value,
    o = e.pickerValue,
    a = e.onHover,
    l = ''.concat(t, '-datetime-panel'),
    c = Gu(i, s),
    u = Z(c, 1),
    h = u[0],
    g = function (m) {
      return r ? Pa(i, m, r) : Pa(i, m, o)
    },
    f = function (m) {
      a == null || a(m && g(m))
    },
    p = function (m) {
      var C = g(m)
      n(h(C, C))
    }
  return d.createElement(
    'div',
    { className: l },
    d.createElement(ol, xe({}, e, { onSelect: p, onHover: f })),
    d.createElement(Cp, e),
  )
}
function VR(e) {
  var t = e.prefixCls,
    i = e.locale,
    s = e.generateConfig,
    n = e.pickerValue,
    r = e.disabledDate,
    o = e.onPickerValueChange,
    a = ''.concat(t, '-decade-panel'),
    l = br(e, 'decade'),
    c = Z(l, 1),
    u = c[0],
    h = function (R) {
      var b = Math.floor(s.getYear(n) / 100) * 100
      return s.setYear(R, b)
    },
    g = function (R) {
      var b = h(R)
      return s.addYear(b, 99)
    },
    f = h(n),
    p = g(n),
    v = s.addYear(f, -10),
    m = function (R, b) {
      return s.addYear(R, b * 10)
    },
    C = function (R) {
      var b = i.cellYearFormat,
        x = Qt(R, { locale: i, format: b, generateConfig: s }),
        D = Qt(s.addYear(R, 9), { locale: i, format: b, generateConfig: s })
      return ''.concat(x, '-').concat(D)
    },
    w = function (R) {
      return ce(
        {},
        ''.concat(t, '-cell-in-view'),
        Tc(s, R, f) || Tc(s, R, p) || nl(s, f, p, R),
      )
    },
    S = r
      ? function (F, R) {
          var b = s.setDate(F, 1),
            x = s.setMonth(b, 0),
            D = s.setYear(x, Math.floor(s.getYear(x) / 10) * 10),
            O = s.addYear(D, 10),
            M = s.addDate(O, -1)
          return r(D, R) && r(M, R)
        }
      : null,
    y = ''
      .concat(
        Qt(f, { locale: i, format: i.yearFormat, generateConfig: s }),
        '-',
      )
      .concat(Qt(p, { locale: i, format: i.yearFormat, generateConfig: s }))
  return d.createElement(
    zn.Provider,
    { value: u },
    d.createElement(
      'div',
      { className: a },
      d.createElement(
        Rr,
        {
          superOffset: function (R) {
            return s.addYear(n, R * 100)
          },
          onChange: o,
          getStart: h,
          getEnd: g,
        },
        y,
      ),
      d.createElement(
        To,
        xe({}, e, {
          disabledDate: S,
          colNum: 3,
          rowNum: 4,
          baseDate: v,
          getCellDate: m,
          getCellText: C,
          getCellClassName: w,
        }),
      ),
    ),
  )
}
function _R(e) {
  var t = e.prefixCls,
    i = e.locale,
    s = e.generateConfig,
    n = e.pickerValue,
    r = e.disabledDate,
    o = e.onPickerValueChange,
    a = e.onModeChange,
    l = ''.concat(t, '-month-panel'),
    c = br(e, 'month'),
    u = Z(c, 1),
    h = u[0],
    g = s.setMonth(n, 0),
    f =
      i.shortMonths ||
      (s.locale.getShortMonths ? s.locale.getShortMonths(i.locale) : []),
    p = function (y, F) {
      return s.addMonth(y, F)
    },
    v = function (y) {
      var F = s.getMonth(y)
      return i.monthFormat
        ? Qt(y, { locale: i, format: i.monthFormat, generateConfig: s })
        : f[F]
    },
    m = function () {
      return ce({}, ''.concat(t, '-cell-in-view'), !0)
    },
    C = r
      ? function (S, y) {
          var F = s.setDate(S, 1),
            R = s.setMonth(F, s.getMonth(F) + 1),
            b = s.addDate(R, -1)
          return r(F, y) && r(b, y)
        }
      : null,
    w = d.createElement(
      'button',
      {
        type: 'button',
        key: 'year',
        'aria-label': 'year panel',
        onClick: function () {
          a('year')
        },
        tabIndex: -1,
        className: ''.concat(t, '-year-btn'),
      },
      Qt(n, { locale: i, format: i.yearFormat, generateConfig: s }),
    )
  return d.createElement(
    zn.Provider,
    { value: h },
    d.createElement(
      'div',
      { className: l },
      d.createElement(
        Rr,
        {
          superOffset: function (y) {
            return s.addYear(n, y)
          },
          onChange: o,
          getStart: function (y) {
            return s.setMonth(y, 0)
          },
          getEnd: function (y) {
            return s.setMonth(y, 11)
          },
        },
        w,
      ),
      d.createElement(
        To,
        xe({}, e, {
          disabledDate: C,
          titleFormat: i.fieldMonthFormat,
          colNum: 3,
          rowNum: 4,
          baseDate: g,
          getCellDate: p,
          getCellText: v,
          getCellClassName: m,
        }),
      ),
    ),
  )
}
function WR(e) {
  var t = e.prefixCls,
    i = e.locale,
    s = e.generateConfig,
    n = e.pickerValue,
    r = e.onPickerValueChange,
    o = e.onModeChange,
    a = ''.concat(t, '-quarter-panel'),
    l = br(e, 'quarter'),
    c = Z(l, 1),
    u = c[0],
    h = s.setMonth(n, 0),
    g = function (C, w) {
      return s.addMonth(C, w * 3)
    },
    f = function (C) {
      return Qt(C, {
        locale: i,
        format: i.cellQuarterFormat,
        generateConfig: s,
      })
    },
    p = function () {
      return ce({}, ''.concat(t, '-cell-in-view'), !0)
    },
    v = d.createElement(
      'button',
      {
        type: 'button',
        key: 'year',
        'aria-label': 'year panel',
        onClick: function () {
          o('year')
        },
        tabIndex: -1,
        className: ''.concat(t, '-year-btn'),
      },
      Qt(n, { locale: i, format: i.yearFormat, generateConfig: s }),
    )
  return d.createElement(
    zn.Provider,
    { value: u },
    d.createElement(
      'div',
      { className: a },
      d.createElement(
        Rr,
        {
          superOffset: function (C) {
            return s.addYear(n, C)
          },
          onChange: r,
          getStart: function (C) {
            return s.setMonth(C, 0)
          },
          getEnd: function (C) {
            return s.setMonth(C, 11)
          },
        },
        v,
      ),
      d.createElement(
        To,
        xe({}, e, {
          titleFormat: i.fieldQuarterFormat,
          colNum: 4,
          rowNum: 1,
          baseDate: h,
          getCellDate: g,
          getCellText: f,
          getCellClassName: p,
        }),
      ),
    ),
  )
}
function $R(e) {
  var t = e.prefixCls,
    i = e.generateConfig,
    s = e.locale,
    n = e.value,
    r = e.hoverValue,
    o = e.hoverRangeValue,
    a = s.locale,
    l = ''.concat(t, '-week-panel-row'),
    c = function (h) {
      var g = {}
      if (o) {
        var f = Z(o, 2),
          p = f[0],
          v = f[1],
          m = Zr(i, a, p, h),
          C = Zr(i, a, v, h)
        ;(g[''.concat(l, '-range-start')] = m),
          (g[''.concat(l, '-range-end')] = C),
          (g[''.concat(l, '-range-hover')] = !m && !C && nl(i, p, v, h))
      }
      return (
        r &&
          (g[''.concat(l, '-hover')] = r.some(function (w) {
            return Zr(i, a, h, w)
          })),
        pe(l, ce({}, ''.concat(l, '-selected'), !o && Zr(i, a, n, h)), g)
      )
    }
  return d.createElement(
    ol,
    xe({}, e, { mode: 'week', panelName: 'week', rowClassName: c }),
  )
}
function zR(e) {
  var t = e.prefixCls,
    i = e.locale,
    s = e.generateConfig,
    n = e.pickerValue,
    r = e.disabledDate,
    o = e.onPickerValueChange,
    a = e.onModeChange,
    l = ''.concat(t, '-year-panel'),
    c = br(e, 'year'),
    u = Z(c, 1),
    h = u[0],
    g = function (b) {
      var x = Math.floor(s.getYear(n) / 10) * 10
      return s.setYear(b, x)
    },
    f = function (b) {
      var x = g(b)
      return s.addYear(x, 9)
    },
    p = g(n),
    v = f(n),
    m = s.addYear(p, -1),
    C = function (b, x) {
      return s.addYear(b, x)
    },
    w = function (b) {
      return Qt(b, { locale: i, format: i.cellYearFormat, generateConfig: s })
    },
    S = function (b) {
      return ce(
        {},
        ''.concat(t, '-cell-in-view'),
        kn(s, b, p) || kn(s, b, v) || nl(s, p, v, b),
      )
    },
    y = r
      ? function (R, b) {
          var x = s.setMonth(R, 0),
            D = s.setDate(x, 1),
            O = s.addYear(D, 1),
            M = s.addDate(O, -1)
          return r(D, b) && r(M, b)
        }
      : null,
    F = d.createElement(
      'button',
      {
        type: 'button',
        key: 'decade',
        'aria-label': 'decade panel',
        onClick: function () {
          a('decade')
        },
        tabIndex: -1,
        className: ''.concat(t, '-decade-btn'),
      },
      Qt(p, { locale: i, format: i.yearFormat, generateConfig: s }),
      '-',
      Qt(v, { locale: i, format: i.yearFormat, generateConfig: s }),
    )
  return d.createElement(
    zn.Provider,
    { value: h },
    d.createElement(
      'div',
      { className: l },
      d.createElement(
        Rr,
        {
          superOffset: function (b) {
            return s.addYear(n, b * 10)
          },
          onChange: o,
          getStart: g,
          getEnd: f,
        },
        F,
      ),
      d.createElement(
        To,
        xe({}, e, {
          disabledDate: y,
          titleFormat: i.fieldYearFormat,
          colNum: 3,
          rowNum: 4,
          baseDate: m,
          getCellDate: C,
          getCellText: w,
          getCellClassName: S,
        }),
      ),
    ),
  )
}
var UR = {
  date: ol,
  datetime: BR,
  week: $R,
  month: _R,
  quarter: WR,
  year: zR,
  decade: VR,
  time: Cp,
}
function jR(e, t) {
  var i,
    s = e.locale,
    n = e.generateConfig,
    r = e.direction,
    o = e.prefixCls,
    a = e.tabIndex,
    l = a === void 0 ? 0 : a,
    c = e.multiple,
    u = e.defaultValue,
    h = e.value,
    g = e.onChange,
    f = e.onSelect,
    p = e.defaultPickerValue,
    v = e.pickerValue,
    m = e.onPickerValueChange,
    C = e.mode,
    w = e.onPanelChange,
    S = e.picker,
    y = S === void 0 ? 'date' : S,
    F = e.showTime,
    R = e.hoverValue,
    b = e.hoverRangeValue,
    x = e.cellRender,
    D = e.dateRender,
    O = e.monthCellRender,
    M = e.components,
    L = M === void 0 ? {} : M,
    V = e.hideHeader,
    A =
      ((i = d.useContext(ss)) === null || i === void 0
        ? void 0
        : i.prefixCls) ||
      o ||
      'rc-picker',
    I = d.useRef()
  d.useImperativeHandle(t, function () {
    return { nativeElement: I.current }
  })
  var P = tp(e),
    k = Z(P, 4),
    E = k[0],
    N = k[1],
    T = k[2],
    G = k[3],
    H = Jf(s, N),
    _ = y === 'date' && F ? 'datetime' : y,
    B = d.useMemo(
      function () {
        return ip(_, T, G, E, H)
      },
      [_, T, G, E, H],
    ),
    z = n.getNow(),
    Q = ai(y, {
      value: C,
      postState: function (be) {
        return be || 'date'
      },
    }),
    J = Z(Q, 2),
    se = J[0],
    ie = J[1],
    U = se === 'date' && B ? 'datetime' : se,
    W = vp(n, s, _),
    j = ai(u, { value: h }),
    K = Z(j, 2),
    q = K[0],
    ne = K[1],
    oe = d.useMemo(
      function () {
        var ae = $n(q).filter(function (be) {
          return be
        })
        return c ? ae : ae.slice(0, 1)
      },
      [q, c],
    ),
    le = Bt(function (ae) {
      ne(ae),
        g &&
          (ae === null ||
            oe.length !== ae.length ||
            oe.some(function (be, De) {
              return !fi(n, s, be, ae[De], _)
            })) &&
          (g == null || g(c ? ae : ae[0]))
    }),
    me = Bt(function (ae) {
      if ((f == null || f(ae), se === y)) {
        var be = c ? W(oe, ae) : [ae]
        le(be)
      }
    }),
    ye = ai(p || oe[0] || z, { value: v }),
    Me = Z(ye, 2),
    He = Me[0],
    $e = Me[1]
  d.useEffect(
    function () {
      oe[0] && !v && $e(oe[0])
    },
    [oe[0]],
  )
  var Fe = function (be, De) {
      w == null || w(be || v, De || se)
    },
    ve = function (be) {
      var De =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
      $e(be), m == null || m(be), De && Fe(be)
    },
    Be = function (be, De) {
      ie(be), De && ve(De), Fe(De, be)
    },
    Se = function (be) {
      if ((me(be), ve(be), se !== y)) {
        var De = ['decade', 'year'],
          fe = [].concat(De, ['month']),
          Ce = {
            quarter: [].concat(De, ['quarter']),
            week: [].concat(St(fe), ['week']),
            date: [].concat(St(fe), ['date']),
          },
          at = Ce[y] || fe,
          vt = at.indexOf(se),
          pt = at[vt + 1]
        pt && Be(pt, be)
      }
    },
    we = d.useMemo(
      function () {
        var ae, be
        if (Array.isArray(b)) {
          var De = Z(b, 2)
          ;(ae = De[0]), (be = De[1])
        } else ae = b
        return !ae && !be
          ? null
          : ((ae = ae || be),
            (be = be || ae),
            n.isAfter(ae, be) ? [be, ae] : [ae, be])
      },
      [b, n],
    ),
    ze = Lu(x, D, O),
    Ue = L[U] || UR[U] || ol,
    ke = d.useContext(rn),
    Xe = d.useMemo(
      function () {
        return re(re({}, ke), {}, { hideHeader: V })
      },
      [ke, V],
    ),
    Ye = ''.concat(A, '-panel'),
    ge = sl(e, [
      'showWeek',
      'prevIcon',
      'nextIcon',
      'superPrevIcon',
      'superNextIcon',
      'disabledDate',
      'minDate',
      'maxDate',
      'onHover',
    ])
  return d.createElement(
    rn.Provider,
    { value: Xe },
    d.createElement(
      'div',
      {
        ref: I,
        tabIndex: l,
        className: pe(Ye, ce({}, ''.concat(Ye, '-rtl'), r === 'rtl')),
      },
      d.createElement(
        Ue,
        xe({}, ge, {
          showTime: B,
          prefixCls: A,
          locale: H,
          generateConfig: n,
          onModeChange: Be,
          pickerValue: He,
          onPickerValueChange: function (be) {
            ve(be, !0)
          },
          value: oe[0],
          onSelect: Se,
          values: oe,
          cellRender: ze,
          hoverRangeValue: we,
          hoverValue: R,
        }),
      ),
    ),
  )
}
var jl = d.memo(d.forwardRef(jR))
function YR(e) {
  var t = e.picker,
    i = e.multiplePanel,
    s = e.pickerValue,
    n = e.onPickerValueChange,
    r = e.needConfirm,
    o = e.onSubmit,
    a = e.range,
    l = e.hoverValue,
    c = d.useContext(ss),
    u = c.prefixCls,
    h = c.generateConfig,
    g = d.useCallback(
      function (w, S) {
        return eo(h, t, w, S)
      },
      [h, t],
    ),
    f = d.useMemo(
      function () {
        return g(s, 1)
      },
      [s, g],
    ),
    p = function (S) {
      n(g(S, -1))
    },
    v = {
      onCellDblClick: function () {
        r && o()
      },
    },
    m = t === 'time',
    C = re(
      re({}, e),
      {},
      { hoverValue: null, hoverRangeValue: null, hideHeader: m },
    )
  return (
    a ? (C.hoverRangeValue = l) : (C.hoverValue = l),
    i
      ? d.createElement(
          'div',
          { className: ''.concat(u, '-panels') },
          d.createElement(
            rn.Provider,
            { value: re(re({}, v), {}, { hideNext: !0 }) },
            d.createElement(jl, C),
          ),
          d.createElement(
            rn.Provider,
            { value: re(re({}, v), {}, { hidePrev: !0 }) },
            d.createElement(
              jl,
              xe({}, C, { pickerValue: f, onPickerValueChange: p }),
            ),
          ),
        )
      : d.createElement(
          rn.Provider,
          { value: re({}, v) },
          d.createElement(jl, C),
        )
  )
}
function Oh(e) {
  return typeof e == 'function' ? e() : e
}
function KR(e) {
  var t = e.prefixCls,
    i = e.presets,
    s = e.onClick,
    n = e.onHover
  return i.length
    ? d.createElement(
        'div',
        { className: ''.concat(t, '-presets') },
        d.createElement(
          'ul',
          null,
          i.map(function (r, o) {
            var a = r.label,
              l = r.value
            return d.createElement(
              'li',
              {
                key: o,
                onClick: function () {
                  s(Oh(l))
                },
                onMouseEnter: function () {
                  n(Oh(l))
                },
                onMouseLeave: function () {
                  n(null)
                },
              },
              a,
            )
          }),
        ),
      )
    : null
}
function Sp(e) {
  var t = e.panelRender,
    i = e.internalMode,
    s = e.picker,
    n = e.showNow,
    r = e.range,
    o = e.multiple,
    a = e.activeOffset,
    l = a === void 0 ? 0 : a,
    c = e.placement,
    u = e.presets,
    h = e.onPresetHover,
    g = e.onPresetSubmit,
    f = e.onFocus,
    p = e.onBlur,
    v = e.onPanelMouseDown,
    m = e.direction,
    C = e.value,
    w = e.onSelect,
    S = e.isInvalid,
    y = e.defaultOpenValue,
    F = e.onOk,
    R = e.onSubmit,
    b = d.useContext(ss),
    x = b.prefixCls,
    D = ''.concat(x, '-panel'),
    O = m === 'rtl',
    M = d.useRef(null),
    L = d.useRef(null),
    V = d.useState(0),
    A = Z(V, 2),
    I = A[0],
    P = A[1],
    k = d.useState(0),
    E = Z(k, 2),
    N = E[0],
    T = E[1],
    G = function (le) {
      le.offsetWidth && P(le.offsetWidth)
    }
  d.useEffect(
    function () {
      if (r) {
        var oe,
          le =
            ((oe = M.current) === null || oe === void 0
              ? void 0
              : oe.offsetWidth) || 0,
          me = I - le
        l <= me ? T(0) : T(l + le - I)
      }
    },
    [I, l, r],
  )
  function H(oe) {
    return oe.filter(function (le) {
      return le
    })
  }
  var _ = d.useMemo(
      function () {
        return H($n(C))
      },
      [C],
    ),
    B = s === 'time' && !_.length,
    z = d.useMemo(
      function () {
        return B ? H([y]) : _
      },
      [B, _, y],
    ),
    Q = B ? y : _,
    J = d.useMemo(
      function () {
        return z.length
          ? z.some(function (oe) {
              return S(oe)
            })
          : !0
      },
      [z, S],
    ),
    se = function () {
      B && w(y), F(), R()
    },
    ie = d.createElement(
      'div',
      { className: ''.concat(x, '-panel-layout') },
      d.createElement(KR, { prefixCls: x, presets: u, onClick: g, onHover: h }),
      d.createElement(
        'div',
        null,
        d.createElement(YR, xe({}, e, { value: Q })),
        d.createElement(
          LR,
          xe({}, e, { showNow: o ? !1 : n, invalid: J, onSubmit: se }),
        ),
      ),
    )
  t && (ie = t(ie))
  var U = ''.concat(D, '-container'),
    W = 'marginLeft',
    j = 'marginRight',
    K = d.createElement(
      'div',
      {
        onMouseDown: v,
        tabIndex: -1,
        className: pe(U, ''.concat(x, '-').concat(i, '-panel-container')),
        style: ce(ce({}, O ? j : W, N), O ? W : j, 'auto'),
        onFocus: f,
        onBlur: p,
      },
      ie,
    )
  if (r) {
    var q = il(c, O),
      ne = Uf(q, O)
    K = d.createElement(
      'div',
      {
        onMouseDown: v,
        ref: L,
        className: pe(
          ''.concat(x, '-range-wrapper'),
          ''.concat(x, '-').concat(s, '-range-wrapper'),
        ),
      },
      d.createElement('div', {
        ref: M,
        className: ''.concat(x, '-range-arrow'),
        style: ce({}, ne, l),
      }),
      d.createElement(Do, { onResize: G }, K),
    )
  }
  return K
}
function wp(e, t) {
  var i = e.format,
    s = e.maskFormat,
    n = e.generateConfig,
    r = e.locale,
    o = e.preserveInvalidOnBlur,
    a = e.inputReadOnly,
    l = e.required,
    c = e['aria-required'],
    u = e.onSubmit,
    h = e.onFocus,
    g = e.onBlur,
    f = e.onInputChange,
    p = e.onInvalid,
    v = e.open,
    m = e.onOpenChange,
    C = e.onKeyDown,
    w = e.onChange,
    S = e.activeHelp,
    y = e.name,
    F = e.autoComplete,
    R = e.id,
    b = e.value,
    x = e.invalid,
    D = e.placeholder,
    O = e.disabled,
    M = e.activeIndex,
    L = e.allHelp,
    V = e.picker,
    A = function (H, _) {
      var B = n.locale.parse(r.locale, H, [_])
      return B && n.isValidate(B) ? B : null
    },
    I = i[0],
    P = d.useCallback(
      function (G) {
        return Qt(G, { locale: r, format: I, generateConfig: n })
      },
      [r, n, I],
    ),
    k = d.useMemo(
      function () {
        return b.map(P)
      },
      [b, P],
    ),
    E = d.useMemo(
      function () {
        var G = V === 'time' ? 8 : 10,
          H = typeof I == 'function' ? I(n.getNow()).length : I.length
        return Math.max(G, H) + 2
      },
      [I, V, n],
    ),
    N = function (H) {
      for (var _ = 0; _ < i.length; _ += 1) {
        var B = i[_]
        if (typeof B == 'string') {
          var z = A(H, B)
          if (z) return z
        }
      }
      return !1
    },
    T = function (H) {
      function _(Q) {
        return H !== void 0 ? Q[H] : Q
      }
      var B = Bs(e, { aria: !0, data: !0 }),
        z = re(
          re({}, B),
          {},
          {
            format: s,
            validateFormat: function (J) {
              return !!N(J)
            },
            preserveInvalidOnBlur: o,
            readOnly: a,
            required: l,
            'aria-required': c,
            name: y,
            autoComplete: F,
            size: E,
            id: _(R),
            value: _(k) || '',
            invalid: _(x),
            placeholder: _(D),
            active: M === H,
            helped: L || (S && M === H),
            disabled: _(O),
            onFocus: function (J) {
              h(J, H)
            },
            onBlur: function (J) {
              g(J, H)
            },
            onSubmit: u,
            onChange: function (J) {
              f()
              var se = N(J)
              if (se) {
                p(!1, H), w(se, H)
                return
              }
              p(!!J, H)
            },
            onHelp: function () {
              m(!0, { index: H })
            },
            onKeyDown: function (J) {
              var se = !1
              if (
                (C == null ||
                  C(J, function () {
                    se = !0
                  }),
                !J.defaultPrevented && !se)
              )
                switch (J.key) {
                  case 'Escape':
                    m(!1, { index: H })
                    break
                  case 'Enter':
                    v || m(!0)
                    break
                }
            },
          },
          t == null ? void 0 : t({ valueTexts: k }),
        )
      return (
        Object.keys(z).forEach(function (Q) {
          z[Q] === void 0 && delete z[Q]
        }),
        z
      )
    }
  return [T, P]
}
var qR = ['onMouseEnter', 'onMouseLeave']
function yp(e) {
  return d.useMemo(
    function () {
      return sl(e, qR)
    },
    [e],
  )
}
var QR = ['icon', 'type'],
  XR = ['onClear']
function al(e) {
  var t = e.icon,
    i = e.type,
    s = Kt(e, QR),
    n = d.useContext(ss),
    r = n.prefixCls
  return t
    ? d.createElement(
        'span',
        xe({ className: ''.concat(r, '-').concat(i) }, s),
        t,
      )
    : null
}
function Ac(e) {
  var t = e.onClear,
    i = Kt(e, XR)
  return d.createElement(
    al,
    xe({}, i, {
      type: 'clear',
      role: 'button',
      onMouseDown: function (n) {
        n.preventDefault()
      },
      onClick: function (n) {
        n.stopPropagation(), t()
      },
    }),
  )
}
var Yl = ['YYYY', 'MM', 'DD', 'HH', 'mm', 'ss', 'SSS'],
  Lh = '',
  JR = (function () {
    function e(t) {
      qa(this, e),
        ce(this, 'format', void 0),
        ce(this, 'maskFormat', void 0),
        ce(this, 'cells', void 0),
        ce(this, 'maskCells', void 0),
        (this.format = t)
      var i = Yl.map(function (a) {
          return '('.concat(a, ')')
        }).join('|'),
        s = new RegExp(i, 'g')
      this.maskFormat = t.replace(s, function (a) {
        return Lh.repeat(a.length)
      })
      var n = new RegExp('('.concat(Yl.join('|'), ')')),
        r = (t.split(n) || []).filter(function (a) {
          return a
        }),
        o = 0
      ;(this.cells = r.map(function (a) {
        var l = Yl.includes(a),
          c = o,
          u = o + a.length
        return (o = u), { text: a, mask: l, start: c, end: u }
      })),
        (this.maskCells = this.cells.filter(function (a) {
          return a.mask
        }))
    }
    return (
      Qa(e, [
        {
          key: 'getSelection',
          value: function (i) {
            var s = this.maskCells[i] || {},
              n = s.start,
              r = s.end
            return [n || 0, r || 0]
          },
        },
        {
          key: 'match',
          value: function (i) {
            for (var s = 0; s < this.maskFormat.length; s += 1) {
              var n = this.maskFormat[s],
                r = i[s]
              if (!r || (n !== Lh && n !== r)) return !1
            }
            return !0
          },
        },
        {
          key: 'size',
          value: function () {
            return this.maskCells.length
          },
        },
        {
          key: 'getMaskCellIndex',
          value: function (i) {
            for (
              var s = Number.MAX_SAFE_INTEGER, n = 0, r = 0;
              r < this.maskCells.length;
              r += 1
            ) {
              var o = this.maskCells[r],
                a = o.start,
                l = o.end
              if (i >= a && i <= l) return r
              var c = Math.min(Math.abs(i - a), Math.abs(i - l))
              c < s && ((s = c), (n = r))
            }
            return n
          },
        },
      ]),
      e
    )
  })()
function ZR(e) {
  var t = {
    YYYY: [0, 9999, new Date().getFullYear()],
    MM: [1, 12],
    DD: [1, 31],
    HH: [0, 23],
    mm: [0, 59],
    ss: [0, 59],
    SSS: [0, 999],
  }
  return t[e]
}
var e0 = [
    'active',
    'showActiveCls',
    'suffixIcon',
    'format',
    'validateFormat',
    'onChange',
    'onInput',
    'helped',
    'onHelp',
    'onSubmit',
    'onKeyDown',
    'preserveInvalidOnBlur',
    'invalid',
    'clearIcon',
  ],
  Oc = d.forwardRef(function (e, t) {
    var i = e.active,
      s = e.showActiveCls,
      n = s === void 0 ? !0 : s,
      r = e.suffixIcon,
      o = e.format,
      a = e.validateFormat,
      l = e.onChange
    e.onInput
    var c = e.helped,
      u = e.onHelp,
      h = e.onSubmit,
      g = e.onKeyDown,
      f = e.preserveInvalidOnBlur,
      p = f === void 0 ? !1 : f,
      v = e.invalid,
      m = e.clearIcon,
      C = Kt(e, e0),
      w = e.value,
      S = e.onFocus,
      y = e.onBlur,
      F = e.onMouseUp,
      R = d.useContext(ss),
      b = R.prefixCls,
      x = R.input,
      D = x === void 0 ? 'input' : x,
      O = ''.concat(b, '-input'),
      M = d.useState(!1),
      L = Z(M, 2),
      V = L[0],
      A = L[1],
      I = d.useState(w),
      P = Z(I, 2),
      k = P[0],
      E = P[1],
      N = d.useState(''),
      T = Z(N, 2),
      G = T[0],
      H = T[1],
      _ = d.useState(null),
      B = Z(_, 2),
      z = B[0],
      Q = B[1],
      J = d.useState(null),
      se = Z(J, 2),
      ie = se[0],
      U = se[1],
      W = k || ''
    d.useEffect(
      function () {
        E(w)
      },
      [w],
    )
    var j = d.useRef(),
      K = d.useRef()
    d.useImperativeHandle(t, function () {
      return {
        nativeElement: j.current,
        inputElement: K.current,
        focus: function (ae) {
          K.current.focus(ae)
        },
        blur: function () {
          K.current.blur()
        },
      }
    })
    var q = d.useMemo(
        function () {
          return new JR(o || '')
        },
        [o],
      ),
      ne = d.useMemo(
        function () {
          return c ? [0, 0] : q.getSelection(z)
        },
        [q, z, c],
      ),
      oe = Z(ne, 2),
      le = oe[0],
      me = oe[1],
      ye = function (ae) {
        ae && ae !== o && ae !== w && u()
      },
      Me = Bt(function (ge) {
        a(ge) && l(ge), E(ge), ye(ge)
      }),
      He = function (ae) {
        if (!o) {
          var be = ae.target.value
          ye(be), E(be), l(be)
        }
      },
      $e = function (ae) {
        var be = ae.clipboardData.getData('text')
        a(be) && Me(be)
      },
      Fe = d.useRef(!1),
      ve = function () {
        Fe.current = !0
      },
      Be = function (ae) {
        var be = ae.target,
          De = be.selectionStart,
          fe = q.getMaskCellIndex(De)
        Q(fe), U({}), F == null || F(ae), (Fe.current = !1)
      },
      Se = function (ae) {
        A(!0), Q(0), H(''), S(ae)
      },
      we = function (ae) {
        y(ae)
      },
      ze = function (ae) {
        A(!1), we(ae)
      }
    Nu(i, function () {
      !i && !p && E(w)
    })
    var Ue = function (ae) {
        ae.key === 'Enter' && a(W) && h(), g == null || g(ae)
      },
      ke = function (ae) {
        Ue(ae)
        var be = ae.key,
          De = null,
          fe = null,
          Ce = me - le,
          at = o.slice(le, me),
          vt = function (Mt) {
            Q(function (Ut) {
              var Rt = Ut + Mt
              return (
                (Rt = Math.max(Rt, 0)), (Rt = Math.min(Rt, q.size() - 1)), Rt
              )
            })
          },
          pt = function (Mt) {
            var Ut = ZR(at),
              Rt = Z(Ut, 3),
              oi = Rt[0],
              Ct = Rt[1],
              ui = Rt[2],
              jt = W.slice(le, me),
              kt = Number(jt)
            if (isNaN(kt)) return String(ui || (Mt > 0 ? oi : Ct))
            var _e = kt + Mt,
              Ne = Ct - oi + 1
            return String(oi + ((Ne + _e - oi) % Ne))
          }
        switch (be) {
          case 'Backspace':
          case 'Delete':
            ;(De = ''), (fe = at)
            break
          case 'ArrowLeft':
            ;(De = ''), vt(-1)
            break
          case 'ArrowRight':
            ;(De = ''), vt(1)
            break
          case 'ArrowUp':
            ;(De = ''), (fe = pt(1))
            break
          case 'ArrowDown':
            ;(De = ''), (fe = pt(-1))
            break
          default:
            isNaN(Number(be)) || ((De = G + be), (fe = De))
            break
        }
        if (
          (De !== null && (H(De), De.length >= Ce && (vt(1), H(''))),
          fe !== null)
        ) {
          var $t = W.slice(0, le) + Ou(fe, Ce) + W.slice(me)
          Me($t.slice(0, o.length))
        }
        U({})
      },
      Xe = d.useRef()
    li(
      function () {
        if (!(!V || !o || Fe.current)) {
          if (!q.match(W)) {
            Me(o)
            return
          }
          return (
            K.current.setSelectionRange(le, me),
            (Xe.current = bt(function () {
              K.current.setSelectionRange(le, me)
            })),
            function () {
              bt.cancel(Xe.current)
            }
          )
        }
      },
      [q, o, V, W, z, le, me, ie, Me],
    )
    var Ye = o
      ? {
          onFocus: Se,
          onBlur: ze,
          onKeyDown: ke,
          onMouseDown: ve,
          onMouseUp: Be,
          onPaste: $e,
        }
      : {}
    return d.createElement(
      'div',
      {
        ref: j,
        className: pe(
          O,
          ce(
            ce({}, ''.concat(O, '-active'), i && n),
            ''.concat(O, '-placeholder'),
            c,
          ),
        ),
      },
      d.createElement(
        D,
        xe(
          { ref: K, 'aria-invalid': v, autoComplete: 'off' },
          C,
          { onKeyDown: Ue, onBlur: we },
          Ye,
          { value: W, onChange: He },
        ),
      ),
      d.createElement(al, { type: 'suffix', icon: r }),
      m,
    )
  }),
  t0 = [
    'id',
    'clearIcon',
    'suffixIcon',
    'separator',
    'activeIndex',
    'activeHelp',
    'allHelp',
    'focused',
    'onFocus',
    'onBlur',
    'onKeyDown',
    'locale',
    'generateConfig',
    'placeholder',
    'className',
    'style',
    'onClick',
    'onClear',
    'value',
    'onChange',
    'onSubmit',
    'onInputChange',
    'format',
    'maskFormat',
    'preserveInvalidOnBlur',
    'onInvalid',
    'disabled',
    'invalid',
    'inputReadOnly',
    'direction',
    'onOpenChange',
    'onActiveOffset',
    'placement',
    'onMouseDown',
    'required',
    'aria-required',
    'autoFocus',
  ],
  i0 = ['index']
function s0(e, t) {
  var i = e.id,
    s = e.clearIcon,
    n = e.suffixIcon,
    r = e.separator,
    o = r === void 0 ? '~' : r,
    a = e.activeIndex
  e.activeHelp, e.allHelp
  var l = e.focused
  e.onFocus, e.onBlur, e.onKeyDown, e.locale, e.generateConfig
  var c = e.placeholder,
    u = e.className,
    h = e.style,
    g = e.onClick,
    f = e.onClear,
    p = e.value
  e.onChange,
    e.onSubmit,
    e.onInputChange,
    e.format,
    e.maskFormat,
    e.preserveInvalidOnBlur,
    e.onInvalid
  var v = e.disabled,
    m = e.invalid
  e.inputReadOnly
  var C = e.direction
  e.onOpenChange
  var w = e.onActiveOffset,
    S = e.placement,
    y = e.onMouseDown
  e.required, e['aria-required']
  var F = e.autoFocus,
    R = Kt(e, t0),
    b = C === 'rtl',
    x = d.useContext(ss),
    D = x.prefixCls,
    O = d.useMemo(
      function () {
        if (typeof i == 'string') return [i]
        var W = i || {}
        return [W.start, W.end]
      },
      [i],
    ),
    M = d.useRef(),
    L = d.useRef(),
    V = d.useRef(),
    A = function (j) {
      var K
      return (K = [L, V][j]) === null || K === void 0 ? void 0 : K.current
    }
  d.useImperativeHandle(t, function () {
    return {
      nativeElement: M.current,
      focus: function (j) {
        if (Zt(j) === 'object') {
          var K,
            q = j || {},
            ne = q.index,
            oe = ne === void 0 ? 0 : ne,
            le = Kt(q, i0)
          ;(K = A(oe)) === null || K === void 0 || K.focus(le)
        } else {
          var me
          ;(me = A(j ?? 0)) === null || me === void 0 || me.focus()
        }
      },
      blur: function () {
        var j, K
        ;(j = A(0)) === null || j === void 0 || j.blur(),
          (K = A(1)) === null || K === void 0 || K.blur()
      },
    }
  })
  var I = yp(R),
    P = d.useMemo(
      function () {
        return Array.isArray(c) ? c : [c, c]
      },
      [c],
    ),
    k = wp(re(re({}, e), {}, { id: O, placeholder: P })),
    E = Z(k, 1),
    N = E[0],
    T = il(S, b),
    G = Uf(T, b),
    H = T == null ? void 0 : T.toLowerCase().endsWith('right'),
    _ = d.useState({ position: 'absolute', width: 0 }),
    B = Z(_, 2),
    z = B[0],
    Q = B[1],
    J = Bt(function () {
      var W = A(a)
      if (W) {
        var j = W.nativeElement,
          K = j.offsetWidth,
          q = j.offsetLeft,
          ne = j.offsetParent,
          oe = (ne == null ? void 0 : ne.offsetWidth) || 0,
          le = H ? oe - K - q : q
        Q(function (me) {
          return re(re({}, me), {}, ce({ width: K }, G, le))
        }),
          w(le)
      }
    })
  d.useEffect(
    function () {
      J()
    },
    [a],
  )
  var se = s && ((p[0] && !v[0]) || (p[1] && !v[1])),
    ie = F && !v[0],
    U = F && !ie && !v[1]
  return d.createElement(
    Do,
    { onResize: J },
    d.createElement(
      'div',
      xe({}, I, {
        className: pe(
          D,
          ''.concat(D, '-range'),
          ce(
            ce(
              ce(
                ce({}, ''.concat(D, '-focused'), l),
                ''.concat(D, '-disabled'),
                v.every(function (W) {
                  return W
                }),
              ),
              ''.concat(D, '-invalid'),
              m.some(function (W) {
                return W
              }),
            ),
            ''.concat(D, '-rtl'),
            b,
          ),
          u,
        ),
        style: h,
        ref: M,
        onClick: g,
        onMouseDown: function (j) {
          var K = j.target
          K !== L.current.inputElement &&
            K !== V.current.inputElement &&
            j.preventDefault(),
            y == null || y(j)
        },
      }),
      d.createElement(
        Oc,
        xe({ ref: L }, N(0), { autoFocus: ie, 'date-range': 'start' }),
      ),
      d.createElement(
        'div',
        { className: ''.concat(D, '-range-separator') },
        o,
      ),
      d.createElement(
        Oc,
        xe({ ref: V }, N(1), { autoFocus: U, 'date-range': 'end' }),
      ),
      d.createElement('div', {
        className: ''.concat(D, '-active-bar'),
        style: z,
      }),
      d.createElement(al, { type: 'suffix', icon: n }),
      se && d.createElement(Ac, { icon: s, onClear: f }),
    ),
  )
}
var n0 = d.forwardRef(s0)
function kh(e, t) {
  var i = e ?? t
  return Array.isArray(i) ? i : [i, i]
}
function qo(e) {
  return e === 1 ? 'end' : 'start'
}
function r0(e, t) {
  var i = rp(e, function () {
      var et = e.disabled,
        qe = e.allowEmpty,
        nt = kh(et, !1),
        Yt = kh(qe, !1)
      return { disabled: nt, allowEmpty: Yt }
    }),
    s = Z(i, 6),
    n = s[0],
    r = s[1],
    o = s[2],
    a = s[3],
    l = s[4],
    c = s[5],
    u = n.prefixCls,
    h = n.styles,
    g = n.classNames,
    f = n.placement,
    p = n.defaultValue,
    v = n.value,
    m = n.needConfirm,
    C = n.onKeyDown,
    w = n.disabled,
    S = n.allowEmpty,
    y = n.disabledDate,
    F = n.minDate,
    R = n.maxDate,
    b = n.defaultOpen,
    x = n.open,
    D = n.onOpenChange,
    O = n.locale,
    M = n.generateConfig,
    L = n.picker,
    V = n.showNow,
    A = n.showToday,
    I = n.showTime,
    P = n.mode,
    k = n.onPanelChange,
    E = n.onCalendarChange,
    N = n.onOk,
    T = n.defaultPickerValue,
    G = n.pickerValue,
    H = n.onPickerValueChange,
    _ = n.inputReadOnly,
    B = n.suffixIcon,
    z = n.onFocus,
    Q = n.onBlur,
    J = n.presets,
    se = n.ranges,
    ie = n.components,
    U = n.cellRender,
    W = n.dateRender,
    j = n.monthCellRender,
    K = n.onClick,
    q = ap(t),
    ne = op(x, b, w, D),
    oe = Z(ne, 2),
    le = oe[0],
    me = oe[1],
    ye = function (qe, nt) {
      ;(w.some(function (Yt) {
        return !Yt
      }) ||
        !qe) &&
        me(qe, nt)
    },
    Me = fp(M, O, a, !0, !1, p, v, E, N),
    He = Z(Me, 5),
    $e = He[0],
    Fe = He[1],
    ve = He[2],
    Be = He[3],
    Se = He[4],
    we = ve(),
    ze = cp(w, S, le),
    Ue = Z(ze, 7),
    ke = Ue[0],
    Xe = Ue[1],
    Ye = Ue[2],
    ge = Ue[3],
    ae = Ue[4],
    be = Ue[5],
    De = Ue[6],
    fe = function (qe, nt) {
      Xe(!0), z == null || z(qe, { range: qo(nt ?? ge) })
    },
    Ce = function (qe, nt) {
      Xe(!1), Q == null || Q(qe, { range: qo(nt ?? ge) })
    },
    at = d.useMemo(
      function () {
        if (!I) return null
        var et = I.disabledTime,
          qe = et
            ? function (nt) {
                var Yt = qo(ge),
                  Ki = Kf(we, De, ge)
                return et(nt, Yt, { from: Ki })
              }
            : void 0
        return re(re({}, I), {}, { disabledTime: qe })
      },
      [I, ge, we, De],
    ),
    vt = ai([L, L], { value: P }),
    pt = Z(vt, 2),
    $t = pt[0],
    zt = pt[1],
    Mt = $t[ge] || L,
    Ut = Mt === 'date' && at ? 'datetime' : Mt,
    Rt = Ut === L && Ut !== 'time',
    oi = mp(L, Mt, V, A, !0),
    Ct = pp(n, $e, Fe, ve, Be, w, a, ke, le, c),
    ui = Z(Ct, 2),
    jt = ui[0],
    kt = ui[1],
    _e = IR(we, w, De, M, O, y),
    Ne = Qf(we, c, S),
    Ie = Z(Ne, 2),
    We = Ie[0],
    it = Ie[1],
    mt = up(
      M,
      O,
      we,
      $t,
      le,
      ge,
      r,
      Rt,
      T,
      G,
      at == null ? void 0 : at.defaultOpenValue,
      H,
      F,
      R,
    ),
    ei = Z(mt, 2),
    ti = ei[0],
    Ei = ei[1],
    Ft = Bt(function (et, qe, nt) {
      var Yt = so($t, ge, qe)
      if (((Yt[0] !== $t[0] || Yt[1] !== $t[1]) && zt(Yt), k && nt !== !1)) {
        var Ki = St(we)
        et && (Ki[ge] = et), k(Ki, Yt)
      }
    }),
    Tt = function (qe, nt) {
      return so(we, nt, qe)
    },
    di = function (qe, nt) {
      var Yt = we
      qe && (Yt = Tt(qe, ge))
      var Ki = be(Yt)
      Be(Yt),
        jt(ge, Ki === null),
        Ki === null
          ? ye(!1, { force: !0 })
          : nt || q.current.focus({ index: Ki })
    },
    Ai = function (qe) {
      var nt,
        Yt = qe.target.getRootNode()
      if (
        !q.current.nativeElement.contains(
          (nt = Yt.activeElement) !== null && nt !== void 0
            ? nt
            : document.activeElement,
        )
      ) {
        var Ki = w.findIndex(function (lS) {
          return !lS
        })
        Ki >= 0 && q.current.focus({ index: Ki })
      }
      ye(!0), K == null || K(qe)
    },
    ys = function () {
      kt(null), ye(!1, { force: !0 })
    },
    Te = d.useState(null),
    Ee = Z(Te, 2),
    Je = Ee[0],
    ut = Ee[1],
    Ht = d.useState(null),
    vi = Z(Ht, 2),
    hi = vi[0],
    bs = vi[1],
    qs = d.useMemo(
      function () {
        return hi || we
      },
      [we, hi],
    )
  d.useEffect(
    function () {
      le || bs(null)
    },
    [le],
  )
  var Rs = d.useState(0),
    os = Z(Rs, 2),
    pn = os[0],
    Qn = os[1],
    Gr = lp(J, se),
    Xn = function (qe) {
      bs(qe), ut('preset')
    },
    Br = function (qe) {
      var nt = kt(qe)
      nt && ye(!1, { force: !0 })
    },
    Vr = function (qe) {
      di(qe)
    },
    _r = function (qe) {
      bs(qe ? Tt(qe, ge) : null), ut('cell')
    },
    Wr = function (qe) {
      ye(!0), fe(qe)
    },
    Jn = function () {
      Ye('panel')
    },
    mn = function (qe) {
      var nt = so(we, ge, qe)
      Be(nt), !m && !o && r === Ut && di(qe)
    },
    st = function () {
      ye(!1)
    },
    Ke = Lu(U, W, j, qo(ge)),
    ii = we[ge] || null,
    si = Bt(function (et) {
      return c(et, { activeIndex: ge })
    }),
    At = d.useMemo(
      function () {
        var et = Bs(n, !1),
          qe = zs(
            n,
            [].concat(St(Object.keys(et)), [
              'onChange',
              'onCalendarChange',
              'style',
              'className',
              'onPanelChange',
              'disabledTime',
            ]),
          )
        return qe
      },
      [n],
    ),
    Ae = d.createElement(
      Sp,
      xe({}, At, {
        showNow: oi,
        showTime: at,
        range: !0,
        multiplePanel: Rt,
        activeOffset: pn,
        placement: f,
        disabledDate: _e,
        onFocus: Wr,
        onBlur: Ce,
        onPanelMouseDown: Jn,
        picker: L,
        mode: Mt,
        internalMode: Ut,
        onPanelChange: Ft,
        format: l,
        value: ii,
        isInvalid: si,
        onChange: null,
        onSelect: mn,
        pickerValue: ti,
        defaultOpenValue: $n(I == null ? void 0 : I.defaultOpenValue)[ge],
        onPickerValueChange: Ei,
        hoverValue: qs,
        onHover: _r,
        needConfirm: m,
        onSubmit: di,
        onOk: Se,
        presets: Gr,
        onPresetHover: Xn,
        onPresetSubmit: Br,
        onNow: Vr,
        cellRender: Ke,
      }),
    ),
    Ge = function (qe, nt) {
      var Yt = Tt(qe, nt)
      Be(Yt)
    },
    Et = function () {
      Ye('input')
    },
    ni = function (qe, nt) {
      Ye('input'),
        ye(!0, { inherit: !0 }),
        ge !== nt && le && !m && o && di(null, !0),
        ae(nt),
        fe(qe, nt)
    },
    Yi = function (qe, nt) {
      if ((ye(!1), !m && Ye() === 'input')) {
        var Yt = be(we)
        jt(ge, Yt === null)
      }
      Ce(qe, nt)
    },
    Fs = function (qe, nt) {
      qe.key === 'Tab' && di(null, !0), C == null || C(qe, nt)
    },
    Zn = d.useMemo(
      function () {
        return {
          prefixCls: u,
          locale: O,
          generateConfig: M,
          button: ie.button,
          input: ie.input,
        }
      },
      [u, O, M, ie.button, ie.input],
    )
  return (
    li(
      function () {
        le && ge !== void 0 && Ft(null, L, !1)
      },
      [le, ge, L],
    ),
    li(
      function () {
        var et = Ye()
        !le && et === 'input' && (ye(!1), di(null, !0)),
          !le && o && !m && et === 'panel' && (ye(!0), di())
      },
      [le],
    ),
    d.createElement(
      ss.Provider,
      { value: Zn },
      d.createElement(
        jf,
        xe({}, qf(n), {
          popupElement: Ae,
          popupStyle: h.popup,
          popupClassName: g.popup,
          visible: le,
          onClose: st,
          range: !0,
        }),
        d.createElement(
          n0,
          xe({}, n, {
            ref: q,
            suffixIcon: B,
            activeIndex: ke || le ? ge : null,
            activeHelp: !!hi,
            allHelp: !!hi && Je === 'preset',
            focused: ke,
            onFocus: ni,
            onBlur: Yi,
            onKeyDown: Fs,
            onSubmit: di,
            value: qs,
            maskFormat: l,
            onChange: Ge,
            onInputChange: Et,
            format: a,
            inputReadOnly: _,
            disabled: w,
            open: le,
            onOpenChange: ye,
            onClick: Ai,
            onClear: ys,
            invalid: We,
            onInvalid: it,
            onActiveOffset: Qn,
          }),
        ),
      ),
    )
  )
}
var o0 = d.forwardRef(r0)
function a0(e) {
  var t = e.prefixCls,
    i = e.value,
    s = e.onRemove,
    n = e.removeIcon,
    r = n === void 0 ? '' : n,
    o = e.formatDate,
    a = e.disabled,
    l = e.maxTagCount,
    c = e.placeholder,
    u = ''.concat(t, '-selector'),
    h = ''.concat(t, '-selection'),
    g = ''.concat(h, '-overflow')
  function f(m, C) {
    return d.createElement(
      'span',
      {
        className: pe(''.concat(h, '-item')),
        title: typeof m == 'string' ? m : null,
      },
      d.createElement('span', { className: ''.concat(h, '-item-content') }, m),
      !a &&
        C &&
        d.createElement(
          'span',
          {
            onMouseDown: function (S) {
              S.preventDefault()
            },
            onClick: C,
            className: ''.concat(h, '-item-remove'),
          },
          r,
        ),
    )
  }
  function p(m) {
    var C = o(m),
      w = function (y) {
        y && y.stopPropagation(), s(m)
      }
    return f(C, w)
  }
  function v(m) {
    var C = '+ '.concat(m.length, ' ...')
    return f(C)
  }
  return d.createElement(
    'div',
    { className: u },
    d.createElement(Zg, {
      prefixCls: g,
      data: i,
      renderItem: p,
      renderRest: v,
      itemKey: function (C) {
        return o(C)
      },
      maxCount: l,
    }),
    !i.length &&
      d.createElement(
        'span',
        { className: ''.concat(t, '-selection-placeholder') },
        c,
      ),
  )
}
var l0 = [
  'id',
  'open',
  'clearIcon',
  'suffixIcon',
  'activeHelp',
  'allHelp',
  'focused',
  'onFocus',
  'onBlur',
  'onKeyDown',
  'locale',
  'generateConfig',
  'placeholder',
  'className',
  'style',
  'onClick',
  'onClear',
  'internalPicker',
  'value',
  'onChange',
  'onSubmit',
  'onInputChange',
  'multiple',
  'maxTagCount',
  'format',
  'maskFormat',
  'preserveInvalidOnBlur',
  'onInvalid',
  'disabled',
  'invalid',
  'inputReadOnly',
  'direction',
  'onOpenChange',
  'onMouseDown',
  'required',
  'aria-required',
  'autoFocus',
  'removeIcon',
]
function c0(e, t) {
  e.id
  var i = e.open,
    s = e.clearIcon,
    n = e.suffixIcon
  e.activeHelp, e.allHelp
  var r = e.focused
  e.onFocus, e.onBlur, e.onKeyDown
  var o = e.locale,
    a = e.generateConfig,
    l = e.placeholder,
    c = e.className,
    u = e.style,
    h = e.onClick,
    g = e.onClear,
    f = e.internalPicker,
    p = e.value,
    v = e.onChange,
    m = e.onSubmit
  e.onInputChange
  var C = e.multiple,
    w = e.maxTagCount
  e.format, e.maskFormat, e.preserveInvalidOnBlur, e.onInvalid
  var S = e.disabled,
    y = e.invalid
  e.inputReadOnly
  var F = e.direction
  e.onOpenChange
  var R = e.onMouseDown
  e.required, e['aria-required']
  var b = e.autoFocus,
    x = e.removeIcon,
    D = Kt(e, l0),
    O = F === 'rtl',
    M = d.useContext(ss),
    L = M.prefixCls,
    V = d.useRef(),
    A = d.useRef()
  d.useImperativeHandle(t, function () {
    return {
      nativeElement: V.current,
      focus: function (z) {
        var Q
        ;(Q = A.current) === null || Q === void 0 || Q.focus(z)
      },
      blur: function () {
        var z
        ;(z = A.current) === null || z === void 0 || z.blur()
      },
    }
  })
  var I = yp(D),
    P = function (z) {
      v([z])
    },
    k = function (z) {
      var Q = p.filter(function (J) {
        return J && !fi(a, o, J, z, f)
      })
      v(Q), i || m()
    },
    E = wp(re(re({}, e), {}, { onChange: P }), function (B) {
      var z = B.valueTexts
      return { value: z[0] || '', active: r }
    }),
    N = Z(E, 2),
    T = N[0],
    G = N[1],
    H = !!(s && p.length && !S),
    _ = C
      ? d.createElement(
          d.Fragment,
          null,
          d.createElement(a0, {
            prefixCls: L,
            value: p,
            onRemove: k,
            formatDate: G,
            maxTagCount: w,
            disabled: S,
            removeIcon: x,
            placeholder: l,
          }),
          d.createElement('input', {
            className: ''.concat(L, '-multiple-input'),
            value: p.map(G).join(','),
            ref: A,
            readOnly: !0,
            autoFocus: b,
          }),
          d.createElement(al, { type: 'suffix', icon: n }),
          H && d.createElement(Ac, { icon: s, onClear: g }),
        )
      : d.createElement(
          Oc,
          xe({ ref: A }, T(), {
            autoFocus: b,
            suffixIcon: n,
            clearIcon: H && d.createElement(Ac, { icon: s, onClear: g }),
            showActiveCls: !1,
          }),
        )
  return d.createElement(
    'div',
    xe({}, I, {
      className: pe(
        L,
        ce(
          ce(
            ce(
              ce(
                ce({}, ''.concat(L, '-multiple'), C),
                ''.concat(L, '-focused'),
                r,
              ),
              ''.concat(L, '-disabled'),
              S,
            ),
            ''.concat(L, '-invalid'),
            y,
          ),
          ''.concat(L, '-rtl'),
          O,
        ),
        c,
      ),
      style: u,
      ref: V,
      onClick: h,
      onMouseDown: function (z) {
        var Q,
          J = z.target
        J !==
          ((Q = A.current) === null || Q === void 0
            ? void 0
            : Q.inputElement) && z.preventDefault(),
          R == null || R(z)
      },
    }),
    _,
  )
}
var u0 = d.forwardRef(c0)
function d0(e, t) {
  var i = rp(e),
    s = Z(i, 6),
    n = s[0],
    r = s[1],
    o = s[2],
    a = s[3],
    l = s[4],
    c = s[5],
    u = n,
    h = u.prefixCls,
    g = u.styles,
    f = u.classNames,
    p = u.order,
    v = u.defaultValue,
    m = u.value,
    C = u.needConfirm,
    w = u.onChange,
    S = u.onKeyDown,
    y = u.disabled,
    F = u.disabledDate,
    R = u.minDate,
    b = u.maxDate,
    x = u.defaultOpen,
    D = u.open,
    O = u.onOpenChange,
    M = u.locale,
    L = u.generateConfig,
    V = u.picker,
    A = u.showNow,
    I = u.showToday,
    P = u.showTime,
    k = u.mode,
    E = u.onPanelChange,
    N = u.onCalendarChange,
    T = u.onOk,
    G = u.multiple,
    H = u.defaultPickerValue,
    _ = u.pickerValue,
    B = u.onPickerValueChange,
    z = u.inputReadOnly,
    Q = u.suffixIcon,
    J = u.removeIcon,
    se = u.onFocus,
    ie = u.onBlur,
    U = u.presets,
    W = u.components,
    j = u.cellRender,
    K = u.dateRender,
    q = u.monthCellRender,
    ne = u.onClick,
    oe = ap(t)
  function le(Ae) {
    return Ae === null ? null : G ? Ae : Ae[0]
  }
  var me = vp(L, M, r),
    ye = op(D, x, [y], O),
    Me = Z(ye, 2),
    He = Me[0],
    $e = Me[1],
    Fe = function (Ge, Et, ni) {
      if (N) {
        var Yi = re({}, ni)
        delete Yi.range, N(le(Ge), le(Et), Yi)
      }
    },
    ve = function (Ge) {
      T == null || T(le(Ge))
    },
    Be = fp(L, M, a, !1, p, v, m, Fe, ve),
    Se = Z(Be, 5),
    we = Se[0],
    ze = Se[1],
    Ue = Se[2],
    ke = Se[3],
    Xe = Se[4],
    Ye = Ue(),
    ge = cp([y]),
    ae = Z(ge, 4),
    be = ae[0],
    De = ae[1],
    fe = ae[2],
    Ce = ae[3],
    at = function (Ge) {
      De(!0), se == null || se(Ge, {})
    },
    vt = function (Ge) {
      De(!1), ie == null || ie(Ge, {})
    },
    pt = ai(V, { value: k }),
    $t = Z(pt, 2),
    zt = $t[0],
    Mt = $t[1],
    Ut = zt === 'date' && P ? 'datetime' : zt,
    Rt = mp(V, zt, A, I),
    oi =
      w &&
      function (Ae, Ge) {
        w(le(Ae), le(Ge))
      },
    Ct = pp(
      re(re({}, n), {}, { onChange: oi }),
      we,
      ze,
      Ue,
      ke,
      [],
      a,
      be,
      He,
      c,
    ),
    ui = Z(Ct, 2),
    jt = ui[1],
    kt = Qf(Ye, c),
    _e = Z(kt, 2),
    Ne = _e[0],
    Ie = _e[1],
    We = d.useMemo(
      function () {
        return Ne.some(function (Ae) {
          return Ae
        })
      },
      [Ne],
    ),
    it = function (Ge, Et) {
      if (B) {
        var ni = re(re({}, Et), {}, { mode: Et.mode[0] })
        delete ni.range, B(Ge[0], ni)
      }
    },
    mt = up(
      L,
      M,
      Ye,
      [zt],
      He,
      Ce,
      r,
      !1,
      H,
      _,
      $n(P == null ? void 0 : P.defaultOpenValue),
      it,
      R,
      b,
    ),
    ei = Z(mt, 2),
    ti = ei[0],
    Ei = ei[1],
    Ft = Bt(function (Ae, Ge, Et) {
      if ((Mt(Ge), E && Et !== !1)) {
        var ni = Ae || Ye[Ye.length - 1]
        E(ni, Ge)
      }
    }),
    Tt = function () {
      jt(Ue()), $e(!1, { force: !0 })
    },
    di = function (Ge) {
      !y &&
        !oe.current.nativeElement.contains(document.activeElement) &&
        oe.current.focus(),
        $e(!0),
        ne == null || ne(Ge)
    },
    Ai = function () {
      jt(null), $e(!1, { force: !0 })
    },
    ys = d.useState(null),
    Te = Z(ys, 2),
    Ee = Te[0],
    Je = Te[1],
    ut = d.useState(null),
    Ht = Z(ut, 2),
    vi = Ht[0],
    hi = Ht[1],
    bs = d.useMemo(
      function () {
        var Ae = [vi].concat(St(Ye)).filter(function (Ge) {
          return Ge
        })
        return G ? Ae : Ae.slice(0, 1)
      },
      [Ye, vi, G],
    ),
    qs = d.useMemo(
      function () {
        return !G && vi
          ? [vi]
          : Ye.filter(function (Ae) {
              return Ae
            })
      },
      [Ye, vi, G],
    )
  d.useEffect(
    function () {
      He || hi(null)
    },
    [He],
  )
  var Rs = lp(U),
    os = function (Ge) {
      hi(Ge), Je('preset')
    },
    pn = function (Ge) {
      var Et = G ? me(Ue(), Ge) : [Ge],
        ni = jt(Et)
      ni && !G && $e(!1, { force: !0 })
    },
    Qn = function (Ge) {
      pn(Ge)
    },
    Gr = function (Ge) {
      hi(Ge), Je('cell')
    },
    Xn = function (Ge) {
      $e(!0), at(Ge)
    },
    Br = function (Ge) {
      fe('panel')
      var Et = G ? me(Ue(), Ge) : [Ge]
      ke(Et), !C && !o && r === Ut && Tt()
    },
    Vr = function () {
      $e(!1)
    },
    _r = Lu(j, K, q),
    Wr = d.useMemo(
      function () {
        var Ae = Bs(n, !1),
          Ge = zs(
            n,
            [].concat(St(Object.keys(Ae)), [
              'onChange',
              'onCalendarChange',
              'style',
              'className',
              'onPanelChange',
            ]),
          )
        return re(re({}, Ge), {}, { multiple: n.multiple })
      },
      [n],
    ),
    Jn = d.createElement(
      Sp,
      xe({}, Wr, {
        showNow: Rt,
        showTime: P,
        disabledDate: F,
        onFocus: Xn,
        onBlur: vt,
        picker: V,
        mode: zt,
        internalMode: Ut,
        onPanelChange: Ft,
        format: l,
        value: Ye,
        isInvalid: c,
        onChange: null,
        onSelect: Br,
        pickerValue: ti,
        defaultOpenValue: P == null ? void 0 : P.defaultOpenValue,
        onPickerValueChange: Ei,
        hoverValue: bs,
        onHover: Gr,
        needConfirm: C,
        onSubmit: Tt,
        onOk: Xe,
        presets: Rs,
        onPresetHover: os,
        onPresetSubmit: pn,
        onNow: Qn,
        cellRender: _r,
      }),
    ),
    mn = function (Ge) {
      ke(Ge)
    },
    st = function () {
      fe('input')
    },
    Ke = function (Ge) {
      fe('input'), $e(!0, { inherit: !0 }), at(Ge)
    },
    ii = function (Ge) {
      $e(!1), vt(Ge)
    },
    si = function (Ge, Et) {
      Ge.key === 'Tab' && Tt(), S == null || S(Ge, Et)
    },
    At = d.useMemo(
      function () {
        return {
          prefixCls: h,
          locale: M,
          generateConfig: L,
          button: W.button,
          input: W.input,
        }
      },
      [h, M, L, W.button, W.input],
    )
  return (
    li(
      function () {
        He && Ce !== void 0 && Ft(null, V, !1)
      },
      [He, Ce, V],
    ),
    li(
      function () {
        var Ae = fe()
        !He && Ae === 'input' && ($e(!1), Tt()),
          !He && o && !C && Ae === 'panel' && ($e(!0), Tt())
      },
      [He],
    ),
    d.createElement(
      ss.Provider,
      { value: At },
      d.createElement(
        jf,
        xe({}, qf(n), {
          popupElement: Jn,
          popupStyle: g.popup,
          popupClassName: f.popup,
          visible: He,
          onClose: Vr,
        }),
        d.createElement(
          u0,
          xe({}, n, {
            ref: oe,
            suffixIcon: Q,
            removeIcon: J,
            activeHelp: !!vi,
            allHelp: !!vi && Ee === 'preset',
            focused: be,
            onFocus: Ke,
            onBlur: ii,
            onKeyDown: si,
            onSubmit: Tt,
            value: qs,
            maskFormat: l,
            onChange: mn,
            onInputChange: st,
            internalPicker: r,
            format: a,
            inputReadOnly: z,
            disabled: y,
            open: He,
            onOpenChange: $e,
            onClick: di,
            onClear: Ai,
            invalid: We,
            onInvalid: function (Ge) {
              Ie(Ge, 0)
            },
          }),
        ),
      ),
    )
  )
}
var h0 = d.forwardRef(d0)
function Bu(e) {
  return Jt(e, { inputAffixPadding: e.paddingXXS })
}
const Vu = (e) => {
    const {
      controlHeight: t,
      fontSize: i,
      lineHeight: s,
      lineWidth: n,
      controlHeightSM: r,
      controlHeightLG: o,
      fontSizeLG: a,
      lineHeightLG: l,
      paddingSM: c,
      controlPaddingHorizontalSM: u,
      controlPaddingHorizontal: h,
      colorFillAlter: g,
      colorPrimaryHover: f,
      colorPrimary: p,
      controlOutlineWidth: v,
      controlOutline: m,
      colorErrorOutline: C,
      colorWarningOutline: w,
      colorBgContainer: S,
    } = e
    return {
      paddingBlock: Math.max(Math.round(((t - i * s) / 2) * 10) / 10 - n, 0),
      paddingBlockSM: Math.max(Math.round(((r - i * s) / 2) * 10) / 10 - n, 0),
      paddingBlockLG: Math.ceil(((o - a * l) / 2) * 10) / 10 - n,
      paddingInline: c - n,
      paddingInlineSM: u - n,
      paddingInlineLG: h - n,
      addonBg: g,
      activeBorderColor: p,
      hoverBorderColor: f,
      activeShadow: `0 0 0 ${v}px ${m}`,
      errorActiveShadow: `0 0 0 ${v}px ${C}`,
      warningActiveShadow: `0 0 0 ${v}px ${w}`,
      hoverBg: S,
      activeBg: S,
      inputFontSize: i,
      inputFontSizeLG: a,
      inputFontSizeSM: i,
    }
  },
  g0 = (e) => ({ borderColor: e.hoverBorderColor, backgroundColor: e.hoverBg }),
  _u = (e) => ({
    color: e.colorTextDisabled,
    backgroundColor: e.colorBgContainerDisabled,
    borderColor: e.colorBorder,
    boxShadow: 'none',
    cursor: 'not-allowed',
    opacity: 1,
    'input[disabled], textarea[disabled]': { cursor: 'not-allowed' },
    '&:hover:not([disabled])': Object.assign(
      {},
      g0(
        Jt(e, {
          hoverBorderColor: e.colorBorder,
          hoverBg: e.colorBgContainerDisabled,
        }),
      ),
    ),
  }),
  bp = (e, t) => ({
    background: e.colorBgContainer,
    borderWidth: e.lineWidth,
    borderStyle: e.lineType,
    borderColor: t.borderColor,
    '&:hover': { borderColor: t.hoverBorderColor, backgroundColor: e.hoverBg },
    '&:focus, &:focus-within': {
      borderColor: t.activeBorderColor,
      boxShadow: t.activeShadow,
      outline: 0,
      backgroundColor: e.activeBg,
    },
  }),
  Hh = (e, t) => ({
    [`&${e.componentCls}-status-${t.status}:not(${e.componentCls}-disabled)`]:
      Object.assign(Object.assign({}, bp(e, t)), {
        [`${e.componentCls}-prefix, ${e.componentCls}-suffix`]: {
          color: t.affixColor,
        },
      }),
    [`&${e.componentCls}-status-${t.status}${e.componentCls}-disabled`]: {
      borderColor: t.borderColor,
    },
  }),
  Rp = (e, t) => ({
    '&-outlined': Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {},
              bp(e, {
                borderColor: e.colorBorder,
                hoverBorderColor: e.hoverBorderColor,
                activeBorderColor: e.activeBorderColor,
                activeShadow: e.activeShadow,
              }),
            ),
            {
              [`&${e.componentCls}-disabled, &[disabled]`]: Object.assign(
                {},
                _u(e),
              ),
            },
          ),
          Hh(e, {
            status: 'error',
            borderColor: e.colorError,
            hoverBorderColor: e.colorErrorBorderHover,
            activeBorderColor: e.colorError,
            activeShadow: e.errorActiveShadow,
            affixColor: e.colorError,
          }),
        ),
        Hh(e, {
          status: 'warning',
          borderColor: e.colorWarning,
          hoverBorderColor: e.colorWarningBorderHover,
          activeBorderColor: e.colorWarning,
          activeShadow: e.warningActiveShadow,
          affixColor: e.colorWarning,
        }),
      ),
      t,
    ),
  }),
  Nh = (e, t) => ({
    [`&${e.componentCls}-group-wrapper-status-${t.status}`]: {
      [`${e.componentCls}-group-addon`]: {
        borderColor: t.addonBorderColor,
        color: t.addonColor,
      },
    },
  }),
  f0 = (e) => ({
    '&-outlined': Object.assign(
      Object.assign(
        Object.assign(
          {
            [`${e.componentCls}-group`]: {
              '&-addon': {
                background: e.addonBg,
                border: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
              },
              '&-addon:first-child': { borderInlineEnd: 0 },
              '&-addon:last-child': { borderInlineStart: 0 },
            },
          },
          Nh(e, {
            status: 'error',
            addonBorderColor: e.colorError,
            addonColor: e.colorErrorText,
          }),
        ),
        Nh(e, {
          status: 'warning',
          addonBorderColor: e.colorWarning,
          addonColor: e.colorWarningText,
        }),
      ),
      {
        [`&${e.componentCls}-group-wrapper-disabled`]: {
          [`${e.componentCls}-group-addon`]: Object.assign({}, _u(e)),
        },
      },
    ),
  }),
  Fp = (e, t) => {
    const { componentCls: i } = e
    return {
      '&-borderless': Object.assign(
        {
          background: 'transparent',
          border: 'none',
          '&:focus, &:focus-within': { outline: 'none' },
          [`&${i}-disabled, &[disabled]`]: { color: e.colorTextDisabled },
          [`&${i}-status-error`]: {
            '&, & input, & textarea': { color: e.colorError },
          },
          [`&${i}-status-warning`]: {
            '&, & input, & textarea': { color: e.colorWarning },
          },
        },
        t,
      ),
    }
  },
  Ep = (e, t) => ({
    background: t.bg,
    borderWidth: e.lineWidth,
    borderStyle: e.lineType,
    borderColor: 'transparent',
    'input&, & input, textarea&, & textarea': {
      color: t == null ? void 0 : t.inputColor,
    },
    '&:hover': { background: t.hoverBg },
    '&:focus, &:focus-within': {
      outline: 0,
      borderColor: t.activeBorderColor,
      backgroundColor: e.activeBg,
    },
  }),
  Gh = (e, t) => ({
    [`&${e.componentCls}-status-${t.status}:not(${e.componentCls}-disabled)`]:
      Object.assign(Object.assign({}, Ep(e, t)), {
        [`${e.componentCls}-prefix, ${e.componentCls}-suffix`]: {
          color: t.affixColor,
        },
      }),
  }),
  Pp = (e, t) => ({
    '&-filled': Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {},
              Ep(e, {
                bg: e.colorFillTertiary,
                hoverBg: e.colorFillSecondary,
                activeBorderColor: e.activeBorderColor,
              }),
            ),
            {
              [`&${e.componentCls}-disabled, &[disabled]`]: Object.assign(
                {},
                _u(e),
              ),
            },
          ),
          Gh(e, {
            status: 'error',
            bg: e.colorErrorBg,
            hoverBg: e.colorErrorBgHover,
            activeBorderColor: e.colorError,
            inputColor: e.colorErrorText,
            affixColor: e.colorError,
          }),
        ),
        Gh(e, {
          status: 'warning',
          bg: e.colorWarningBg,
          hoverBg: e.colorWarningBgHover,
          activeBorderColor: e.colorWarning,
          inputColor: e.colorWarningText,
          affixColor: e.colorWarning,
        }),
      ),
      t,
    ),
  }),
  Bh = (e, t) => ({
    [`&${e.componentCls}-group-wrapper-status-${t.status}`]: {
      [`${e.componentCls}-group-addon`]: {
        background: t.addonBg,
        color: t.addonColor,
      },
    },
  }),
  p0 = (e) => ({
    '&-filled': Object.assign(
      Object.assign(
        Object.assign(
          {
            [`${e.componentCls}-group`]: {
              '&-addon': { background: e.colorFillTertiary },
              [`${e.componentCls}-filled:not(:focus):not(:focus-within)`]: {
                '&:not(:first-child)': {
                  borderInlineStart: `${de(e.lineWidth)} ${e.lineType} ${e.colorSplit}`,
                },
                '&:not(:last-child)': {
                  borderInlineEnd: `${de(e.lineWidth)} ${e.lineType} ${e.colorSplit}`,
                },
              },
            },
          },
          Bh(e, {
            status: 'error',
            addonBg: e.colorErrorBg,
            addonColor: e.colorErrorText,
          }),
        ),
        Bh(e, {
          status: 'warning',
          addonBg: e.colorWarningBg,
          addonColor: e.colorWarningText,
        }),
      ),
      {
        [`&${e.componentCls}-group-wrapper-disabled`]: {
          [`${e.componentCls}-group`]: {
            '&-addon': {
              background: e.colorFillTertiary,
              color: e.colorTextDisabled,
            },
            '&-addon:first-child': {
              borderInlineStart: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
              borderTop: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
              borderBottom: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
            },
            '&-addon:last-child': {
              borderInlineEnd: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
              borderTop: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
              borderBottom: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
            },
          },
        },
      },
    ),
  }),
  xp = (e) => ({
    '&::-moz-placeholder': { opacity: 1 },
    '&::placeholder': { color: e, userSelect: 'none' },
    '&:placeholder-shown': { textOverflow: 'ellipsis' },
  }),
  Dp = (e) => {
    const {
      paddingBlockLG: t,
      lineHeightLG: i,
      borderRadiusLG: s,
      paddingInlineLG: n,
    } = e
    return {
      padding: `${de(t)} ${de(n)}`,
      fontSize: e.inputFontSizeLG,
      lineHeight: i,
      borderRadius: s,
    }
  },
  Mp = (e) => ({
    padding: `${de(e.paddingBlockSM)} ${de(e.paddingInlineSM)}`,
    fontSize: e.inputFontSizeSM,
    borderRadius: e.borderRadiusSM,
  }),
  Ip = (e) =>
    Object.assign(
      Object.assign(
        {
          position: 'relative',
          display: 'inline-block',
          width: '100%',
          minWidth: 0,
          padding: `${de(e.paddingBlock)} ${de(e.paddingInline)}`,
          color: e.colorText,
          fontSize: e.inputFontSize,
          lineHeight: e.lineHeight,
          borderRadius: e.borderRadius,
          transition: `all ${e.motionDurationMid}`,
        },
        xp(e.colorTextPlaceholder),
      ),
      {
        'textarea&': {
          maxWidth: '100%',
          height: 'auto',
          minHeight: e.controlHeight,
          lineHeight: e.lineHeight,
          verticalAlign: 'bottom',
          transition: `all ${e.motionDurationSlow}, height 0s`,
          resize: 'vertical',
        },
        '&-lg': Object.assign({}, Dp(e)),
        '&-sm': Object.assign({}, Mp(e)),
        '&-rtl, &-textarea-rtl': { direction: 'rtl' },
      },
    ),
  m0 = (e) => {
    const { componentCls: t, antCls: i } = e
    return {
      position: 'relative',
      display: 'table',
      width: '100%',
      borderCollapse: 'separate',
      borderSpacing: 0,
      "&[class*='col-']": {
        paddingInlineEnd: e.paddingXS,
        '&:last-child': { paddingInlineEnd: 0 },
      },
      [`&-lg ${t}, &-lg > ${t}-group-addon`]: Object.assign({}, Dp(e)),
      [`&-sm ${t}, &-sm > ${t}-group-addon`]: Object.assign({}, Mp(e)),
      [`&-lg ${i}-select-single ${i}-select-selector`]: {
        height: e.controlHeightLG,
      },
      [`&-sm ${i}-select-single ${i}-select-selector`]: {
        height: e.controlHeightSM,
      },
      [`> ${t}`]: {
        display: 'table-cell',
        '&:not(:first-child):not(:last-child)': { borderRadius: 0 },
      },
      [`${t}-group`]: {
        '&-addon, &-wrap': {
          display: 'table-cell',
          width: 1,
          whiteSpace: 'nowrap',
          verticalAlign: 'middle',
          '&:not(:first-child):not(:last-child)': { borderRadius: 0 },
        },
        '&-wrap > *': { display: 'block !important' },
        '&-addon': {
          position: 'relative',
          padding: `0 ${de(e.paddingInline)}`,
          color: e.colorText,
          fontWeight: 'normal',
          fontSize: e.inputFontSize,
          textAlign: 'center',
          borderRadius: e.borderRadius,
          transition: `all ${e.motionDurationSlow}`,
          lineHeight: 1,
          [`${i}-select`]: {
            margin: `${de(e.calc(e.paddingBlock).add(1).mul(-1).equal())} ${de(e.calc(e.paddingInline).mul(-1).equal())}`,
            [`&${i}-select-single:not(${i}-select-customize-input):not(${i}-pagination-size-changer)`]:
              {
                [`${i}-select-selector`]: {
                  backgroundColor: 'inherit',
                  border: `${de(e.lineWidth)} ${e.lineType} transparent`,
                  boxShadow: 'none',
                },
              },
          },
          [`${i}-cascader-picker`]: {
            margin: `-9px ${de(e.calc(e.paddingInline).mul(-1).equal())}`,
            backgroundColor: 'transparent',
            [`${i}-cascader-input`]: {
              textAlign: 'start',
              border: 0,
              boxShadow: 'none',
            },
          },
        },
      },
      [t]: {
        width: '100%',
        marginBottom: 0,
        textAlign: 'inherit',
        '&:focus': { zIndex: 1, borderInlineEndWidth: 1 },
        '&:hover': {
          zIndex: 1,
          borderInlineEndWidth: 1,
          [`${t}-search-with-button &`]: { zIndex: 0 },
        },
      },
      [`> ${t}:first-child, ${t}-group-addon:first-child`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${i}-select ${i}-select-selector`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
        },
      },
      [`> ${t}-affix-wrapper`]: {
        [`&:not(:first-child) ${t}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
        },
        [`&:not(:last-child) ${t}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
        },
      },
      [`> ${t}:last-child, ${t}-group-addon:last-child`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
        [`${i}-select ${i}-select-selector`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
        },
      },
      [`${t}-affix-wrapper`]: {
        '&:not(:last-child)': {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
          [`${t}-search &`]: {
            borderStartStartRadius: e.borderRadius,
            borderEndStartRadius: e.borderRadius,
          },
        },
        [`&:not(:first-child), ${t}-search &:not(:first-child)`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
        },
      },
      [`&${t}-group-compact`]: Object.assign(
        Object.assign({ display: 'block' }, LS()),
        {
          [`${t}-group-addon, ${t}-group-wrap, > ${t}`]: {
            '&:not(:first-child):not(:last-child)': {
              borderInlineEndWidth: e.lineWidth,
              '&:hover, &:focus': { zIndex: 1 },
            },
          },
          '& > *': {
            display: 'inline-flex',
            float: 'none',
            verticalAlign: 'top',
            borderRadius: 0,
          },
          [`
        & > ${t}-affix-wrapper,
        & > ${t}-number-affix-wrapper,
        & > ${i}-picker-range
      `]: { display: 'inline-flex' },
          '& > *:not(:last-child)': {
            marginInlineEnd: e.calc(e.lineWidth).mul(-1).equal(),
            borderInlineEndWidth: e.lineWidth,
          },
          [t]: { float: 'none' },
          [`& > ${i}-select > ${i}-select-selector,
      & > ${i}-select-auto-complete ${t},
      & > ${i}-cascader-picker ${t},
      & > ${t}-group-wrapper ${t}`]: {
            borderInlineEndWidth: e.lineWidth,
            borderRadius: 0,
            '&:hover, &:focus': { zIndex: 1 },
          },
          [`& > ${i}-select-focused`]: { zIndex: 1 },
          [`& > ${i}-select > ${i}-select-arrow`]: { zIndex: 1 },
          [`& > *:first-child,
      & > ${i}-select:first-child > ${i}-select-selector,
      & > ${i}-select-auto-complete:first-child ${t},
      & > ${i}-cascader-picker:first-child ${t}`]: {
            borderStartStartRadius: e.borderRadius,
            borderEndStartRadius: e.borderRadius,
          },
          [`& > *:last-child,
      & > ${i}-select:last-child > ${i}-select-selector,
      & > ${i}-cascader-picker:last-child ${t},
      & > ${i}-cascader-picker-focused:last-child ${t}`]: {
            borderInlineEndWidth: e.lineWidth,
            borderStartEndRadius: e.borderRadius,
            borderEndEndRadius: e.borderRadius,
          },
          [`& > ${i}-select-auto-complete ${t}`]: { verticalAlign: 'top' },
          [`${t}-group-wrapper + ${t}-group-wrapper`]: {
            marginInlineStart: e.calc(e.lineWidth).mul(-1).equal(),
            [`${t}-affix-wrapper`]: { borderRadius: 0 },
          },
          [`${t}-group-wrapper:not(:last-child)`]: {
            [`&${t}-search > ${t}-group`]: {
              [`& > ${t}-group-addon > ${t}-search-button`]: {
                borderRadius: 0,
              },
              [`& > ${t}`]: {
                borderStartStartRadius: e.borderRadius,
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
                borderEndStartRadius: e.borderRadius,
              },
            },
          },
        },
      ),
    }
  },
  v0 = (e) => {
    const { componentCls: t, controlHeightSM: i, lineWidth: s, calc: n } = e,
      o = n(i).sub(n(s).mul(2)).sub(16).div(2).equal()
    return {
      [t]: Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(Object.assign({}, Ns(e)), Ip(e)),
              Rp(e),
            ),
            Pp(e),
          ),
          Fp(e),
        ),
        {
          '&[type="color"]': {
            height: e.controlHeight,
            [`&${t}-lg`]: { height: e.controlHeightLG },
            [`&${t}-sm`]: { height: i, paddingTop: o, paddingBottom: o },
          },
          '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration':
            { '-webkit-appearance': 'none' },
        },
      ),
    }
  },
  C0 = (e) => {
    const { componentCls: t } = e
    return {
      [`${t}-clear-icon`]: {
        margin: 0,
        color: e.colorTextQuaternary,
        fontSize: e.fontSizeIcon,
        verticalAlign: -1,
        cursor: 'pointer',
        transition: `color ${e.motionDurationSlow}`,
        '&:hover': { color: e.colorTextTertiary },
        '&:active': { color: e.colorText },
        '&-hidden': { visibility: 'hidden' },
        '&-has-suffix': { margin: `0 ${de(e.inputAffixPadding)}` },
      },
    }
  },
  S0 = (e) => {
    const {
        componentCls: t,
        inputAffixPadding: i,
        colorTextDescription: s,
        motionDurationSlow: n,
        colorIcon: r,
        colorIconHover: o,
        iconCls: a,
      } = e,
      l = `${t}-affix-wrapper`,
      c = `${t}-affix-wrapper-disabled`
    return {
      [l]: Object.assign(
        Object.assign(
          Object.assign(Object.assign({}, Ip(e)), {
            display: 'inline-flex',
            [`&:not(${t}-disabled):hover`]: {
              zIndex: 1,
              [`${t}-search-with-button &`]: { zIndex: 0 },
            },
            '&-focused, &:focus': { zIndex: 1 },
            [`> input${t}`]: { padding: 0 },
            [`> input${t}, > textarea${t}`]: {
              fontSize: 'inherit',
              border: 'none',
              borderRadius: 0,
              outline: 'none',
              background: 'transparent',
              color: 'inherit',
              '&::-ms-reveal': { display: 'none' },
              '&:focus': { boxShadow: 'none !important' },
            },
            '&::before': {
              display: 'inline-block',
              width: 0,
              visibility: 'hidden',
              content: '"\\a0"',
            },
            [t]: {
              '&-prefix, &-suffix': {
                display: 'flex',
                flex: 'none',
                alignItems: 'center',
                '> *:not(:last-child)': { marginInlineEnd: e.paddingXS },
              },
              '&-show-count-suffix': { color: s },
              '&-show-count-has-suffix': { marginInlineEnd: e.paddingXXS },
              '&-prefix': { marginInlineEnd: i },
              '&-suffix': { marginInlineStart: i },
            },
          }),
          C0(e),
        ),
        {
          [`${a}${t}-password-icon`]: {
            color: r,
            cursor: 'pointer',
            transition: `all ${n}`,
            '&:hover': { color: o },
          },
        },
      ),
      [c]: {
        [`${a}${t}-password-icon`]: {
          color: r,
          cursor: 'not-allowed',
          '&:hover': { color: r },
        },
      },
    }
  },
  w0 = (e) => {
    const { componentCls: t, borderRadiusLG: i, borderRadiusSM: s } = e
    return {
      [`${t}-group`]: Object.assign(
        Object.assign(Object.assign({}, Ns(e)), m0(e)),
        {
          '&-rtl': { direction: 'rtl' },
          '&-wrapper': Object.assign(
            Object.assign(
              Object.assign(
                {
                  display: 'inline-block',
                  width: '100%',
                  textAlign: 'start',
                  verticalAlign: 'top',
                  '&-rtl': { direction: 'rtl' },
                  '&-lg': {
                    [`${t}-group-addon`]: {
                      borderRadius: i,
                      fontSize: e.inputFontSizeLG,
                    },
                  },
                  '&-sm': { [`${t}-group-addon`]: { borderRadius: s } },
                },
                f0(e),
              ),
              p0(e),
            ),
            {
              [`&:not(${t}-compact-first-item):not(${t}-compact-last-item)${t}-compact-item`]:
                { [`${t}, ${t}-group-addon`]: { borderRadius: 0 } },
              [`&:not(${t}-compact-last-item)${t}-compact-first-item`]: {
                [`${t}, ${t}-group-addon`]: {
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0,
                },
              },
              [`&:not(${t}-compact-first-item)${t}-compact-last-item`]: {
                [`${t}, ${t}-group-addon`]: {
                  borderStartStartRadius: 0,
                  borderEndStartRadius: 0,
                },
              },
              [`&:not(${t}-compact-last-item)${t}-compact-item`]: {
                [`${t}-affix-wrapper`]: {
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0,
                },
              },
            },
          ),
        },
      ),
    }
  },
  y0 = (e) => {
    const { componentCls: t, antCls: i } = e,
      s = `${t}-search`
    return {
      [s]: {
        [t]: {
          '&:hover, &:focus': {
            [`+ ${t}-group-addon ${s}-button:not(${i}-btn-primary)`]: {
              borderInlineStartColor: e.colorPrimaryHover,
            },
          },
        },
        [`${t}-affix-wrapper`]: { height: e.controlHeight, borderRadius: 0 },
        [`${t}-lg`]: { lineHeight: e.calc(e.lineHeightLG).sub(2e-4).equal() },
        [`> ${t}-group`]: {
          [`> ${t}-group-addon:last-child`]: {
            insetInlineStart: -1,
            padding: 0,
            border: 0,
            [`${s}-button`]: {
              marginInlineEnd: -1,
              paddingTop: 0,
              paddingBottom: 0,
              borderStartStartRadius: 0,
              borderEndStartRadius: 0,
              boxShadow: 'none',
            },
            [`${s}-button:not(${i}-btn-primary)`]: {
              color: e.colorTextDescription,
              '&:hover': { color: e.colorPrimaryHover },
              '&:active': { color: e.colorPrimaryActive },
              [`&${i}-btn-loading::before`]: {
                insetInlineStart: 0,
                insetInlineEnd: 0,
                insetBlockStart: 0,
                insetBlockEnd: 0,
              },
            },
          },
        },
        [`${s}-button`]: {
          height: e.controlHeight,
          '&:hover, &:focus': { zIndex: 1 },
        },
        '&-large': {
          [`${t}-affix-wrapper, ${s}-button`]: { height: e.controlHeightLG },
        },
        '&-small': {
          [`${t}-affix-wrapper, ${s}-button`]: { height: e.controlHeightSM },
        },
        '&-rtl': { direction: 'rtl' },
        [`&${t}-compact-item`]: {
          [`&:not(${t}-compact-last-item)`]: {
            [`${t}-group-addon`]: {
              [`${t}-search-button`]: {
                marginInlineEnd: e.calc(e.lineWidth).mul(-1).equal(),
                borderRadius: 0,
              },
            },
          },
          [`&:not(${t}-compact-first-item)`]: {
            [`${t},${t}-affix-wrapper`]: { borderRadius: 0 },
          },
          [`> ${t}-group-addon ${t}-search-button,
        > ${t},
        ${t}-affix-wrapper`]: { '&:hover, &:focus, &:active': { zIndex: 2 } },
          [`> ${t}-affix-wrapper-focused`]: { zIndex: 2 },
        },
      },
    }
  },
  b0 = (e) => {
    const { componentCls: t, paddingLG: i } = e,
      s = `${t}-textarea`
    return {
      [s]: {
        position: 'relative',
        '&-show-count': {
          [`> ${t}`]: { height: '100%' },
          [`${t}-data-count`]: {
            position: 'absolute',
            bottom: e.calc(e.fontSize).mul(e.lineHeight).mul(-1).equal(),
            insetInlineEnd: 0,
            color: e.colorTextDescription,
            whiteSpace: 'nowrap',
            pointerEvents: 'none',
          },
        },
        [`
        &-allow-clear > ${t},
        &-affix-wrapper${s}-has-feedback ${t}
      `]: { paddingInlineEnd: i },
        [`&-affix-wrapper${t}-affix-wrapper`]: {
          padding: 0,
          [`> textarea${t}`]: {
            fontSize: 'inherit',
            border: 'none',
            outline: 'none',
            background: 'transparent',
            '&:focus': { boxShadow: 'none !important' },
          },
          [`${t}-suffix`]: {
            margin: 0,
            '> *:not(:last-child)': { marginInline: 0 },
            [`${t}-clear-icon`]: {
              position: 'absolute',
              insetInlineEnd: e.paddingInline,
              insetBlockStart: e.paddingXS,
            },
            [`${s}-suffix`]: {
              position: 'absolute',
              top: 0,
              insetInlineEnd: e.paddingInline,
              bottom: 0,
              zIndex: 1,
              display: 'inline-flex',
              alignItems: 'center',
              margin: 'auto',
              pointerEvents: 'none',
            },
          },
        },
        [`&-affix-wrapper${t}-affix-wrapper-sm`]: {
          [`${t}-suffix`]: {
            [`${t}-clear-icon`]: { insetInlineEnd: e.paddingInlineSM },
          },
        },
      },
    }
  },
  R0 = (e) => {
    const { componentCls: t } = e
    return {
      [`${t}-out-of-range`]: {
        [`&, & input, & textarea, ${t}-show-count-suffix, ${t}-data-count`]: {
          color: e.colorError,
        },
      },
    }
  },
  Wu = dn(
    'Input',
    (e) => {
      const t = Jt(e, Bu(e))
      return [v0(t), b0(t), S0(t), w0(t), y0(t), R0(t), el(t)]
    },
    Vu,
    { resetFont: !1 },
  ),
  Kl = (e, t) => {
    const { componentCls: i, controlHeight: s } = e,
      n = t ? `${i}-${t}` : '',
      r = Af(e)
    return [
      {
        [`${i}-multiple${n}`]: {
          paddingBlock: r.containerPadding,
          paddingInlineStart: r.basePadding,
          minHeight: s,
          [`${i}-selection-item`]: {
            height: r.itemHeight,
            lineHeight: de(r.itemLineHeight),
          },
        },
      },
    ]
  },
  F0 = (e) => {
    const { componentCls: t, calc: i, lineWidth: s } = e,
      n = Jt(e, {
        fontHeight: e.fontSize,
        selectHeight: e.controlHeightSM,
        multipleSelectItemHeight: e.multipleItemHeightSM,
        borderRadius: e.borderRadiusSM,
        borderRadiusSM: e.borderRadiusXS,
        controlHeight: e.controlHeightSM,
      }),
      r = Jt(e, {
        fontHeight: i(e.multipleItemHeightLG).sub(i(s).mul(2).equal()).equal(),
        fontSize: e.fontSizeLG,
        selectHeight: e.controlHeightLG,
        multipleSelectItemHeight: e.multipleItemHeightLG,
        borderRadius: e.borderRadiusLG,
        borderRadiusSM: e.borderRadius,
        controlHeight: e.controlHeightLG,
      })
    return [
      Kl(n, 'small'),
      Kl(e),
      Kl(r, 'large'),
      {
        [`${t}${t}-multiple`]: Object.assign(
          Object.assign(
            {
              width: '100%',
              cursor: 'text',
              [`${t}-selector`]: {
                flex: 'auto',
                padding: 0,
                position: 'relative',
                '&:after': { margin: 0 },
                [`${t}-selection-placeholder`]: {
                  position: 'absolute',
                  top: '50%',
                  insetInlineStart: e.inputPaddingHorizontalBase,
                  insetInlineEnd: 0,
                  transform: 'translateY(-50%)',
                  transition: `all ${e.motionDurationSlow}`,
                  overflow: 'hidden',
                  whiteSpace: 'nowrap',
                  textOverflow: 'ellipsis',
                  flex: 1,
                  color: e.colorTextPlaceholder,
                  pointerEvents: 'none',
                },
              },
            },
            Of(e),
          ),
          {
            [`${t}-multiple-input`]: {
              width: 0,
              height: 0,
              border: 0,
              visibility: 'hidden',
              position: 'absolute',
              zIndex: -1,
            },
          },
        ),
      },
    ]
  },
  E0 = (e) => {
    const {
      pickerCellCls: t,
      pickerCellInnerCls: i,
      cellHeight: s,
      borderRadiusSM: n,
      motionDurationMid: r,
      cellHoverBg: o,
      lineWidth: a,
      lineType: l,
      colorPrimary: c,
      cellActiveWithRangeBg: u,
      colorTextLightSolid: h,
      colorTextDisabled: g,
      cellBgDisabled: f,
      colorFillSecondary: p,
    } = e
    return {
      '&::before': {
        position: 'absolute',
        top: '50%',
        insetInlineStart: 0,
        insetInlineEnd: 0,
        zIndex: 1,
        height: s,
        transform: 'translateY(-50%)',
        content: '""',
      },
      [i]: {
        position: 'relative',
        zIndex: 2,
        display: 'inline-block',
        minWidth: s,
        height: s,
        lineHeight: de(s),
        borderRadius: n,
        transition: `background ${r}`,
      },
      [`&:hover:not(${t}-in-view),
    &:hover:not(${t}-selected):not(${t}-range-start):not(${t}-range-end)`]: {
        [i]: { background: o },
      },
      [`&-in-view${t}-today ${i}`]: {
        '&::before': {
          position: 'absolute',
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          zIndex: 1,
          border: `${de(a)} ${l} ${c}`,
          borderRadius: n,
          content: '""',
        },
      },
      [`&-in-view${t}-in-range,
      &-in-view${t}-range-start,
      &-in-view${t}-range-end`]: {
        position: 'relative',
        [`&:not(${t}-disabled):before`]: { background: u },
      },
      [`&-in-view${t}-selected,
      &-in-view${t}-range-start,
      &-in-view${t}-range-end`]: {
        [`&:not(${t}-disabled) ${i}`]: { color: h, background: c },
        [`&${t}-disabled ${i}`]: { background: p },
      },
      [`&-in-view${t}-range-start:not(${t}-disabled):before`]: {
        insetInlineStart: '50%',
      },
      [`&-in-view${t}-range-end:not(${t}-disabled):before`]: {
        insetInlineEnd: '50%',
      },
      [`&-in-view${t}-range-start:not(${t}-range-end) ${i}`]: {
        borderStartStartRadius: n,
        borderEndStartRadius: n,
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
      },
      [`&-in-view${t}-range-end:not(${t}-range-start) ${i}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
        borderStartEndRadius: n,
        borderEndEndRadius: n,
      },
      '&-disabled': {
        color: g,
        pointerEvents: 'none',
        [i]: { background: 'transparent' },
        '&::before': { background: f },
      },
      [`&-disabled${t}-today ${i}::before`]: { borderColor: g },
    }
  },
  P0 = (e) => {
    const {
        componentCls: t,
        pickerCellCls: i,
        pickerCellInnerCls: s,
        pickerYearMonthCellWidth: n,
        pickerControlIconSize: r,
        cellWidth: o,
        paddingSM: a,
        paddingXS: l,
        paddingXXS: c,
        colorBgContainer: u,
        lineWidth: h,
        lineType: g,
        borderRadiusLG: f,
        colorPrimary: p,
        colorTextHeading: v,
        colorSplit: m,
        pickerControlIconBorderWidth: C,
        colorIcon: w,
        textHeight: S,
        motionDurationMid: y,
        colorIconHover: F,
        fontWeightStrong: R,
        cellHeight: b,
        pickerCellPaddingVertical: x,
        colorTextDisabled: D,
        colorText: O,
        fontSize: M,
        motionDurationSlow: L,
        withoutTimeCellHeight: V,
        pickerQuarterPanelContentHeight: A,
        borderRadiusSM: I,
        colorTextLightSolid: P,
        cellHoverBg: k,
        timeColumnHeight: E,
        timeColumnWidth: N,
        timeCellHeight: T,
        controlItemBgActive: G,
        marginXXS: H,
        pickerDatePanelPaddingHorizontal: _,
        pickerControlIconMargin: B,
      } = e,
      z = e.calc(o).mul(7).add(e.calc(_).mul(2)).equal()
    return {
      [t]: {
        '&-panel': {
          display: 'inline-flex',
          flexDirection: 'column',
          textAlign: 'center',
          background: u,
          borderRadius: f,
          outline: 'none',
          '&-focused': { borderColor: p },
          '&-rtl': {
            [`${t}-prev-icon,
              ${t}-super-prev-icon`]: { transform: 'rotate(45deg)' },
            [`${t}-next-icon,
              ${t}-super-next-icon`]: { transform: 'rotate(-135deg)' },
            [`${t}-time-panel`]: {
              [`${t}-content`]: {
                direction: 'ltr',
                '> *': { direction: 'rtl' },
              },
            },
          },
        },
        '&-decade-panel,\n        &-year-panel,\n        &-quarter-panel,\n        &-month-panel,\n        &-week-panel,\n        &-date-panel,\n        &-time-panel':
          { display: 'flex', flexDirection: 'column', width: z },
        '&-header': {
          display: 'flex',
          padding: `0 ${de(l)}`,
          color: v,
          borderBottom: `${de(h)} ${g} ${m}`,
          '> *': { flex: 'none' },
          button: {
            padding: 0,
            color: w,
            lineHeight: de(S),
            background: 'transparent',
            border: 0,
            cursor: 'pointer',
            transition: `color ${y}`,
            fontSize: 'inherit',
            display: 'inline-flex',
            alignItems: 'center',
            justifyContent: 'center',
          },
          '> button': {
            minWidth: '1.6em',
            fontSize: M,
            '&:hover': { color: F },
            '&:disabled': { opacity: 0.25, pointerEvents: 'none' },
          },
          '&-view': {
            flex: 'auto',
            fontWeight: R,
            lineHeight: de(S),
            '> button': {
              color: 'inherit',
              fontWeight: 'inherit',
              '&:not(:first-child)': { marginInlineStart: l },
              '&:hover': { color: p },
            },
          },
        },
        '&-prev-icon,\n        &-next-icon,\n        &-super-prev-icon,\n        &-super-next-icon':
          {
            position: 'relative',
            width: r,
            height: r,
            '&::before': {
              position: 'absolute',
              top: 0,
              insetInlineStart: 0,
              width: r,
              height: r,
              border: '0 solid currentcolor',
              borderBlockWidth: `${de(C)} 0`,
              borderInlineWidth: `${de(C)} 0`,
              content: '""',
            },
          },
        '&-super-prev-icon,\n        &-super-next-icon': {
          '&::after': {
            position: 'absolute',
            top: B,
            insetInlineStart: B,
            display: 'inline-block',
            width: r,
            height: r,
            border: '0 solid currentcolor',
            borderBlockWidth: `${de(C)} 0`,
            borderInlineWidth: `${de(C)} 0`,
            content: '""',
          },
        },
        '&-prev-icon, &-super-prev-icon': { transform: 'rotate(-45deg)' },
        '&-next-icon, &-super-next-icon': { transform: 'rotate(135deg)' },
        '&-content': {
          width: '100%',
          tableLayout: 'fixed',
          borderCollapse: 'collapse',
          'th, td': { position: 'relative', minWidth: b, fontWeight: 'normal' },
          th: {
            height: e.calc(b).add(e.calc(x).mul(2)).equal(),
            color: O,
            verticalAlign: 'middle',
          },
        },
        '&-cell': Object.assign(
          {
            padding: `${de(x)} 0`,
            color: D,
            cursor: 'pointer',
            '&-in-view': { color: O },
          },
          E0(e),
        ),
        '&-decade-panel,\n        &-year-panel,\n        &-quarter-panel,\n        &-month-panel':
          {
            [`${t}-content`]: { height: e.calc(V).mul(4).equal() },
            [s]: { padding: `0 ${de(l)}` },
          },
        '&-quarter-panel': { [`${t}-content`]: { height: A } },
        '&-decade-panel': {
          [s]: { padding: `0 ${de(e.calc(l).div(2).equal())}` },
          [`${t}-cell::before`]: { display: 'none' },
        },
        '&-year-panel,\n        &-quarter-panel,\n        &-month-panel': {
          [`${t}-body`]: { padding: `0 ${de(l)}` },
          [s]: { width: n },
        },
        '&-date-panel': {
          [`${t}-body`]: { padding: `${de(l)} ${de(_)}` },
          [`${t}-content th`]: { boxSizing: 'border-box', padding: 0 },
        },
        '&-week-panel': {
          [`${t}-cell`]: {
            [`&:hover ${s},
            &-selected ${s},
            ${s}`]: { background: 'transparent !important' },
          },
          '&-row': {
            td: {
              '&:before': { transition: `background ${y}` },
              '&:first-child:before': {
                borderStartStartRadius: I,
                borderEndStartRadius: I,
              },
              '&:last-child:before': {
                borderStartEndRadius: I,
                borderEndEndRadius: I,
              },
            },
            '&:hover td': { '&:before': { background: k } },
            '&-range-start td, &-range-end td, &-selected td, &-hover td': {
              [`&${i}`]: {
                '&:before': { background: p },
                [`&${t}-cell-week`]: {
                  color: new Ts(P).setAlpha(0.5).toHexString(),
                },
                [s]: { color: P },
              },
            },
            '&-range-hover td:before': { background: G },
          },
        },
        '&-week-panel, &-date-panel-show-week': {
          [`${t}-body`]: { padding: `${de(l)} ${de(a)}` },
          [`${t}-content th`]: { width: 'auto' },
        },
        '&-datetime-panel': {
          display: 'flex',
          [`${t}-time-panel`]: { borderInlineStart: `${de(h)} ${g} ${m}` },
          [`${t}-date-panel,
          ${t}-time-panel`]: { transition: `opacity ${L}` },
          '&-active': {
            [`${t}-date-panel,
            ${t}-time-panel`]: { opacity: 0.3, '&-active': { opacity: 1 } },
          },
        },
        '&-time-panel': {
          width: 'auto',
          minWidth: 'auto',
          [`${t}-content`]: { display: 'flex', flex: 'auto', height: E },
          '&-column': {
            flex: '1 0 auto',
            width: N,
            margin: `${de(c)} 0`,
            padding: 0,
            overflowY: 'hidden',
            textAlign: 'start',
            listStyle: 'none',
            transition: `background ${y}`,
            overflowX: 'hidden',
            '&::-webkit-scrollbar': {
              width: 8,
              backgroundColor: 'transparent',
            },
            '&::-webkit-scrollbar-thumb': {
              backgroundColor: e.colorTextTertiary,
              borderRadius: e.borderRadiusSM,
            },
            '&': {
              scrollbarWidth: 'thin',
              scrollbarColor: `${e.colorTextTertiary} transparent`,
            },
            '&::after': {
              display: 'block',
              height: e.calc('100%').sub(T).equal(),
              content: '""',
            },
            '&:not(:first-child)': { borderInlineStart: `${de(h)} ${g} ${m}` },
            '&-active': { background: new Ts(G).setAlpha(0.2).toHexString() },
            '&:hover': { overflowY: 'auto' },
            '> li': {
              margin: 0,
              padding: 0,
              [`&${t}-time-panel-cell`]: {
                marginInline: H,
                [`${t}-time-panel-cell-inner`]: {
                  display: 'block',
                  width: e.calc(N).sub(e.calc(H).mul(2)).equal(),
                  height: T,
                  margin: 0,
                  paddingBlock: 0,
                  paddingInlineEnd: 0,
                  paddingInlineStart: e.calc(N).sub(T).div(2).equal(),
                  color: O,
                  lineHeight: de(T),
                  borderRadius: I,
                  cursor: 'pointer',
                  transition: `background ${y}`,
                  '&:hover': { background: k },
                },
                '&-selected': {
                  [`${t}-time-panel-cell-inner`]: { background: G },
                },
                '&-disabled': {
                  [`${t}-time-panel-cell-inner`]: {
                    color: D,
                    background: 'transparent',
                    cursor: 'not-allowed',
                  },
                },
              },
            },
          },
        },
      },
    }
  },
  x0 = (e) => {
    const {
      componentCls: t,
      textHeight: i,
      lineWidth: s,
      paddingSM: n,
      antCls: r,
      colorPrimary: o,
      cellActiveWithRangeBg: a,
      colorPrimaryBorder: l,
      lineType: c,
      colorSplit: u,
    } = e
    return {
      [`${t}-dropdown`]: {
        [`${t}-footer`]: {
          borderTop: `${de(s)} ${c} ${u}`,
          '&-extra': {
            padding: `0 ${de(n)}`,
            lineHeight: de(e.calc(i).sub(e.calc(s).mul(2)).equal()),
            textAlign: 'start',
            '&:not(:last-child)': { borderBottom: `${de(s)} ${c} ${u}` },
          },
        },
        [`${t}-panels + ${t}-footer ${t}-ranges`]: {
          justifyContent: 'space-between',
        },
        [`${t}-ranges`]: {
          marginBlock: 0,
          paddingInline: de(n),
          overflow: 'hidden',
          textAlign: 'start',
          listStyle: 'none',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          '> li': {
            lineHeight: de(e.calc(i).sub(e.calc(s).mul(2)).equal()),
            display: 'inline-block',
          },
          [`${t}-now-btn-disabled`]: {
            pointerEvents: 'none',
            color: e.colorTextDisabled,
          },
          [`${t}-preset > ${r}-tag-blue`]: {
            color: o,
            background: a,
            borderColor: l,
            cursor: 'pointer',
          },
          [`${t}-ok`]: {
            paddingBlock: e.calc(s).mul(2).equal(),
            marginInlineStart: 'auto',
          },
        },
      },
    }
  },
  D0 = (e) => {
    const { componentCls: t, controlHeightLG: i, paddingXXS: s, padding: n } = e
    return {
      pickerCellCls: `${t}-cell`,
      pickerCellInnerCls: `${t}-cell-inner`,
      pickerYearMonthCellWidth: e.calc(i).mul(1.5).equal(),
      pickerQuarterPanelContentHeight: e.calc(i).mul(1.4).equal(),
      pickerCellPaddingVertical: e.calc(s).add(e.calc(s).div(2)).equal(),
      pickerCellBorderGap: 2,
      pickerControlIconSize: 7,
      pickerControlIconMargin: 4,
      pickerControlIconBorderWidth: 1.5,
      pickerDatePanelPaddingHorizontal: e.calc(n).add(e.calc(s).div(2)).equal(),
    }
  },
  M0 = (e) => {
    const {
        colorBgContainerDisabled: t,
        controlHeight: i,
        controlHeightSM: s,
        controlHeightLG: n,
        paddingXXS: r,
        lineWidth: o,
      } = e,
      a = r * 2,
      l = o * 2,
      c = Math.min(i - a, i - l),
      u = Math.min(s - a, s - l),
      h = Math.min(n - a, n - l)
    return {
      INTERNAL_FIXED_ITEM_MARGIN: Math.floor(r / 2),
      cellHoverBg: e.controlItemBgHover,
      cellActiveWithRangeBg: e.controlItemBgActive,
      cellHoverWithRangeBg: new Ts(e.colorPrimary).lighten(35).toHexString(),
      cellRangeBorderColor: new Ts(e.colorPrimary).lighten(20).toHexString(),
      cellBgDisabled: t,
      timeColumnWidth: n * 1.4,
      timeColumnHeight: 28 * 8,
      timeCellHeight: 28,
      cellWidth: s * 1.5,
      cellHeight: s,
      textHeight: n,
      withoutTimeCellHeight: n * 1.65,
      multipleItemBg: e.colorFillSecondary,
      multipleItemBorderColor: 'transparent',
      multipleItemHeight: c,
      multipleItemHeightSM: u,
      multipleItemHeightLG: h,
      multipleSelectorBgDisabled: t,
      multipleItemColorDisabled: e.colorTextDisabled,
      multipleItemBorderColorDisabled: 'transparent',
    }
  },
  I0 = (e) =>
    Object.assign(
      Object.assign(Object.assign(Object.assign({}, Vu(e)), M0(e)), kS(e)),
      {
        presetsWidth: 120,
        presetsMaxWidth: 200,
        zIndexPopup: e.zIndexPopupBase + 50,
      },
    ),
  T0 = (e) => {
    const { componentCls: t } = e
    return {
      [t]: [
        Object.assign(Object.assign(Object.assign({}, Rp(e)), Pp(e)), Fp(e)),
        {
          '&-outlined': {
            [`&${t}-multiple ${t}-selection-item`]: {
              background: e.multipleItemBg,
              border: `${de(e.lineWidth)} ${e.lineType} ${e.multipleItemBorderColor}`,
            },
          },
          '&-filled': {
            [`&${t}-multiple ${t}-selection-item`]: {
              background: e.colorBgContainer,
              border: `${de(e.lineWidth)} ${e.lineType} ${e.colorSplit}`,
            },
          },
          '&-borderless': {
            [`&${t}-multiple ${t}-selection-item`]: {
              background: e.multipleItemBg,
              border: `${de(e.lineWidth)} ${e.lineType} ${e.multipleItemBorderColor}`,
            },
          },
        },
      ],
    }
  },
  ql = (e, t, i, s) => {
    const n = e.calc(i).add(2).equal(),
      r = e.max(e.calc(t).sub(n).div(2).equal(), 0),
      o = e.max(e.calc(t).sub(n).sub(r).equal(), 0)
    return { padding: `${de(r)} ${de(s)} ${de(o)}` }
  },
  A0 = (e) => {
    const { componentCls: t, colorError: i, colorWarning: s } = e
    return {
      [`${t}:not(${t}-disabled):not([disabled])`]: {
        [`&${t}-status-error`]: { [`${t}-active-bar`]: { background: i } },
        [`&${t}-status-warning`]: { [`${t}-active-bar`]: { background: s } },
      },
    }
  },
  O0 = (e) => {
    const {
      componentCls: t,
      antCls: i,
      controlHeight: s,
      paddingInline: n,
      lineWidth: r,
      lineType: o,
      colorBorder: a,
      borderRadius: l,
      motionDurationMid: c,
      colorTextDisabled: u,
      colorTextPlaceholder: h,
      controlHeightLG: g,
      fontSizeLG: f,
      controlHeightSM: p,
      paddingInlineSM: v,
      paddingXS: m,
      marginXS: C,
      colorTextDescription: w,
      lineWidthBold: S,
      colorPrimary: y,
      motionDurationSlow: F,
      zIndexPopup: R,
      paddingXXS: b,
      sizePopupArrow: x,
      colorBgElevated: D,
      borderRadiusLG: O,
      boxShadowSecondary: M,
      borderRadiusSM: L,
      colorSplit: V,
      cellHoverBg: A,
      presetsWidth: I,
      presetsMaxWidth: P,
      boxShadowPopoverArrow: k,
      fontHeight: E,
      fontHeightLG: N,
      lineHeightLG: T,
    } = e
    return [
      {
        [t]: Object.assign(
          Object.assign(Object.assign({}, Ns(e)), ql(e, s, E, n)),
          {
            position: 'relative',
            display: 'inline-flex',
            alignItems: 'center',
            lineHeight: 1,
            borderRadius: l,
            transition: `border ${c}, box-shadow ${c}, background ${c}`,
            [`${t}-input`]: {
              position: 'relative',
              display: 'inline-flex',
              alignItems: 'center',
              width: '100%',
              '> input': Object.assign(
                Object.assign(
                  {
                    position: 'relative',
                    display: 'inline-block',
                    width: '100%',
                    color: 'inherit',
                    fontSize: e.fontSize,
                    lineHeight: e.lineHeight,
                    transition: `all ${c}`,
                  },
                  xp(h),
                ),
                {
                  flex: 'auto',
                  minWidth: 1,
                  height: 'auto',
                  padding: 0,
                  background: 'transparent',
                  border: 0,
                  fontFamily: 'inherit',
                  '&:focus': { boxShadow: 'none', outline: 0 },
                  '&[disabled]': {
                    background: 'transparent',
                    color: u,
                    cursor: 'not-allowed',
                  },
                },
              ),
              '&-placeholder': { '> input': { color: h } },
            },
            '&-large': Object.assign(Object.assign({}, ql(e, g, N, n)), {
              [`${t}-input > input`]: { fontSize: f, lineHeight: T },
            }),
            '&-small': Object.assign({}, ql(e, p, E, v)),
            [`${t}-suffix`]: {
              display: 'flex',
              flex: 'none',
              alignSelf: 'center',
              marginInlineStart: e.calc(m).div(2).equal(),
              color: u,
              lineHeight: 1,
              pointerEvents: 'none',
              transition: `opacity ${c}, color ${c}`,
              '> *': {
                verticalAlign: 'top',
                '&:not(:last-child)': { marginInlineEnd: C },
              },
            },
            [`${t}-clear`]: {
              position: 'absolute',
              top: '50%',
              insetInlineEnd: 0,
              color: u,
              lineHeight: 1,
              transform: 'translateY(-50%)',
              cursor: 'pointer',
              opacity: 0,
              transition: `opacity ${c}, color ${c}`,
              '> *': { verticalAlign: 'top' },
              '&:hover': { color: w },
            },
            '&:hover': {
              [`${t}-clear`]: { opacity: 1 },
              [`${t}-suffix:not(:last-child)`]: { opacity: 0 },
            },
            [`${t}-separator`]: {
              position: 'relative',
              display: 'inline-block',
              width: '1em',
              height: f,
              color: u,
              fontSize: f,
              verticalAlign: 'top',
              cursor: 'default',
              [`${t}-focused &`]: { color: w },
              [`${t}-range-separator &`]: {
                [`${t}-disabled &`]: { cursor: 'not-allowed' },
              },
            },
            '&-range': {
              position: 'relative',
              display: 'inline-flex',
              [`${t}-active-bar`]: {
                bottom: e.calc(r).mul(-1).equal(),
                height: S,
                background: y,
                opacity: 0,
                transition: `all ${F} ease-out`,
                pointerEvents: 'none',
              },
              [`&${t}-focused`]: { [`${t}-active-bar`]: { opacity: 1 } },
              [`${t}-range-separator`]: {
                alignItems: 'center',
                padding: `0 ${de(m)}`,
                lineHeight: 1,
              },
            },
            '&-range, &-multiple': {
              [`${t}-clear`]: { insetInlineEnd: n },
              [`&${t}-small`]: { [`${t}-clear`]: { insetInlineEnd: v } },
            },
            '&-dropdown': Object.assign(
              Object.assign(Object.assign({}, Ns(e)), P0(e)),
              {
                pointerEvents: 'none',
                position: 'absolute',
                top: -9999,
                left: { _skip_check_: !0, value: -9999 },
                zIndex: R,
                [`&${t}-dropdown-hidden`]: { display: 'none' },
                '&-rtl': { direction: 'rtl' },
                [`&${t}-dropdown-placement-bottomLeft,
            &${t}-dropdown-placement-bottomRight`]: {
                  [`${t}-range-arrow`]: {
                    top: 0,
                    display: 'block',
                    transform: 'translateY(-100%)',
                  },
                },
                [`&${t}-dropdown-placement-topLeft,
            &${t}-dropdown-placement-topRight`]: {
                  [`${t}-range-arrow`]: {
                    bottom: 0,
                    display: 'block',
                    transform: 'translateY(100%) rotate(180deg)',
                  },
                },
                [`&${i}-slide-up-enter${i}-slide-up-enter-active${t}-dropdown-placement-topLeft,
          &${i}-slide-up-enter${i}-slide-up-enter-active${t}-dropdown-placement-topRight,
          &${i}-slide-up-appear${i}-slide-up-appear-active${t}-dropdown-placement-topLeft,
          &${i}-slide-up-appear${i}-slide-up-appear-active${t}-dropdown-placement-topRight`]:
                  { animationName: nf },
                [`&${i}-slide-up-enter${i}-slide-up-enter-active${t}-dropdown-placement-bottomLeft,
          &${i}-slide-up-enter${i}-slide-up-enter-active${t}-dropdown-placement-bottomRight,
          &${i}-slide-up-appear${i}-slide-up-appear-active${t}-dropdown-placement-bottomLeft,
          &${i}-slide-up-appear${i}-slide-up-appear-active${t}-dropdown-placement-bottomRight`]:
                  { animationName: sf },
                [`&${i}-slide-up-leave ${t}-panel-container`]: {
                  pointerEvents: 'none',
                },
                [`&${i}-slide-up-leave${i}-slide-up-leave-active${t}-dropdown-placement-topLeft,
          &${i}-slide-up-leave${i}-slide-up-leave-active${t}-dropdown-placement-topRight`]:
                  { animationName: of },
                [`&${i}-slide-up-leave${i}-slide-up-leave-active${t}-dropdown-placement-bottomLeft,
          &${i}-slide-up-leave${i}-slide-up-leave-active${t}-dropdown-placement-bottomRight`]:
                  { animationName: rf },
                [`${t}-panel > ${t}-time-panel`]: { paddingTop: b },
                [`${t}-range-wrapper`]: {
                  display: 'flex',
                  position: 'relative',
                },
                [`${t}-range-arrow`]: Object.assign(
                  Object.assign(
                    {
                      position: 'absolute',
                      zIndex: 1,
                      display: 'none',
                      paddingInline: e.calc(n).mul(1.5).equal(),
                      boxSizing: 'content-box',
                      transition: `all ${F} ease-out`,
                    },
                    HS(e, D, k),
                  ),
                  {
                    '&:before': {
                      insetInlineStart: e.calc(n).mul(1.5).equal(),
                    },
                  },
                ),
                [`${t}-panel-container`]: {
                  overflow: 'hidden',
                  verticalAlign: 'top',
                  background: D,
                  borderRadius: O,
                  boxShadow: M,
                  transition: `margin ${F}`,
                  display: 'inline-block',
                  pointerEvents: 'auto',
                  [`${t}-panel-layout`]: {
                    display: 'flex',
                    flexWrap: 'nowrap',
                    alignItems: 'stretch',
                  },
                  [`${t}-presets`]: {
                    display: 'flex',
                    flexDirection: 'column',
                    minWidth: I,
                    maxWidth: P,
                    ul: {
                      height: 0,
                      flex: 'auto',
                      listStyle: 'none',
                      overflow: 'auto',
                      margin: 0,
                      padding: m,
                      borderInlineEnd: `${de(r)} ${o} ${V}`,
                      li: Object.assign(Object.assign({}, ho), {
                        borderRadius: L,
                        paddingInline: m,
                        paddingBlock: e.calc(p).sub(E).div(2).equal(),
                        cursor: 'pointer',
                        transition: `all ${F}`,
                        '+ li': { marginTop: C },
                        '&:hover': { background: A },
                      }),
                    },
                  },
                  [`${t}-panels`]: {
                    display: 'inline-flex',
                    flexWrap: 'nowrap',
                    '&:last-child': { [`${t}-panel`]: { borderWidth: 0 } },
                  },
                  [`${t}-panel`]: {
                    verticalAlign: 'top',
                    background: 'transparent',
                    borderRadius: 0,
                    borderWidth: 0,
                    [`${t}-content, table`]: { textAlign: 'center' },
                    '&-focused': { borderColor: a },
                  },
                },
              },
            ),
            '&-dropdown-range': {
              padding: `${de(e.calc(x).mul(2).div(3).equal())} 0`,
              '&-hidden': { display: 'none' },
            },
            '&-rtl': {
              direction: 'rtl',
              [`${t}-separator`]: { transform: 'rotate(180deg)' },
              [`${t}-footer`]: { '&-extra': { direction: 'rtl' } },
            },
          },
        ),
      },
      ba(e, 'slide-up'),
      ba(e, 'slide-down'),
      Ea(e, 'move-up'),
      Ea(e, 'move-down'),
    ]
  },
  Tp = dn(
    'DatePicker',
    (e) => {
      const t = Jt(Bu(e), D0(e), {
        inputPaddingHorizontalBase: e.calc(e.paddingSM).sub(1).equal(),
        multipleSelectItemHeight: e.multipleItemHeight,
        selectHeight: e.controlHeight,
      })
      return [
        x0(t),
        O0(t),
        T0(t),
        A0(t),
        F0(t),
        el(e, { focusElCls: `${e.componentCls}-focused` }),
      ]
    },
    I0,
  )
var L0 = {
    icon: {
      tag: 'svg',
      attrs: { viewBox: '64 64 896 896', focusable: 'false' },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z',
          },
        },
        {
          tag: 'path',
          attrs: {
            d: 'M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z',
          },
        },
      ],
    },
    name: 'plus',
    theme: 'outlined',
  },
  k0 = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: L0 }))
  },
  H0 = d.forwardRef(k0),
  Vh = function (t, i) {
    if (!t) return null
    var s = {
      left: t.offsetLeft,
      right: t.parentElement.clientWidth - t.clientWidth - t.offsetLeft,
      width: t.clientWidth,
      top: t.offsetTop,
      bottom: t.parentElement.clientHeight - t.clientHeight - t.offsetTop,
      height: t.clientHeight,
    }
    return i
      ? {
          left: 0,
          right: 0,
          width: 0,
          top: s.top,
          bottom: s.bottom,
          height: s.height,
        }
      : {
          left: s.left,
          right: s.right,
          width: s.width,
          top: 0,
          bottom: 0,
          height: 0,
        }
  },
  as = function (t) {
    return t !== void 0 ? ''.concat(t, 'px') : void 0
  }
function N0(e) {
  var t = e.prefixCls,
    i = e.containerRef,
    s = e.value,
    n = e.getValueIndex,
    r = e.motionName,
    o = e.onMotionStart,
    a = e.onMotionEnd,
    l = e.direction,
    c = e.vertical,
    u = c === void 0 ? !1 : c,
    h = d.useRef(null),
    g = d.useState(s),
    f = Z(g, 2),
    p = f[0],
    v = f[1],
    m = function (I) {
      var P,
        k = n(I),
        E =
          (P = i.current) === null || P === void 0
            ? void 0
            : P.querySelectorAll('.'.concat(t, '-item'))[k]
      return (E == null ? void 0 : E.offsetParent) && E
    },
    C = d.useState(null),
    w = Z(C, 2),
    S = w[0],
    y = w[1],
    F = d.useState(null),
    R = Z(F, 2),
    b = R[0],
    x = R[1]
  li(
    function () {
      if (p !== s) {
        var A = m(p),
          I = m(s),
          P = Vh(A, u),
          k = Vh(I, u)
        v(s), y(P), x(k), A && I ? o() : a()
      }
    },
    [s],
  )
  var D = d.useMemo(
      function () {
        if (u) {
          var A
          return as(
            (A = S == null ? void 0 : S.top) !== null && A !== void 0 ? A : 0,
          )
        }
        return as(
          l === 'rtl'
            ? -(S == null ? void 0 : S.right)
            : S == null
              ? void 0
              : S.left,
        )
      },
      [u, l, S],
    ),
    O = d.useMemo(
      function () {
        if (u) {
          var A
          return as(
            (A = b == null ? void 0 : b.top) !== null && A !== void 0 ? A : 0,
          )
        }
        return as(
          l === 'rtl'
            ? -(b == null ? void 0 : b.right)
            : b == null
              ? void 0
              : b.left,
        )
      },
      [u, l, b],
    ),
    M = function () {
      return u
        ? {
            transform: 'translateY(var(--thumb-start-top))',
            height: 'var(--thumb-start-height)',
          }
        : {
            transform: 'translateX(var(--thumb-start-left))',
            width: 'var(--thumb-start-width)',
          }
    },
    L = function () {
      return u
        ? {
            transform: 'translateY(var(--thumb-active-top))',
            height: 'var(--thumb-active-height)',
          }
        : {
            transform: 'translateX(var(--thumb-active-left))',
            width: 'var(--thumb-active-width)',
          }
    },
    V = function () {
      y(null), x(null), a()
    }
  return !S || !b
    ? null
    : d.createElement(
        vu,
        {
          visible: !0,
          motionName: r,
          motionAppear: !0,
          onAppearStart: M,
          onAppearActive: L,
          onVisibleChanged: V,
        },
        function (A, I) {
          var P = A.className,
            k = A.style,
            E = re(
              re({}, k),
              {},
              {
                '--thumb-start-left': D,
                '--thumb-start-width': as(S == null ? void 0 : S.width),
                '--thumb-active-left': O,
                '--thumb-active-width': as(b == null ? void 0 : b.width),
                '--thumb-start-top': D,
                '--thumb-start-height': as(S == null ? void 0 : S.height),
                '--thumb-active-top': O,
                '--thumb-active-height': as(b == null ? void 0 : b.height),
              },
            ),
            N = {
              ref: $s(h, I),
              style: E,
              className: pe(''.concat(t, '-thumb'), P),
            }
          return d.createElement('div', N)
        },
      )
}
var G0 = [
  'prefixCls',
  'direction',
  'vertical',
  'options',
  'disabled',
  'defaultValue',
  'value',
  'onChange',
  'className',
  'motionName',
]
function B0(e) {
  if (typeof e.title < 'u') return e.title
  if (Zt(e.label) !== 'object') {
    var t
    return (t = e.label) === null || t === void 0 ? void 0 : t.toString()
  }
}
function V0(e) {
  return e.map(function (t) {
    if (Zt(t) === 'object' && t !== null) {
      var i = B0(t)
      return re(re({}, t), {}, { title: i })
    }
    return {
      label: t == null ? void 0 : t.toString(),
      title: t == null ? void 0 : t.toString(),
      value: t,
    }
  })
}
var _0 = function (t) {
    var i = t.prefixCls,
      s = t.className,
      n = t.disabled,
      r = t.checked,
      o = t.label,
      a = t.title,
      l = t.value,
      c = t.onChange,
      u = function (g) {
        n || c(g, l)
      }
    return d.createElement(
      'label',
      { className: pe(s, ce({}, ''.concat(i, '-item-disabled'), n)) },
      d.createElement('input', {
        className: ''.concat(i, '-item-input'),
        type: 'radio',
        disabled: n,
        checked: r,
        onChange: u,
      }),
      d.createElement(
        'div',
        {
          className: ''.concat(i, '-item-label'),
          title: a,
          role: 'option',
          'aria-selected': r,
        },
        o,
      ),
    )
  },
  W0 = d.forwardRef(function (e, t) {
    var i,
      s,
      n = e.prefixCls,
      r = n === void 0 ? 'rc-segmented' : n,
      o = e.direction,
      a = e.vertical,
      l = e.options,
      c = l === void 0 ? [] : l,
      u = e.disabled,
      h = e.defaultValue,
      g = e.value,
      f = e.onChange,
      p = e.className,
      v = p === void 0 ? '' : p,
      m = e.motionName,
      C = m === void 0 ? 'thumb-motion' : m,
      w = Kt(e, G0),
      S = d.useRef(null),
      y = d.useMemo(
        function () {
          return $s(S, t)
        },
        [S, t],
      ),
      F = d.useMemo(
        function () {
          return V0(c)
        },
        [c],
      ),
      R = ai((i = F[0]) === null || i === void 0 ? void 0 : i.value, {
        value: g,
        defaultValue: h,
      }),
      b = Z(R, 2),
      x = b[0],
      D = b[1],
      O = d.useState(!1),
      M = Z(O, 2),
      L = M[0],
      V = M[1],
      A = function (k, E) {
        u || (D(E), f == null || f(E))
      },
      I = zs(w, ['children'])
    return d.createElement(
      'div',
      xe({ role: 'listbox', 'aria-label': 'segmented control' }, I, {
        className: pe(
          r,
          ((s = {}),
          ce(s, ''.concat(r, '-rtl'), o === 'rtl'),
          ce(s, ''.concat(r, '-disabled'), u),
          ce(s, ''.concat(r, '-vertical'), a),
          s),
          v,
        ),
        ref: y,
      }),
      d.createElement(
        'div',
        { className: ''.concat(r, '-group') },
        d.createElement(N0, {
          vertical: a,
          prefixCls: r,
          value: x,
          containerRef: S,
          motionName: ''.concat(r, '-').concat(C),
          direction: o,
          getValueIndex: function (k) {
            return F.findIndex(function (E) {
              return E.value === k
            })
          },
          onMotionStart: function () {
            V(!0)
          },
          onMotionEnd: function () {
            V(!1)
          },
        }),
        F.map(function (P) {
          return d.createElement(
            _0,
            xe({}, P, {
              key: P.value,
              prefixCls: r,
              className: pe(
                P.className,
                ''.concat(r, '-item'),
                ce({}, ''.concat(r, '-item-selected'), P.value === x && !L),
              ),
              checked: P.value === x,
              onChange: A,
              disabled: !!u || !!P.disabled,
            }),
          )
        }),
      ),
    )
  }),
  $0 = W0
function _h(e, t) {
  return {
    [`${e}, ${e}:hover, ${e}:focus`]: {
      color: t.colorTextDisabled,
      cursor: 'not-allowed',
    },
  }
}
function Wh(e) {
  return { backgroundColor: e.itemSelectedBg, boxShadow: e.boxShadowTertiary }
}
const z0 = Object.assign({ overflow: 'hidden' }, ho),
  U0 = (e) => {
    const { componentCls: t } = e,
      i = e.calc(e.controlHeight).sub(e.calc(e.trackPadding).mul(2)).equal(),
      s = e.calc(e.controlHeightLG).sub(e.calc(e.trackPadding).mul(2)).equal(),
      n = e.calc(e.controlHeightSM).sub(e.calc(e.trackPadding).mul(2)).equal()
    return {
      [t]: Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(Object.assign({}, Ns(e)), {
              display: 'inline-block',
              padding: e.trackPadding,
              color: e.itemColor,
              background: e.trackBg,
              borderRadius: e.borderRadius,
              transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
              [`${t}-group`]: {
                position: 'relative',
                display: 'flex',
                alignItems: 'stretch',
                justifyItems: 'flex-start',
                flexDirection: 'row',
                width: '100%',
              },
              [`&${t}-rtl`]: { direction: 'rtl' },
              [`&${t}-vertical`]: {
                [`${t}-group`]: { flexDirection: 'column' },
                [`${t}-thumb`]: {
                  width: '100%',
                  height: 0,
                  padding: `0 ${de(e.paddingXXS)}`,
                },
              },
              [`&${t}-block`]: { display: 'flex' },
              [`&${t}-block ${t}-item`]: { flex: 1, minWidth: 0 },
              [`${t}-item`]: {
                position: 'relative',
                textAlign: 'center',
                cursor: 'pointer',
                transition: `color ${e.motionDurationMid} ${e.motionEaseInOut}`,
                borderRadius: e.borderRadiusSM,
                transform: 'translateZ(0)',
                '&-selected': Object.assign(Object.assign({}, Wh(e)), {
                  color: e.itemSelectedColor,
                }),
                '&::after': {
                  content: '""',
                  position: 'absolute',
                  zIndex: -1,
                  width: '100%',
                  height: '100%',
                  top: 0,
                  insetInlineStart: 0,
                  borderRadius: 'inherit',
                  transition: `background-color ${e.motionDurationMid}`,
                  pointerEvents: 'none',
                },
                [`&:hover:not(${t}-item-selected):not(${t}-item-disabled)`]: {
                  color: e.itemHoverColor,
                  '&::after': { backgroundColor: e.itemHoverBg },
                },
                [`&:active:not(${t}-item-selected):not(${t}-item-disabled)`]: {
                  color: e.itemHoverColor,
                  '&::after': { backgroundColor: e.itemActiveBg },
                },
                '&-label': Object.assign(
                  {
                    minHeight: i,
                    lineHeight: de(i),
                    padding: `0 ${de(e.segmentedPaddingHorizontal)}`,
                  },
                  z0,
                ),
                '&-icon + *': {
                  marginInlineStart: e.calc(e.marginSM).div(2).equal(),
                },
                '&-input': {
                  position: 'absolute',
                  insetBlockStart: 0,
                  insetInlineStart: 0,
                  width: 0,
                  height: 0,
                  opacity: 0,
                  pointerEvents: 'none',
                },
              },
              [`${t}-thumb`]: Object.assign(Object.assign({}, Wh(e)), {
                position: 'absolute',
                insetBlockStart: 0,
                insetInlineStart: 0,
                width: 0,
                height: '100%',
                padding: `${de(e.paddingXXS)} 0`,
                borderRadius: e.borderRadiusSM,
                transition: `transform ${e.motionDurationSlow} ${e.motionEaseInOut}, height ${e.motionDurationSlow} ${e.motionEaseInOut}`,
                [`& ~ ${t}-item:not(${t}-item-selected):not(${t}-item-disabled)::after`]:
                  { backgroundColor: 'transparent' },
              }),
              [`&${t}-lg`]: {
                borderRadius: e.borderRadiusLG,
                [`${t}-item-label`]: {
                  minHeight: s,
                  lineHeight: de(s),
                  padding: `0 ${de(e.segmentedPaddingHorizontal)}`,
                  fontSize: e.fontSizeLG,
                },
                [`${t}-item, ${t}-thumb`]: { borderRadius: e.borderRadius },
              },
              [`&${t}-sm`]: {
                borderRadius: e.borderRadiusSM,
                [`${t}-item-label`]: {
                  minHeight: n,
                  lineHeight: de(n),
                  padding: `0 ${de(e.segmentedPaddingHorizontalSM)}`,
                },
                [`${t}-item, ${t}-thumb`]: { borderRadius: e.borderRadiusXS },
              },
            }),
            _h(`&-disabled ${t}-item`, e),
          ),
          _h(`${t}-item-disabled`, e),
        ),
        {
          [`${t}-thumb-motion-appear-active`]: {
            transition: `transform ${e.motionDurationSlow} ${e.motionEaseInOut}, width ${e.motionDurationSlow} ${e.motionEaseInOut}`,
            willChange: 'transform, width',
          },
        },
      ),
    }
  },
  j0 = (e) => {
    const {
      colorTextLabel: t,
      colorText: i,
      colorFillSecondary: s,
      colorBgElevated: n,
      colorFill: r,
      lineWidthBold: o,
      colorBgLayout: a,
    } = e
    return {
      trackPadding: o,
      trackBg: a,
      itemColor: t,
      itemHoverColor: i,
      itemHoverBg: s,
      itemSelectedBg: n,
      itemActiveBg: r,
      itemSelectedColor: i,
    }
  },
  Y0 = dn(
    'Segmented',
    (e) => {
      const { lineWidth: t, calc: i } = e,
        s = Jt(e, {
          segmentedPaddingHorizontal: i(e.controlPaddingHorizontal)
            .sub(t)
            .equal(),
          segmentedPaddingHorizontalSM: i(e.controlPaddingHorizontalSM)
            .sub(t)
            .equal(),
        })
      return [U0(s)]
    },
    j0,
  )
var $h = function (e, t) {
  var i = {}
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) &&
      t.indexOf(s) < 0 &&
      (i[s] = e[s])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
      t.indexOf(s[n]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
        (i[s[n]] = e[s[n]])
  return i
}
function K0(e) {
  return typeof e == 'object' && !!(e != null && e.icon)
}
const q0 = d.forwardRef((e, t) => {
    const {
        prefixCls: i,
        className: s,
        rootClassName: n,
        block: r,
        options: o = [],
        size: a = 'middle',
        style: l,
        vertical: c,
      } = e,
      u = $h(e, [
        'prefixCls',
        'className',
        'rootClassName',
        'block',
        'options',
        'size',
        'style',
        'vertical',
      ]),
      { getPrefixCls: h, direction: g, segmented: f } = d.useContext(qt),
      p = h('segmented', i),
      [v, m, C] = Y0(p),
      w = Us(a),
      S = d.useMemo(
        () =>
          o.map((R) => {
            if (K0(R)) {
              const { icon: b, label: x } = R,
                D = $h(R, ['icon', 'label'])
              return Object.assign(Object.assign({}, D), {
                label: d.createElement(
                  d.Fragment,
                  null,
                  d.createElement('span', { className: `${p}-item-icon` }, b),
                  x && d.createElement('span', null, x),
                ),
              })
            }
            return R
          }),
        [o, p],
      ),
      y = pe(
        s,
        n,
        f == null ? void 0 : f.className,
        {
          [`${p}-block`]: r,
          [`${p}-sm`]: w === 'small',
          [`${p}-lg`]: w === 'large',
          [`${p}-vertical`]: c,
        },
        m,
        C,
      ),
      F = Object.assign(Object.assign({}, f == null ? void 0 : f.style), l)
    return v(
      d.createElement(
        $0,
        Object.assign({}, u, {
          className: y,
          style: F,
          options: S,
          ref: t,
          prefixCls: p,
          direction: g,
          vertical: c,
        }),
      ),
    )
  }),
  Q0 = q0
function X0(e) {
  return !!(e.addonBefore || e.addonAfter)
}
function J0(e) {
  return !!(e.prefix || e.suffix || e.allowClear)
}
function zh(e, t, i) {
  var s = t.cloneNode(!0),
    n = Object.create(e, { target: { value: s }, currentTarget: { value: s } })
  return (
    (s.value = i),
    typeof t.selectionStart == 'number' &&
      typeof t.selectionEnd == 'number' &&
      ((s.selectionStart = t.selectionStart),
      (s.selectionEnd = t.selectionEnd)),
    (s.setSelectionRange = function () {
      t.setSelectionRange.apply(t, arguments)
    }),
    n
  )
}
function xa(e, t, i, s) {
  if (i) {
    var n = t
    if (t.type === 'click') {
      ;(n = zh(t, e, '')), i(n)
      return
    }
    if (e.type !== 'file' && s !== void 0) {
      ;(n = zh(t, e, s)), i(n)
      return
    }
    i(n)
  }
}
function Z0(e, t) {
  if (e) {
    e.focus(t)
    var i = t || {},
      s = i.cursor
    if (s) {
      var n = e.value.length
      switch (s) {
        case 'start':
          e.setSelectionRange(0, 0)
          break
        case 'end':
          e.setSelectionRange(n, n)
          break
        default:
          e.setSelectionRange(0, n)
      }
    }
  }
}
var Ap = $.forwardRef(function (e, t) {
    var i,
      s,
      n = e.inputElement,
      r = e.children,
      o = e.prefixCls,
      a = e.prefix,
      l = e.suffix,
      c = e.addonBefore,
      u = e.addonAfter,
      h = e.className,
      g = e.style,
      f = e.disabled,
      p = e.readOnly,
      v = e.focused,
      m = e.triggerFocus,
      C = e.allowClear,
      w = e.value,
      S = e.handleReset,
      y = e.hidden,
      F = e.classes,
      R = e.classNames,
      b = e.dataAttrs,
      x = e.styles,
      D = e.components,
      O = e.onClear,
      M = r ?? n,
      L = (D == null ? void 0 : D.affixWrapper) || 'span',
      V = (D == null ? void 0 : D.groupWrapper) || 'span',
      A = (D == null ? void 0 : D.wrapper) || 'span',
      I = (D == null ? void 0 : D.groupAddon) || 'span',
      P = d.useRef(null),
      k = function (q) {
        var ne
        ;(ne = P.current) !== null &&
          ne !== void 0 &&
          ne.contains(q.target) &&
          (m == null || m())
      },
      E = J0(e),
      N = d.cloneElement(M, {
        value: w,
        className:
          pe(M.props.className, !E && (R == null ? void 0 : R.variant)) || null,
      }),
      T = d.useRef(null)
    if (
      ($.useImperativeHandle(t, function () {
        return { nativeElement: T.current || P.current }
      }),
      E)
    ) {
      var G = null
      if (C) {
        var H = !f && !p && w,
          _ = ''.concat(o, '-clear-icon'),
          B =
            Zt(C) === 'object' && C !== null && C !== void 0 && C.clearIcon
              ? C.clearIcon
              : ''
        G = $.createElement(
          'span',
          {
            onClick: function (q) {
              S == null || S(q), O == null || O()
            },
            onMouseDown: function (q) {
              return q.preventDefault()
            },
            className: pe(
              _,
              ce(
                ce({}, ''.concat(_, '-hidden'), !H),
                ''.concat(_, '-has-suffix'),
                !!l,
              ),
            ),
            role: 'button',
            tabIndex: -1,
          },
          B,
        )
      }
      var z = ''.concat(o, '-affix-wrapper'),
        Q = pe(
          z,
          ce(
            ce(
              ce(
                ce(
                  ce({}, ''.concat(o, '-disabled'), f),
                  ''.concat(z, '-disabled'),
                  f,
                ),
                ''.concat(z, '-focused'),
                v,
              ),
              ''.concat(z, '-readonly'),
              p,
            ),
            ''.concat(z, '-input-with-clear-btn'),
            l && C && w,
          ),
          F == null ? void 0 : F.affixWrapper,
          R == null ? void 0 : R.affixWrapper,
          R == null ? void 0 : R.variant,
        ),
        J =
          (l || C) &&
          $.createElement(
            'span',
            {
              className: pe(
                ''.concat(o, '-suffix'),
                R == null ? void 0 : R.suffix,
              ),
              style: x == null ? void 0 : x.suffix,
            },
            G,
            l,
          )
      N = $.createElement(
        L,
        xe(
          {
            className: Q,
            style: x == null ? void 0 : x.affixWrapper,
            onClick: k,
          },
          b == null ? void 0 : b.affixWrapper,
          { ref: P },
        ),
        a &&
          $.createElement(
            'span',
            {
              className: pe(
                ''.concat(o, '-prefix'),
                R == null ? void 0 : R.prefix,
              ),
              style: x == null ? void 0 : x.prefix,
            },
            a,
          ),
        N,
        J,
      )
    }
    if (X0(e)) {
      var se = ''.concat(o, '-group'),
        ie = ''.concat(se, '-addon'),
        U = ''.concat(se, '-wrapper'),
        W = pe(
          ''.concat(o, '-wrapper'),
          se,
          F == null ? void 0 : F.wrapper,
          R == null ? void 0 : R.wrapper,
        ),
        j = pe(
          U,
          ce({}, ''.concat(U, '-disabled'), f),
          F == null ? void 0 : F.group,
          R == null ? void 0 : R.groupWrapper,
        )
      N = $.createElement(
        V,
        { className: j, ref: T },
        $.createElement(
          A,
          { className: W },
          c && $.createElement(I, { className: ie }, c),
          N,
          u && $.createElement(I, { className: ie }, u),
        ),
      )
    }
    return $.cloneElement(N, {
      className:
        pe((i = N.props) === null || i === void 0 ? void 0 : i.className, h) ||
        null,
      style: re(
        re({}, (s = N.props) === null || s === void 0 ? void 0 : s.style),
        g,
      ),
      hidden: y,
    })
  }),
  eF = ['show']
function Op(e, t) {
  return d.useMemo(
    function () {
      var i = {}
      t && (i.show = Zt(t) === 'object' && t.formatter ? t.formatter : !!t),
        (i = re(re({}, i), e))
      var s = i,
        n = s.show,
        r = Kt(s, eF)
      return re(
        re({}, r),
        {},
        {
          show: !!n,
          showFormatter: typeof n == 'function' ? n : void 0,
          strategy:
            r.strategy ||
            function (o) {
              return o.length
            },
        },
      )
    },
    [e, t],
  )
}
var tF = [
    'autoComplete',
    'onChange',
    'onFocus',
    'onBlur',
    'onPressEnter',
    'onKeyDown',
    'onKeyUp',
    'prefixCls',
    'disabled',
    'htmlSize',
    'className',
    'maxLength',
    'suffix',
    'showCount',
    'count',
    'type',
    'classes',
    'classNames',
    'styles',
    'onCompositionStart',
    'onCompositionEnd',
  ],
  iF = d.forwardRef(function (e, t) {
    var i = e.autoComplete,
      s = e.onChange,
      n = e.onFocus,
      r = e.onBlur,
      o = e.onPressEnter,
      a = e.onKeyDown,
      l = e.onKeyUp,
      c = e.prefixCls,
      u = c === void 0 ? 'rc-input' : c,
      h = e.disabled,
      g = e.htmlSize,
      f = e.className,
      p = e.maxLength,
      v = e.suffix,
      m = e.showCount,
      C = e.count,
      w = e.type,
      S = w === void 0 ? 'text' : w,
      y = e.classes,
      F = e.classNames,
      R = e.styles,
      b = e.onCompositionStart,
      x = e.onCompositionEnd,
      D = Kt(e, tF),
      O = d.useState(!1),
      M = Z(O, 2),
      L = M[0],
      V = M[1],
      A = d.useRef(!1),
      I = d.useRef(!1),
      P = d.useRef(null),
      k = d.useRef(null),
      E = function (ve) {
        P.current && Z0(P.current, ve)
      },
      N = ai(e.defaultValue, { value: e.value }),
      T = Z(N, 2),
      G = T[0],
      H = T[1],
      _ = G == null ? '' : String(G),
      B = d.useState(null),
      z = Z(B, 2),
      Q = z[0],
      J = z[1],
      se = Op(C, m),
      ie = se.max || p,
      U = se.strategy(_),
      W = !!ie && U > ie
    d.useImperativeHandle(t, function () {
      var Fe
      return {
        focus: E,
        blur: function () {
          var Be
          ;(Be = P.current) === null || Be === void 0 || Be.blur()
        },
        setSelectionRange: function (Be, Se, we) {
          var ze
          ;(ze = P.current) === null ||
            ze === void 0 ||
            ze.setSelectionRange(Be, Se, we)
        },
        select: function () {
          var Be
          ;(Be = P.current) === null || Be === void 0 || Be.select()
        },
        input: P.current,
        nativeElement:
          ((Fe = k.current) === null || Fe === void 0
            ? void 0
            : Fe.nativeElement) || P.current,
      }
    }),
      d.useEffect(
        function () {
          V(function (Fe) {
            return Fe && h ? !1 : Fe
          })
        },
        [h],
      )
    var j = function (ve, Be, Se) {
      var we = Be
      if (
        !A.current &&
        se.exceedFormatter &&
        se.max &&
        se.strategy(Be) > se.max
      ) {
        if (((we = se.exceedFormatter(Be, { max: se.max })), Be !== we)) {
          var ze, Ue
          J([
            ((ze = P.current) === null || ze === void 0
              ? void 0
              : ze.selectionStart) || 0,
            ((Ue = P.current) === null || Ue === void 0
              ? void 0
              : Ue.selectionEnd) || 0,
          ])
        }
      } else if (Se.source === 'compositionEnd') return
      H(we), P.current && xa(P.current, ve, s, we)
    }
    d.useEffect(
      function () {
        if (Q) {
          var Fe
          ;(Fe = P.current) === null ||
            Fe === void 0 ||
            Fe.setSelectionRange.apply(Fe, St(Q))
        }
      },
      [Q],
    )
    var K = function (ve) {
        j(ve, ve.target.value, { source: 'change' })
      },
      q = function (ve) {
        ;(A.current = !1),
          j(ve, ve.currentTarget.value, { source: 'compositionEnd' }),
          x == null || x(ve)
      },
      ne = function (ve) {
        o && ve.key === 'Enter' && !I.current && ((I.current = !0), o(ve)),
          a == null || a(ve)
      },
      oe = function (ve) {
        ve.key === 'Enter' && (I.current = !1), l == null || l(ve)
      },
      le = function (ve) {
        V(!0), n == null || n(ve)
      },
      me = function (ve) {
        V(!1), r == null || r(ve)
      },
      ye = function (ve) {
        H(''), E(), P.current && xa(P.current, ve, s)
      },
      Me = W && ''.concat(u, '-out-of-range'),
      He = function () {
        var ve = zs(e, [
          'prefixCls',
          'onPressEnter',
          'addonBefore',
          'addonAfter',
          'prefix',
          'suffix',
          'allowClear',
          'defaultValue',
          'showCount',
          'count',
          'classes',
          'htmlSize',
          'styles',
          'classNames',
          'onClear',
        ])
        return $.createElement(
          'input',
          xe({ autoComplete: i }, ve, {
            onChange: K,
            onFocus: le,
            onBlur: me,
            onKeyDown: ne,
            onKeyUp: oe,
            className: pe(
              u,
              ce({}, ''.concat(u, '-disabled'), h),
              F == null ? void 0 : F.input,
            ),
            style: R == null ? void 0 : R.input,
            ref: P,
            size: g,
            type: S,
            onCompositionStart: function (Se) {
              ;(A.current = !0), b == null || b(Se)
            },
            onCompositionEnd: q,
          }),
        )
      },
      $e = function () {
        var ve = Number(ie) > 0
        if (v || se.show) {
          var Be = se.showFormatter
            ? se.showFormatter({ value: _, count: U, maxLength: ie })
            : ''.concat(U).concat(ve ? ' / '.concat(ie) : '')
          return $.createElement(
            $.Fragment,
            null,
            se.show &&
              $.createElement(
                'span',
                {
                  className: pe(
                    ''.concat(u, '-show-count-suffix'),
                    ce({}, ''.concat(u, '-show-count-has-suffix'), !!v),
                    F == null ? void 0 : F.count,
                  ),
                  style: re({}, R == null ? void 0 : R.count),
                },
                Be,
              ),
            v,
          )
        }
        return null
      }
    return $.createElement(
      Ap,
      xe({}, D, {
        prefixCls: u,
        className: pe(f, Me),
        handleReset: ye,
        value: _,
        focused: L,
        triggerFocus: E,
        suffix: $e(),
        disabled: h,
        classes: y,
        classNames: F,
        styles: R,
      }),
      He(),
    )
  })
const sF = (e) => {
    const { getPrefixCls: t, direction: i } = d.useContext(qt),
      { prefixCls: s, className: n } = e,
      r = t('input-group', s),
      o = t('input'),
      [a, l] = Wu(o),
      c = pe(
        r,
        {
          [`${r}-lg`]: e.size === 'large',
          [`${r}-sm`]: e.size === 'small',
          [`${r}-compact`]: e.compact,
          [`${r}-rtl`]: i === 'rtl',
        },
        l,
        n,
      ),
      u = d.useContext(Gs),
      h = d.useMemo(
        () => Object.assign(Object.assign({}, u), { isFormItemInput: !1 }),
        [u],
      )
    return a(
      d.createElement(
        'span',
        {
          className: c,
          style: e.style,
          onMouseEnter: e.onMouseEnter,
          onMouseLeave: e.onMouseLeave,
          onFocus: e.onFocus,
          onBlur: e.onBlur,
        },
        d.createElement(Gs.Provider, { value: h }, e.children),
      ),
    )
  },
  Lp = (e) => {
    let t
    return (
      typeof e == 'object' && e != null && e.clearIcon
        ? (t = e)
        : e && (t = { clearIcon: $.createElement(df, null) }),
      t
    )
  }
function kp(e, t) {
  const i = d.useRef([]),
    s = () => {
      i.current.push(
        setTimeout(() => {
          var n, r, o, a
          !((n = e.current) === null || n === void 0) &&
            n.input &&
            ((r = e.current) === null || r === void 0
              ? void 0
              : r.input.getAttribute('type')) === 'password' &&
            !((o = e.current) === null || o === void 0) &&
            o.input.hasAttribute('value') &&
            ((a = e.current) === null ||
              a === void 0 ||
              a.input.removeAttribute('value'))
        }),
      )
    }
  return (
    d.useEffect(
      () => (
        t && s(),
        () =>
          i.current.forEach((n) => {
            n && clearTimeout(n)
          })
      ),
      [],
    ),
    s
  )
}
function nF(e) {
  return !!(e.prefix || e.suffix || e.allowClear || e.showCount)
}
var rF = function (e, t) {
  var i = {}
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) &&
      t.indexOf(s) < 0 &&
      (i[s] = e[s])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
      t.indexOf(s[n]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
        (i[s[n]] = e[s[n]])
  return i
}
function oF(e, t) {
  if (!e) return
  e.focus(t)
  const { cursor: i } = t || {}
  if (i) {
    const s = e.value.length
    switch (i) {
      case 'start':
        e.setSelectionRange(0, 0)
        break
      case 'end':
        e.setSelectionRange(s, s)
        break
      default:
        e.setSelectionRange(0, s)
    }
  }
}
const ll = d.forwardRef((e, t) => {
    var i
    const {
        prefixCls: s,
        bordered: n = !0,
        status: r,
        size: o,
        disabled: a,
        onBlur: l,
        onFocus: c,
        suffix: u,
        allowClear: h,
        addonAfter: g,
        addonBefore: f,
        className: p,
        style: v,
        styles: m,
        rootClassName: C,
        onChange: w,
        classNames: S,
        variant: y,
      } = e,
      F = rF(e, [
        'prefixCls',
        'bordered',
        'status',
        'size',
        'disabled',
        'onBlur',
        'onFocus',
        'suffix',
        'allowClear',
        'addonAfter',
        'addonBefore',
        'className',
        'style',
        'styles',
        'rootClassName',
        'onChange',
        'classNames',
        'variant',
      ]),
      { getPrefixCls: R, direction: b, input: x } = $.useContext(qt),
      D = R('input', s),
      O = d.useRef(null),
      M = Sr(D),
      [L, V, A] = Wu(D, M),
      { compactSize: I, compactItemClassnames: P } = Cr(D, b),
      k = Us((K) => {
        var q
        return (q = o ?? I) !== null && q !== void 0 ? q : K
      }),
      E = $.useContext(Vn),
      N = a ?? E,
      { status: T, hasFeedback: G, feedbackIcon: H } = d.useContext(Gs),
      _ = wr(T, r),
      B = nF(e) || !!G
    d.useRef(B)
    const z = kp(O, !0),
      Q = (K) => {
        z(), l == null || l(K)
      },
      J = (K) => {
        z(), c == null || c(K)
      },
      se = (K) => {
        z(), w == null || w(K)
      },
      ie = (G || u) && $.createElement($.Fragment, null, u, G && H),
      U = Lp(h ?? (x == null ? void 0 : x.allowClear)),
      [W, j] = Io('input', y, n)
    return L(
      $.createElement(
        iF,
        Object.assign(
          {
            ref: $s(t, O),
            prefixCls: D,
            autoComplete: x == null ? void 0 : x.autoComplete,
          },
          F,
          {
            disabled: N,
            onBlur: Q,
            onFocus: J,
            style: Object.assign(
              Object.assign({}, x == null ? void 0 : x.style),
              v,
            ),
            styles: Object.assign(
              Object.assign({}, x == null ? void 0 : x.styles),
              m,
            ),
            suffix: ie,
            allowClear: U,
            className: pe(p, C, A, M, P, x == null ? void 0 : x.className),
            onChange: se,
            addonBefore: f && $.createElement(Ra, { form: !0, space: !0 }, f),
            addonAfter: g && $.createElement(Ra, { form: !0, space: !0 }, g),
            classNames: Object.assign(
              Object.assign(
                Object.assign({}, S),
                x == null ? void 0 : x.classNames,
              ),
              {
                input: pe(
                  {
                    [`${D}-sm`]: k === 'small',
                    [`${D}-lg`]: k === 'large',
                    [`${D}-rtl`]: b === 'rtl',
                  },
                  S == null ? void 0 : S.input,
                  (i = x == null ? void 0 : x.classNames) === null ||
                    i === void 0
                    ? void 0
                    : i.input,
                  V,
                ),
                variant: pe({ [`${D}-${W}`]: j }, gr(D, _)),
                affixWrapper: pe(
                  {
                    [`${D}-affix-wrapper-sm`]: k === 'small',
                    [`${D}-affix-wrapper-lg`]: k === 'large',
                    [`${D}-affix-wrapper-rtl`]: b === 'rtl',
                  },
                  V,
                ),
                wrapper: pe({ [`${D}-group-rtl`]: b === 'rtl' }, V),
                groupWrapper: pe(
                  {
                    [`${D}-group-wrapper-sm`]: k === 'small',
                    [`${D}-group-wrapper-lg`]: k === 'large',
                    [`${D}-group-wrapper-rtl`]: b === 'rtl',
                    [`${D}-group-wrapper-${W}`]: j,
                  },
                  gr(`${D}-group-wrapper`, _, G),
                  V,
                ),
              },
            ),
          },
        ),
      ),
    )
  }),
  aF = (e) => {
    const { componentCls: t, paddingXS: i } = e
    return {
      [t]: {
        display: 'inline-flex',
        alignItems: 'center',
        flexWrap: 'nowrap',
        columnGap: i,
        '&-rtl': { direction: 'rtl' },
        [`${t}-input`]: { textAlign: 'center', paddingInline: e.paddingXXS },
        [`&${t}-sm ${t}-input`]: {
          paddingInline: e.calc(e.paddingXXS).div(2).equal(),
        },
        [`&${t}-lg ${t}-input`]: { paddingInline: e.paddingXS },
      },
    }
  },
  lF = dn(
    ['Input', 'OTP'],
    (e) => {
      const t = Jt(e, Bu(e))
      return [aF(t)]
    },
    Vu,
  )
var cF = function (e, t) {
  var i = {}
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) &&
      t.indexOf(s) < 0 &&
      (i[s] = e[s])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
      t.indexOf(s[n]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
        (i[s[n]] = e[s[n]])
  return i
}
const uF = d.forwardRef((e, t) => {
  const { value: i, onChange: s, onActiveChange: n, index: r, mask: o } = e,
    a = cF(e, ['value', 'onChange', 'onActiveChange', 'index', 'mask']),
    l = i && typeof o == 'string' ? o : i,
    c = (p) => {
      s(r, p.target.value)
    },
    u = d.useRef(null)
  d.useImperativeHandle(t, () => u.current)
  const h = () => {
      bt(() => {
        var p
        const v = (p = u.current) === null || p === void 0 ? void 0 : p.input
        document.activeElement === v && v && v.select()
      })
    },
    g = (p) => {
      let { key: v } = p
      v === 'ArrowLeft' ? n(r - 1) : v === 'ArrowRight' && n(r + 1), h()
    },
    f = (p) => {
      p.key === 'Backspace' && !i && n(r - 1), h()
    }
  return d.createElement(
    ll,
    Object.assign({ type: o === !0 ? 'password' : 'text' }, a, {
      ref: u,
      value: l,
      onInput: c,
      onFocus: h,
      onKeyDown: g,
      onKeyUp: f,
      onMouseDown: h,
      onMouseUp: h,
    }),
  )
})
var dF = function (e, t) {
  var i = {}
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) &&
      t.indexOf(s) < 0 &&
      (i[s] = e[s])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
      t.indexOf(s[n]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
        (i[s[n]] = e[s[n]])
  return i
}
function Qo(e) {
  return (e || '').split('')
}
const hF = d.forwardRef((e, t) => {
  const {
      prefixCls: i,
      length: s = 6,
      size: n,
      defaultValue: r,
      value: o,
      onChange: a,
      formatter: l,
      variant: c,
      disabled: u,
      status: h,
      autoFocus: g,
      mask: f,
      type: p,
    } = e,
    v = dF(e, [
      'prefixCls',
      'length',
      'size',
      'defaultValue',
      'value',
      'onChange',
      'formatter',
      'variant',
      'disabled',
      'status',
      'autoFocus',
      'mask',
      'type',
    ]),
    { getPrefixCls: m, direction: C } = d.useContext(qt),
    w = m('otp', i),
    S = Bs(v, { aria: !0, data: !0, attr: !0 }),
    y = Sr(w),
    [F, R, b] = lF(w, y),
    x = Us((H) => n ?? H),
    D = d.useContext(Gs),
    O = wr(D.status, h),
    M = d.useMemo(
      () =>
        Object.assign(Object.assign({}, D), {
          status: O,
          hasFeedback: !1,
          feedbackIcon: null,
        }),
      [D, O],
    ),
    L = d.useRef(null),
    V = d.useRef({})
  d.useImperativeHandle(t, () => ({
    focus: () => {
      var H
      ;(H = V.current[0]) === null || H === void 0 || H.focus()
    },
    blur: () => {
      var H
      for (let _ = 0; _ < s; _ += 1)
        (H = V.current[_]) === null || H === void 0 || H.blur()
    },
    nativeElement: L.current,
  }))
  const A = (H) => (l ? l(H) : H),
    [I, P] = d.useState(Qo(A(r || '')))
  d.useEffect(() => {
    o !== void 0 && P(Qo(o))
  }, [o])
  const k = Bt((H) => {
      P(H),
        a &&
          H.length === s &&
          H.every((_) => _) &&
          H.some((_, B) => I[B] !== _) &&
          a(H.join(''))
    }),
    E = Bt((H, _) => {
      let B = St(I)
      for (let Q = 0; Q < H; Q += 1) B[Q] || (B[Q] = '')
      _.length <= 1 ? (B[H] = _) : (B = B.slice(0, H).concat(Qo(_))),
        (B = B.slice(0, s))
      for (let Q = B.length - 1; Q >= 0 && !B[Q]; Q -= 1) B.pop()
      const z = A(B.map((Q) => Q || ' ').join(''))
      return (B = Qo(z).map((Q, J) => (Q === ' ' && !B[J] ? B[J] : Q))), B
    }),
    N = (H, _) => {
      var B
      const z = E(H, _),
        Q = Math.min(H + _.length, s - 1)
      Q !== H && ((B = V.current[Q]) === null || B === void 0 || B.focus()),
        k(z)
    },
    T = (H) => {
      var _
      ;(_ = V.current[H]) === null || _ === void 0 || _.focus()
    },
    G = { variant: c, disabled: u, status: O, mask: f, type: p }
  return F(
    d.createElement(
      'div',
      Object.assign({}, S, {
        ref: L,
        className: pe(
          w,
          {
            [`${w}-sm`]: x === 'small',
            [`${w}-lg`]: x === 'large',
            [`${w}-rtl`]: C === 'rtl',
          },
          b,
          R,
        ),
      }),
      d.createElement(
        Gs.Provider,
        { value: M },
        Array.from({ length: s }).map((H, _) => {
          const B = `otp-${_}`,
            z = I[_] || ''
          return d.createElement(
            uF,
            Object.assign(
              {
                ref: (Q) => {
                  V.current[_] = Q
                },
                key: B,
                index: _,
                size: x,
                htmlSize: 1,
                className: `${w}-input`,
                onChange: N,
                value: z,
                onActiveChange: T,
                autoFocus: _ === 0 && g,
              },
              G,
            ),
          )
        }),
      ),
    ),
  )
})
var gF = {
    icon: {
      tag: 'svg',
      attrs: { viewBox: '64 64 896 896', focusable: 'false' },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z',
          },
        },
        {
          tag: 'path',
          attrs: {
            d: 'M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z',
          },
        },
      ],
    },
    name: 'eye-invisible',
    theme: 'outlined',
  },
  fF = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: gF }))
  },
  pF = d.forwardRef(fF),
  mF = {
    icon: {
      tag: 'svg',
      attrs: { viewBox: '64 64 896 896', focusable: 'false' },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z',
          },
        },
      ],
    },
    name: 'eye',
    theme: 'outlined',
  },
  vF = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: mF }))
  },
  CF = d.forwardRef(vF),
  SF = function (e, t) {
    var i = {}
    for (var s in e)
      Object.prototype.hasOwnProperty.call(e, s) &&
        t.indexOf(s) < 0 &&
        (i[s] = e[s])
    if (e != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
        t.indexOf(s[n]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
          (i[s[n]] = e[s[n]])
    return i
  }
const wF = (e) => (e ? d.createElement(CF, null) : d.createElement(pF, null)),
  yF = { click: 'onClick', hover: 'onMouseOver' },
  bF = d.forwardRef((e, t) => {
    const {
        disabled: i,
        action: s = 'click',
        visibilityToggle: n = !0,
        iconRender: r = wF,
      } = e,
      o = d.useContext(Vn),
      a = i ?? o,
      l = typeof n == 'object' && n.visible !== void 0,
      [c, u] = d.useState(() => (l ? n.visible : !1)),
      h = d.useRef(null)
    d.useEffect(() => {
      l && u(n.visible)
    }, [l, n])
    const g = kp(h),
      f = () => {
        a ||
          (c && g(),
          u((O) => {
            var M
            const L = !O
            return (
              typeof n == 'object' &&
                ((M = n.onVisibleChange) === null ||
                  M === void 0 ||
                  M.call(n, L)),
              L
            )
          }))
      },
      p = (O) => {
        const M = yF[s] || '',
          L = r(c),
          V = {
            [M]: f,
            className: `${O}-icon`,
            key: 'passwordIcon',
            onMouseDown: (A) => {
              A.preventDefault()
            },
            onMouseUp: (A) => {
              A.preventDefault()
            },
          }
        return d.cloneElement(
          d.isValidElement(L) ? L : d.createElement('span', null, L),
          V,
        )
      },
      { className: v, prefixCls: m, inputPrefixCls: C, size: w } = e,
      S = SF(e, ['className', 'prefixCls', 'inputPrefixCls', 'size']),
      { getPrefixCls: y } = d.useContext(qt),
      F = y('input', C),
      R = y('input-password', m),
      b = n && p(R),
      x = pe(R, v, { [`${R}-${w}`]: !!w }),
      D = Object.assign(
        Object.assign({}, zs(S, ['suffix', 'iconRender', 'visibilityToggle'])),
        {
          type: c ? 'text' : 'password',
          className: x,
          prefixCls: F,
          suffix: b,
        },
      )
    return (
      w && (D.size = w),
      d.createElement(ll, Object.assign({ ref: $s(t, h) }, D))
    )
  })
var RF = function (e, t) {
  var i = {}
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) &&
      t.indexOf(s) < 0 &&
      (i[s] = e[s])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
      t.indexOf(s[n]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
        (i[s[n]] = e[s[n]])
  return i
}
const FF = d.forwardRef((e, t) => {
  const {
      prefixCls: i,
      inputPrefixCls: s,
      className: n,
      size: r,
      suffix: o,
      enterButton: a = !1,
      addonAfter: l,
      loading: c,
      disabled: u,
      onSearch: h,
      onChange: g,
      onCompositionStart: f,
      onCompositionEnd: p,
    } = e,
    v = RF(e, [
      'prefixCls',
      'inputPrefixCls',
      'className',
      'size',
      'suffix',
      'enterButton',
      'addonAfter',
      'loading',
      'disabled',
      'onSearch',
      'onChange',
      'onCompositionStart',
      'onCompositionEnd',
    ]),
    { getPrefixCls: m, direction: C } = d.useContext(qt),
    w = d.useRef(!1),
    S = m('input-search', i),
    y = m('input', s),
    { compactSize: F } = Cr(S, C),
    R = Us((T) => {
      var G
      return (G = r ?? F) !== null && G !== void 0 ? G : T
    }),
    b = d.useRef(null),
    x = (T) => {
      T != null &&
        T.target &&
        T.type === 'click' &&
        h &&
        h(T.target.value, T, { source: 'clear' }),
        g == null || g(T)
    },
    D = (T) => {
      var G
      document.activeElement ===
        ((G = b.current) === null || G === void 0 ? void 0 : G.input) &&
        T.preventDefault()
    },
    O = (T) => {
      var G, H
      h &&
        h(
          (H = (G = b.current) === null || G === void 0 ? void 0 : G.input) ===
            null || H === void 0
            ? void 0
            : H.value,
          T,
          { source: 'input' },
        )
    },
    M = (T) => {
      w.current || c || O(T)
    },
    L = typeof a == 'boolean' ? d.createElement(Au, null) : null,
    V = `${S}-button`
  let A
  const I = a || {},
    P = I.type && I.type.__ANT_BUTTON === !0
  P || I.type === 'button'
    ? (A = wa(
        I,
        Object.assign(
          {
            onMouseDown: D,
            onClick: (T) => {
              var G, H
              ;(H =
                (G = I == null ? void 0 : I.props) === null || G === void 0
                  ? void 0
                  : G.onClick) === null ||
                H === void 0 ||
                H.call(G, T),
                O(T)
            },
            key: 'enterButton',
          },
          P ? { className: V, size: R } : {},
        ),
      ))
    : (A = d.createElement(
        Ds,
        {
          className: V,
          type: a ? 'primary' : void 0,
          size: R,
          disabled: u,
          key: 'enterButton',
          onMouseDown: D,
          onClick: O,
          loading: c,
          icon: L,
        },
        a,
      )),
    l && (A = [A, wa(l, { key: 'addonAfter' })])
  const k = pe(
      S,
      {
        [`${S}-rtl`]: C === 'rtl',
        [`${S}-${R}`]: !!R,
        [`${S}-with-button`]: !!a,
      },
      n,
    ),
    E = (T) => {
      ;(w.current = !0), f == null || f(T)
    },
    N = (T) => {
      ;(w.current = !1), p == null || p(T)
    }
  return d.createElement(
    ll,
    Object.assign({ ref: $s(b, t), onPressEnter: M }, v, {
      size: R,
      onCompositionStart: E,
      onCompositionEnd: N,
      prefixCls: y,
      addonAfter: A,
      suffix: o,
      onChange: x,
      className: k,
      disabled: u,
    }),
  )
})
var EF = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`,
  PF = [
    'letter-spacing',
    'line-height',
    'padding-top',
    'padding-bottom',
    'font-family',
    'font-weight',
    'font-size',
    'font-variant',
    'text-rendering',
    'text-transform',
    'width',
    'text-indent',
    'padding-left',
    'padding-right',
    'border-width',
    'box-sizing',
    'word-break',
    'white-space',
  ],
  Ql = {},
  Oi
function xF(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    i =
      e.getAttribute('id') ||
      e.getAttribute('data-reactid') ||
      e.getAttribute('name')
  if (t && Ql[i]) return Ql[i]
  var s = window.getComputedStyle(e),
    n =
      s.getPropertyValue('box-sizing') ||
      s.getPropertyValue('-moz-box-sizing') ||
      s.getPropertyValue('-webkit-box-sizing'),
    r =
      parseFloat(s.getPropertyValue('padding-bottom')) +
      parseFloat(s.getPropertyValue('padding-top')),
    o =
      parseFloat(s.getPropertyValue('border-bottom-width')) +
      parseFloat(s.getPropertyValue('border-top-width')),
    a = PF.map(function (c) {
      return ''.concat(c, ':').concat(s.getPropertyValue(c))
    }).join(';'),
    l = { sizingStyle: a, paddingSize: r, borderSize: o, boxSizing: n }
  return t && i && (Ql[i] = l), l
}
function DF(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null,
    s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null
  Oi ||
    ((Oi = document.createElement('textarea')),
    Oi.setAttribute('tab-index', '-1'),
    Oi.setAttribute('aria-hidden', 'true'),
    Oi.setAttribute('name', 'hiddenTextarea'),
    document.body.appendChild(Oi)),
    e.getAttribute('wrap')
      ? Oi.setAttribute('wrap', e.getAttribute('wrap'))
      : Oi.removeAttribute('wrap')
  var n = xF(e, t),
    r = n.paddingSize,
    o = n.borderSize,
    a = n.boxSizing,
    l = n.sizingStyle
  Oi.setAttribute('style', ''.concat(l, ';').concat(EF)),
    (Oi.value = e.value || e.placeholder || '')
  var c = void 0,
    u = void 0,
    h,
    g = Oi.scrollHeight
  if (
    (a === 'border-box' ? (g += o) : a === 'content-box' && (g -= r),
    i !== null || s !== null)
  ) {
    Oi.value = ' '
    var f = Oi.scrollHeight - r
    i !== null &&
      ((c = f * i),
      a === 'border-box' && (c = c + r + o),
      (g = Math.max(c, g))),
      s !== null &&
        ((u = f * s),
        a === 'border-box' && (u = u + r + o),
        (h = g > u ? '' : 'hidden'),
        (g = Math.min(u, g)))
  }
  var p = { height: g, overflowY: h, resize: 'none' }
  return c && (p.minHeight = c), u && (p.maxHeight = u), p
}
var MF = [
    'prefixCls',
    'defaultValue',
    'value',
    'autoSize',
    'onResize',
    'className',
    'style',
    'disabled',
    'onChange',
    'onInternalAutoSize',
  ],
  Xl = 0,
  Jl = 1,
  Zl = 2,
  IF = d.forwardRef(function (e, t) {
    var i = e,
      s = i.prefixCls,
      n = i.defaultValue,
      r = i.value,
      o = i.autoSize,
      a = i.onResize,
      l = i.className,
      c = i.style,
      u = i.disabled,
      h = i.onChange
    i.onInternalAutoSize
    var g = Kt(i, MF),
      f = ai(n, {
        value: r,
        postState: function (B) {
          return B ?? ''
        },
      }),
      p = Z(f, 2),
      v = p[0],
      m = p[1],
      C = function (B) {
        m(B.target.value), h == null || h(B)
      },
      w = d.useRef()
    d.useImperativeHandle(t, function () {
      return { textArea: w.current }
    })
    var S = d.useMemo(
        function () {
          return o && Zt(o) === 'object' ? [o.minRows, o.maxRows] : []
        },
        [o],
      ),
      y = Z(S, 2),
      F = y[0],
      R = y[1],
      b = !!o,
      x = function () {
        try {
          if (document.activeElement === w.current) {
            var B = w.current,
              z = B.selectionStart,
              Q = B.selectionEnd,
              J = B.scrollTop
            w.current.setSelectionRange(z, Q), (w.current.scrollTop = J)
          }
        } catch {}
      },
      D = d.useState(Zl),
      O = Z(D, 2),
      M = O[0],
      L = O[1],
      V = d.useState(),
      A = Z(V, 2),
      I = A[0],
      P = A[1],
      k = function () {
        L(Xl)
      }
    li(
      function () {
        b && k()
      },
      [r, F, R, b],
    ),
      li(
        function () {
          if (M === Xl) L(Jl)
          else if (M === Jl) {
            var _ = DF(w.current, !1, F, R)
            L(Zl), P(_)
          } else x()
        },
        [M],
      )
    var E = d.useRef(),
      N = function () {
        bt.cancel(E.current)
      },
      T = function (B) {
        M === Zl &&
          (a == null || a(B),
          o &&
            (N(),
            (E.current = bt(function () {
              k()
            }))))
      }
    d.useEffect(function () {
      return N
    }, [])
    var G = b ? I : null,
      H = re(re({}, c), G)
    return (
      (M === Xl || M === Jl) &&
        ((H.overflowY = 'hidden'), (H.overflowX = 'hidden')),
      d.createElement(
        Do,
        { onResize: T, disabled: !(o || a) },
        d.createElement(
          'textarea',
          xe({}, g, {
            ref: w,
            style: H,
            className: pe(s, l, ce({}, ''.concat(s, '-disabled'), u)),
            disabled: u,
            value: v,
            onChange: C,
          }),
        ),
      )
    )
  }),
  TF = [
    'defaultValue',
    'value',
    'onFocus',
    'onBlur',
    'onChange',
    'allowClear',
    'maxLength',
    'onCompositionStart',
    'onCompositionEnd',
    'suffix',
    'prefixCls',
    'showCount',
    'count',
    'className',
    'style',
    'disabled',
    'hidden',
    'classNames',
    'styles',
    'onResize',
    'onClear',
    'onPressEnter',
    'readOnly',
    'autoSize',
    'onKeyDown',
  ],
  AF = $.forwardRef(function (e, t) {
    var i,
      s = e.defaultValue,
      n = e.value,
      r = e.onFocus,
      o = e.onBlur,
      a = e.onChange,
      l = e.allowClear,
      c = e.maxLength,
      u = e.onCompositionStart,
      h = e.onCompositionEnd,
      g = e.suffix,
      f = e.prefixCls,
      p = f === void 0 ? 'rc-textarea' : f,
      v = e.showCount,
      m = e.count,
      C = e.className,
      w = e.style,
      S = e.disabled,
      y = e.hidden,
      F = e.classNames,
      R = e.styles,
      b = e.onResize,
      x = e.onClear,
      D = e.onPressEnter,
      O = e.readOnly,
      M = e.autoSize,
      L = e.onKeyDown,
      V = Kt(e, TF),
      A = ai(s, { value: n, defaultValue: s }),
      I = Z(A, 2),
      P = I[0],
      k = I[1],
      E = P == null ? '' : String(P),
      N = $.useState(!1),
      T = Z(N, 2),
      G = T[0],
      H = T[1],
      _ = $.useRef(!1),
      B = $.useState(null),
      z = Z(B, 2),
      Q = z[0],
      J = z[1],
      se = d.useRef(null),
      ie = d.useRef(null),
      U = function () {
        var ae
        return (ae = ie.current) === null || ae === void 0
          ? void 0
          : ae.textArea
      },
      W = function () {
        U().focus()
      }
    d.useImperativeHandle(t, function () {
      var ge
      return {
        resizableTextArea: ie.current,
        focus: W,
        blur: function () {
          U().blur()
        },
        nativeElement:
          ((ge = se.current) === null || ge === void 0
            ? void 0
            : ge.nativeElement) || U(),
      }
    }),
      d.useEffect(
        function () {
          H(function (ge) {
            return !S && ge
          })
        },
        [S],
      )
    var j = $.useState(null),
      K = Z(j, 2),
      q = K[0],
      ne = K[1]
    $.useEffect(
      function () {
        if (q) {
          var ge
          ;(ge = U()).setSelectionRange.apply(ge, St(q))
        }
      },
      [q],
    )
    var oe = Op(m, v),
      le = (i = oe.max) !== null && i !== void 0 ? i : c,
      me = Number(le) > 0,
      ye = oe.strategy(E),
      Me = !!le && ye > le,
      He = function (ae, be) {
        var De = be
        !_.current &&
          oe.exceedFormatter &&
          oe.max &&
          oe.strategy(be) > oe.max &&
          ((De = oe.exceedFormatter(be, { max: oe.max })),
          be !== De && ne([U().selectionStart || 0, U().selectionEnd || 0])),
          k(De),
          xa(ae.currentTarget, ae, a, De)
      },
      $e = function (ae) {
        ;(_.current = !0), u == null || u(ae)
      },
      Fe = function (ae) {
        ;(_.current = !1), He(ae, ae.currentTarget.value), h == null || h(ae)
      },
      ve = function (ae) {
        He(ae, ae.target.value)
      },
      Be = function (ae) {
        ae.key === 'Enter' && D && D(ae), L == null || L(ae)
      },
      Se = function (ae) {
        H(!0), r == null || r(ae)
      },
      we = function (ae) {
        H(!1), o == null || o(ae)
      },
      ze = function (ae) {
        k(''), W(), xa(U(), ae, a)
      },
      Ue = g,
      ke
    oe.show &&
      (oe.showFormatter
        ? (ke = oe.showFormatter({ value: E, count: ye, maxLength: le }))
        : (ke = ''.concat(ye).concat(me ? ' / '.concat(le) : '')),
      (Ue = $.createElement(
        $.Fragment,
        null,
        Ue,
        $.createElement(
          'span',
          {
            className: pe(
              ''.concat(p, '-data-count'),
              F == null ? void 0 : F.count,
            ),
            style: R == null ? void 0 : R.count,
          },
          ke,
        ),
      )))
    var Xe = function (ae) {
        var be
        b == null || b(ae),
          (be = U()) !== null && be !== void 0 && be.style.height && J(!0)
      },
      Ye = !M && !v && !l
    return $.createElement(
      Ap,
      {
        ref: se,
        value: E,
        allowClear: l,
        handleReset: ze,
        suffix: Ue,
        prefixCls: p,
        classNames: re(
          re({}, F),
          {},
          {
            affixWrapper: pe(
              F == null ? void 0 : F.affixWrapper,
              ce(
                ce({}, ''.concat(p, '-show-count'), v),
                ''.concat(p, '-textarea-allow-clear'),
                l,
              ),
            ),
          },
        ),
        disabled: S,
        focused: G,
        className: pe(C, Me && ''.concat(p, '-out-of-range')),
        style: re(re({}, w), Q && !Ye ? { height: 'auto' } : {}),
        dataAttrs: {
          affixWrapper: { 'data-count': typeof ke == 'string' ? ke : void 0 },
        },
        hidden: y,
        readOnly: O,
        onClear: x,
      },
      $.createElement(
        IF,
        xe({}, V, {
          autoSize: M,
          maxLength: c,
          onKeyDown: Be,
          onChange: ve,
          onFocus: Se,
          onBlur: we,
          onCompositionStart: $e,
          onCompositionEnd: Fe,
          className: pe(F == null ? void 0 : F.textarea),
          style: re(
            re({}, R == null ? void 0 : R.textarea),
            {},
            { resize: w == null ? void 0 : w.resize },
          ),
          disabled: S,
          prefixCls: p,
          onResize: Xe,
          ref: ie,
          readOnly: O,
        }),
      ),
    )
  }),
  OF = function (e, t) {
    var i = {}
    for (var s in e)
      Object.prototype.hasOwnProperty.call(e, s) &&
        t.indexOf(s) < 0 &&
        (i[s] = e[s])
    if (e != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
        t.indexOf(s[n]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
          (i[s[n]] = e[s[n]])
    return i
  }
const LF = d.forwardRef((e, t) => {
    var i, s
    const {
        prefixCls: n,
        bordered: r = !0,
        size: o,
        disabled: a,
        status: l,
        allowClear: c,
        classNames: u,
        rootClassName: h,
        className: g,
        style: f,
        styles: p,
        variant: v,
      } = e,
      m = OF(e, [
        'prefixCls',
        'bordered',
        'size',
        'disabled',
        'status',
        'allowClear',
        'classNames',
        'rootClassName',
        'className',
        'style',
        'styles',
        'variant',
      ]),
      { getPrefixCls: C, direction: w, textArea: S } = d.useContext(qt),
      y = Us(o),
      F = d.useContext(Vn),
      R = a ?? F,
      { status: b, hasFeedback: x, feedbackIcon: D } = d.useContext(Gs),
      O = wr(b, l),
      M = d.useRef(null)
    d.useImperativeHandle(t, () => {
      var T
      return {
        resizableTextArea:
          (T = M.current) === null || T === void 0
            ? void 0
            : T.resizableTextArea,
        focus: (G) => {
          var H, _
          oF(
            (_ =
              (H = M.current) === null || H === void 0
                ? void 0
                : H.resizableTextArea) === null || _ === void 0
              ? void 0
              : _.textArea,
            G,
          )
        },
        blur: () => {
          var G
          return (G = M.current) === null || G === void 0 ? void 0 : G.blur()
        },
      }
    })
    const L = C('input', n),
      V = Sr(L),
      [A, I, P] = Wu(L, V),
      [k, E] = Io('textArea', v, r),
      N = Lp(c ?? (S == null ? void 0 : S.allowClear))
    return A(
      d.createElement(
        AF,
        Object.assign(
          { autoComplete: S == null ? void 0 : S.autoComplete },
          m,
          {
            style: Object.assign(
              Object.assign({}, S == null ? void 0 : S.style),
              f,
            ),
            styles: Object.assign(
              Object.assign({}, S == null ? void 0 : S.styles),
              p,
            ),
            disabled: R,
            allowClear: N,
            className: pe(P, V, g, h, S == null ? void 0 : S.className),
            classNames: Object.assign(
              Object.assign(
                Object.assign({}, u),
                S == null ? void 0 : S.classNames,
              ),
              {
                textarea: pe(
                  { [`${L}-sm`]: y === 'small', [`${L}-lg`]: y === 'large' },
                  I,
                  u == null ? void 0 : u.textarea,
                  (i = S == null ? void 0 : S.classNames) === null ||
                    i === void 0
                    ? void 0
                    : i.textarea,
                ),
                variant: pe({ [`${L}-${k}`]: E }, gr(L, O)),
                affixWrapper: pe(
                  `${L}-textarea-affix-wrapper`,
                  {
                    [`${L}-affix-wrapper-rtl`]: w === 'rtl',
                    [`${L}-affix-wrapper-sm`]: y === 'small',
                    [`${L}-affix-wrapper-lg`]: y === 'large',
                    [`${L}-textarea-show-count`]:
                      e.showCount ||
                      ((s = e.count) === null || s === void 0
                        ? void 0
                        : s.show),
                  },
                  I,
                ),
              },
            ),
            prefixCls: L,
            suffix:
              x &&
              d.createElement('span', { className: `${L}-textarea-suffix` }, D),
            ref: M,
          },
        ),
      ),
    )
  }),
  Fr = ll
Fr.Group = sF
Fr.Search = FF
Fr.TextArea = LF
Fr.Password = bF
Fr.OTP = hF
var kF = {
    icon: {
      tag: 'svg',
      attrs: { viewBox: '64 64 896 896', focusable: 'false' },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z',
          },
        },
      ],
    },
    name: 'calendar',
    theme: 'outlined',
  },
  HF = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: kF }))
  },
  Hp = d.forwardRef(HF),
  NF = {
    icon: {
      tag: 'svg',
      attrs: { viewBox: '64 64 896 896', focusable: 'false' },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z',
          },
        },
        {
          tag: 'path',
          attrs: {
            d: 'M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z',
          },
        },
      ],
    },
    name: 'clock-circle',
    theme: 'outlined',
  },
  GF = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: NF }))
  },
  Np = d.forwardRef(GF),
  BF = {
    icon: {
      tag: 'svg',
      attrs: { viewBox: '0 0 1024 1024', focusable: 'false' },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z',
          },
        },
      ],
    },
    name: 'swap-right',
    theme: 'outlined',
  },
  VF = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: BF }))
  },
  _F = d.forwardRef(VF)
function WF(e, t, i) {
  return i !== void 0
    ? i
    : t === 'year' && e.lang.yearPlaceholder
      ? e.lang.yearPlaceholder
      : t === 'quarter' && e.lang.quarterPlaceholder
        ? e.lang.quarterPlaceholder
        : t === 'month' && e.lang.monthPlaceholder
          ? e.lang.monthPlaceholder
          : t === 'week' && e.lang.weekPlaceholder
            ? e.lang.weekPlaceholder
            : t === 'time' && e.timePickerLocale.placeholder
              ? e.timePickerLocale.placeholder
              : e.lang.placeholder
}
function $F(e, t, i) {
  return i !== void 0
    ? i
    : t === 'year' && e.lang.yearPlaceholder
      ? e.lang.rangeYearPlaceholder
      : t === 'quarter' && e.lang.quarterPlaceholder
        ? e.lang.rangeQuarterPlaceholder
        : t === 'month' && e.lang.monthPlaceholder
          ? e.lang.rangeMonthPlaceholder
          : t === 'week' && e.lang.weekPlaceholder
            ? e.lang.rangeWeekPlaceholder
            : t === 'time' && e.timePickerLocale.placeholder
              ? e.timePickerLocale.rangePlaceholder
              : e.lang.rangePlaceholder
}
function $u(e, t) {
  const i = { adjustX: 1, adjustY: 1 }
  switch (t) {
    case 'bottomLeft':
      return { points: ['tl', 'bl'], offset: [0, 4], overflow: i }
    case 'bottomRight':
      return { points: ['tr', 'br'], offset: [0, 4], overflow: i }
    case 'topLeft':
      return { points: ['bl', 'tl'], offset: [0, -4], overflow: i }
    case 'topRight':
      return { points: ['br', 'tr'], offset: [0, -4], overflow: i }
    default:
      return {
        points: e === 'rtl' ? ['tr', 'br'] : ['tl', 'bl'],
        offset: [0, 4],
        overflow: i,
      }
  }
}
function Gp(e, t) {
  const { allowClear: i = !0 } = e,
    { clearIcon: s, removeIcon: n } = Hf(
      Object.assign(Object.assign({}, e), {
        prefixCls: t,
        componentName: 'DatePicker',
      }),
    )
  return [
    d.useMemo(
      () =>
        i === !1 ? !1 : Object.assign({ clearIcon: s }, i === !0 ? {} : i),
      [i, s],
    ),
    n,
  ]
}
const [zF, UF] = ['week', 'WeekPicker'],
  [jF, YF] = ['month', 'MonthPicker'],
  [KF, qF] = ['year', 'YearPicker'],
  [QF, XF] = ['quarter', 'QuarterPicker'],
  [Bp, Uh] = ['time', 'TimePicker'],
  JF = (e) =>
    d.createElement(Ds, Object.assign({ size: 'small', type: 'primary' }, e))
function Vp(e) {
  return d.useMemo(() => Object.assign({ button: JF }, e), [e])
}
var ZF = function (e, t) {
  var i = {}
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) &&
      t.indexOf(s) < 0 &&
      (i[s] = e[s])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
      t.indexOf(s[n]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
        (i[s[n]] = e[s[n]])
  return i
}
const eE = (e) =>
  d.forwardRef((i, s) => {
    var n
    const {
        prefixCls: r,
        getPopupContainer: o,
        components: a,
        className: l,
        style: c,
        placement: u,
        size: h,
        disabled: g,
        bordered: f = !0,
        placeholder: p,
        popupClassName: v,
        dropdownClassName: m,
        status: C,
        rootClassName: w,
        variant: S,
        picker: y,
      } = i,
      F = ZF(i, [
        'prefixCls',
        'getPopupContainer',
        'components',
        'className',
        'style',
        'placement',
        'size',
        'disabled',
        'bordered',
        'placeholder',
        'popupClassName',
        'dropdownClassName',
        'status',
        'rootClassName',
        'variant',
        'picker',
      ]),
      R = d.useRef(null),
      {
        getPrefixCls: b,
        direction: x,
        getPopupContainer: D,
        rangePicker: O,
      } = d.useContext(qt),
      M = b('picker', r),
      { compactSize: L, compactItemClassnames: V } = Cr(M, x),
      A = b(),
      [I, P] = Io('rangePicker', S, f),
      k = Sr(M),
      [E, N, T] = Tp(M, k),
      [G] = Gp(i, M),
      H = Vp(a),
      _ = Us((q) => {
        var ne
        return (ne = h ?? L) !== null && ne !== void 0 ? ne : q
      }),
      B = d.useContext(Vn),
      z = g ?? B,
      Q = d.useContext(Gs),
      { hasFeedback: J, status: se, feedbackIcon: ie } = Q,
      U = d.createElement(
        d.Fragment,
        null,
        y === Bp ? d.createElement(Np, null) : d.createElement(Hp, null),
        J && ie,
      )
    d.useImperativeHandle(s, () => R.current)
    const [W] = wu('Calendar', lf),
      j = Object.assign(Object.assign({}, W), i.locale),
      [K] = Su(
        'DatePicker',
        (n = i.popupStyle) === null || n === void 0 ? void 0 : n.zIndex,
      )
    return E(
      d.createElement(
        Ra,
        { space: !0 },
        d.createElement(
          o0,
          Object.assign(
            {
              separator: d.createElement(
                'span',
                { 'aria-label': 'to', className: `${M}-separator` },
                d.createElement(_F, null),
              ),
              disabled: z,
              ref: R,
              popupAlign: $u(x, u),
              placement: u,
              placeholder: $F(j, y, p),
              suffixIcon: U,
              prevIcon: d.createElement('span', {
                className: `${M}-prev-icon`,
              }),
              nextIcon: d.createElement('span', {
                className: `${M}-next-icon`,
              }),
              superPrevIcon: d.createElement('span', {
                className: `${M}-super-prev-icon`,
              }),
              superNextIcon: d.createElement('span', {
                className: `${M}-super-next-icon`,
              }),
              transitionName: `${A}-slide-up`,
              picker: y,
            },
            F,
            {
              className: pe(
                { [`${M}-${_}`]: _, [`${M}-${I}`]: P },
                gr(M, wr(se, C), J),
                N,
                V,
                l,
                O == null ? void 0 : O.className,
                T,
                k,
                w,
              ),
              style: Object.assign(
                Object.assign({}, O == null ? void 0 : O.style),
                c,
              ),
              locale: j.lang,
              prefixCls: M,
              getPopupContainer: o || D,
              generateConfig: e,
              components: H,
              direction: x,
              classNames: { popup: pe(N, v || m, T, k, w) },
              styles: {
                popup: Object.assign(Object.assign({}, i.popupStyle), {
                  zIndex: K,
                }),
              },
              allowClear: G,
            },
          ),
        ),
      ),
    )
  })
var tE = function (e, t) {
  var i = {}
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) &&
      t.indexOf(s) < 0 &&
      (i[s] = e[s])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
      t.indexOf(s[n]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
        (i[s[n]] = e[s[n]])
  return i
}
const iE = (e) => {
    const t = (l, c) => {
        const u = c === Uh ? 'timePicker' : 'datePicker'
        return d.forwardRef((g, f) => {
          var p
          const {
              prefixCls: v,
              getPopupContainer: m,
              components: C,
              style: w,
              className: S,
              rootClassName: y,
              size: F,
              bordered: R,
              placement: b,
              placeholder: x,
              popupClassName: D,
              dropdownClassName: O,
              disabled: M,
              status: L,
              variant: V,
              onCalendarChange: A,
            } = g,
            I = tE(g, [
              'prefixCls',
              'getPopupContainer',
              'components',
              'style',
              'className',
              'rootClassName',
              'size',
              'bordered',
              'placement',
              'placeholder',
              'popupClassName',
              'dropdownClassName',
              'disabled',
              'status',
              'variant',
              'onCalendarChange',
            ]),
            {
              getPrefixCls: P,
              direction: k,
              getPopupContainer: E,
              [u]: N,
            } = d.useContext(qt),
            T = P('picker', v),
            { compactSize: G, compactItemClassnames: H } = Cr(T, k),
            _ = d.useRef(null),
            [B, z] = Io('datePicker', V, R),
            Q = Sr(T),
            [J, se, ie] = Tp(T, Q)
          d.useImperativeHandle(f, () => _.current)
          const U = { showToday: !0 },
            W = l || g.picker,
            j = P(),
            { onSelect: K, multiple: q } = I,
            ne = K && l === 'time' && !q,
            oe = (Xe, Ye, ge) => {
              A == null || A(Xe, Ye, ge), ne && K(Xe)
            },
            [le, me] = Gp(g, T),
            ye = Vp(C),
            Me = Us((Xe) => {
              var Ye
              return (Ye = F ?? G) !== null && Ye !== void 0 ? Ye : Xe
            }),
            He = d.useContext(Vn),
            $e = M ?? He,
            Fe = d.useContext(Gs),
            { hasFeedback: ve, status: Be, feedbackIcon: Se } = Fe,
            we = d.createElement(
              d.Fragment,
              null,
              W === 'time'
                ? d.createElement(Np, null)
                : d.createElement(Hp, null),
              ve && Se,
            ),
            [ze] = wu('DatePicker', lf),
            Ue = Object.assign(Object.assign({}, ze), g.locale),
            [ke] = Su(
              'DatePicker',
              (p = g.popupStyle) === null || p === void 0 ? void 0 : p.zIndex,
            )
          return J(
            d.createElement(
              Ra,
              { space: !0 },
              d.createElement(
                h0,
                Object.assign(
                  {
                    ref: _,
                    placeholder: WF(Ue, W, x),
                    suffixIcon: we,
                    dropdownAlign: $u(k, b),
                    placement: b,
                    prevIcon: d.createElement('span', {
                      className: `${T}-prev-icon`,
                    }),
                    nextIcon: d.createElement('span', {
                      className: `${T}-next-icon`,
                    }),
                    superPrevIcon: d.createElement('span', {
                      className: `${T}-super-prev-icon`,
                    }),
                    superNextIcon: d.createElement('span', {
                      className: `${T}-super-next-icon`,
                    }),
                    transitionName: `${j}-slide-up`,
                    picker: l,
                    onCalendarChange: oe,
                  },
                  U,
                  I,
                  {
                    locale: Ue.lang,
                    className: pe(
                      { [`${T}-${Me}`]: Me, [`${T}-${B}`]: z },
                      gr(T, wr(Be, L), ve),
                      se,
                      H,
                      N == null ? void 0 : N.className,
                      S,
                      ie,
                      Q,
                      y,
                    ),
                    style: Object.assign(
                      Object.assign({}, N == null ? void 0 : N.style),
                      w,
                    ),
                    prefixCls: T,
                    getPopupContainer: m || E,
                    generateConfig: e,
                    components: ye,
                    direction: k,
                    disabled: $e,
                    classNames: { popup: pe(se, ie, Q, y, D || O) },
                    styles: {
                      popup: Object.assign(Object.assign({}, g.popupStyle), {
                        zIndex: ke,
                      }),
                    },
                    allowClear: le,
                    removeIcon: me,
                  },
                ),
              ),
            ),
          )
        })
      },
      i = t(),
      s = t(zF, UF),
      n = t(jF, YF),
      r = t(KF, qF),
      o = t(QF, XF),
      a = t(Bp, Uh)
    return {
      DatePicker: i,
      WeekPicker: s,
      MonthPicker: n,
      YearPicker: r,
      TimePicker: a,
      QuarterPicker: o,
    }
  },
  _p = (e) => {
    const {
        DatePicker: t,
        WeekPicker: i,
        MonthPicker: s,
        YearPicker: n,
        TimePicker: r,
        QuarterPicker: o,
      } = iE(e),
      a = eE(e),
      l = t
    return (
      (l.WeekPicker = i),
      (l.MonthPicker = s),
      (l.YearPicker = n),
      (l.RangePicker = a),
      (l.TimePicker = r),
      (l.QuarterPicker = o),
      l
    )
  },
  Er = _p(mR)
function Wp(e) {
  const t = $u(e.direction, e.placement)
  return (
    (t.overflow.adjustY = !1),
    (t.overflow.adjustX = !1),
    Object.assign(Object.assign({}, e), { dropdownAlign: t })
  )
}
const sE = xu(Er, 'picker', null, Wp)
Er._InternalPanelDoNotUseOrYouWillBeFired = sE
const nE = xu(Er.RangePicker, 'picker', null, Wp)
Er._InternalRangePanelDoNotUseOrYouWillBeFired = nE
Er.generatePicker = _p
var rE = {
    icon: {
      tag: 'svg',
      attrs: { viewBox: '64 64 896 896', focusable: 'false' },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM504 618H320c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM312 490v48c0 4.4 3.6 8 8 8h384c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H320c-4.4 0-8 3.6-8 8z',
          },
        },
      ],
    },
    name: 'file-text',
    theme: 'outlined',
  },
  oE = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: rE }))
  },
  aE = d.forwardRef(oE),
  lE = {
    icon: {
      tag: 'svg',
      attrs: { viewBox: '64 64 896 896', focusable: 'false' },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z',
          },
        },
      ],
    },
    name: 'delete',
    theme: 'outlined',
  },
  cE = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: lE }))
  },
  uE = d.forwardRef(cE),
  dE = {
    icon: {
      tag: 'svg',
      attrs: { viewBox: '64 64 896 896', focusable: 'false' },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M893.3 293.3L730.7 130.7c-7.5-7.5-16.7-13-26.7-16V112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V338.5c0-17-6.7-33.2-18.7-45.2zM384 184h256v104H384V184zm456 656H184V184h136v136c0 17.7 14.3 32 32 32h320c17.7 0 32-14.3 32-32V205.8l136 136V840zM512 442c-79.5 0-144 64.5-144 144s64.5 144 144 144 144-64.5 144-144-64.5-144-144-144zm0 224c-44.2 0-80-35.8-80-80s35.8-80 80-80 80 35.8 80 80-35.8 80-80 80z',
          },
        },
      ],
    },
    name: 'save',
    theme: 'outlined',
  },
  hE = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: dE }))
  },
  gE = d.forwardRef(hE),
  fE = {
    icon: {
      tag: 'svg',
      attrs: { viewBox: '64 64 896 896', focusable: 'false' },
      children: [
        {
          tag: 'path',
          attrs: {
            d: 'M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 208H676V232h212v136zm0 224H676V432h212v160zM412 432h200v160H412V432zm200-64H412V232h200v136zm-476 64h212v160H136V432zm0-200h212v136H136V232zm0 424h212v136H136V656zm276 0h200v136H412V656zm476 136H676V656h212v136z',
          },
        },
      ],
    },
    name: 'table',
    theme: 'outlined',
  },
  pE = function (t, i) {
    return d.createElement(Fi, xe({}, t, { ref: i, icon: fE }))
  },
  mE = d.forwardRef(pE)
const vE = (e) => {
    const {
        paddingXXS: t,
        lineWidth: i,
        tagPaddingHorizontal: s,
        componentCls: n,
        calc: r,
      } = e,
      o = r(s).sub(i).equal(),
      a = r(t).sub(i).equal()
    return {
      [n]: Object.assign(Object.assign({}, Ns(e)), {
        display: 'inline-block',
        height: 'auto',
        marginInlineEnd: e.marginXS,
        paddingInline: o,
        fontSize: e.tagFontSize,
        lineHeight: e.tagLineHeight,
        whiteSpace: 'nowrap',
        background: e.defaultBg,
        border: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
        borderRadius: e.borderRadiusSM,
        opacity: 1,
        transition: `all ${e.motionDurationMid}`,
        textAlign: 'start',
        position: 'relative',
        [`&${n}-rtl`]: { direction: 'rtl' },
        '&, a, a:hover': { color: e.defaultColor },
        [`${n}-close-icon`]: {
          marginInlineStart: a,
          fontSize: e.tagIconSize,
          color: e.colorTextDescription,
          cursor: 'pointer',
          transition: `all ${e.motionDurationMid}`,
          '&:hover': { color: e.colorTextHeading },
        },
        [`&${n}-has-color`]: {
          borderColor: 'transparent',
          [`&, a, a:hover, ${e.iconCls}-close, ${e.iconCls}-close:hover`]: {
            color: e.colorTextLightSolid,
          },
        },
        '&-checkable': {
          backgroundColor: 'transparent',
          borderColor: 'transparent',
          cursor: 'pointer',
          [`&:not(${n}-checkable-checked):hover`]: {
            color: e.colorPrimary,
            backgroundColor: e.colorFillSecondary,
          },
          '&:active, &-checked': { color: e.colorTextLightSolid },
          '&-checked': {
            backgroundColor: e.colorPrimary,
            '&:hover': { backgroundColor: e.colorPrimaryHover },
          },
          '&:active': { backgroundColor: e.colorPrimaryActive },
        },
        '&-hidden': { display: 'none' },
        [`> ${e.iconCls} + span, > span + ${e.iconCls}`]: {
          marginInlineStart: o,
        },
      }),
      [`${n}-borderless`]: {
        borderColor: 'transparent',
        background: e.tagBorderlessBg,
      },
    }
  },
  zu = (e) => {
    const { lineWidth: t, fontSizeIcon: i, calc: s } = e,
      n = e.fontSizeSM
    return Jt(e, {
      tagFontSize: n,
      tagLineHeight: de(s(e.lineHeightSM).mul(n).equal()),
      tagIconSize: s(i).sub(s(t).mul(2)).equal(),
      tagPaddingHorizontal: 8,
      tagBorderlessBg: e.defaultBg,
    })
  },
  Uu = (e) => ({
    defaultBg: new Ts(e.colorFillQuaternary)
      .onBackground(e.colorBgContainer)
      .toHexString(),
    defaultColor: e.colorText,
  }),
  $p = dn(
    'Tag',
    (e) => {
      const t = zu(e)
      return vE(t)
    },
    Uu,
  )
var CE = function (e, t) {
  var i = {}
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) &&
      t.indexOf(s) < 0 &&
      (i[s] = e[s])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
      t.indexOf(s[n]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
        (i[s[n]] = e[s[n]])
  return i
}
const SE = d.forwardRef((e, t) => {
    const {
        prefixCls: i,
        style: s,
        className: n,
        checked: r,
        onChange: o,
        onClick: a,
      } = e,
      l = CE(e, [
        'prefixCls',
        'style',
        'className',
        'checked',
        'onChange',
        'onClick',
      ]),
      { getPrefixCls: c, tag: u } = d.useContext(qt),
      h = (C) => {
        o == null || o(!r), a == null || a(C)
      },
      g = c('tag', i),
      [f, p, v] = $p(g),
      m = pe(
        g,
        `${g}-checkable`,
        { [`${g}-checkable-checked`]: r },
        u == null ? void 0 : u.className,
        n,
        p,
        v,
      )
    return f(
      d.createElement(
        'span',
        Object.assign({}, l, {
          ref: t,
          style: Object.assign(
            Object.assign({}, s),
            u == null ? void 0 : u.style,
          ),
          className: m,
          onClick: h,
        }),
      ),
    )
  }),
  wE = (e) =>
    NS(e, (t, i) => {
      let { textColor: s, lightBorderColor: n, lightColor: r, darkColor: o } = i
      return {
        [`${e.componentCls}${e.componentCls}-${t}`]: {
          color: s,
          background: r,
          borderColor: n,
          '&-inverse': {
            color: e.colorTextLightSolid,
            background: o,
            borderColor: o,
          },
          [`&${e.componentCls}-borderless`]: { borderColor: 'transparent' },
        },
      }
    }),
  yE = Cu(
    ['Tag', 'preset'],
    (e) => {
      const t = zu(e)
      return wE(t)
    },
    Uu,
  )
function bE(e) {
  return typeof e != 'string' ? e : e.charAt(0).toUpperCase() + e.slice(1)
}
const Xo = (e, t, i) => {
    const s = bE(i)
    return {
      [`${e.componentCls}${e.componentCls}-${t}`]: {
        color: e[`color${i}`],
        background: e[`color${s}Bg`],
        borderColor: e[`color${s}Border`],
        [`&${e.componentCls}-borderless`]: { borderColor: 'transparent' },
      },
    }
  },
  RE = Cu(
    ['Tag', 'status'],
    (e) => {
      const t = zu(e)
      return [
        Xo(t, 'success', 'Success'),
        Xo(t, 'processing', 'Info'),
        Xo(t, 'error', 'Error'),
        Xo(t, 'warning', 'Warning'),
      ]
    },
    Uu,
  )
var FE = function (e, t) {
  var i = {}
  for (var s in e)
    Object.prototype.hasOwnProperty.call(e, s) &&
      t.indexOf(s) < 0 &&
      (i[s] = e[s])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var n = 0, s = Object.getOwnPropertySymbols(e); n < s.length; n++)
      t.indexOf(s[n]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, s[n]) &&
        (i[s[n]] = e[s[n]])
  return i
}
const EE = d.forwardRef((e, t) => {
    const {
        prefixCls: i,
        className: s,
        rootClassName: n,
        style: r,
        children: o,
        icon: a,
        color: l,
        onClose: c,
        bordered: u = !0,
        visible: h,
      } = e,
      g = FE(e, [
        'prefixCls',
        'className',
        'rootClassName',
        'style',
        'children',
        'icon',
        'color',
        'onClose',
        'bordered',
        'visible',
      ]),
      { getPrefixCls: f, direction: p, tag: v } = d.useContext(qt),
      [m, C] = d.useState(!0),
      w = zs(g, ['closeIcon', 'closable'])
    d.useEffect(() => {
      h !== void 0 && C(h)
    }, [h])
    const S = GS(l),
      y = BS(l),
      F = S || y,
      R = Object.assign(
        Object.assign(
          { backgroundColor: l && !F ? l : void 0 },
          v == null ? void 0 : v.style,
        ),
        r,
      ),
      b = f('tag', i),
      [x, D, O] = $p(b),
      M = pe(
        b,
        v == null ? void 0 : v.className,
        {
          [`${b}-${l}`]: F,
          [`${b}-has-color`]: l && !F,
          [`${b}-hidden`]: !m,
          [`${b}-rtl`]: p === 'rtl',
          [`${b}-borderless`]: !u,
        },
        s,
        n,
        D,
        O,
      ),
      L = (E) => {
        E.stopPropagation(), c == null || c(E), !E.defaultPrevented && C(!1)
      },
      [, V] = fy(fh(e), fh(v), {
        closable: !1,
        closeIconRender: (E) => {
          const N = d.createElement(
            'span',
            { className: `${b}-close-icon`, onClick: L },
            E,
          )
          return VS(E, N, (T) => ({
            onClick: (G) => {
              var H
              ;(H = T == null ? void 0 : T.onClick) === null ||
                H === void 0 ||
                H.call(T, G),
                L(G)
            },
            className: pe(T == null ? void 0 : T.className, `${b}-close-icon`),
          }))
        },
      }),
      A = typeof g.onClick == 'function' || (o && o.type === 'a'),
      I = a || null,
      P = I
        ? d.createElement(
            d.Fragment,
            null,
            I,
            o && d.createElement('span', null, o),
          )
        : o,
      k = d.createElement(
        'span',
        Object.assign({}, w, { ref: t, className: M, style: R }),
        P,
        V,
        S && d.createElement(yE, { key: 'preset', prefixCls: b }),
        y && d.createElement(RE, { key: 'status', prefixCls: b }),
      )
    return x(A ? d.createElement(ff, { component: 'Tag' }, k) : k)
  }),
  zp = EE
zp.CheckableTag = SE
const PE = () =>
  Oe.jsxs('svg', {
    className: 'w-4 h-4 opacity-65',
    viewBox: '0 0 24 24',
    fill: 'none',
    xmlns: 'http://www.w3.org/2000/svg',
    children: [
      Oe.jsx('path', {
        d: 'M22 6.5H16',
        stroke: '#292D32',
        strokeWidth: '1.5',
        strokeMiterlimit: '10',
        strokeLinecap: 'round',
        strokeLinejoin: 'round',
      }),
      Oe.jsx('path', {
        d: 'M6 6.5H2',
        stroke: '#292D32',
        strokeWidth: '1.5',
        strokeMiterlimit: '10',
        strokeLinecap: 'round',
        strokeLinejoin: 'round',
      }),
      Oe.jsx('path', {
        d: 'M10 10C11.933 10 13.5 8.433 13.5 6.5C13.5 4.567 11.933 3 10 3C8.067 3 6.5 4.567 6.5 6.5C6.5 8.433 8.067 10 10 10Z',
        stroke: '#292D32',
        strokeWidth: '1.5',
        strokeMiterlimit: '10',
        strokeLinecap: 'round',
        strokeLinejoin: 'round',
      }),
      Oe.jsx('path', {
        d: 'M22 17.5H18',
        stroke: '#292D32',
        strokeWidth: '1.5',
        strokeMiterlimit: '10',
        strokeLinecap: 'round',
        strokeLinejoin: 'round',
      }),
      Oe.jsx('path', {
        d: 'M8 17.5H2',
        stroke: '#292D32',
        strokeWidth: '1.5',
        strokeMiterlimit: '10',
        strokeLinecap: 'round',
        strokeLinejoin: 'round',
      }),
      Oe.jsx('path', {
        d: 'M14 21C15.933 21 17.5 19.433 17.5 17.5C17.5 15.567 15.933 14 14 14C12.067 14 10.5 15.567 10.5 17.5C10.5 19.433 12.067 21 14 21Z',
        stroke: '#292D32',
        strokeWidth: '1.5',
        strokeMiterlimit: '10',
        strokeLinecap: 'round',
        strokeLinejoin: 'round',
      }),
    ],
  })
function Up(e, t) {
  return function () {
    return e.apply(t, arguments)
  }
}
const { toString: xE } = Object.prototype,
  { getPrototypeOf: ju } = Object,
  cl = ((e) => (t) => {
    const i = xE.call(t)
    return e[i] || (e[i] = i.slice(8, -1).toLowerCase())
  })(Object.create(null)),
  ns = (e) => ((e = e.toLowerCase()), (t) => cl(t) === e),
  ul = (e) => (t) => typeof t === e,
  { isArray: Pr } = Array,
  fo = ul('undefined')
function DE(e) {
  return (
    e !== null &&
    !fo(e) &&
    e.constructor !== null &&
    !fo(e.constructor) &&
    ki(e.constructor.isBuffer) &&
    e.constructor.isBuffer(e)
  )
}
const jp = ns('ArrayBuffer')
function ME(e) {
  let t
  return (
    typeof ArrayBuffer < 'u' && ArrayBuffer.isView
      ? (t = ArrayBuffer.isView(e))
      : (t = e && e.buffer && jp(e.buffer)),
    t
  )
}
const IE = ul('string'),
  ki = ul('function'),
  Yp = ul('number'),
  dl = (e) => e !== null && typeof e == 'object',
  TE = (e) => e === !0 || e === !1,
  la = (e) => {
    if (cl(e) !== 'object') return !1
    const t = ju(e)
    return (
      (t === null ||
        t === Object.prototype ||
        Object.getPrototypeOf(t) === null) &&
      !(Symbol.toStringTag in e) &&
      !(Symbol.iterator in e)
    )
  },
  AE = ns('Date'),
  OE = ns('File'),
  LE = ns('Blob'),
  kE = ns('FileList'),
  HE = (e) => dl(e) && ki(e.pipe),
  NE = (e) => {
    let t
    return (
      e &&
      ((typeof FormData == 'function' && e instanceof FormData) ||
        (ki(e.append) &&
          ((t = cl(e)) === 'formdata' ||
            (t === 'object' &&
              ki(e.toString) &&
              e.toString() === '[object FormData]'))))
    )
  },
  GE = ns('URLSearchParams'),
  [BE, VE, _E, WE] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(
    ns,
  ),
  $E = (e) =>
    e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
function Ao(e, t, { allOwnKeys: i = !1 } = {}) {
  if (e === null || typeof e > 'u') return
  let s, n
  if ((typeof e != 'object' && (e = [e]), Pr(e)))
    for (s = 0, n = e.length; s < n; s++) t.call(null, e[s], s, e)
  else {
    const r = i ? Object.getOwnPropertyNames(e) : Object.keys(e),
      o = r.length
    let a
    for (s = 0; s < o; s++) (a = r[s]), t.call(null, e[a], a, e)
  }
}
function Kp(e, t) {
  t = t.toLowerCase()
  const i = Object.keys(e)
  let s = i.length,
    n
  for (; s-- > 0; ) if (((n = i[s]), t === n.toLowerCase())) return n
  return null
}
const En =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
        ? self
        : typeof window < 'u'
          ? window
          : global,
  qp = (e) => !fo(e) && e !== En
function Lc() {
  const { caseless: e } = (qp(this) && this) || {},
    t = {},
    i = (s, n) => {
      const r = (e && Kp(t, n)) || n
      la(t[r]) && la(s)
        ? (t[r] = Lc(t[r], s))
        : la(s)
          ? (t[r] = Lc({}, s))
          : Pr(s)
            ? (t[r] = s.slice())
            : (t[r] = s)
    }
  for (let s = 0, n = arguments.length; s < n; s++)
    arguments[s] && Ao(arguments[s], i)
  return t
}
const zE = (e, t, i, { allOwnKeys: s } = {}) => (
    Ao(
      t,
      (n, r) => {
        i && ki(n) ? (e[r] = Up(n, i)) : (e[r] = n)
      },
      { allOwnKeys: s },
    ),
    e
  ),
  UE = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e),
  jE = (e, t, i, s) => {
    ;(e.prototype = Object.create(t.prototype, s)),
      (e.prototype.constructor = e),
      Object.defineProperty(e, 'super', { value: t.prototype }),
      i && Object.assign(e.prototype, i)
  },
  YE = (e, t, i, s) => {
    let n, r, o
    const a = {}
    if (((t = t || {}), e == null)) return t
    do {
      for (n = Object.getOwnPropertyNames(e), r = n.length; r-- > 0; )
        (o = n[r]), (!s || s(o, e, t)) && !a[o] && ((t[o] = e[o]), (a[o] = !0))
      e = i !== !1 && ju(e)
    } while (e && (!i || i(e, t)) && e !== Object.prototype)
    return t
  },
  KE = (e, t, i) => {
    ;(e = String(e)),
      (i === void 0 || i > e.length) && (i = e.length),
      (i -= t.length)
    const s = e.indexOf(t, i)
    return s !== -1 && s === i
  },
  qE = (e) => {
    if (!e) return null
    if (Pr(e)) return e
    let t = e.length
    if (!Yp(t)) return null
    const i = new Array(t)
    for (; t-- > 0; ) i[t] = e[t]
    return i
  },
  QE = (
    (e) => (t) =>
      e && t instanceof e
  )(typeof Uint8Array < 'u' && ju(Uint8Array)),
  XE = (e, t) => {
    const s = (e && e[Symbol.iterator]).call(e)
    let n
    for (; (n = s.next()) && !n.done; ) {
      const r = n.value
      t.call(e, r[0], r[1])
    }
  },
  JE = (e, t) => {
    let i
    const s = []
    for (; (i = e.exec(t)) !== null; ) s.push(i)
    return s
  },
  ZE = ns('HTMLFormElement'),
  eP = (e) =>
    e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (i, s, n) {
      return s.toUpperCase() + n
    }),
  jh = (
    ({ hasOwnProperty: e }) =>
    (t, i) =>
      e.call(t, i)
  )(Object.prototype),
  tP = ns('RegExp'),
  Qp = (e, t) => {
    const i = Object.getOwnPropertyDescriptors(e),
      s = {}
    Ao(i, (n, r) => {
      let o
      ;(o = t(n, r, e)) !== !1 && (s[r] = o || n)
    }),
      Object.defineProperties(e, s)
  },
  iP = (e) => {
    Qp(e, (t, i) => {
      if (ki(e) && ['arguments', 'caller', 'callee'].indexOf(i) !== -1)
        return !1
      const s = e[i]
      if (ki(s)) {
        if (((t.enumerable = !1), 'writable' in t)) {
          t.writable = !1
          return
        }
        t.set ||
          (t.set = () => {
            throw Error("Can not rewrite read-only method '" + i + "'")
          })
      }
    })
  },
  sP = (e, t) => {
    const i = {},
      s = (n) => {
        n.forEach((r) => {
          i[r] = !0
        })
      }
    return Pr(e) ? s(e) : s(String(e).split(t)), i
  },
  nP = () => {},
  rP = (e, t) => (e != null && Number.isFinite((e = +e)) ? e : t),
  ec = 'abcdefghijklmnopqrstuvwxyz',
  Yh = '0123456789',
  Xp = { DIGIT: Yh, ALPHA: ec, ALPHA_DIGIT: ec + ec.toUpperCase() + Yh },
  oP = (e = 16, t = Xp.ALPHA_DIGIT) => {
    let i = ''
    const { length: s } = t
    for (; e--; ) i += t[(Math.random() * s) | 0]
    return i
  }
function aP(e) {
  return !!(
    e &&
    ki(e.append) &&
    e[Symbol.toStringTag] === 'FormData' &&
    e[Symbol.iterator]
  )
}
const lP = (e) => {
    const t = new Array(10),
      i = (s, n) => {
        if (dl(s)) {
          if (t.indexOf(s) >= 0) return
          if (!('toJSON' in s)) {
            t[n] = s
            const r = Pr(s) ? [] : {}
            return (
              Ao(s, (o, a) => {
                const l = i(o, n + 1)
                !fo(l) && (r[a] = l)
              }),
              (t[n] = void 0),
              r
            )
          }
        }
        return s
      }
    return i(e, 0)
  },
  cP = ns('AsyncFunction'),
  uP = (e) => e && (dl(e) || ki(e)) && ki(e.then) && ki(e.catch),
  Jp = ((e, t) =>
    e
      ? setImmediate
      : t
        ? ((i, s) => (
            En.addEventListener(
              'message',
              ({ source: n, data: r }) => {
                n === En && r === i && s.length && s.shift()()
              },
              !1,
            ),
            (n) => {
              s.push(n), En.postMessage(i, '*')
            }
          ))(`axios@${Math.random()}`, [])
        : (i) => setTimeout(i))(
    typeof setImmediate == 'function',
    ki(En.postMessage),
  ),
  dP =
    typeof queueMicrotask < 'u'
      ? queueMicrotask.bind(En)
      : (typeof process < 'u' && process.nextTick) || Jp,
  ee = {
    isArray: Pr,
    isArrayBuffer: jp,
    isBuffer: DE,
    isFormData: NE,
    isArrayBufferView: ME,
    isString: IE,
    isNumber: Yp,
    isBoolean: TE,
    isObject: dl,
    isPlainObject: la,
    isReadableStream: BE,
    isRequest: VE,
    isResponse: _E,
    isHeaders: WE,
    isUndefined: fo,
    isDate: AE,
    isFile: OE,
    isBlob: LE,
    isRegExp: tP,
    isFunction: ki,
    isStream: HE,
    isURLSearchParams: GE,
    isTypedArray: QE,
    isFileList: kE,
    forEach: Ao,
    merge: Lc,
    extend: zE,
    trim: $E,
    stripBOM: UE,
    inherits: jE,
    toFlatObject: YE,
    kindOf: cl,
    kindOfTest: ns,
    endsWith: KE,
    toArray: qE,
    forEachEntry: XE,
    matchAll: JE,
    isHTMLForm: ZE,
    hasOwnProperty: jh,
    hasOwnProp: jh,
    reduceDescriptors: Qp,
    freezeMethods: iP,
    toObjectSet: sP,
    toCamelCase: eP,
    noop: nP,
    toFiniteNumber: rP,
    findKey: Kp,
    global: En,
    isContextDefined: qp,
    ALPHABET: Xp,
    generateString: oP,
    isSpecCompliantForm: aP,
    toJSONObject: lP,
    isAsyncFn: cP,
    isThenable: uP,
    setImmediate: Jp,
    asap: dP,
  }
function Qe(e, t, i, s, n) {
  Error.call(this),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack),
    (this.message = e),
    (this.name = 'AxiosError'),
    t && (this.code = t),
    i && (this.config = i),
    s && (this.request = s),
    n && ((this.response = n), (this.status = n.status ? n.status : null))
}
ee.inherits(Qe, Error, {
  toJSON: function () {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: ee.toJSONObject(this.config),
      code: this.code,
      status: this.status,
    }
  },
})
const Zp = Qe.prototype,
  em = {}
;[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL',
].forEach((e) => {
  em[e] = { value: e }
})
Object.defineProperties(Qe, em)
Object.defineProperty(Zp, 'isAxiosError', { value: !0 })
Qe.from = (e, t, i, s, n, r) => {
  const o = Object.create(Zp)
  return (
    ee.toFlatObject(
      e,
      o,
      function (l) {
        return l !== Error.prototype
      },
      (a) => a !== 'isAxiosError',
    ),
    Qe.call(o, e.message, t, i, s, n),
    (o.cause = e),
    (o.name = e.name),
    r && Object.assign(o, r),
    o
  )
}
const hP = null
function kc(e) {
  return ee.isPlainObject(e) || ee.isArray(e)
}
function tm(e) {
  return ee.endsWith(e, '[]') ? e.slice(0, -2) : e
}
function Kh(e, t, i) {
  return e
    ? e
        .concat(t)
        .map(function (n, r) {
          return (n = tm(n)), !i && r ? '[' + n + ']' : n
        })
        .join(i ? '.' : '')
    : t
}
function gP(e) {
  return ee.isArray(e) && !e.some(kc)
}
const fP = ee.toFlatObject(ee, {}, null, function (t) {
  return /^is[A-Z]/.test(t)
})
function hl(e, t, i) {
  if (!ee.isObject(e)) throw new TypeError('target must be an object')
  ;(t = t || new FormData()),
    (i = ee.toFlatObject(
      i,
      { metaTokens: !0, dots: !1, indexes: !1 },
      !1,
      function (v, m) {
        return !ee.isUndefined(m[v])
      },
    ))
  const s = i.metaTokens,
    n = i.visitor || u,
    r = i.dots,
    o = i.indexes,
    l = (i.Blob || (typeof Blob < 'u' && Blob)) && ee.isSpecCompliantForm(t)
  if (!ee.isFunction(n)) throw new TypeError('visitor must be a function')
  function c(p) {
    if (p === null) return ''
    if (ee.isDate(p)) return p.toISOString()
    if (!l && ee.isBlob(p))
      throw new Qe('Blob is not supported. Use a Buffer instead.')
    return ee.isArrayBuffer(p) || ee.isTypedArray(p)
      ? l && typeof Blob == 'function'
        ? new Blob([p])
        : Buffer.from(p)
      : p
  }
  function u(p, v, m) {
    let C = p
    if (p && !m && typeof p == 'object') {
      if (ee.endsWith(v, '{}'))
        (v = s ? v : v.slice(0, -2)), (p = JSON.stringify(p))
      else if (
        (ee.isArray(p) && gP(p)) ||
        ((ee.isFileList(p) || ee.endsWith(v, '[]')) && (C = ee.toArray(p)))
      )
        return (
          (v = tm(v)),
          C.forEach(function (S, y) {
            !(ee.isUndefined(S) || S === null) &&
              t.append(
                o === !0 ? Kh([v], y, r) : o === null ? v : v + '[]',
                c(S),
              )
          }),
          !1
        )
    }
    return kc(p) ? !0 : (t.append(Kh(m, v, r), c(p)), !1)
  }
  const h = [],
    g = Object.assign(fP, {
      defaultVisitor: u,
      convertValue: c,
      isVisitable: kc,
    })
  function f(p, v) {
    if (!ee.isUndefined(p)) {
      if (h.indexOf(p) !== -1)
        throw Error('Circular reference detected in ' + v.join('.'))
      h.push(p),
        ee.forEach(p, function (C, w) {
          ;(!(ee.isUndefined(C) || C === null) &&
            n.call(t, C, ee.isString(w) ? w.trim() : w, v, g)) === !0 &&
            f(C, v ? v.concat(w) : [w])
        }),
        h.pop()
    }
  }
  if (!ee.isObject(e)) throw new TypeError('data must be an object')
  return f(e), t
}
function qh(e) {
  const t = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\0',
  }
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (s) {
    return t[s]
  })
}
function Yu(e, t) {
  ;(this._pairs = []), e && hl(e, this, t)
}
const im = Yu.prototype
im.append = function (t, i) {
  this._pairs.push([t, i])
}
im.toString = function (t) {
  const i = t
    ? function (s) {
        return t.call(this, s, qh)
      }
    : qh
  return this._pairs
    .map(function (n) {
      return i(n[0]) + '=' + i(n[1])
    }, '')
    .join('&')
}
function pP(e) {
  return encodeURIComponent(e)
    .replace(/%3A/gi, ':')
    .replace(/%24/g, '$')
    .replace(/%2C/gi, ',')
    .replace(/%20/g, '+')
    .replace(/%5B/gi, '[')
    .replace(/%5D/gi, ']')
}
function sm(e, t, i) {
  if (!t) return e
  const s = (i && i.encode) || pP,
    n = i && i.serialize
  let r
  if (
    (n
      ? (r = n(t, i))
      : (r = ee.isURLSearchParams(t) ? t.toString() : new Yu(t, i).toString(s)),
    r)
  ) {
    const o = e.indexOf('#')
    o !== -1 && (e = e.slice(0, o)),
      (e += (e.indexOf('?') === -1 ? '?' : '&') + r)
  }
  return e
}
class Qh {
  constructor() {
    this.handlers = []
  }
  use(t, i, s) {
    return (
      this.handlers.push({
        fulfilled: t,
        rejected: i,
        synchronous: s ? s.synchronous : !1,
        runWhen: s ? s.runWhen : null,
      }),
      this.handlers.length - 1
    )
  }
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null)
  }
  clear() {
    this.handlers && (this.handlers = [])
  }
  forEach(t) {
    ee.forEach(this.handlers, function (s) {
      s !== null && t(s)
    })
  }
}
const nm = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1,
  },
  mP = typeof URLSearchParams < 'u' ? URLSearchParams : Yu,
  vP = typeof FormData < 'u' ? FormData : null,
  CP = typeof Blob < 'u' ? Blob : null,
  SP = {
    isBrowser: !0,
    classes: { URLSearchParams: mP, FormData: vP, Blob: CP },
    protocols: ['http', 'https', 'file', 'blob', 'url', 'data'],
  },
  Ku = typeof window < 'u' && typeof document < 'u',
  Hc = (typeof navigator == 'object' && navigator) || void 0,
  wP =
    Ku &&
    (!Hc || ['ReactNative', 'NativeScript', 'NS'].indexOf(Hc.product) < 0),
  yP =
    typeof WorkerGlobalScope < 'u' &&
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts == 'function',
  bP = (Ku && window.location.href) || 'http://localhost',
  RP = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        hasBrowserEnv: Ku,
        hasStandardBrowserEnv: wP,
        hasStandardBrowserWebWorkerEnv: yP,
        navigator: Hc,
        origin: bP,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  Ii = { ...RP, ...SP }
function FP(e, t) {
  return hl(
    e,
    new Ii.classes.URLSearchParams(),
    Object.assign(
      {
        visitor: function (i, s, n, r) {
          return Ii.isNode && ee.isBuffer(i)
            ? (this.append(s, i.toString('base64')), !1)
            : r.defaultVisitor.apply(this, arguments)
        },
      },
      t,
    ),
  )
}
function EP(e) {
  return ee
    .matchAll(/\w+|\[(\w*)]/g, e)
    .map((t) => (t[0] === '[]' ? '' : t[1] || t[0]))
}
function PP(e) {
  const t = {},
    i = Object.keys(e)
  let s
  const n = i.length
  let r
  for (s = 0; s < n; s++) (r = i[s]), (t[r] = e[r])
  return t
}
function rm(e) {
  function t(i, s, n, r) {
    let o = i[r++]
    if (o === '__proto__') return !0
    const a = Number.isFinite(+o),
      l = r >= i.length
    return (
      (o = !o && ee.isArray(n) ? n.length : o),
      l
        ? (ee.hasOwnProp(n, o) ? (n[o] = [n[o], s]) : (n[o] = s), !a)
        : ((!n[o] || !ee.isObject(n[o])) && (n[o] = []),
          t(i, s, n[o], r) && ee.isArray(n[o]) && (n[o] = PP(n[o])),
          !a)
    )
  }
  if (ee.isFormData(e) && ee.isFunction(e.entries)) {
    const i = {}
    return (
      ee.forEachEntry(e, (s, n) => {
        t(EP(s), n, i, 0)
      }),
      i
    )
  }
  return null
}
function xP(e, t, i) {
  if (ee.isString(e))
    try {
      return (t || JSON.parse)(e), ee.trim(e)
    } catch (s) {
      if (s.name !== 'SyntaxError') throw s
    }
  return (0, JSON.stringify)(e)
}
const Oo = {
  transitional: nm,
  adapter: ['xhr', 'http', 'fetch'],
  transformRequest: [
    function (t, i) {
      const s = i.getContentType() || '',
        n = s.indexOf('application/json') > -1,
        r = ee.isObject(t)
      if ((r && ee.isHTMLForm(t) && (t = new FormData(t)), ee.isFormData(t)))
        return n ? JSON.stringify(rm(t)) : t
      if (
        ee.isArrayBuffer(t) ||
        ee.isBuffer(t) ||
        ee.isStream(t) ||
        ee.isFile(t) ||
        ee.isBlob(t) ||
        ee.isReadableStream(t)
      )
        return t
      if (ee.isArrayBufferView(t)) return t.buffer
      if (ee.isURLSearchParams(t))
        return (
          i.setContentType(
            'application/x-www-form-urlencoded;charset=utf-8',
            !1,
          ),
          t.toString()
        )
      let a
      if (r) {
        if (s.indexOf('application/x-www-form-urlencoded') > -1)
          return FP(t, this.formSerializer).toString()
        if ((a = ee.isFileList(t)) || s.indexOf('multipart/form-data') > -1) {
          const l = this.env && this.env.FormData
          return hl(a ? { 'files[]': t } : t, l && new l(), this.formSerializer)
        }
      }
      return r || n ? (i.setContentType('application/json', !1), xP(t)) : t
    },
  ],
  transformResponse: [
    function (t) {
      const i = this.transitional || Oo.transitional,
        s = i && i.forcedJSONParsing,
        n = this.responseType === 'json'
      if (ee.isResponse(t) || ee.isReadableStream(t)) return t
      if (t && ee.isString(t) && ((s && !this.responseType) || n)) {
        const o = !(i && i.silentJSONParsing) && n
        try {
          return JSON.parse(t)
        } catch (a) {
          if (o)
            throw a.name === 'SyntaxError'
              ? Qe.from(a, Qe.ERR_BAD_RESPONSE, this, null, this.response)
              : a
        }
      }
      return t
    },
  ],
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: Ii.classes.FormData, Blob: Ii.classes.Blob },
  validateStatus: function (t) {
    return t >= 200 && t < 300
  },
  headers: {
    common: {
      Accept: 'application/json, text/plain, */*',
      'Content-Type': void 0,
    },
  },
}
ee.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (e) => {
  Oo.headers[e] = {}
})
const DP = ee.toObjectSet([
    'age',
    'authorization',
    'content-length',
    'content-type',
    'etag',
    'expires',
    'from',
    'host',
    'if-modified-since',
    'if-unmodified-since',
    'last-modified',
    'location',
    'max-forwards',
    'proxy-authorization',
    'referer',
    'retry-after',
    'user-agent',
  ]),
  MP = (e) => {
    const t = {}
    let i, s, n
    return (
      e &&
        e
          .split(
            `
`,
          )
          .forEach(function (o) {
            ;(n = o.indexOf(':')),
              (i = o.substring(0, n).trim().toLowerCase()),
              (s = o.substring(n + 1).trim()),
              !(!i || (t[i] && DP[i])) &&
                (i === 'set-cookie'
                  ? t[i]
                    ? t[i].push(s)
                    : (t[i] = [s])
                  : (t[i] = t[i] ? t[i] + ', ' + s : s))
          }),
      t
    )
  },
  Xh = Symbol('internals')
function jr(e) {
  return e && String(e).trim().toLowerCase()
}
function ca(e) {
  return e === !1 || e == null ? e : ee.isArray(e) ? e.map(ca) : String(e)
}
function IP(e) {
  const t = Object.create(null),
    i = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g
  let s
  for (; (s = i.exec(e)); ) t[s[1]] = s[2]
  return t
}
const TP = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim())
function tc(e, t, i, s, n) {
  if (ee.isFunction(s)) return s.call(this, t, i)
  if ((n && (t = i), !!ee.isString(t))) {
    if (ee.isString(s)) return t.indexOf(s) !== -1
    if (ee.isRegExp(s)) return s.test(t)
  }
}
function AP(e) {
  return e
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (t, i, s) => i.toUpperCase() + s)
}
function OP(e, t) {
  const i = ee.toCamelCase(' ' + t)
  ;['get', 'set', 'has'].forEach((s) => {
    Object.defineProperty(e, s + i, {
      value: function (n, r, o) {
        return this[s].call(this, t, n, r, o)
      },
      configurable: !0,
    })
  })
}
class Ti {
  constructor(t) {
    t && this.set(t)
  }
  set(t, i, s) {
    const n = this
    function r(a, l, c) {
      const u = jr(l)
      if (!u) throw new Error('header name must be a non-empty string')
      const h = ee.findKey(n, u)
      ;(!h || n[h] === void 0 || c === !0 || (c === void 0 && n[h] !== !1)) &&
        (n[h || l] = ca(a))
    }
    const o = (a, l) => ee.forEach(a, (c, u) => r(c, u, l))
    if (ee.isPlainObject(t) || t instanceof this.constructor) o(t, i)
    else if (ee.isString(t) && (t = t.trim()) && !TP(t)) o(MP(t), i)
    else if (ee.isHeaders(t)) for (const [a, l] of t.entries()) r(l, a, s)
    else t != null && r(i, t, s)
    return this
  }
  get(t, i) {
    if (((t = jr(t)), t)) {
      const s = ee.findKey(this, t)
      if (s) {
        const n = this[s]
        if (!i) return n
        if (i === !0) return IP(n)
        if (ee.isFunction(i)) return i.call(this, n, s)
        if (ee.isRegExp(i)) return i.exec(n)
        throw new TypeError('parser must be boolean|regexp|function')
      }
    }
  }
  has(t, i) {
    if (((t = jr(t)), t)) {
      const s = ee.findKey(this, t)
      return !!(s && this[s] !== void 0 && (!i || tc(this, this[s], s, i)))
    }
    return !1
  }
  delete(t, i) {
    const s = this
    let n = !1
    function r(o) {
      if (((o = jr(o)), o)) {
        const a = ee.findKey(s, o)
        a && (!i || tc(s, s[a], a, i)) && (delete s[a], (n = !0))
      }
    }
    return ee.isArray(t) ? t.forEach(r) : r(t), n
  }
  clear(t) {
    const i = Object.keys(this)
    let s = i.length,
      n = !1
    for (; s--; ) {
      const r = i[s]
      ;(!t || tc(this, this[r], r, t, !0)) && (delete this[r], (n = !0))
    }
    return n
  }
  normalize(t) {
    const i = this,
      s = {}
    return (
      ee.forEach(this, (n, r) => {
        const o = ee.findKey(s, r)
        if (o) {
          ;(i[o] = ca(n)), delete i[r]
          return
        }
        const a = t ? AP(r) : String(r).trim()
        a !== r && delete i[r], (i[a] = ca(n)), (s[a] = !0)
      }),
      this
    )
  }
  concat(...t) {
    return this.constructor.concat(this, ...t)
  }
  toJSON(t) {
    const i = Object.create(null)
    return (
      ee.forEach(this, (s, n) => {
        s != null && s !== !1 && (i[n] = t && ee.isArray(s) ? s.join(', ') : s)
      }),
      i
    )
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]()
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, i]) => t + ': ' + i).join(`
`)
  }
  get [Symbol.toStringTag]() {
    return 'AxiosHeaders'
  }
  static from(t) {
    return t instanceof this ? t : new this(t)
  }
  static concat(t, ...i) {
    const s = new this(t)
    return i.forEach((n) => s.set(n)), s
  }
  static accessor(t) {
    const s = (this[Xh] = this[Xh] = { accessors: {} }).accessors,
      n = this.prototype
    function r(o) {
      const a = jr(o)
      s[a] || (OP(n, o), (s[a] = !0))
    }
    return ee.isArray(t) ? t.forEach(r) : r(t), this
  }
}
Ti.accessor([
  'Content-Type',
  'Content-Length',
  'Accept',
  'Accept-Encoding',
  'User-Agent',
  'Authorization',
])
ee.reduceDescriptors(Ti.prototype, ({ value: e }, t) => {
  let i = t[0].toUpperCase() + t.slice(1)
  return {
    get: () => e,
    set(s) {
      this[i] = s
    },
  }
})
ee.freezeMethods(Ti)
function ic(e, t) {
  const i = this || Oo,
    s = t || i,
    n = Ti.from(s.headers)
  let r = s.data
  return (
    ee.forEach(e, function (a) {
      r = a.call(i, r, n.normalize(), t ? t.status : void 0)
    }),
    n.normalize(),
    r
  )
}
function om(e) {
  return !!(e && e.__CANCEL__)
}
function xr(e, t, i) {
  Qe.call(this, e ?? 'canceled', Qe.ERR_CANCELED, t, i),
    (this.name = 'CanceledError')
}
ee.inherits(xr, Qe, { __CANCEL__: !0 })
function am(e, t, i) {
  const s = i.config.validateStatus
  !i.status || !s || s(i.status)
    ? e(i)
    : t(
        new Qe(
          'Request failed with status code ' + i.status,
          [Qe.ERR_BAD_REQUEST, Qe.ERR_BAD_RESPONSE][
            Math.floor(i.status / 100) - 4
          ],
          i.config,
          i.request,
          i,
        ),
      )
}
function LP(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e)
  return (t && t[1]) || ''
}
function kP(e, t) {
  e = e || 10
  const i = new Array(e),
    s = new Array(e)
  let n = 0,
    r = 0,
    o
  return (
    (t = t !== void 0 ? t : 1e3),
    function (l) {
      const c = Date.now(),
        u = s[r]
      o || (o = c), (i[n] = l), (s[n] = c)
      let h = r,
        g = 0
      for (; h !== n; ) (g += i[h++]), (h = h % e)
      if (((n = (n + 1) % e), n === r && (r = (r + 1) % e), c - o < t)) return
      const f = u && c - u
      return f ? Math.round((g * 1e3) / f) : void 0
    }
  )
}
function HP(e, t) {
  let i = 0,
    s = 1e3 / t,
    n,
    r
  const o = (c, u = Date.now()) => {
    ;(i = u), (n = null), r && (clearTimeout(r), (r = null)), e.apply(null, c)
  }
  return [
    (...c) => {
      const u = Date.now(),
        h = u - i
      h >= s
        ? o(c, u)
        : ((n = c),
          r ||
            (r = setTimeout(() => {
              ;(r = null), o(n)
            }, s - h)))
    },
    () => n && o(n),
  ]
}
const Da = (e, t, i = 3) => {
    let s = 0
    const n = kP(50, 250)
    return HP((r) => {
      const o = r.loaded,
        a = r.lengthComputable ? r.total : void 0,
        l = o - s,
        c = n(l),
        u = o <= a
      s = o
      const h = {
        loaded: o,
        total: a,
        progress: a ? o / a : void 0,
        bytes: l,
        rate: c || void 0,
        estimated: c && a && u ? (a - o) / c : void 0,
        event: r,
        lengthComputable: a != null,
        [t ? 'download' : 'upload']: !0,
      }
      e(h)
    }, i)
  },
  Jh = (e, t) => {
    const i = e != null
    return [(s) => t[0]({ lengthComputable: i, total: e, loaded: s }), t[1]]
  },
  Zh =
    (e) =>
    (...t) =>
      ee.asap(() => e(...t)),
  NP = Ii.hasStandardBrowserEnv
    ? (function () {
        const t =
            Ii.navigator && /(msie|trident)/i.test(Ii.navigator.userAgent),
          i = document.createElement('a')
        let s
        function n(r) {
          let o = r
          return (
            t && (i.setAttribute('href', o), (o = i.href)),
            i.setAttribute('href', o),
            {
              href: i.href,
              protocol: i.protocol ? i.protocol.replace(/:$/, '') : '',
              host: i.host,
              search: i.search ? i.search.replace(/^\?/, '') : '',
              hash: i.hash ? i.hash.replace(/^#/, '') : '',
              hostname: i.hostname,
              port: i.port,
              pathname:
                i.pathname.charAt(0) === '/' ? i.pathname : '/' + i.pathname,
            }
          )
        }
        return (
          (s = n(window.location.href)),
          function (o) {
            const a = ee.isString(o) ? n(o) : o
            return a.protocol === s.protocol && a.host === s.host
          }
        )
      })()
    : (function () {
        return function () {
          return !0
        }
      })(),
  GP = Ii.hasStandardBrowserEnv
    ? {
        write(e, t, i, s, n, r) {
          const o = [e + '=' + encodeURIComponent(t)]
          ee.isNumber(i) && o.push('expires=' + new Date(i).toGMTString()),
            ee.isString(s) && o.push('path=' + s),
            ee.isString(n) && o.push('domain=' + n),
            r === !0 && o.push('secure'),
            (document.cookie = o.join('; '))
        },
        read(e) {
          const t = document.cookie.match(
            new RegExp('(^|;\\s*)(' + e + ')=([^;]*)'),
          )
          return t ? decodeURIComponent(t[3]) : null
        },
        remove(e) {
          this.write(e, '', Date.now() - 864e5)
        },
      }
    : {
        write() {},
        read() {
          return null
        },
        remove() {},
      }
function BP(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
}
function VP(e, t) {
  return t ? e.replace(/\/?\/$/, '') + '/' + t.replace(/^\/+/, '') : e
}
function lm(e, t) {
  return e && !BP(t) ? VP(e, t) : t
}
const eg = (e) => (e instanceof Ti ? { ...e } : e)
function Hn(e, t) {
  t = t || {}
  const i = {}
  function s(c, u, h) {
    return ee.isPlainObject(c) && ee.isPlainObject(u)
      ? ee.merge.call({ caseless: h }, c, u)
      : ee.isPlainObject(u)
        ? ee.merge({}, u)
        : ee.isArray(u)
          ? u.slice()
          : u
  }
  function n(c, u, h) {
    if (ee.isUndefined(u)) {
      if (!ee.isUndefined(c)) return s(void 0, c, h)
    } else return s(c, u, h)
  }
  function r(c, u) {
    if (!ee.isUndefined(u)) return s(void 0, u)
  }
  function o(c, u) {
    if (ee.isUndefined(u)) {
      if (!ee.isUndefined(c)) return s(void 0, c)
    } else return s(void 0, u)
  }
  function a(c, u, h) {
    if (h in t) return s(c, u)
    if (h in e) return s(void 0, c)
  }
  const l = {
    url: r,
    method: r,
    data: r,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (c, u) => n(eg(c), eg(u), !0),
  }
  return (
    ee.forEach(Object.keys(Object.assign({}, e, t)), function (u) {
      const h = l[u] || n,
        g = h(e[u], t[u], u)
      ;(ee.isUndefined(g) && h !== a) || (i[u] = g)
    }),
    i
  )
}
const cm = (e) => {
    const t = Hn({}, e)
    let {
      data: i,
      withXSRFToken: s,
      xsrfHeaderName: n,
      xsrfCookieName: r,
      headers: o,
      auth: a,
    } = t
    ;(t.headers = o = Ti.from(o)),
      (t.url = sm(lm(t.baseURL, t.url), e.params, e.paramsSerializer)),
      a &&
        o.set(
          'Authorization',
          'Basic ' +
            btoa(
              (a.username || '') +
                ':' +
                (a.password ? unescape(encodeURIComponent(a.password)) : ''),
            ),
        )
    let l
    if (ee.isFormData(i)) {
      if (Ii.hasStandardBrowserEnv || Ii.hasStandardBrowserWebWorkerEnv)
        o.setContentType(void 0)
      else if ((l = o.getContentType()) !== !1) {
        const [c, ...u] = l
          ? l
              .split(';')
              .map((h) => h.trim())
              .filter(Boolean)
          : []
        o.setContentType([c || 'multipart/form-data', ...u].join('; '))
      }
    }
    if (
      Ii.hasStandardBrowserEnv &&
      (s && ee.isFunction(s) && (s = s(t)), s || (s !== !1 && NP(t.url)))
    ) {
      const c = n && r && GP.read(r)
      c && o.set(n, c)
    }
    return t
  },
  _P = typeof XMLHttpRequest < 'u',
  WP =
    _P &&
    function (e) {
      return new Promise(function (i, s) {
        const n = cm(e)
        let r = n.data
        const o = Ti.from(n.headers).normalize()
        let { responseType: a, onUploadProgress: l, onDownloadProgress: c } = n,
          u,
          h,
          g,
          f,
          p
        function v() {
          f && f(),
            p && p(),
            n.cancelToken && n.cancelToken.unsubscribe(u),
            n.signal && n.signal.removeEventListener('abort', u)
        }
        let m = new XMLHttpRequest()
        m.open(n.method.toUpperCase(), n.url, !0), (m.timeout = n.timeout)
        function C() {
          if (!m) return
          const S = Ti.from(
              'getAllResponseHeaders' in m && m.getAllResponseHeaders(),
            ),
            F = {
              data:
                !a || a === 'text' || a === 'json'
                  ? m.responseText
                  : m.response,
              status: m.status,
              statusText: m.statusText,
              headers: S,
              config: e,
              request: m,
            }
          am(
            function (b) {
              i(b), v()
            },
            function (b) {
              s(b), v()
            },
            F,
          ),
            (m = null)
        }
        'onloadend' in m
          ? (m.onloadend = C)
          : (m.onreadystatechange = function () {
              !m ||
                m.readyState !== 4 ||
                (m.status === 0 &&
                  !(m.responseURL && m.responseURL.indexOf('file:') === 0)) ||
                setTimeout(C)
            }),
          (m.onabort = function () {
            m &&
              (s(new Qe('Request aborted', Qe.ECONNABORTED, e, m)), (m = null))
          }),
          (m.onerror = function () {
            s(new Qe('Network Error', Qe.ERR_NETWORK, e, m)), (m = null)
          }),
          (m.ontimeout = function () {
            let y = n.timeout
              ? 'timeout of ' + n.timeout + 'ms exceeded'
              : 'timeout exceeded'
            const F = n.transitional || nm
            n.timeoutErrorMessage && (y = n.timeoutErrorMessage),
              s(
                new Qe(
                  y,
                  F.clarifyTimeoutError ? Qe.ETIMEDOUT : Qe.ECONNABORTED,
                  e,
                  m,
                ),
              ),
              (m = null)
          }),
          r === void 0 && o.setContentType(null),
          'setRequestHeader' in m &&
            ee.forEach(o.toJSON(), function (y, F) {
              m.setRequestHeader(F, y)
            }),
          ee.isUndefined(n.withCredentials) ||
            (m.withCredentials = !!n.withCredentials),
          a && a !== 'json' && (m.responseType = n.responseType),
          c && (([g, p] = Da(c, !0)), m.addEventListener('progress', g)),
          l &&
            m.upload &&
            (([h, f] = Da(l)),
            m.upload.addEventListener('progress', h),
            m.upload.addEventListener('loadend', f)),
          (n.cancelToken || n.signal) &&
            ((u = (S) => {
              m &&
                (s(!S || S.type ? new xr(null, e, m) : S),
                m.abort(),
                (m = null))
            }),
            n.cancelToken && n.cancelToken.subscribe(u),
            n.signal &&
              (n.signal.aborted ? u() : n.signal.addEventListener('abort', u)))
        const w = LP(n.url)
        if (w && Ii.protocols.indexOf(w) === -1) {
          s(new Qe('Unsupported protocol ' + w + ':', Qe.ERR_BAD_REQUEST, e))
          return
        }
        m.send(r || null)
      })
    },
  $P = (e, t) => {
    const { length: i } = (e = e ? e.filter(Boolean) : [])
    if (t || i) {
      let s = new AbortController(),
        n
      const r = function (c) {
        if (!n) {
          ;(n = !0), a()
          const u = c instanceof Error ? c : this.reason
          s.abort(
            u instanceof Qe ? u : new xr(u instanceof Error ? u.message : u),
          )
        }
      }
      let o =
        t &&
        setTimeout(() => {
          ;(o = null), r(new Qe(`timeout ${t} of ms exceeded`, Qe.ETIMEDOUT))
        }, t)
      const a = () => {
        e &&
          (o && clearTimeout(o),
          (o = null),
          e.forEach((c) => {
            c.unsubscribe ? c.unsubscribe(r) : c.removeEventListener('abort', r)
          }),
          (e = null))
      }
      e.forEach((c) => c.addEventListener('abort', r))
      const { signal: l } = s
      return (l.unsubscribe = () => ee.asap(a)), l
    }
  },
  zP = function* (e, t) {
    let i = e.byteLength
    if (i < t) {
      yield e
      return
    }
    let s = 0,
      n
    for (; s < i; ) (n = s + t), yield e.slice(s, n), (s = n)
  },
  UP = async function* (e, t) {
    for await (const i of jP(e)) yield* zP(i, t)
  },
  jP = async function* (e) {
    if (e[Symbol.asyncIterator]) {
      yield* e
      return
    }
    const t = e.getReader()
    try {
      for (;;) {
        const { done: i, value: s } = await t.read()
        if (i) break
        yield s
      }
    } finally {
      await t.cancel()
    }
  },
  tg = (e, t, i, s) => {
    const n = UP(e, t)
    let r = 0,
      o,
      a = (l) => {
        o || ((o = !0), s && s(l))
      }
    return new ReadableStream(
      {
        async pull(l) {
          try {
            const { done: c, value: u } = await n.next()
            if (c) {
              a(), l.close()
              return
            }
            let h = u.byteLength
            if (i) {
              let g = (r += h)
              i(g)
            }
            l.enqueue(new Uint8Array(u))
          } catch (c) {
            throw (a(c), c)
          }
        },
        cancel(l) {
          return a(l), n.return()
        },
      },
      { highWaterMark: 2 },
    )
  },
  gl =
    typeof fetch == 'function' &&
    typeof Request == 'function' &&
    typeof Response == 'function',
  um = gl && typeof ReadableStream == 'function',
  YP =
    gl &&
    (typeof TextEncoder == 'function'
      ? (
          (e) => (t) =>
            e.encode(t)
        )(new TextEncoder())
      : async (e) => new Uint8Array(await new Response(e).arrayBuffer())),
  dm = (e, ...t) => {
    try {
      return !!e(...t)
    } catch {
      return !1
    }
  },
  KP =
    um &&
    dm(() => {
      let e = !1
      const t = new Request(Ii.origin, {
        body: new ReadableStream(),
        method: 'POST',
        get duplex() {
          return (e = !0), 'half'
        },
      }).headers.has('Content-Type')
      return e && !t
    }),
  ig = 64 * 1024,
  Nc = um && dm(() => ee.isReadableStream(new Response('').body)),
  Ma = { stream: Nc && ((e) => e.body) }
gl &&
  ((e) => {
    ;['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach((t) => {
      !Ma[t] &&
        (Ma[t] = ee.isFunction(e[t])
          ? (i) => i[t]()
          : (i, s) => {
              throw new Qe(
                `Response type '${t}' is not supported`,
                Qe.ERR_NOT_SUPPORT,
                s,
              )
            })
    })
  })(new Response())
const qP = async (e) => {
    if (e == null) return 0
    if (ee.isBlob(e)) return e.size
    if (ee.isSpecCompliantForm(e))
      return (
        await new Request(Ii.origin, { method: 'POST', body: e }).arrayBuffer()
      ).byteLength
    if (ee.isArrayBufferView(e) || ee.isArrayBuffer(e)) return e.byteLength
    if ((ee.isURLSearchParams(e) && (e = e + ''), ee.isString(e)))
      return (await YP(e)).byteLength
  },
  QP = async (e, t) => {
    const i = ee.toFiniteNumber(e.getContentLength())
    return i ?? qP(t)
  },
  XP =
    gl &&
    (async (e) => {
      let {
        url: t,
        method: i,
        data: s,
        signal: n,
        cancelToken: r,
        timeout: o,
        onDownloadProgress: a,
        onUploadProgress: l,
        responseType: c,
        headers: u,
        withCredentials: h = 'same-origin',
        fetchOptions: g,
      } = cm(e)
      c = c ? (c + '').toLowerCase() : 'text'
      let f = $P([n, r && r.toAbortSignal()], o),
        p
      const v =
        f &&
        f.unsubscribe &&
        (() => {
          f.unsubscribe()
        })
      let m
      try {
        if (
          l &&
          KP &&
          i !== 'get' &&
          i !== 'head' &&
          (m = await QP(u, s)) !== 0
        ) {
          let F = new Request(t, { method: 'POST', body: s, duplex: 'half' }),
            R
          if (
            (ee.isFormData(s) &&
              (R = F.headers.get('content-type')) &&
              u.setContentType(R),
            F.body)
          ) {
            const [b, x] = Jh(m, Da(Zh(l)))
            s = tg(F.body, ig, b, x)
          }
        }
        ee.isString(h) || (h = h ? 'include' : 'omit')
        const C = 'credentials' in Request.prototype
        p = new Request(t, {
          ...g,
          signal: f,
          method: i.toUpperCase(),
          headers: u.normalize().toJSON(),
          body: s,
          duplex: 'half',
          credentials: C ? h : void 0,
        })
        let w = await fetch(p)
        const S = Nc && (c === 'stream' || c === 'response')
        if (Nc && (a || (S && v))) {
          const F = {}
          ;['status', 'statusText', 'headers'].forEach((D) => {
            F[D] = w[D]
          })
          const R = ee.toFiniteNumber(w.headers.get('content-length')),
            [b, x] = (a && Jh(R, Da(Zh(a), !0))) || []
          w = new Response(
            tg(w.body, ig, b, () => {
              x && x(), v && v()
            }),
            F,
          )
        }
        c = c || 'text'
        let y = await Ma[ee.findKey(Ma, c) || 'text'](w, e)
        return (
          !S && v && v(),
          await new Promise((F, R) => {
            am(F, R, {
              data: y,
              headers: Ti.from(w.headers),
              status: w.status,
              statusText: w.statusText,
              config: e,
              request: p,
            })
          })
        )
      } catch (C) {
        throw (
          (v && v(),
          C && C.name === 'TypeError' && /fetch/i.test(C.message)
            ? Object.assign(new Qe('Network Error', Qe.ERR_NETWORK, e, p), {
                cause: C.cause || C,
              })
            : Qe.from(C, C && C.code, e, p))
        )
      }
    }),
  Gc = { http: hP, xhr: WP, fetch: XP }
ee.forEach(Gc, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, 'name', { value: t })
    } catch {}
    Object.defineProperty(e, 'adapterName', { value: t })
  }
})
const sg = (e) => `- ${e}`,
  JP = (e) => ee.isFunction(e) || e === null || e === !1,
  hm = {
    getAdapter: (e) => {
      e = ee.isArray(e) ? e : [e]
      const { length: t } = e
      let i, s
      const n = {}
      for (let r = 0; r < t; r++) {
        i = e[r]
        let o
        if (
          ((s = i),
          !JP(i) && ((s = Gc[(o = String(i)).toLowerCase()]), s === void 0))
        )
          throw new Qe(`Unknown adapter '${o}'`)
        if (s) break
        n[o || '#' + r] = s
      }
      if (!s) {
        const r = Object.entries(n).map(
          ([a, l]) =>
            `adapter ${a} ` +
            (l === !1
              ? 'is not supported by the environment'
              : 'is not available in the build'),
        )
        let o = t
          ? r.length > 1
            ? `since :
` +
              r.map(sg).join(`
`)
            : ' ' + sg(r[0])
          : 'as no adapter specified'
        throw new Qe(
          'There is no suitable adapter to dispatch the request ' + o,
          'ERR_NOT_SUPPORT',
        )
      }
      return s
    },
    adapters: Gc,
  }
function sc(e) {
  if (
    (e.cancelToken && e.cancelToken.throwIfRequested(),
    e.signal && e.signal.aborted)
  )
    throw new xr(null, e)
}
function ng(e) {
  return (
    sc(e),
    (e.headers = Ti.from(e.headers)),
    (e.data = ic.call(e, e.transformRequest)),
    ['post', 'put', 'patch'].indexOf(e.method) !== -1 &&
      e.headers.setContentType('application/x-www-form-urlencoded', !1),
    hm
      .getAdapter(e.adapter || Oo.adapter)(e)
      .then(
        function (s) {
          return (
            sc(e),
            (s.data = ic.call(e, e.transformResponse, s)),
            (s.headers = Ti.from(s.headers)),
            s
          )
        },
        function (s) {
          return (
            om(s) ||
              (sc(e),
              s &&
                s.response &&
                ((s.response.data = ic.call(
                  e,
                  e.transformResponse,
                  s.response,
                )),
                (s.response.headers = Ti.from(s.response.headers)))),
            Promise.reject(s)
          )
        },
      )
  )
}
const gm = '1.7.7',
  qu = {}
;['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(
  (e, t) => {
    qu[e] = function (s) {
      return typeof s === e || 'a' + (t < 1 ? 'n ' : ' ') + e
    }
  },
)
const rg = {}
qu.transitional = function (t, i, s) {
  function n(r, o) {
    return (
      '[Axios v' +
      gm +
      "] Transitional option '" +
      r +
      "'" +
      o +
      (s ? '. ' + s : '')
    )
  }
  return (r, o, a) => {
    if (t === !1)
      throw new Qe(
        n(o, ' has been removed' + (i ? ' in ' + i : '')),
        Qe.ERR_DEPRECATED,
      )
    return (
      i &&
        !rg[o] &&
        ((rg[o] = !0),
        console.warn(
          n(
            o,
            ' has been deprecated since v' +
              i +
              ' and will be removed in the near future',
          ),
        )),
      t ? t(r, o, a) : !0
    )
  }
}
function ZP(e, t, i) {
  if (typeof e != 'object')
    throw new Qe('options must be an object', Qe.ERR_BAD_OPTION_VALUE)
  const s = Object.keys(e)
  let n = s.length
  for (; n-- > 0; ) {
    const r = s[n],
      o = t[r]
    if (o) {
      const a = e[r],
        l = a === void 0 || o(a, r, e)
      if (l !== !0)
        throw new Qe('option ' + r + ' must be ' + l, Qe.ERR_BAD_OPTION_VALUE)
      continue
    }
    if (i !== !0) throw new Qe('Unknown option ' + r, Qe.ERR_BAD_OPTION)
  }
}
const Bc = { assertOptions: ZP, validators: qu },
  Xs = Bc.validators
class Dn {
  constructor(t) {
    ;(this.defaults = t),
      (this.interceptors = { request: new Qh(), response: new Qh() })
  }
  async request(t, i) {
    try {
      return await this._request(t, i)
    } catch (s) {
      if (s instanceof Error) {
        let n
        Error.captureStackTrace
          ? Error.captureStackTrace((n = {}))
          : (n = new Error())
        const r = n.stack ? n.stack.replace(/^.+\n/, '') : ''
        try {
          s.stack
            ? r &&
              !String(s.stack).endsWith(r.replace(/^.+\n.+\n/, '')) &&
              (s.stack +=
                `
` + r)
            : (s.stack = r)
        } catch {}
      }
      throw s
    }
  }
  _request(t, i) {
    typeof t == 'string' ? ((i = i || {}), (i.url = t)) : (i = t || {}),
      (i = Hn(this.defaults, i))
    const { transitional: s, paramsSerializer: n, headers: r } = i
    s !== void 0 &&
      Bc.assertOptions(
        s,
        {
          silentJSONParsing: Xs.transitional(Xs.boolean),
          forcedJSONParsing: Xs.transitional(Xs.boolean),
          clarifyTimeoutError: Xs.transitional(Xs.boolean),
        },
        !1,
      ),
      n != null &&
        (ee.isFunction(n)
          ? (i.paramsSerializer = { serialize: n })
          : Bc.assertOptions(
              n,
              { encode: Xs.function, serialize: Xs.function },
              !0,
            )),
      (i.method = (i.method || this.defaults.method || 'get').toLowerCase())
    let o = r && ee.merge(r.common, r[i.method])
    r &&
      ee.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        (p) => {
          delete r[p]
        },
      ),
      (i.headers = Ti.concat(o, r))
    const a = []
    let l = !0
    this.interceptors.request.forEach(function (v) {
      ;(typeof v.runWhen == 'function' && v.runWhen(i) === !1) ||
        ((l = l && v.synchronous), a.unshift(v.fulfilled, v.rejected))
    })
    const c = []
    this.interceptors.response.forEach(function (v) {
      c.push(v.fulfilled, v.rejected)
    })
    let u,
      h = 0,
      g
    if (!l) {
      const p = [ng.bind(this), void 0]
      for (
        p.unshift.apply(p, a),
          p.push.apply(p, c),
          g = p.length,
          u = Promise.resolve(i);
        h < g;

      )
        u = u.then(p[h++], p[h++])
      return u
    }
    g = a.length
    let f = i
    for (h = 0; h < g; ) {
      const p = a[h++],
        v = a[h++]
      try {
        f = p(f)
      } catch (m) {
        v.call(this, m)
        break
      }
    }
    try {
      u = ng.call(this, f)
    } catch (p) {
      return Promise.reject(p)
    }
    for (h = 0, g = c.length; h < g; ) u = u.then(c[h++], c[h++])
    return u
  }
  getUri(t) {
    t = Hn(this.defaults, t)
    const i = lm(t.baseURL, t.url)
    return sm(i, t.params, t.paramsSerializer)
  }
}
ee.forEach(['delete', 'get', 'head', 'options'], function (t) {
  Dn.prototype[t] = function (i, s) {
    return this.request(
      Hn(s || {}, { method: t, url: i, data: (s || {}).data }),
    )
  }
})
ee.forEach(['post', 'put', 'patch'], function (t) {
  function i(s) {
    return function (r, o, a) {
      return this.request(
        Hn(a || {}, {
          method: t,
          headers: s ? { 'Content-Type': 'multipart/form-data' } : {},
          url: r,
          data: o,
        }),
      )
    }
  }
  ;(Dn.prototype[t] = i()), (Dn.prototype[t + 'Form'] = i(!0))
})
class Qu {
  constructor(t) {
    if (typeof t != 'function')
      throw new TypeError('executor must be a function.')
    let i
    this.promise = new Promise(function (r) {
      i = r
    })
    const s = this
    this.promise.then((n) => {
      if (!s._listeners) return
      let r = s._listeners.length
      for (; r-- > 0; ) s._listeners[r](n)
      s._listeners = null
    }),
      (this.promise.then = (n) => {
        let r
        const o = new Promise((a) => {
          s.subscribe(a), (r = a)
        }).then(n)
        return (
          (o.cancel = function () {
            s.unsubscribe(r)
          }),
          o
        )
      }),
      t(function (r, o, a) {
        s.reason || ((s.reason = new xr(r, o, a)), i(s.reason))
      })
  }
  throwIfRequested() {
    if (this.reason) throw this.reason
  }
  subscribe(t) {
    if (this.reason) {
      t(this.reason)
      return
    }
    this._listeners ? this._listeners.push(t) : (this._listeners = [t])
  }
  unsubscribe(t) {
    if (!this._listeners) return
    const i = this._listeners.indexOf(t)
    i !== -1 && this._listeners.splice(i, 1)
  }
  toAbortSignal() {
    const t = new AbortController(),
      i = (s) => {
        t.abort(s)
      }
    return (
      this.subscribe(i),
      (t.signal.unsubscribe = () => this.unsubscribe(i)),
      t.signal
    )
  }
  static source() {
    let t
    return {
      token: new Qu(function (n) {
        t = n
      }),
      cancel: t,
    }
  }
}
function ex(e) {
  return function (i) {
    return e.apply(null, i)
  }
}
function tx(e) {
  return ee.isObject(e) && e.isAxiosError === !0
}
const Vc = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
}
Object.entries(Vc).forEach(([e, t]) => {
  Vc[t] = e
})
function fm(e) {
  const t = new Dn(e),
    i = Up(Dn.prototype.request, t)
  return (
    ee.extend(i, Dn.prototype, t, { allOwnKeys: !0 }),
    ee.extend(i, t, null, { allOwnKeys: !0 }),
    (i.create = function (n) {
      return fm(Hn(e, n))
    }),
    i
  )
}
const Wt = fm(Oo)
Wt.Axios = Dn
Wt.CanceledError = xr
Wt.CancelToken = Qu
Wt.isCancel = om
Wt.VERSION = gm
Wt.toFormData = hl
Wt.AxiosError = Qe
Wt.Cancel = Wt.CanceledError
Wt.all = function (t) {
  return Promise.all(t)
}
Wt.spread = ex
Wt.isAxiosError = tx
Wt.mergeConfig = Hn
Wt.AxiosHeaders = Ti
Wt.formToJSON = (e) => rm(ee.isHTMLForm(e) ? new FormData(e) : e)
Wt.getAdapter = hm.getAdapter
Wt.HttpStatusCode = Vc
Wt.default = Wt
const ix = window.location.hostname,
  og = window.location.port
let no
const ag = `${ix}${og ? ':' + og : ''}`
ag === '192.168.60.50' || ag === '192.168.68.26:3000'
  ? (no = '')
  : (no = 'http://localhost:8080/api/v1')
const sx = {
    workingTag: 'Q',
    companySeq: 1,
    languageSeq: 6,
    codeHelpSeq: '10009',
    keyword: '',
    param1: '',
    param2: '',
    param3: '',
    param4: '',
    conditionSeq: '2',
    pageCount: 1,
    pageSize: 350,
    subConditionSql: 'TypeSeq = 3031001',
    accUnit: 1,
    bizUnit: 0,
    factUnit: 0,
    deptSeq: 0,
    wkDeptSeq: 0,
    empSeq: 0,
    userSeq: 18770,
  },
  nx = (e) => {
    const t = { ...sx, keyword: e },
      i = `%${t.keyword}%`,
      s = {
        workingTag: t.workingTag,
        companySeq: t.companySeq,
        languageSeq: t.languageSeq,
        codeHelpSeq: t.codeHelpSeq,
        keyword: i,
        param1: t.param1,
        param2: t.param2,
        param3: t.param3,
        param4: t.param4,
        conditionSeq: t.conditionSeq,
        pageCount: t.pageCount,
        pageSize: t.pageSize,
        subConditionSql: t.subConditionSql,
        accUnit: t.accUnit,
        bizUnit: t.bizUnit,
        factUnit: t.factUnit,
        deptSeq: t.deptSeq,
        wkDeptSeq: t.wkDeptSeq,
        empSeq: t.empSeq,
        userSeq: t.userSeq,
      }
    return Wt.post(`${no}/mssql/users/SCACodeHelpQuery`, s, {
      headers: { 'Content-Type': 'application/json' },
    })
      .then((n) => {
        if (n.status === 200 || n.status === 201) return n.data
        throw new Error('Error from API: ' + n.data.message)
      })
      .catch((n) => {
        const r = n.response
          ? n.response.data.message || 'Error from API'
          : 'Unknown error occurred'
        throw new Error(r)
      })
  },
  { RangePicker: rx } = Er
function ox({
  keyword: e,
  setKeyword: t,
  value: i,
  setValue: s,
  loadingCodeHelp: n,
  setIsDrawerVisible: r,
  handleSearch: o,
  setUmEmpType: a,
  dateRange: l,
  setDateRange: c,
}) {
  const { t: u } = cf()
  _S()
  const h = (p) => {
      a(p)
    },
    g = (p) => {
      s(p)
    },
    f = () => {
      r(!0)
    }
  return Oe.jsxs('div', {
    className: 'mt-1',
    children: [
      Oe.jsx('div', {
        className: 'group p-2 mb-2  bg-white border rounded-lg',
        children: Oe.jsxs('div', {
          className: 'flex gap-4 justify-between',
          children: [
            Oe.jsxs('div', {
              className: 'flex gap-4',
              children: [
                Oe.jsx(Ds, {
                  type: 'primary',
                  onClick: o,
                  loading: n,
                  icon: Oe.jsx(Au, {}),
                  size: 'middle',
                  children: 'Truy vn',
                }),
                Oe.jsx(Ds, {
                  type: 'default',
                  icon: Oe.jsx(gE, {}),
                  size: 'middle',
                  children: 'Lu',
                }),
                Oe.jsx(Ds, {
                  type: 'primary',
                  danger: !0,
                  icon: Oe.jsx(uE, {}),
                  size: 'middle',
                  children: 'Xa',
                }),
                Oe.jsx(Ds, {
                  type: 'dashed',
                  icon: Oe.jsx(H0, {}),
                  size: 'middle',
                  children: 'Thm',
                }),
              ],
            }),
            Oe.jsxs('div', {
              className: 'flex gap-4',
              children: [
                Oe.jsx(Q0, {
                  options: [
                    { label: 'Table', value: 'Table', icon: Oe.jsx(mE, {}) },
                    { label: 'Sheet', value: 'Sheet', icon: Oe.jsx(aE, {}) },
                  ],
                  size: 'middle',
                  value: i,
                  onChange: g,
                }),
                Oe.jsxs(Ds, {
                  size: 'middle',
                  className: 'bg-white',
                  onClick: f,
                  children: [Oe.jsx(PE, {}), 'Column'],
                }),
              ],
            }),
          ],
        }),
      }),
      Oe.jsxs('details', {
        className:
          'group p-2 [&_summary::-webkit-details-marker]:hidden  bg-white border rounded-lg',
        open: !0,
        children: [
          Oe.jsxs('summary', {
            className:
              'flex cursor-pointer items-center justify-between gap-1.5 text-gray-900',
            children: [
              Oe.jsx('h2', {
                className: ' text-base font-medium',
                children: u('CNG C'),
              }),
              Oe.jsx('span', {
                className: 'relative size-5 shrink-0',
                children: Oe.jsx('svg', {
                  className:
                    'size-5 shrink-0 transition duration-300 group-open:-rotate-180',
                  xmlns: 'http://www.w3.org/2000/svg',
                  fill: 'none',
                  viewBox: '0 0 24 24',
                  stroke: 'currentColor',
                  children: Oe.jsx('path', {
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    strokeWidth: '2',
                    d: 'M19 9l-7 7-7-7',
                  }),
                }),
              }),
            ],
          }),
          Oe.jsxs('div', {
            className: 'flex p-3 gap-4',
            children: [
              Oe.jsxs('div', {
                className: 'flex flex-col',
                children: [
                  Oe.jsx(WS, {
                    title: 'Gi tr mc nh l 2024-01-01',
                    children: Oe.jsx('label', {
                      htmlFor: 'datePicker',
                      children: 'Thi gian',
                    }),
                  }),
                  Oe.jsx(rx, {
                    id: 'datePicker',
                    size: 'middle',
                    value: l,
                    onChange: c,
                  }),
                ],
              }),
              Oe.jsxs('div', {
                className: 'flex flex-col',
                children: [
                  Oe.jsx('label', {
                    htmlFor: 'typeSelect',
                    children: 'Phn loi nhn vin',
                  }),
                  Oe.jsx(yr, {
                    id: 'typeSelect',
                    defaultValue: 'All',
                    style: { width: 120 },
                    size: 'middle',
                    onChange: h,
                    options: [
                      { value: 0, label: 'All' },
                      { value: 3059001, label: 'Official' },
                      { value: 3059002, label: 'Seasonal' },
                    ],
                  }),
                ],
              }),
              Oe.jsxs('div', {
                className: 'flex flex-col',
                children: [
                  Oe.jsx('label', {
                    htmlFor: 'typeSelect',
                    children: 'Nhn vin',
                  }),
                  Oe.jsx(Fr, {
                    size: 'middle',
                    value: e,
                    onChange: (p) => t(p.target.value),
                    placeholder: 'Tn hoc m nhn vin',
                    className: 'bg-blue-50',
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
    ],
  })
}
var Dr = class {
    constructor() {
      ;(this.allSyncListeners = new Map()),
        (this.allAsyncListeners = new Map()),
        (this.globalSyncListeners = new Set()),
        (this.globalAsyncListeners = new Set()),
        (this.asyncFunctionsQueue = []),
        (this.scheduled = !1),
        (this.firedEvents = {})
    }
    setFrameworkOverrides(e) {
      this.frameworkOverrides = e
    }
    getListeners(e, t, i) {
      const s = t ? this.allAsyncListeners : this.allSyncListeners
      let n = s.get(e)
      return !n && i && ((n = new Set()), s.set(e, n)), n
    }
    noRegisteredListenersExist() {
      return (
        this.allSyncListeners.size === 0 &&
        this.allAsyncListeners.size === 0 &&
        this.globalSyncListeners.size === 0 &&
        this.globalAsyncListeners.size === 0
      )
    }
    addEventListener(e, t, i = !1) {
      this.getListeners(e, i, !0).add(t)
    }
    removeEventListener(e, t, i = !1) {
      const s = this.getListeners(e, i, !1)
      s &&
        (s.delete(t),
        s.size === 0 &&
          (i ? this.allAsyncListeners : this.allSyncListeners).delete(e))
    }
    addGlobalListener(e, t = !1) {
      ;(t ? this.globalAsyncListeners : this.globalSyncListeners).add(e)
    }
    removeGlobalListener(e, t = !1) {
      ;(t ? this.globalAsyncListeners : this.globalSyncListeners).delete(e)
    }
    dispatchEvent(e) {
      const t = e
      this.dispatchToListeners(t, !0),
        this.dispatchToListeners(t, !1),
        (this.firedEvents[t.type] = !0)
    }
    dispatchEventOnce(e) {
      this.firedEvents[e.type] || this.dispatchEvent(e)
    }
    dispatchToListeners(e, t) {
      const i = e.type
      if (t && 'event' in e) {
        const a = e.event
        a instanceof Event && (e.eventPath = a.composedPath())
      }
      const s = (a, l) =>
          a.forEach((c) => {
            if (!l.has(c)) return
            const u = this.frameworkOverrides
              ? () => this.frameworkOverrides.wrapIncoming(() => c(e))
              : () => c(e)
            t ? this.dispatchAsync(u) : u()
          }),
        n = this.getListeners(i, t, !1) ?? new Set(),
        r = new Set(n)
      r.size > 0 && s(r, n),
        new Set(
          t ? this.globalAsyncListeners : this.globalSyncListeners,
        ).forEach((a) => {
          const l = this.frameworkOverrides
            ? () => this.frameworkOverrides.wrapIncoming(() => a(i, e))
            : () => a(i, e)
          t ? this.dispatchAsync(l) : l()
        })
    }
    dispatchAsync(e) {
      if ((this.asyncFunctionsQueue.push(e), !this.scheduled)) {
        const t = () => {
          window.setTimeout(this.flushAsyncQueue.bind(this), 0)
        }
        this.frameworkOverrides ? this.frameworkOverrides.wrapIncoming(t) : t(),
          (this.scheduled = !0)
      }
    }
    flushAsyncQueue() {
      this.scheduled = !1
      const e = this.asyncFunctionsQueue.slice()
      ;(this.asyncFunctionsQueue = []), e.forEach((t) => t())
    }
  },
  pm = ((e) => (
    (e.CommunityCoreModule = '@ag-grid-community/core'),
    (e.InfiniteRowModelModule = '@ag-grid-community/infinite-row-model'),
    (e.ClientSideRowModelModule = '@ag-grid-community/client-side-row-model'),
    (e.CsvExportModule = '@ag-grid-community/csv-export'),
    (e.EnterpriseCoreModule = '@ag-grid-enterprise/core'),
    (e.RowGroupingModule = '@ag-grid-enterprise/row-grouping'),
    (e.ColumnsToolPanelModule = '@ag-grid-enterprise/column-tool-panel'),
    (e.FiltersToolPanelModule = '@ag-grid-enterprise/filter-tool-panel'),
    (e.MenuModule = '@ag-grid-enterprise/menu'),
    (e.SetFilterModule = '@ag-grid-enterprise/set-filter'),
    (e.MultiFilterModule = '@ag-grid-enterprise/multi-filter'),
    (e.StatusBarModule = '@ag-grid-enterprise/status-bar'),
    (e.SideBarModule = '@ag-grid-enterprise/side-bar'),
    (e.RangeSelectionModule = '@ag-grid-enterprise/range-selection'),
    (e.MasterDetailModule = '@ag-grid-enterprise/master-detail'),
    (e.RichSelectModule = '@ag-grid-enterprise/rich-select'),
    (e.GridChartsModule = '@ag-grid-enterprise/charts'),
    (e.ViewportRowModelModule = '@ag-grid-enterprise/viewport-row-model'),
    (e.ServerSideRowModelModule = '@ag-grid-enterprise/server-side-row-model'),
    (e.ExcelExportModule = '@ag-grid-enterprise/excel-export'),
    (e.ClipboardModule = '@ag-grid-enterprise/clipboard'),
    (e.SparklinesModule = '@ag-grid-enterprise/sparklines'),
    (e.AdvancedFilterModule = '@ag-grid-enterprise/advanced-filter'),
    (e.AngularModule = '@ag-grid-community/angular'),
    (e.ReactModule = '@ag-grid-community/react'),
    (e.VueModule = '@ag-grid-community/vue'),
    e
  ))(pm || {}),
  lg = {}
function Xu(e, t) {
  lg[t] || (e(), (lg[t] = !0))
}
function Xi(e, ...t) {
  console.log('AG Grid: ' + e, ...t)
}
function te(e, ...t) {
  Xu(
    () => console.warn('AG Grid: ' + e, ...t),
    e + (t == null ? void 0 : t.join('')),
  )
}
function ht(e, ...t) {
  Xu(
    () => console.error('AG Grid: ' + e, ...t),
    e + (t == null ? void 0 : t.join('')),
  )
}
function Ju(e) {
  return !!(e && e.constructor && e.call && e.apply)
}
function ax(e) {
  lx(e, 400)
}
var nc = [],
  rc = !1
function cg(e) {
  nc.push(e),
    !rc &&
      ((rc = !0),
      window.setTimeout(() => {
        const t = nc.slice()
        ;(nc.length = 0), (rc = !1), t.forEach((i) => i())
      }, 0))
}
function lx(e, t = 0) {
  e.length > 0 && window.setTimeout(() => e.forEach((i) => i()), t)
}
function bi(e, t) {
  let i
  return function (...s) {
    const n = this
    window.clearTimeout(i),
      (i = window.setTimeout(function () {
        e.apply(n, s)
      }, t))
  }
}
function ug(e, t) {
  let i = 0
  return function (...s) {
    const n = this,
      r = new Date().getTime()
    r - i < t || ((i = r), e.apply(n, s))
  }
}
function cx(e, t, i = 100, s) {
  const n = new Date().getTime()
  let r = null,
    o = !1
  const a = () => {
    const l = new Date().getTime() - n > i
    ;(e() || l) &&
      (t(),
      (o = !0),
      r != null && (window.clearInterval(r), (r = null)),
      l && s && te(s))
  }
  a(), o || (r = window.setInterval(a, 10))
}
function ux(...e) {
  return (t) => e.reduce((i, s) => s(i), t)
}
function As(e) {
  return e == null || e === '' ? null : e
}
function ue(e, t = !1) {
  return e != null && (e !== '' || t)
}
function ot(e) {
  return !ue(e)
}
function Hi(e) {
  return e == null || e.length === 0
}
function _c(e) {
  return e != null && typeof e.toString == 'function' ? e.toString() : null
}
function Mn(e) {
  if (e === void 0) return
  if (e === null || e === '') return null
  if (typeof e == 'number') return isNaN(e) ? void 0 : e
  const t = parseInt(e, 10)
  return isNaN(t) ? void 0 : t
}
function Wc(e) {
  if (e !== void 0) return e === null || e === '' ? !1 : $c(e)
}
function $c(e) {
  return typeof e == 'boolean'
    ? e
    : typeof e == 'string'
      ? e.toUpperCase() === 'TRUE' || e == ''
      : !1
}
function po(e, t) {
  const i = e ? JSON.stringify(e) : null,
    s = t ? JSON.stringify(t) : null
  return i === s
}
function dx(e, t, i = !1) {
  const s = e == null,
    n = t == null
  if (
    (e && e.toNumber && (e = e.toNumber()),
    t && t.toNumber && (t = t.toNumber()),
    s && n)
  )
    return 0
  if (s) return -1
  if (n) return 1
  function r(o, a) {
    return o > a ? 1 : o < a ? -1 : 0
  }
  if (typeof e != 'string' || !i) return r(e, t)
  try {
    return e.localeCompare(t)
  } catch {
    return r(e, t)
  }
}
function ua(e) {
  if (e instanceof Set || e instanceof Map) {
    const t = []
    return e.forEach((i) => t.push(i)), t
  }
  return Object.values(e)
}
function mm(e, t) {
  return e.get('rowModelType') === t
}
function Pt(e) {
  return mm(e, 'clientSide')
}
function ms(e) {
  return mm(e, 'serverSide')
}
function ci(e, t) {
  return e.get('domLayout') === t
}
function Ia(e) {
  return Oa(e) !== void 0
}
function Ta(e) {
  return !e.get('suppressAsyncEvents')
}
function vm(e) {
  return typeof e.get('getRowHeight') == 'function'
}
function hx(e, t) {
  return t
    ? !e.get('enableStrictPivotColumnOrder')
    : e.get('maintainColumnOrder')
}
function ln(e, t, i = !1, s) {
  if ((s == null && (s = e.environment.getDefaultRowHeight()), vm(e))) {
    if (i) return { height: s, estimated: !0 }
    const o = { node: t, data: t.data },
      a = e.getCallback('getRowHeight')(o)
    if (zc(a))
      return (
        a === 0 &&
          te(
            'The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead.',
          ),
        { height: Math.max(1, a), estimated: !1 }
      )
  }
  if (t.detail && e.get('masterDetail')) return gx(e)
  const n = e.get('rowHeight')
  return { height: n && zc(n) ? n : s, estimated: !1 }
}
function gx(e) {
  if (e.get('detailRowAutoHeight')) return { height: 1, estimated: !1 }
  const t = e.get('detailRowHeight')
  return zc(t) ? { height: t, estimated: !1 } : { height: 300, estimated: !1 }
}
function In(e) {
  const { environment: t } = e,
    i = e.get('rowHeight')
  if (!i || ot(i)) return t.getDefaultRowHeight()
  const s = t.refreshRowHeightVariable()
  return s !== -1
    ? s
    : (te('row height must be a number if not using standard row model'),
      t.getDefaultRowHeight())
}
function zc(e) {
  return !isNaN(e) && typeof e == 'number' && isFinite(e)
}
function mo(e, t, i) {
  const s = t[e.getDomDataKey()]
  return s ? s[i] : void 0
}
function Nn(e, t, i, s) {
  const n = e.getDomDataKey()
  let r = t[n]
  ot(r) && ((r = {}), (t[n] = r)), (r[i] = s)
}
function Gt(e) {
  let t = null
  const i = e.get('getDocument')
  return (
    i && ue(i) ? (t = i()) : e.eGridDiv && (t = e.eGridDiv.ownerDocument),
    t && ue(t) ? t : document
  )
}
function Cm(e) {
  return Gt(e).defaultView || window
}
function vo(e) {
  return e.eGridDiv.getRootNode()
}
function Lt(e) {
  return vo(e).activeElement
}
function Sm(e) {
  const t = Gt(e),
    i = Lt(e)
  return i === null || i === t.body
}
function or(e) {
  return e.get('ensureDomOrder') ? !1 : e.get('animateRows')
}
function fl(e) {
  return !(
    e.get('paginateChildRows') ||
    e.get('groupHideOpenParents') ||
    ci(e, 'print')
  )
}
function cs(e) {
  const t = e.get('autoGroupColumnDef')
  return !(t != null && t.comparator) && !e.get('treeData')
}
function Uc(e) {
  const t = e.get('groupAggFiltering')
  if (typeof t == 'function') return e.getCallback('groupAggFiltering')
  if (t === !0) return () => !0
}
function wm(e) {
  const t = e.get('grandTotalRow')
  if (t) return t
  if (e.get('groupIncludeTotalFooter')) return 'bottom'
}
function ym(e) {
  const t = e.get('groupTotalRow')
  if (typeof t == 'function') return e.getCallback('groupTotalRow')
  if (t) return () => t
  const i = e.get('groupIncludeFooter')
  if (typeof i == 'function') {
    const s = e.getCallback('groupIncludeFooter')
    return (n) => (s(n) ? 'bottom' : void 0)
  }
  return () => (i ? 'bottom' : void 0)
}
function bm(e) {
  return e.exists('groupDisplayType')
    ? e.get('groupDisplayType') === 'multipleColumns'
    : e.get('groupHideOpenParents')
}
function pl(e, t) {
  return t ? !1 : e.get('groupDisplayType') === 'groupRows'
}
function Mr(e) {
  const t = e.getCallback('getRowId')
  return t === void 0
    ? t
    : (i) => {
        let s = t(i)
        return (
          typeof s != 'string' &&
            (te(
              'The getRowId callback must return a string. The ID ',
              s,
              ' is being cast to a string.',
            ),
            (s = String(s))),
          s
        )
      }
}
function fr(e) {
  return (e == null ? void 0 : e.checkboxes) ?? !0
}
function Aa(e) {
  return (
    (e == null ? void 0 : e.mode) === 'multiRow' && (e.headerCheckbox ?? !0)
  )
}
function fx(e) {
  return (e == null ? void 0 : e.hideDisabledCheckboxes) ?? !1
}
function px(e) {
  return typeof e.get('rowSelection') != 'string'
}
function mx(e) {
  return e.get('cellSelection') !== void 0
}
function vx(e) {
  const t = e.get('cellSelection')
  return t !== void 0
    ? typeof t != 'boolean'
      ? ((t == null ? void 0 : t.suppressMultiRanges) ?? !1)
      : !1
    : e.get('suppressMultiRangeSelection')
}
function Vs(e) {
  const t = e.get('cellSelection')
  return t !== void 0 ? !!t : e.get('enableRangeSelection')
}
function Cx(e) {
  var s
  const t = e.get('cellSelection')
  return t !== void 0
    ? typeof t != 'boolean'
      ? ((s = t.handle) == null ? void 0 : s.mode) === 'range'
      : !1
    : e.get('enableRangeHandle')
}
function dg(e) {
  var s
  const t = e.get('cellSelection')
  return t !== void 0
    ? typeof t != 'boolean'
      ? ((s = t.handle) == null ? void 0 : s.mode) === 'fill'
      : !1
    : e.get('enableFillHandle')
}
function Rm(e) {
  const t = e.get('rowSelection') ?? 'single'
  if (typeof t == 'string') {
    const i = e.get('suppressRowClickSelection'),
      s = e.get('suppressRowDeselection')
    return i && s ? !1 : i ? 'enableDeselection' : s ? 'enableSelection' : !0
  }
  return t.mode === 'singleRow' || t.mode === 'multiRow'
    ? (t.enableClickSelection ?? !1)
    : !1
}
function Sx(e) {
  const t = Rm(e)
  return t === !0 || t === 'enableSelection'
}
function hg(e) {
  const t = Rm(e)
  return t === !0 || t === 'enableDeselection'
}
function Zu(e) {
  const t = e.get('rowSelection')
  return typeof t == 'string'
    ? e.get('isRowSelectable')
    : t == null
      ? void 0
      : t.isRowSelectable
}
function Oa(e) {
  const t = e.get('rowSelection')
  if (typeof t == 'string')
    switch (t) {
      case 'multiple':
        return 'multiRow'
      case 'single':
        return 'singleRow'
      default:
        return
    }
  return t == null ? void 0 : t.mode
}
function Fm(e) {
  return Oa(e) === 'multiRow'
}
function wx(e) {
  const t = e.get('rowSelection')
  return typeof t == 'string'
    ? e.get('rowMultiSelectWithClick')
    : ((t == null ? void 0 : t.enableSelectionWithoutKeys) ?? !1)
}
function ed(e) {
  const t = e.get('rowSelection')
  if (typeof t == 'string') {
    const i = e.get('groupSelectsChildren'),
      s = e.get('groupSelectsFiltered')
    return i && s ? 'filteredDescendants' : i ? 'descendants' : 'self'
  }
  return (t == null ? void 0 : t.mode) === 'multiRow' ? t.groupSelects : void 0
}
function Gn(e) {
  const t = ed(e)
  return t === 'descendants' || t === 'filteredDescendants'
}
function oc(e) {
  return (
    e.isModuleRegistered('@ag-grid-enterprise/set-filter') &&
    !e.get('suppressSetFilterByDefault')
  )
}
function rt(e) {
  if (!(!e || !e.length)) return e[e.length - 1]
}
function gn(e, t, i) {
  return e == null && t == null
    ? !0
    : e != null &&
        t != null &&
        e.length === t.length &&
        e.every((s, n) => (i ? i(s, t[n]) : t[n] === s))
}
function yx(e) {
  return e.sort((t, i) => t - i)
}
function Em(e, t) {
  const i = e.indexOf(t)
  i >= 0 && ((e[i] = e[e.length - 1]), e.pop())
}
function Ri(e, t) {
  const i = e.indexOf(t)
  i >= 0 && e.splice(i, 1)
}
function bx(e, t) {
  for (let i = 0; i < t.length; i++) Em(e, t[i])
}
function Rx(e, t) {
  for (let i = 0; i < t.length; i++) Ri(e, t[i])
}
function La(e, t, i) {
  e.splice(i, 0, t)
}
function Pm(e, t, i) {
  Rx(e, t),
    t
      .slice()
      .reverse()
      .forEach((s) => La(e, s, i))
}
function Tn(e, t) {
  return e.indexOf(t) > -1
}
function Fx(e) {
  return (e == null ? void 0 : e.flatMap((t) => t)) ?? []
}
function gg(e, t) {
  t == null || e == null || t.forEach((i) => e.push(i))
}
var xm = '__ag_Grid_Stop_Propagation',
  Ex = ['touchstart', 'touchend', 'touchmove', 'touchcancel', 'scroll'],
  ac = {}
function pr(e) {
  e[xm] = !0
}
function Os(e) {
  return e[xm] === !0
}
var Dm = (() => {
  const e = {
    select: 'input',
    change: 'input',
    submit: 'form',
    reset: 'form',
    error: 'img',
    load: 'img',
    abort: 'img',
  }
  return (i) => {
    if (typeof ac[i] == 'boolean') return ac[i]
    const s = document.createElement(e[i] || 'div')
    return (i = 'on' + i), (ac[i] = i in s)
  }
})()
function jc(e, t, i) {
  let s = t
  for (; s; ) {
    const n = mo(e, s, i)
    if (n) return n
    s = s.parentElement
  }
  return null
}
function Px(e, t) {
  return !t || !e ? !1 : Dx(t).indexOf(e) >= 0
}
function xx(e) {
  const t = []
  let i = e.target
  for (; i; ) t.push(i), (i = i.parentElement)
  return t
}
function Dx(e) {
  const t = e
  return t.path ? t.path : t.composedPath ? t.composedPath() : xx(t)
}
function Mx(e, t, i, s) {
  const r = Tn(Ex, i) ? { passive: !0 } : void 0
  e && e.addEventListener && e.addEventListener(t, i, s, r)
}
var X = class {
  constructor() {
    ;(this.destroyFunctions = []),
      (this.destroyed = !1),
      (this.__v_skip = !0),
      (this.propertyListenerId = 0),
      (this.lastChangeSetIdLookup = {}),
      (this.isAlive = () => !this.destroyed)
  }
  preWireBeans(e) {
    ;(this.frameworkOverrides = e.frameworkOverrides),
      (this.stubContext = e.context),
      (this.eventService = e.eventService),
      (this.gos = e.gos),
      (this.localeService = e.localeService)
  }
  getFrameworkOverrides() {
    return this.frameworkOverrides
  }
  destroy() {
    for (let e = 0; e < this.destroyFunctions.length; e++)
      this.destroyFunctions[e]()
    ;(this.destroyFunctions.length = 0),
      (this.destroyed = !0),
      this.dispatchLocalEvent({ type: 'destroyed' })
  }
  addEventListener(e, t, i) {
    this.localEventService || (this.localEventService = new Dr()),
      this.localEventService.addEventListener(e, t, i)
  }
  removeEventListener(e, t, i) {
    this.localEventService &&
      this.localEventService.removeEventListener(e, t, i)
  }
  dispatchLocalEvent(e) {
    this.localEventService && this.localEventService.dispatchEvent(e)
  }
  addManagedElementListeners(e, t) {
    return this._setupListeners(e, t)
  }
  addManagedEventListeners(e) {
    return this._setupListeners(this.eventService, e)
  }
  addManagedListeners(e, t) {
    return this._setupListeners(e, t)
  }
  _setupListeners(e, t) {
    const i = []
    for (const s in t) {
      const n = t[s]
      n && i.push(this._setupListener(e, s, n))
    }
    return i
  }
  _setupListener(e, t, i) {
    if (this.destroyed) return () => null
    e instanceof HTMLElement
      ? Mx(this.getFrameworkOverrides(), e, t, i)
      : e.addEventListener(t, i)
    const s = () => (e.removeEventListener(t, i), null)
    return (
      this.destroyFunctions.push(s),
      () => (
        s(),
        (this.destroyFunctions = this.destroyFunctions.filter((n) => n !== s)),
        null
      )
    )
  }
  setupGridOptionListener(e, t) {
    this.gos.addPropertyEventListener(e, t)
    const i = () => (this.gos.removePropertyEventListener(e, t), null)
    return (
      this.destroyFunctions.push(i),
      () => (
        i(),
        (this.destroyFunctions = this.destroyFunctions.filter((s) => s !== i)),
        null
      )
    )
  }
  addManagedPropertyListener(e, t) {
    return this.destroyed ? () => null : this.setupGridOptionListener(e, t)
  }
  addManagedPropertyListeners(e, t) {
    if (this.destroyed) return
    const i = e.join('-') + this.propertyListenerId++,
      s = (n) => {
        if (n.changeSet) {
          if (n.changeSet && n.changeSet.id === this.lastChangeSetIdLookup[i])
            return
          this.lastChangeSetIdLookup[i] = n.changeSet.id
        }
        const r = {
          type: 'gridPropertyChanged',
          changeSet: n.changeSet,
          source: n.source,
        }
        t(r)
      }
    e.forEach((n) => this.setupGridOptionListener(n, s))
  }
  addDestroyFunc(e) {
    this.isAlive() ? this.destroyFunctions.push(e) : e()
  }
  createManagedBean(e, t) {
    const i = this.createBean(e, t)
    return this.addDestroyFunc(this.destroyBean.bind(this, e, t)), i
  }
  createBean(e, t, i) {
    return (t || this.stubContext).createBean(e, i)
  }
  destroyBean(e, t) {
    return (t || this.stubContext).destroyBean(e)
  }
  destroyBeans(e, t) {
    return (t || this.stubContext).destroyBeans(e)
  }
}
function wi(e) {
  return e instanceof da
}
var da = class extends X {
    constructor(e, t, i, s) {
      super(),
        (this.isColumn = !1),
        (this.expandable = !1),
        (this.instanceId = Tm()),
        (this.expandableListenerRemoveCallback = null),
        (this.colGroupDef = e),
        (this.groupId = t),
        (this.expanded = !!e && !!e.openByDefault),
        (this.padding = i),
        (this.level = s)
    }
    destroy() {
      this.expandableListenerRemoveCallback && this.reset(null, void 0),
        super.destroy()
    }
    reset(e, t) {
      ;(this.colGroupDef = e),
        (this.level = t),
        (this.originalParent = null),
        this.expandableListenerRemoveCallback &&
          this.expandableListenerRemoveCallback(),
        (this.children = void 0),
        (this.expandable = void 0)
    }
    getInstanceId() {
      return this.instanceId
    }
    setOriginalParent(e) {
      this.originalParent = e
    }
    getOriginalParent() {
      return this.originalParent
    }
    getLevel() {
      return this.level
    }
    isVisible() {
      return this.children ? this.children.some((e) => e.isVisible()) : !1
    }
    isPadding() {
      return this.padding
    }
    setExpanded(e) {
      ;(this.expanded = e === void 0 ? !1 : e),
        this.dispatchLocalEvent({ type: 'expandedChanged' })
    }
    isExpandable() {
      return this.expandable
    }
    isExpanded() {
      return this.expanded
    }
    getGroupId() {
      return this.groupId
    }
    getId() {
      return this.getGroupId()
    }
    setChildren(e) {
      this.children = e
    }
    getChildren() {
      return this.children
    }
    getColGroupDef() {
      return this.colGroupDef
    }
    getLeafColumns() {
      const e = []
      return this.addLeafColumns(e), e
    }
    addLeafColumns(e) {
      this.children &&
        this.children.forEach((t) => {
          cn(t) ? e.push(t) : wi(t) && t.addLeafColumns(e)
        })
    }
    getColumnGroupShow() {
      const e = this.colGroupDef
      if (e) return e.columnGroupShow
    }
    setupExpandable() {
      this.setExpandable(),
        this.expandableListenerRemoveCallback &&
          this.expandableListenerRemoveCallback()
      const e = this.onColumnVisibilityChanged.bind(this)
      this.getLeafColumns().forEach((t) =>
        t.addEventListener('visibleChanged', e),
      ),
        (this.expandableListenerRemoveCallback = () => {
          this.getLeafColumns().forEach((t) =>
            t.removeEventListener('visibleChanged', e),
          ),
            (this.expandableListenerRemoveCallback = null)
        })
    }
    setExpandable() {
      if (this.isPadding()) return
      let e = !1,
        t = !1,
        i = !1
      const s = this.findChildrenRemovingPadding()
      for (let r = 0, o = s.length; r < o; r++) {
        const a = s[r]
        if (!a.isVisible()) continue
        const l = a.getColumnGroupShow()
        l === 'open'
          ? ((e = !0), (i = !0))
          : l === 'closed'
            ? ((t = !0), (i = !0))
            : ((e = !0), (t = !0))
      }
      const n = e && t && i
      this.expandable !== n &&
        ((this.expandable = n),
        this.dispatchLocalEvent({ type: 'expandableChanged' }))
    }
    findChildrenRemovingPadding() {
      const e = [],
        t = (i) => {
          i.forEach((s) => {
            wi(s) && s.isPadding() ? t(s.children) : e.push(s)
          })
        }
      return t(this.children), e
    }
    onColumnVisibilityChanged() {
      this.setExpandable()
    }
  },
  Mm = 'ag-Grid-ControlsColumn',
  Ix = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'controlsColService')
    }
    createControlsCols() {
      const { gos: e } = this,
        t = e.get('rowSelection')
      if (!t || typeof t != 'object') return []
      const i = fr(t),
        s = Aa(t)
      if (i || s) {
        const n = e.get('selectionColumnDef'),
          o = {
            maxWidth: 50,
            resizable: !1,
            suppressHeaderMenuButton: !0,
            sortable: !1,
            suppressMovable: !0,
            lockPosition: e.get('enableRtl') ? 'right' : 'left',
            comparator(l, c, u, h) {
              const g = u.isSelected(),
                f = h.isSelected()
              return g && f ? 0 : g ? 1 : -1
            },
            editable: !1,
            suppressFillHandle: !0,
            ...n,
            colId: `${Mm}`,
          },
          a = new nd(o, null, o.colId, !1)
        return this.createBean(a), [a]
      }
      return []
    }
  },
  ml = 'ag-Grid-AutoColumn'
function td(e) {
  const t = [],
    i = (s) => {
      for (let n = 0; n < s.length; n++) {
        const r = s[n]
        cn(r) ? t.push(r) : wi(r) && i(r.getChildren())
      }
    }
  return i(e), t
}
function xs(e) {
  return e.reduce((t, i) => t + i.getActualWidth(), 0)
}
function tn(e, t, i) {
  const s = {}
  if (!t) return
  _s(null, t, (r) => {
    s[r.getInstanceId()] = r
  }),
    i &&
      _s(null, i, (r) => {
        s[r.getInstanceId()] = null
      })
  const n = Object.values(s).filter((r) => r != null)
  e.destroyBeans(n)
}
function Yc(e) {
  return e.getId().startsWith(ml)
}
function Lo(e) {
  return e.getColId().startsWith(Mm)
}
function ha(e) {
  let t = []
  return (
    e instanceof Array
      ? e.some((s) => typeof s != 'string')
        ? te(
            "if colDef.type is supplied an array it should be of type 'string[]'",
          )
        : (t = e)
      : typeof e == 'string'
        ? (t = e.split(','))
        : te("colDef.type should be of type 'string' | 'string[]'"),
    t
  )
}
var id = class {
    constructor(e) {
      ;(this.frameworkOverrides = e),
        (this.wrappedListeners = new Map()),
        (this.wrappedGlobalListeners = new Map())
    }
    wrap(e) {
      let t = e
      return (
        this.frameworkOverrides.shouldWrapOutgoing &&
          ((t = (i) => {
            this.frameworkOverrides.wrapOutgoing(() => e(i))
          }),
          this.wrappedListeners.set(e, t)),
        t
      )
    }
    wrapGlobal(e) {
      let t = e
      return (
        this.frameworkOverrides.shouldWrapOutgoing &&
          ((t = (i, s) => {
            this.frameworkOverrides.wrapOutgoing(() => e(i, s))
          }),
          this.wrappedGlobalListeners.set(e, t)),
        t
      )
    }
    unwrap(e) {
      return this.wrappedListeners.get(e) ?? e
    }
    unwrapGlobal(e) {
      return this.wrappedGlobalListeners.get(e) ?? e
    }
  },
  sd = new Set(['__proto__', 'constructor', 'prototype'])
function Qi(e, t) {
  if (e != null) {
    if (Array.isArray(e)) {
      for (let i = 0; i < e.length; i++) t(i.toString(), e[i])
      return
    }
    for (const [i, s] of Object.entries(e)) t(i, s)
  }
}
function Im(e) {
  const t = {},
    i = Object.keys(e)
  for (let s = 0; s < i.length; s++) {
    if (sd.has(i[s])) continue
    const n = i[s],
      r = e[n]
    t[n] = r
  }
  return t
}
function Kc(e, t) {
  if (!e) return
  const i = e,
    s = {}
  return (
    Object.keys(i).forEach((n) => {
      if ((t && t.indexOf(n) >= 0) || sd.has(n)) return
      const r = i[n]
      Qc(r) && r.constructor === Object ? (s[n] = Kc(r)) : (s[n] = r)
    }),
    s
  )
}
function qc(e) {
  if (!e) return []
  const t = Object
  if (typeof t.values == 'function') return t.values(e)
  const i = []
  for (const s in e)
    e.hasOwnProperty(s) && e.propertyIsEnumerable(s) && i.push(e[s])
  return i
}
function yi(e, t, i = !0, s = !1) {
  ue(t) &&
    Qi(t, (n, r) => {
      if (sd.has(n)) return
      let o = e[n]
      o !== r &&
        (s &&
          o == null &&
          r != null &&
          typeof r == 'object' &&
          r.constructor === Object &&
          ((o = {}), (e[n] = o)),
        Qc(r) && Qc(o) && !Array.isArray(o)
          ? yi(o, r, i, s)
          : (i || r !== void 0) && (e[n] = r))
    })
}
function ro(e, t, i) {
  if (!t || !e) return
  if (!i) return e[t]
  const s = t.split('.')
  let n = e
  for (let r = 0; r < s.length; r++) {
    if (n == null) return
    n = n[s[r]]
  }
  return n
}
function Qc(e) {
  return typeof e == 'object' && e !== null
}
var Tx = { resizable: !0, sortable: !0 },
  Ax = 0
function Tm() {
  return Ax++
}
function cn(e) {
  return e instanceof nd
}
var nd = class extends X {
    constructor(e, t, i, s) {
      super(),
        (this.isColumn = !0),
        (this.instanceId = Tm()),
        (this.autoHeaderHeight = null),
        (this.moving = !1),
        (this.menuVisible = !1),
        (this.lastLeftPinned = !1),
        (this.firstRightPinned = !1),
        (this.filterActive = !1),
        (this.columnEventService = new Dr()),
        (this.tooltipEnabled = !1),
        (this.rowGroupActive = !1),
        (this.pivotActive = !1),
        (this.aggregationActive = !1),
        (this.colDef = e),
        (this.userProvidedColDef = t),
        (this.colId = i),
        (this.primary = s),
        this.setState(e)
    }
    wireBeans(e) {
      this.columnHoverService = e.columnHoverService
    }
    getInstanceId() {
      return this.instanceId
    }
    setState(e) {
      e.sort !== void 0
        ? (e.sort === 'asc' || e.sort === 'desc') && (this.sort = e.sort)
        : (e.initialSort === 'asc' || e.initialSort === 'desc') &&
          (this.sort = e.initialSort)
      const t = e.sortIndex,
        i = e.initialSortIndex
      t !== void 0
        ? t !== null && (this.sortIndex = t)
        : i !== null && (this.sortIndex = i)
      const s = e.hide,
        n = e.initialHide
      s !== void 0 ? (this.visible = !s) : (this.visible = !n),
        e.pinned !== void 0
          ? this.setPinned(e.pinned)
          : this.setPinned(e.initialPinned)
      const r = e.flex,
        o = e.initialFlex
      r !== void 0 ? (this.flex = r) : o !== void 0 && (this.flex = o)
    }
    setColDef(e, t, i) {
      ;(this.colDef = e),
        (this.userProvidedColDef = t),
        this.initMinAndMaxWidths(),
        this.initDotNotation(),
        this.initTooltip(),
        this.columnEventService.dispatchEvent(
          this.createColumnEvent('colDefChanged', i),
        )
    }
    getUserProvidedColDef() {
      return this.userProvidedColDef
    }
    setParent(e) {
      this.parent = e
    }
    getParent() {
      return this.parent
    }
    setOriginalParent(e) {
      this.originalParent = e
    }
    getOriginalParent() {
      return this.originalParent
    }
    postConstruct() {
      this.initMinAndMaxWidths(),
        this.resetActualWidth('gridInitializing'),
        this.initDotNotation(),
        this.initTooltip()
    }
    initDotNotation() {
      const e = this.gos.get('suppressFieldDotNotation')
      ;(this.fieldContainsDots =
        ue(this.colDef.field) && this.colDef.field.indexOf('.') >= 0 && !e),
        (this.tooltipFieldContainsDots =
          ue(this.colDef.tooltipField) &&
          this.colDef.tooltipField.indexOf('.') >= 0 &&
          !e)
    }
    initMinAndMaxWidths() {
      const e = this.colDef
      ;(this.minWidth =
        e.minWidth ?? this.gos.environment.getDefaultColumnMinWidth()),
        (this.maxWidth = e.maxWidth ?? Number.MAX_SAFE_INTEGER)
    }
    initTooltip() {
      this.tooltipEnabled =
        ue(this.colDef.tooltipField) ||
        ue(this.colDef.tooltipValueGetter) ||
        ue(this.colDef.tooltipComponent)
    }
    resetActualWidth(e) {
      const t = this.calculateColInitialWidth(this.colDef)
      this.setActualWidth(t, e, !0)
    }
    calculateColInitialWidth(e) {
      let t
      const i = Mn(e.width),
        s = Mn(e.initialWidth)
      return (
        i != null ? (t = i) : s != null ? (t = s) : (t = 200),
        Math.max(Math.min(t, this.maxWidth), this.minWidth)
      )
    }
    isEmptyGroup() {
      return !1
    }
    isRowGroupDisplayed(e) {
      if (ot(this.colDef) || ot(this.colDef.showRowGroup)) return !1
      const t = this.colDef.showRowGroup === !0,
        i = this.colDef.showRowGroup === e
      return t || i
    }
    isPrimary() {
      return this.primary
    }
    isFilterAllowed() {
      return !!this.colDef.filter
    }
    isFieldContainsDots() {
      return this.fieldContainsDots
    }
    isTooltipEnabled() {
      return this.tooltipEnabled
    }
    isTooltipFieldContainsDots() {
      return this.tooltipFieldContainsDots
    }
    getHighlighted() {
      return this.highlighted
    }
    addEventListener(e, t) {
      var s
      this.frameworkOverrides.shouldWrapOutgoing &&
        !this.frameworkEventListenerService &&
        (this.columnEventService.setFrameworkOverrides(this.frameworkOverrides),
        (this.frameworkEventListenerService = new id(this.frameworkOverrides)))
      const i =
        ((s = this.frameworkEventListenerService) == null
          ? void 0
          : s.wrap(t)) ?? t
      this.columnEventService.addEventListener(e, i)
    }
    removeEventListener(e, t) {
      var s
      const i =
        ((s = this.frameworkEventListenerService) == null
          ? void 0
          : s.unwrap(t)) ?? t
      this.columnEventService.removeEventListener(e, i)
    }
    createColumnFunctionCallbackParams(e) {
      return this.gos.addGridCommonParams({
        node: e,
        data: e.data,
        column: this,
        colDef: this.colDef,
      })
    }
    isSuppressNavigable(e) {
      if (typeof this.colDef.suppressNavigable == 'boolean')
        return this.colDef.suppressNavigable
      if (typeof this.colDef.suppressNavigable == 'function') {
        const t = this.createColumnFunctionCallbackParams(e),
          i = this.colDef.suppressNavigable
        return i(t)
      }
      return !1
    }
    isCellEditable(e) {
      if (e.group) {
        if (this.gos.get('treeData')) {
          if (!e.data && !this.gos.get('enableGroupEdit')) return !1
        } else if (!this.gos.get('enableGroupEdit')) return !1
      }
      return this.isColumnFunc(e, this.colDef.editable)
    }
    isSuppressFillHandle() {
      return !!this.colDef.suppressFillHandle
    }
    isAutoHeight() {
      return !!this.colDef.autoHeight
    }
    isAutoHeaderHeight() {
      return !!this.colDef.autoHeaderHeight
    }
    isRowDrag(e) {
      return this.isColumnFunc(e, this.colDef.rowDrag)
    }
    isDndSource(e) {
      return this.isColumnFunc(e, this.colDef.dndSource)
    }
    isCellCheckboxSelection(e) {
      const t = this.gos.get('rowSelection')
      if (t && typeof t != 'string') {
        const i = Lo(this) && fr(t)
        return this.isColumnFunc(e, i)
      } else return this.isColumnFunc(e, this.colDef.checkboxSelection)
    }
    isSuppressPaste(e) {
      return this.isColumnFunc(
        e,
        this.colDef ? this.colDef.suppressPaste : null,
      )
    }
    isResizable() {
      return !!this.getColDefValue('resizable')
    }
    getColDefValue(e) {
      return this.colDef[e] ?? Tx[e]
    }
    isColumnFunc(e, t) {
      if (typeof t == 'boolean') return t
      if (typeof t == 'function') {
        const i = this.createColumnFunctionCallbackParams(e)
        return t(i)
      }
      return !1
    }
    setHighlighted(e) {
      this.highlighted !== e &&
        ((this.highlighted = e),
        this.columnEventService.dispatchEvent(
          this.createColumnEvent('headerHighlightChanged', 'uiColumnMoved'),
        ))
    }
    setMoving(e, t) {
      ;(this.moving = e),
        this.columnEventService.dispatchEvent(
          this.createColumnEvent('movingChanged', t),
        )
    }
    createColumnEvent(e, t) {
      return this.gos.addGridCommonParams({
        type: e,
        column: this,
        columns: [this],
        source: t,
      })
    }
    isMoving() {
      return this.moving
    }
    getSort() {
      return this.sort
    }
    setSort(e, t) {
      this.sort !== e &&
        ((this.sort = e),
        this.columnEventService.dispatchEvent(
          this.createColumnEvent('sortChanged', t),
        )),
        this.dispatchStateUpdatedEvent('sort')
    }
    isSortable() {
      return !!this.getColDefValue('sortable')
    }
    isSortAscending() {
      return this.sort === 'asc'
    }
    isSortDescending() {
      return this.sort === 'desc'
    }
    isSortNone() {
      return ot(this.sort)
    }
    isSorting() {
      return ue(this.sort)
    }
    getSortIndex() {
      return this.sortIndex
    }
    setSortIndex(e) {
      ;(this.sortIndex = e), this.dispatchStateUpdatedEvent('sortIndex')
    }
    setMenuVisible(e, t) {
      this.menuVisible !== e &&
        ((this.menuVisible = e),
        this.columnEventService.dispatchEvent(
          this.createColumnEvent('menuVisibleChanged', t),
        ))
    }
    isMenuVisible() {
      return this.menuVisible
    }
    setAggFunc(e) {
      ;(this.aggFunc = e), this.dispatchStateUpdatedEvent('aggFunc')
    }
    getAggFunc() {
      return this.aggFunc
    }
    getLeft() {
      return this.left
    }
    getOldLeft() {
      return this.oldLeft
    }
    getRight() {
      return this.left + this.actualWidth
    }
    setLeft(e, t) {
      ;(this.oldLeft = this.left),
        this.left !== e &&
          ((this.left = e),
          this.columnEventService.dispatchEvent(
            this.createColumnEvent('leftChanged', t),
          ))
    }
    isFilterActive() {
      return this.filterActive
    }
    setFilterActive(e, t, i) {
      this.filterActive !== e &&
        ((this.filterActive = e),
        this.columnEventService.dispatchEvent(
          this.createColumnEvent('filterActiveChanged', t),
        ))
      const s = this.createColumnEvent('filterChanged', t)
      i && yi(s, i), this.columnEventService.dispatchEvent(s)
    }
    isHovered() {
      return this.columnHoverService.isHovered(this)
    }
    setPinned(e) {
      e === !0 || e === 'left'
        ? (this.pinned = 'left')
        : e === 'right'
          ? (this.pinned = 'right')
          : (this.pinned = null),
        this.dispatchStateUpdatedEvent('pinned')
    }
    setFirstRightPinned(e, t) {
      this.firstRightPinned !== e &&
        ((this.firstRightPinned = e),
        this.columnEventService.dispatchEvent(
          this.createColumnEvent('firstRightPinnedChanged', t),
        ))
    }
    setLastLeftPinned(e, t) {
      this.lastLeftPinned !== e &&
        ((this.lastLeftPinned = e),
        this.columnEventService.dispatchEvent(
          this.createColumnEvent('lastLeftPinnedChanged', t),
        ))
    }
    isFirstRightPinned() {
      return this.firstRightPinned
    }
    isLastLeftPinned() {
      return this.lastLeftPinned
    }
    isPinned() {
      return this.pinned === 'left' || this.pinned === 'right'
    }
    isPinnedLeft() {
      return this.pinned === 'left'
    }
    isPinnedRight() {
      return this.pinned === 'right'
    }
    getPinned() {
      return this.pinned
    }
    setVisible(e, t) {
      const i = e === !0
      this.visible !== i &&
        ((this.visible = i),
        this.columnEventService.dispatchEvent(
          this.createColumnEvent('visibleChanged', t),
        )),
        this.dispatchStateUpdatedEvent('hide')
    }
    isVisible() {
      return this.visible
    }
    isSpanHeaderHeight() {
      return !this.getColDef().suppressSpanHeaderHeight
    }
    getColumnGroupPaddingInfo() {
      let e = this.getParent()
      if (!e || !e.isPadding())
        return { numberOfParents: 0, isSpanningTotal: !1 }
      const t = e.getPaddingLevel() + 1
      let i = !0
      for (; e; ) {
        if (!e.isPadding()) {
          i = !1
          break
        }
        e = e.getParent()
      }
      return { numberOfParents: t, isSpanningTotal: i }
    }
    getColDef() {
      return this.colDef
    }
    getDefinition() {
      return this.colDef
    }
    getColumnGroupShow() {
      return this.colDef.columnGroupShow
    }
    getColId() {
      return this.colId
    }
    getId() {
      return this.colId
    }
    getUniqueId() {
      return this.colId
    }
    getActualWidth() {
      return this.actualWidth
    }
    getAutoHeaderHeight() {
      return this.autoHeaderHeight
    }
    setAutoHeaderHeight(e) {
      const t = e !== this.autoHeaderHeight
      return (this.autoHeaderHeight = e), t
    }
    createBaseColDefParams(e) {
      return this.gos.addGridCommonParams({
        node: e,
        data: e.data,
        colDef: this.colDef,
        column: this,
      })
    }
    getColSpan(e) {
      if (ot(this.colDef.colSpan)) return 1
      const t = this.createBaseColDefParams(e),
        i = this.colDef.colSpan(t)
      return Math.max(i, 1)
    }
    getRowSpan(e) {
      if (ot(this.colDef.rowSpan)) return 1
      const t = this.createBaseColDefParams(e),
        i = this.colDef.rowSpan(t)
      return Math.max(i, 1)
    }
    setActualWidth(e, t, i = !1) {
      ;(e = Math.max(e, this.minWidth)),
        (e = Math.min(e, this.maxWidth)),
        this.actualWidth !== e &&
          ((this.actualWidth = e),
          this.flex &&
            t !== 'flex' &&
            t !== 'gridInitializing' &&
            (this.flex = null),
          i || this.fireColumnWidthChangedEvent(t)),
        this.dispatchStateUpdatedEvent('width')
    }
    fireColumnWidthChangedEvent(e) {
      this.columnEventService.dispatchEvent(
        this.createColumnEvent('widthChanged', e),
      )
    }
    isGreaterThanMax(e) {
      return e > this.maxWidth
    }
    getMinWidth() {
      return this.minWidth
    }
    getMaxWidth() {
      return this.maxWidth
    }
    getFlex() {
      return this.flex || 0
    }
    setFlex(e) {
      this.flex !== e && (this.flex = e), this.dispatchStateUpdatedEvent('flex')
    }
    setMinimum(e) {
      this.setActualWidth(this.minWidth, e)
    }
    setRowGroupActive(e, t) {
      this.rowGroupActive !== e &&
        ((this.rowGroupActive = e),
        this.columnEventService.dispatchEvent(
          this.createColumnEvent('columnRowGroupChanged', t),
        )),
        this.dispatchStateUpdatedEvent('rowGroup')
    }
    isRowGroupActive() {
      return this.rowGroupActive
    }
    setPivotActive(e, t) {
      this.pivotActive !== e &&
        ((this.pivotActive = e),
        this.columnEventService.dispatchEvent(
          this.createColumnEvent('columnPivotChanged', t),
        )),
        this.dispatchStateUpdatedEvent('pivot')
    }
    isPivotActive() {
      return this.pivotActive
    }
    isAnyFunctionActive() {
      return (
        this.isPivotActive() || this.isRowGroupActive() || this.isValueActive()
      )
    }
    isAnyFunctionAllowed() {
      return (
        this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue()
      )
    }
    setValueActive(e, t) {
      this.aggregationActive !== e &&
        ((this.aggregationActive = e),
        this.columnEventService.dispatchEvent(
          this.createColumnEvent('columnValueChanged', t),
        ))
    }
    isValueActive() {
      return this.aggregationActive
    }
    isAllowPivot() {
      return this.colDef.enablePivot === !0
    }
    isAllowValue() {
      return this.colDef.enableValue === !0
    }
    isAllowRowGroup() {
      return this.colDef.enableRowGroup === !0
    }
    dispatchStateUpdatedEvent(e) {
      this.columnEventService.dispatchEvent({
        type: 'columnStateUpdated',
        key: e,
      })
    }
  },
  Ox = {
    numericColumn: {
      headerClass: 'ag-right-aligned-header',
      cellClass: 'ag-right-aligned-cell',
    },
    rightAligned: {
      headerClass: 'ag-right-aligned-header',
      cellClass: 'ag-right-aligned-cell',
    },
  },
  Lx = class {
    constructor() {
      this.existingKeys = {}
    }
    addExistingKeys(e) {
      for (let t = 0; t < e.length; t++) this.existingKeys[e[t]] = !0
    }
    getUniqueKey(e, t) {
      e = _c(e)
      let i = 0
      for (;;) {
        let s
        if (
          (e
            ? ((s = e), i !== 0 && (s += '_' + i))
            : t
              ? ((s = t), i !== 0 && (s += '_' + i))
              : (s = i),
          !this.existingKeys[s])
        )
          return (this.existingKeys[s] = !0), String(s)
        i++
      }
    }
  },
  kx = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'columnFactory')
    }
    wireBeans(e) {
      this.dataTypeService = e.dataTypeService
    }
    createColumnTree(e, t, i, s) {
      const n = new Lx(),
        {
          existingCols: r,
          existingGroups: o,
          existingColKeys: a,
        } = this.extractExistingTreeData(i)
      n.addExistingKeys(a)
      const l = this.recursivelyCreateColumns(e, 0, t, r, n, o, s),
        c = this.findMaxDept(l, 0),
        u = this.balanceColumnTree(l, 0, c, n)
      return (
        _s(null, u, (g, f) => {
          wi(g) && g.setupExpandable(), g.setOriginalParent(f)
        }),
        { columnTree: u, treeDept: c }
      )
    }
    extractExistingTreeData(e) {
      const t = [],
        i = [],
        s = []
      return (
        e &&
          _s(null, e, (n) => {
            if (wi(n)) {
              const r = n
              i.push(r)
            } else {
              const r = n
              s.push(r.getId()), t.push(r)
            }
          }),
        { existingCols: t, existingGroups: i, existingColKeys: s }
      )
    }
    balanceTreeForAutoCols(e, t) {
      const i = [],
        s = this.findDepth(t)
      return (
        e.forEach((n) => {
          let r = n
          for (let o = s - 1; o >= 0; o--) {
            const a = new da(null, `FAKE_PATH_${n.getId()}}_${o}`, !0, o)
            this.createBean(a),
              a.setChildren([r]),
              r.setOriginalParent(a),
              (r = a)
          }
          s === 0 && n.setOriginalParent(null), i.push(r)
        }),
        [i, s]
      )
    }
    findDepth(e) {
      let t = 0,
        i = e
      for (; i && i[0] && wi(i[0]); ) t++, (i = i[0].getChildren())
      return t
    }
    balanceColumnTree(e, t, i, s) {
      const n = []
      for (let r = 0; r < e.length; r++) {
        const o = e[r]
        if (wi(o)) {
          const a = o,
            l = this.balanceColumnTree(a.getChildren(), t + 1, i, s)
          a.setChildren(l), n.push(a)
        } else {
          let a, l
          for (let c = i - 1; c >= t; c--) {
            const u = s.getUniqueKey(null, null),
              h = this.createMergedColGroupDef(null),
              g = new da(h, u, !0, t)
            this.createBean(g), l && l.setChildren([g]), (l = g), a || (a = l)
          }
          if (a && l)
            if ((n.push(a), e.some((u) => wi(u)))) {
              l.setChildren([o])
              continue
            } else {
              l.setChildren(e)
              break
            }
          n.push(o)
        }
      }
      return n
    }
    findMaxDept(e, t) {
      let i = t
      for (let s = 0; s < e.length; s++) {
        const n = e[s]
        if (wi(n)) {
          const r = n,
            o = this.findMaxDept(r.getChildren(), t + 1)
          i < o && (i = o)
        }
      }
      return i
    }
    recursivelyCreateColumns(e, t, i, s, n, r, o) {
      if (!e) return []
      const a = new Array(e.length)
      for (let l = 0; l < a.length; l++) {
        const c = e[l]
        this.isColumnGroup(c)
          ? (a[l] = this.createColumnGroup(i, c, t, s, n, r, o))
          : (a[l] = this.createColumn(i, c, s, n, o))
      }
      return a
    }
    createColumnGroup(e, t, i, s, n, r, o) {
      const a = this.createMergedColGroupDef(t),
        l = n.getUniqueKey(a.groupId || null, null),
        c = new da(a, l, !1, i)
      this.createBean(c)
      const u = this.findExistingGroup(t, r)
      u && r.splice(u.idx, 1)
      const h = u == null ? void 0 : u.group
      h && c.setExpanded(h.isExpanded())
      const g = this.recursivelyCreateColumns(a.children, i + 1, e, s, n, r, o)
      return c.setChildren(g), c
    }
    createMergedColGroupDef(e) {
      const t = {}
      return (
        Object.assign(t, this.gos.get('defaultColGroupDef')),
        Object.assign(t, e),
        t
      )
    }
    createColumn(e, t, i, s, n) {
      var a
      const r = this.findExistingColumn(t, i)
      r && (i == null || i.splice(r.idx, 1))
      let o = r == null ? void 0 : r.column
      if (o) {
        const l = this.addColumnDefaultAndTypes(t, o.getColId())
        o.setColDef(l, t, n), this.applyColumnState(o, l, n)
      } else {
        const l = s.getUniqueKey(t.colId, t.field),
          c = this.addColumnDefaultAndTypes(t, l)
        ;(o = new nd(c, t, l, e)), this.createBean(o)
      }
      return (a = this.dataTypeService) == null || a.addColumnListeners(o), o
    }
    applyColumnState(e, t, i) {
      const s = Mn(t.flex)
      if ((s !== void 0 && e.setFlex(s), e.getFlex() <= 0)) {
        const a = Mn(t.width)
        if (a != null) e.setActualWidth(a, i)
        else {
          const l = e.getActualWidth()
          e.setActualWidth(l, i)
        }
      }
      t.sort !== void 0 &&
        (t.sort == 'asc' || t.sort == 'desc'
          ? e.setSort(t.sort, i)
          : e.setSort(void 0, i))
      const r = Mn(t.sortIndex)
      r !== void 0 && e.setSortIndex(r)
      const o = Wc(t.hide)
      o !== void 0 && e.setVisible(!o, i),
        t.pinned !== void 0 && e.setPinned(t.pinned)
    }
    findExistingColumn(e, t) {
      if (t)
        for (let i = 0; i < t.length; i++) {
          const s = t[i].getUserProvidedColDef()
          if (!s) continue
          if (e.colId != null) {
            if (t[i].getId() === e.colId) return { idx: i, column: t[i] }
            continue
          }
          if (e.field != null) {
            if (s.field === e.field) return { idx: i, column: t[i] }
            continue
          }
          if (s === e) return { idx: i, column: t[i] }
        }
    }
    findExistingGroup(e, t) {
      if (e.groupId != null)
        for (let s = 0; s < t.length; s++) {
          const n = t[s]
          if (n.getColGroupDef() && n.getId() === e.groupId)
            return { idx: s, group: n }
        }
    }
    addColumnDefaultAndTypes(e, t) {
      var a
      const i = {},
        s = this.gos.get('defaultColDef')
      yi(i, s, !1, !0)
      const n = this.updateColDefAndGetColumnType(i, e, t)
      n && this.assignColumnTypes(n, i), yi(i, e, !1, !0)
      const r = this.gos.get('autoGroupColumnDef'),
        o = cs(this.gos)
      return (
        e.rowGroup &&
          r &&
          o &&
          yi(i, { sort: r.sort, initialSort: r.initialSort }, !1, !0),
        (a = this.dataTypeService) == null || a.validateColDef(i),
        i
      )
    }
    updateColDefAndGetColumnType(e, t, i) {
      var r
      const s =
          (r = this.dataTypeService) == null
            ? void 0
            : r.updateColDefAndGetColumnType(e, t, i),
        n = t.type ?? s ?? e.type
      return (e.type = n), n ? ha(n) : void 0
    }
    assignColumnTypes(e, t) {
      if (!e.length) return
      const i = Object.assign({}, Ox),
        s = this.gos.get('columnTypes') || {}
      Qi(s, (n, r) => {
        n in i
          ? te(
              `the column type '${n}' is a default column type and cannot be overridden.`,
            )
          : (r.type &&
              te(
                "Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type.",
              ),
            (i[n] = r))
      }),
        e.forEach((n) => {
          const r = i[n.trim()]
          r
            ? yi(t, r, !1, !0)
            : te(
                "colDef.type '" +
                  n +
                  "' does not correspond to defined gridOptions.columnTypes",
              )
        })
    }
    isColumnGroup(e) {
      return e.children !== void 0
    }
  }
function _s(e, t, i) {
  if (t)
    for (let s = 0; s < t.length; s++) {
      const n = t[s]
      wi(n) && _s(n, n.getChildren(), i), i(n, e)
    }
}
var Hx = class extends X {
  constructor() {
    super(...arguments),
      (this.beanName = 'columnModel'),
      (this.pivotMode = !1),
      (this.autoHeightActiveAtLeastOnce = !1),
      (this.ready = !1),
      (this.changeEventsDispatching = !1),
      (this.shouldQueueResizeOperations = !1),
      (this.resizeOperationQueue = [])
  }
  wireBeans(e) {
    ;(this.context = e.context),
      (this.ctrlsService = e.ctrlsService),
      (this.columnFactory = e.columnFactory),
      (this.columnSizeService = e.columnSizeService),
      (this.visibleColsService = e.visibleColsService),
      (this.columnViewportService = e.columnViewportService),
      (this.pivotResultColsService = e.pivotResultColsService),
      (this.columnAnimationService = e.columnAnimationService),
      (this.autoColService = e.autoColService),
      (this.controlsColService = e.controlsColService),
      (this.valueCache = e.valueCache),
      (this.columnDefFactory = e.columnDefFactory),
      (this.columnApplyStateService = e.columnApplyStateService),
      (this.columnGroupStateService = e.columnGroupStateService),
      (this.eventDispatcher = e.columnEventDispatcher),
      (this.columnMoveService = e.columnMoveService),
      (this.columnAutosizeService = e.columnAutosizeService),
      (this.funcColsService = e.funcColsService),
      (this.quickFilterService = e.quickFilterService),
      (this.showRowGroupColsService = e.showRowGroupColsService),
      (this.environment = e.environment)
  }
  postConstruct() {
    const e = this.gos.get('pivotMode')
    this.isPivotSettingAllowed(e) && (this.pivotMode = e),
      this.addManagedPropertyListeners(
        [
          'groupDisplayType',
          'treeData',
          'treeDataDisplayType',
          'groupHideOpenParents',
        ],
        (t) => this.refreshAll(bn(t.source)),
      ),
      this.addManagedPropertyListener('rowSelection', (t) => {
        this.onSelectionOptionsChanged(
          t.currentValue,
          t.previousValue,
          bn(t.source),
        )
      }),
      this.addManagedPropertyListener('autoGroupColumnDef', (t) =>
        this.onAutoGroupColumnDefChanged(bn(t.source)),
      ),
      this.addManagedPropertyListeners(
        [
          'defaultColDef',
          'defaultColGroupDef',
          'columnTypes',
          'suppressFieldDotNotation',
        ],
        (t) => this.recreateColumnDefs(bn(t.source)),
      ),
      this.addManagedPropertyListener('pivotMode', (t) =>
        this.setPivotMode(this.gos.get('pivotMode'), bn(t.source)),
      ),
      this.addManagedEventListeners({
        firstDataRendered: () => this.onFirstDataRendered(),
      })
  }
  createColsFromColDefs(e) {
    var c, u, h
    const t = this.colDefs
      ? this.columnApplyStateService.compareColumnStatesAndDispatchEvents(e)
      : void 0
    this.valueCache.expire()
    const i = (c = this.colDefCols) == null ? void 0 : c.list,
      s = (u = this.colDefCols) == null ? void 0 : u.tree,
      n = this.columnFactory.createColumnTree(this.colDefs, !0, s, e)
    tn(
      this.context,
      (h = this.colDefCols) == null ? void 0 : h.tree,
      n.columnTree,
    )
    const r = n.columnTree,
      o = n.treeDept,
      a = td(r),
      l = {}
    a.forEach((g) => (l[g.getId()] = g)),
      (this.colDefCols = { tree: r, treeDepth: o, list: a, map: l }),
      this.funcColsService.extractCols(e, i),
      (this.ready = !0),
      this.refreshCols(!0),
      this.visibleColsService.refresh(e),
      this.columnViewportService.checkViewportColumns(),
      this.eventDispatcher.everythingChanged(e),
      t &&
        ((this.changeEventsDispatching = !0),
        t(),
        (this.changeEventsDispatching = !1)),
      this.eventDispatcher.newColumnsLoaded(e),
      e === 'gridInitializing' && this.columnSizeService.applyAutosizeStrategy()
  }
  refreshCols(e) {
    var n, r, o
    if (!this.colDefCols) return
    const t = (n = this.cols) == null ? void 0 : n.tree
    this.saveColOrder(),
      this.selectCols(),
      this.createAutoCols(),
      this.addAutoCols(),
      this.createControlsCols(),
      this.addControlsCols()
    const i = hx(this.gos, this.showingPivotResult)
    ;(!e || i) && this.restoreColOrder(),
      this.positionLockedCols(),
      (r = this.showRowGroupColsService) == null || r.refresh(),
      (o = this.quickFilterService) == null || o.refreshQuickFilterCols(),
      this.setColSpanActive(),
      this.setAutoHeightActive(),
      this.visibleColsService.clear(),
      this.columnViewportService.clear(),
      !gn(t, this.cols.tree) && this.eventDispatcher.gridColumns()
  }
  selectCols() {
    const e = this.pivotResultColsService.getPivotResultCols()
    if (((this.showingPivotResult = e != null), e)) {
      const { map: t, list: i, tree: s, treeDepth: n } = e
      ;(this.cols = {
        list: i.slice(),
        map: { ...t },
        tree: s.slice(),
        treeDepth: n,
      }),
        e.list.some((o) => {
          var a
          return (
            ((a = this.cols) == null ? void 0 : a.map[o.getColId()]) !== void 0
          )
        }) || (this.lastPivotOrder = null)
    } else {
      const { map: t, list: i, tree: s, treeDepth: n } = this.colDefCols
      this.cols = {
        list: i.slice(),
        map: { ...t },
        tree: s.slice(),
        treeDepth: n,
      }
    }
  }
  getColsToShow() {
    const e = this.isPivotMode() && !this.isShowingPivotResult(),
      t = this.funcColsService.getValueColumns()
    return this.cols.list.filter((s) => {
      const n = Yc(s)
      if (e) {
        const r = t && Tn(t, s)
        return n || r
      } else return n || s.isVisible()
    })
  }
  addAutoCols() {
    this.autoCols != null &&
      ((this.cols.list = this.autoCols.list.concat(this.cols.list)),
      (this.cols.tree = this.autoCols.tree.concat(this.cols.tree)),
      fg(this.cols))
  }
  createAutoCols() {
    var p
    const e = pl(this.gos, this.pivotMode),
      t = this.pivotMode
        ? this.gos.get('pivotSuppressAutoColumn')
        : this.isSuppressAutoCol(),
      i = this.funcColsService.getRowGroupColumns(),
      n = !(i.length > 0 || this.gos.get('treeData')) || t || e,
      r = () => {
        this.autoCols &&
          (tn(this.context, this.autoCols.tree), (this.autoCols = null))
      }
    if (n || !this.autoColService) {
      r()
      return
    }
    const o = this.autoColService.createAutoCols(i) ?? [],
      a = mg(o, ((p = this.autoCols) == null ? void 0 : p.list) || null),
      l = this.cols.treeDepth,
      u = (this.autoCols ? this.autoCols.treeDepth : -1) == l
    if (a && u) return
    r()
    const [h, g] = this.columnFactory.balanceTreeForAutoCols(o, this.cols.tree)
    this.autoCols = { list: o, tree: h, treeDepth: g, map: {} }
    const f = (v) => {
      if (!v) return null
      const m = v.filter((C) => !Yc(C))
      return [...o, ...m]
    }
    ;(this.lastOrder = f(this.lastOrder)),
      (this.lastPivotOrder = f(this.lastPivotOrder))
  }
  createControlsCols() {
    var c, u, h
    const e = () => {
      var g
      tn(this.context, (g = this.controlsCols) == null ? void 0 : g.tree),
        (this.controlsCols = null)
    }
    this.controlsColService || e()
    const t = this.cols.treeDepth,
      s = (((c = this.controlsCols) == null ? void 0 : c.treeDepth) ?? -1) == t,
      n =
        ((u = this.controlsColService) == null
          ? void 0
          : u.createControlsCols()) ?? []
    if (mg(n, ((h = this.controlsCols) == null ? void 0 : h.list) ?? []) && s)
      return
    e()
    const [o, a] = this.columnFactory.balanceTreeForAutoCols(n, this.cols.tree)
    this.controlsCols = { list: n, tree: o, treeDepth: a, map: {} }
    const l = (g) => {
      if (!g) return null
      const f = g.filter((p) => !Lo(p))
      return [...n, ...f]
    }
    ;(this.lastOrder = l(this.lastOrder)),
      (this.lastPivotOrder = l(this.lastPivotOrder))
  }
  addControlsCols() {
    this.controlsCols != null &&
      ((this.cols.list = this.controlsCols.list.concat(this.cols.list)),
      (this.cols.tree = this.controlsCols.tree.concat(this.cols.tree)),
      fg(this.cols))
  }
  refreshAll(e) {
    this.isReady() && (this.refreshCols(!1), this.visibleColsService.refresh(e))
  }
  setColsVisible(e, t = !1, i) {
    this.columnApplyStateService.applyColumnState(
      {
        state: e.map((s) => ({
          colId: typeof s == 'string' ? s : s.getColId(),
          hide: !t,
        })),
      },
      i,
    )
  }
  setColsPinned(e, t, i) {
    if (!this.cols || Hi(e)) return
    if (ci(this.gos, 'print')) {
      te(
        "Changing the column pinning status is not allowed with domLayout='print'",
      )
      return
    }
    this.columnAnimationService.start()
    let s
    t === !0 || t === 'left'
      ? (s = 'left')
      : t === 'right'
        ? (s = 'right')
        : (s = null)
    const n = []
    e.forEach((r) => {
      if (!r) return
      const o = this.getCol(r)
      o && o.getPinned() !== s && (o.setPinned(s), n.push(o))
    }),
      n.length &&
        (this.visibleColsService.refresh(i),
        this.eventDispatcher.columnPinned(n, i)),
      this.columnAnimationService.finish()
  }
  setColumnGroupOpened(e, t, i) {
    let s
    wi(e) ? (s = e.getId()) : (s = e || ''),
      this.columnGroupStateService.setColumnGroupState(
        [{ groupId: s, open: t }],
        i,
      )
  }
  getProvidedColGroup(e) {
    var i
    let t = null
    return (
      _s(null, (i = this.cols) == null ? void 0 : i.tree, (s) => {
        wi(s) && s.getId() === e && (t = s)
      }),
      t
    )
  }
  isColGroupLocked(e) {
    const t = this.gos.get('groupLockGroupColumns')
    if (!e.isRowGroupActive() || t === 0) return !1
    if (t === -1) return !0
    const s = this.funcColsService
      .getRowGroupColumns()
      .findIndex((n) => n.getColId() === e.getColId())
    return t > s
  }
  isSuppressAutoCol() {
    return this.gos.get('groupDisplayType') === 'custom'
      ? !0
      : this.gos.get('treeDataDisplayType') === 'custom'
  }
  setAutoHeightActive() {
    ;(this.autoHeightActive = this.cols.list.some(
      (e) => e.isVisible() && e.isAutoHeight(),
    )),
      this.autoHeightActive &&
        ((this.autoHeightActiveAtLeastOnce = !0),
        Pt(this.gos) ||
          ms(this.gos) ||
          te(
            'autoHeight columns only work with Client Side Row Model and Server Side Row Model.',
          ))
  }
  restoreColOrder() {
    const e = this.showingPivotResult ? this.lastPivotOrder : this.lastOrder
    if (!e) return
    const t = new Map(e.map((l, c) => [l, c]))
    if (!this.cols.list.some((l) => t.has(l))) return
    const s = new Map(this.cols.list.map((l) => [l, !0])),
      n = e.filter((l) => s.has(l)),
      r = new Map(n.map((l) => [l, !0])),
      o = this.cols.list.filter((l) => !r.has(l)),
      a = n.slice()
    o.forEach((l) => {
      let c = l.getOriginalParent()
      if (!c) {
        a.push(l)
        return
      }
      const u = []
      for (; !u.length && c; )
        c.getLeafColumns().forEach((p) => {
          const v = a.indexOf(p) >= 0,
            m = u.indexOf(p) < 0
          v && m && u.push(p)
        }),
          (c = c.getOriginalParent())
      if (!u.length) {
        a.push(l)
        return
      }
      const h = u.map((f) => a.indexOf(f)),
        g = Math.max(...h)
      La(a, l, g + 1)
    }),
      (this.cols.list = a)
  }
  sortColsLikeKeys(e) {
    if (this.cols == null) return
    let t = []
    const i = {}
    e.forEach((n) => {
      if (i[n]) return
      const r = this.cols.map[n]
      r && (t.push(r), (i[n] = !0))
    })
    let s = 0
    if (
      (this.cols.list.forEach((n) => {
        const r = n.getColId()
        if (i[r] != null) return
        r.startsWith(ml) ? La(t, n, s++) : t.push(n)
      }),
      (t = this.columnMoveService.placeLockedColumns(t)),
      !this.columnMoveService.doesMovePassMarryChildren(t))
    ) {
      te(
        'Applying column order broke a group where columns should be married together. Applying new order has been discarded.',
      )
      return
    }
    this.cols.list = t
  }
  sortColsLikeCols(e) {
    !e ||
      e.length <= 1 ||
      e.filter((i) => this.cols.list.indexOf(i) < 0).length > 0 ||
      e.sort((i, s) => {
        const n = this.cols.list.indexOf(i),
          r = this.cols.list.indexOf(s)
        return n - r
      })
  }
  resetColDefIntoCol(e, t) {
    const i = e.getUserProvidedColDef()
    if (!i) return !1
    const s = this.columnFactory.addColumnDefaultAndTypes(i, e.getColId())
    return e.setColDef(s, i, t), !0
  }
  queueResizeOperations() {
    this.shouldQueueResizeOperations = !0
  }
  isShouldQueueResizeOperations() {
    return this.shouldQueueResizeOperations
  }
  processResizeOperations() {
    ;(this.shouldQueueResizeOperations = !1),
      this.resizeOperationQueue.forEach((e) => e()),
      (this.resizeOperationQueue = [])
  }
  pushResizeOperation(e) {
    this.resizeOperationQueue.push(e)
  }
  moveInCols(e, t, i) {
    var s
    Pm((s = this.cols) == null ? void 0 : s.list, e, t),
      this.visibleColsService.refresh(i)
  }
  positionLockedCols() {
    this.cols.list = this.columnMoveService.placeLockedColumns(this.cols.list)
  }
  saveColOrder() {
    var e, t
    this.showingPivotResult
      ? (this.lastPivotOrder = (e = this.cols) == null ? void 0 : e.list)
      : (this.lastOrder = (t = this.cols) == null ? void 0 : t.list)
  }
  getColumnDefs() {
    if (!this.colDefCols) return
    const e = this.colDefCols.list.slice()
    this.showingPivotResult
      ? e.sort((s, n) => this.lastOrder.indexOf(s) - this.lastOrder.indexOf(n))
      : this.lastOrder &&
        e.sort((s, n) => this.cols.list.indexOf(s) - this.cols.list.indexOf(n))
    const t = this.funcColsService.getRowGroupColumns(),
      i = this.funcColsService.getPivotColumns()
    return this.columnDefFactory.buildColumnDefs(e, t, i)
  }
  isShowingPivotResult() {
    return this.showingPivotResult
  }
  isChangeEventsDispatching() {
    return this.changeEventsDispatching
  }
  isColSpanActive() {
    return this.colSpanActive
  }
  isProvidedColGroupsPresent() {
    var e
    return ((e = this.colDefCols) == null ? void 0 : e.treeDepth) > 0
  }
  setColSpanActive() {
    this.colSpanActive = this.cols.list.some(
      (e) => e.getColDef().colSpan != null,
    )
  }
  isAutoRowHeightActive() {
    return this.autoHeightActive
  }
  wasAutoRowHeightEverActive() {
    return this.autoHeightActiveAtLeastOnce
  }
  getHeaderRowCount() {
    return this.cols ? this.cols.treeDepth + 1 : -1
  }
  isReady() {
    return this.ready
  }
  isPivotMode() {
    return this.pivotMode
  }
  setPivotMode(e, t) {
    e === this.pivotMode ||
      !this.isPivotSettingAllowed(this.pivotMode) ||
      ((this.pivotMode = e),
      this.ready &&
        (this.refreshCols(!1),
        this.visibleColsService.refresh(t),
        this.eventDispatcher.pivotModeChanged()))
  }
  isPivotSettingAllowed(e) {
    return e && this.gos.get('treeData')
      ? (te('Pivot mode not available with treeData.'), !1)
      : !0
  }
  isPivotActive() {
    const e = this.funcColsService.getPivotColumns()
    return this.pivotMode && !Hi(e)
  }
  recreateColumnDefs(e) {
    this.cols &&
      (this.autoCols &&
        this.autoColService.updateAutoCols(this.autoCols.list, e),
      this.createColsFromColDefs(e))
  }
  setColumnDefs(e, t) {
    ;(this.colDefs = e), this.createColsFromColDefs(t)
  }
  destroy() {
    var e, t, i
    tn(this.context, (e = this.colDefCols) == null ? void 0 : e.tree),
      tn(this.context, (t = this.autoCols) == null ? void 0 : t.tree),
      tn(this.context, (i = this.controlsCols) == null ? void 0 : i.tree),
      super.destroy()
  }
  getColTree() {
    return this.cols.tree
  }
  getColDefColTree() {
    return this.colDefCols.tree
  }
  getColDefCols() {
    var e
    return (e = this.colDefCols) != null && e.list ? this.colDefCols.list : null
  }
  getCols() {
    var e
    return ((e = this.cols) == null ? void 0 : e.list) ?? []
  }
  getAllCols() {
    var i, s, n
    const e = this.pivotResultColsService.getPivotResultCols(),
      t = e == null ? void 0 : e.list
    return [
      ((i = this.colDefCols) == null ? void 0 : i.list) ?? [],
      ((s = this.autoCols) == null ? void 0 : s.list) ?? [],
      ((n = this.controlsCols) == null ? void 0 : n.list) ?? [],
      t ?? [],
    ].flat()
  }
  getColsForKeys(e) {
    return e ? e.map((t) => this.getCol(t)).filter((t) => t != null) : []
  }
  getColDefCol(e) {
    var t
    return (t = this.colDefCols) != null && t.list
      ? this.getColFromCollection(e, this.colDefCols)
      : null
  }
  getCol(e) {
    return e == null ? null : this.getColFromCollection(e, this.cols)
  }
  getColFromCollection(e, t) {
    if (t == null) return null
    const { map: i, list: s } = t
    if (typeof e == 'string' && i[e]) return i[e]
    for (let n = 0; n < s.length; n++) if (pg(s[n], e)) return s[n]
    return this.getAutoCol(e)
  }
  getAutoCol(e) {
    var t
    return (
      ((t = this.autoCols) == null ? void 0 : t.list.find((i) => pg(i, e))) ??
      null
    )
  }
  getAutoCols() {
    var e
    return ((e = this.autoCols) == null ? void 0 : e.list) ?? null
  }
  setColHeaderHeight(e, t) {
    e.setAutoHeaderHeight(t) &&
      (e.isColumn
        ? this.eventDispatcher.headerHeight(e)
        : this.eventDispatcher.groupHeaderHeight(e))
  }
  getGroupRowsHeight() {
    const e = [],
      t = this.ctrlsService.getHeaderRowContainerCtrls()
    for (const i of t) {
      if (!i) continue
      const s = i.getGroupRowCount() || 0
      for (let n = 0; n < s; n++) {
        const r = i.getGroupRowCtrlAtIndex(n),
          o = e[n]
        if (r) {
          const a = this.getColumnGroupHeaderRowHeight(r)
          ;(o == null || a > o) && (e[n] = a)
        }
      }
    }
    return e
  }
  getColumnGroupHeaderRowHeight(e) {
    const t = this.isPivotMode()
      ? this.getPivotGroupHeaderHeight()
      : this.getGroupHeaderHeight()
    let i = 0
    const s = e.getHeaderCtrls()
    for (const n of s) {
      const r = n.getColumn()
      if (r.isAutoHeaderHeight()) {
        const o = r.getAutoHeaderHeight()
        o != null && o > i && (i = o)
      }
    }
    return Math.max(t, i)
  }
  getColumnHeaderRowHeight() {
    const e = this.isPivotMode()
        ? this.getPivotHeaderHeight()
        : this.getHeaderHeight(),
      i = this.visibleColsService
        .getAllCols()
        .filter((s) => s.isAutoHeaderHeight())
        .map((s) => s.getAutoHeaderHeight() || 0)
    return Math.max(e, ...i)
  }
  getHeaderHeight() {
    return (
      this.gos.get('headerHeight') ?? this.environment.getDefaultHeaderHeight()
    )
  }
  getFloatingFiltersHeight() {
    return this.gos.get('floatingFiltersHeight') ?? this.getHeaderHeight()
  }
  getGroupHeaderHeight() {
    return this.gos.get('groupHeaderHeight') ?? this.getHeaderHeight()
  }
  getPivotHeaderHeight() {
    return this.gos.get('pivotHeaderHeight') ?? this.getHeaderHeight()
  }
  getPivotGroupHeaderHeight() {
    return this.gos.get('pivotGroupHeaderHeight') ?? this.getGroupHeaderHeight()
  }
  onFirstDataRendered() {
    const e = this.gos.get('autoSizeStrategy')
    if ((e == null ? void 0 : e.type) !== 'fitCellContents') return
    const { colIds: t, skipHeader: i } = e
    setTimeout(() => {
      t
        ? this.columnAutosizeService.autoSizeCols({
            colKeys: t,
            skipHeader: i,
            source: 'autosizeColumns',
          })
        : this.columnAutosizeService.autoSizeAllColumns('autosizeColumns', i)
    })
  }
  onAutoGroupColumnDefChanged(e) {
    this.autoCols && this.autoColService.updateAutoCols(this.autoCols.list, e)
  }
  onSelectionOptionsChanged(e, t, i) {
    const s = t && typeof t != 'string' ? fr(t) : void 0,
      n = e && typeof e != 'string' ? fr(e) : void 0,
      r = s !== n,
      o = t && typeof t != 'string' ? Aa(t) : void 0,
      a = e && typeof e != 'string' ? Aa(e) : void 0
    ;(r || o !== a) && this.refreshAll(i)
  }
}
function bn(e) {
  return e === 'gridOptionsUpdated' ? 'gridOptionsChanged' : e
}
function fg(e) {
  ;(e.map = {}), e.list.forEach((t) => (e.map[t.getId()] = t))
}
function pg(e, t) {
  const i = e === t,
    s = e.getColDef() === t,
    n = e.getColId() == t
  return i || s || n
}
function mg(e, t) {
  return gn(e, t, (i, s) => i.getColId() === s.getColId())
}
var Nx = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'columnAutosizeService'),
        (this.timesDelayed = 0)
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.visibleColsService = e.visibleColsService),
        (this.animationFrameService = e.animationFrameService),
        (this.autoWidthCalculator = e.autoWidthCalculator),
        (this.eventDispatcher = e.columnEventDispatcher),
        (this.ctrlsService = e.ctrlsService),
        (this.renderStatusService = e.renderStatusService)
    }
    autoSizeCols(e) {
      if (this.columnModel.isShouldQueueResizeOperations()) {
        this.columnModel.pushResizeOperation(() => this.autoSizeCols(e))
        return
      }
      const {
        colKeys: t,
        skipHeader: i,
        skipHeaderGroups: s,
        stopAtGroup: n,
        source: r = 'api',
      } = e
      if (
        (this.animationFrameService.flushAllFrames(),
        this.timesDelayed < 5 &&
          this.renderStatusService &&
          !this.renderStatusService.areHeaderCellsRendered())
      ) {
        this.timesDelayed++, setTimeout(() => this.autoSizeCols(e))
        return
      }
      this.timesDelayed = 0
      const o = []
      let a = -1
      const l = i ?? this.gos.get('skipHeaderOnAutoSize'),
        c = s ?? l
      for (; a !== 0; ) {
        a = 0
        const u = []
        t.forEach((h) => {
          if (!h) return
          const g = this.columnModel.getCol(h)
          if (!g || o.indexOf(g) >= 0) return
          const f = this.autoWidthCalculator.getPreferredWidthForColumn(g, l)
          if (f > 0) {
            const p = this.normaliseColumnWidth(g, f)
            g.setActualWidth(p, r), o.push(g), a++
          }
          u.push(g)
        }),
          u.length && this.visibleColsService.refresh(r)
      }
      c || this.autoSizeColumnGroupsByColumns(t, r, n),
        this.eventDispatcher.columnResized(o, !0, 'autosizeColumns')
    }
    autoSizeColumn(e, t, i) {
      e &&
        this.autoSizeCols({
          colKeys: [e],
          skipHeader: i,
          skipHeaderGroups: !0,
          source: t,
        })
    }
    autoSizeColumnGroupsByColumns(e, t, i) {
      const s = new Set()
      this.columnModel.getColsForKeys(e).forEach((a) => {
        let l = a.getParent()
        for (; l && l != i; ) l.isPadding() || s.add(l), (l = l.getParent())
      })
      let r
      const o = []
      for (const a of s) {
        for (const l of this.ctrlsService.getHeaderRowContainerCtrls())
          if (((r = l.getHeaderCtrlForColumn(a)), r)) break
        r && r.resizeLeafColumnsToFit(t)
      }
      return o
    }
    autoSizeAllColumns(e, t) {
      if (this.columnModel.isShouldQueueResizeOperations()) {
        this.columnModel.pushResizeOperation(() =>
          this.autoSizeAllColumns(e, t),
        )
        return
      }
      const i = this.visibleColsService.getAllCols()
      this.autoSizeCols({ colKeys: i, skipHeader: t, source: e })
    }
    normaliseColumnWidth(e, t) {
      const i = e.getMinWidth()
      t < i && (t = i)
      const s = e.getMaxWidth()
      return e.isGreaterThanMax(t) && (t = s), t
    }
  },
  Gx = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'funcColsService'),
        (this.rowGroupCols = []),
        (this.valueCols = []),
        (this.pivotCols = [])
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.eventDispatcher = e.columnEventDispatcher),
        (this.aggFuncService = e.aggFuncService),
        (this.visibleColsService = e.visibleColsService)
    }
    getModifyColumnsNoEventsCallbacks() {
      return {
        addGroupCol: (e) => this.rowGroupCols.push(e),
        removeGroupCol: (e) => Ri(this.rowGroupCols, e),
        addPivotCol: (e) => this.pivotCols.push(e),
        removePivotCol: (e) => Ri(this.pivotCols, e),
        addValueCol: (e) => this.valueCols.push(e),
        removeValueCol: (e) => Ri(this.valueCols, e),
      }
    }
    getSourceColumnsForGroupColumn(e) {
      const t = e.getColDef().showRowGroup
      if (!t) return null
      if (t === !0) return this.rowGroupCols.slice(0)
      const i = this.columnModel.getColDefCol(t)
      return i ? [i] : null
    }
    sortRowGroupColumns(e) {
      this.rowGroupCols.sort(e)
    }
    sortPivotColumns(e) {
      this.pivotCols.sort(e)
    }
    getValueColumns() {
      return this.valueCols ? this.valueCols : []
    }
    getPivotColumns() {
      return this.pivotCols ? this.pivotCols : []
    }
    getRowGroupColumns() {
      return this.rowGroupCols ? this.rowGroupCols : []
    }
    isRowGroupEmpty() {
      return Hi(this.rowGroupCols)
    }
    setColumnAggFunc(e, t, i) {
      if (!e) return
      const s = this.columnModel.getColDefCol(e)
      s &&
        (s.setAggFunc(t),
        this.eventDispatcher.columnChanged('columnValueChanged', [s], i))
    }
    setRowGroupColumns(e, t) {
      this.setColList(
        e,
        this.rowGroupCols,
        'columnRowGroupChanged',
        !0,
        !0,
        (i, s) => this.setRowGroupActive(i, s, t),
        t,
      )
    }
    setRowGroupActive(e, t, i) {
      e !== t.isRowGroupActive() &&
        (t.setRowGroupActive(e, i),
        e &&
          !this.gos.get('suppressRowGroupHidesColumns') &&
          this.columnModel.setColsVisible([t], !1, i),
        !e &&
          !this.gos.get('suppressMakeColumnVisibleAfterUnGroup') &&
          this.columnModel.setColsVisible([t], !0, i))
    }
    addRowGroupColumns(e, t) {
      this.updateColList(
        e,
        this.rowGroupCols,
        !0,
        !0,
        (i) => this.setRowGroupActive(!0, i, t),
        'columnRowGroupChanged',
        t,
      )
    }
    removeRowGroupColumns(e, t) {
      this.updateColList(
        e,
        this.rowGroupCols,
        !1,
        !0,
        (i) => this.setRowGroupActive(!1, i, t),
        'columnRowGroupChanged',
        t,
      )
    }
    addPivotColumns(e, t) {
      this.updateColList(
        e,
        this.pivotCols,
        !0,
        !1,
        (i) => i.setPivotActive(!0, t),
        'columnPivotChanged',
        t,
      )
    }
    setPivotColumns(e, t) {
      this.setColList(
        e,
        this.pivotCols,
        'columnPivotChanged',
        !0,
        !1,
        (i, s) => {
          s.setPivotActive(i, t)
        },
        t,
      )
    }
    removePivotColumns(e, t) {
      this.updateColList(
        e,
        this.pivotCols,
        !1,
        !1,
        (i) => i.setPivotActive(!1, t),
        'columnPivotChanged',
        t,
      )
    }
    setValueColumns(e, t) {
      this.setColList(
        e,
        this.valueCols,
        'columnValueChanged',
        !1,
        !1,
        (i, s) => this.setValueActive(i, s, t),
        t,
      )
    }
    setValueActive(e, t, i) {
      if (
        e !== t.isValueActive() &&
        (t.setValueActive(e, i), e && !t.getAggFunc() && this.aggFuncService)
      ) {
        const s = this.aggFuncService.getDefaultAggFunc(t)
        t.setAggFunc(s)
      }
    }
    addValueColumns(e, t) {
      this.updateColList(
        e,
        this.valueCols,
        !0,
        !1,
        (i) => this.setValueActive(!0, i, t),
        'columnValueChanged',
        t,
      )
    }
    removeValueColumns(e, t) {
      this.updateColList(
        e,
        this.valueCols,
        !1,
        !1,
        (i) => this.setValueActive(!1, i, t),
        'columnValueChanged',
        t,
      )
    }
    moveRowGroupColumn(e, t, i) {
      if (this.isRowGroupEmpty()) return
      const s = this.rowGroupCols[e],
        n = this.rowGroupCols.slice(e, t)
      this.rowGroupCols.splice(e, 1),
        this.rowGroupCols.splice(t, 0, s),
        this.eventDispatcher.rowGroupChanged(n, i)
    }
    setColList(e, t, i, s, n, r, o) {
      if (!this.columnModel.getCols()) return
      const a = new Map()
      t.forEach((c, u) => a.set(c, u)),
        (t.length = 0),
        ue(e) &&
          e.forEach((c) => {
            const u = this.columnModel.getColDefCol(c)
            u && t.push(u)
          }),
        t.forEach((c, u) => {
          const h = a.get(c)
          if (h === void 0) {
            a.set(c, 0)
            return
          }
          ;(s && h !== u) || a.delete(c)
        }),
        (this.columnModel.getColDefCols() || []).forEach((c) => {
          const u = t.indexOf(c) >= 0
          r(u, c)
        }),
        n && this.columnModel.refreshCols(!1),
        this.visibleColsService.refresh(o),
        this.eventDispatcher.columnChanged(i, [...a.keys()], o)
    }
    updateColList(e, t, i, s, n, r, o) {
      if (!e || Hi(e)) return
      let a = !1
      const l = new Set()
      e.forEach((c) => {
        if (!c) return
        const u = this.columnModel.getColDefCol(c)
        if (u) {
          if ((l.add(u), i)) {
            if (t.indexOf(u) >= 0) return
            t.push(u)
          } else {
            const h = t.indexOf(u)
            if (h < 0) return
            for (let g = h + 1; g < t.length; g++) l.add(t[g])
            Ri(t, u)
          }
          n(u), (a = !0)
        }
      }),
        a &&
          (s && this.columnModel.refreshCols(!1),
          this.visibleColsService.refresh(o),
          this.eventDispatcher.genericColumnEvent(r, Array.from(l), o))
    }
    extractCols(e, t) {
      this.extractRowGroupCols(e, t),
        this.extractPivotCols(e, t),
        this.extractValueCols(e, t)
    }
    extractValueCols(e, t) {
      ;(this.valueCols = this.extractColsCommon(
        t,
        this.valueCols,
        (i, s) => i.setValueActive(s, e),
        () => {},
        () => {},
        (i) => {
          const s = i.aggFunc
          if (s === null || s === '') return null
          if (s !== void 0) return !!s
        },
        (i) => i.initialAggFunc != null && i.initialAggFunc != '',
      )),
        this.valueCols.forEach((i) => {
          const s = i.getColDef()
          s.aggFunc != null && s.aggFunc != ''
            ? i.setAggFunc(s.aggFunc)
            : i.getAggFunc() || i.setAggFunc(s.initialAggFunc)
        })
    }
    extractRowGroupCols(e, t) {
      this.rowGroupCols = this.extractColsCommon(
        t,
        this.rowGroupCols,
        (i, s) => i.setRowGroupActive(s, e),
        (i) => i.rowGroupIndex,
        (i) => i.initialRowGroupIndex,
        (i) => i.rowGroup,
        (i) => i.initialRowGroup,
      )
    }
    extractPivotCols(e, t) {
      this.pivotCols = this.extractColsCommon(
        t,
        this.pivotCols,
        (i, s) => i.setPivotActive(s, e),
        (i) => i.pivotIndex,
        (i) => i.initialPivotIndex,
        (i) => i.pivot,
        (i) => i.initialPivot,
      )
    }
    extractColsCommon(e = [], t = [], i, s, n, r, o) {
      const a = [],
        l = []
      ;(this.columnModel.getColDefCols() || []).forEach((g) => {
        const f = e.indexOf(g) < 0,
          p = g.getColDef(),
          v = Wc(r(p)),
          m = Wc(o(p)),
          C = Mn(s(p)),
          w = Mn(n(p))
        let S
        v !== void 0
          ? (S = v)
          : C !== void 0
            ? C === null
              ? (S = !1)
              : (S = C >= 0)
            : f
              ? m !== void 0
                ? (S = m)
                : w !== void 0
                  ? (S = w != null && w >= 0)
                  : (S = !1)
              : (S = t.indexOf(g) >= 0),
          S &&
            ((f ? C != null || w != null : C != null) ? a.push(g) : l.push(g))
      })
      const u = (g) => {
        const f = s(g.getColDef()),
          p = n(g.getColDef())
        return f ?? p
      }
      a.sort((g, f) => {
        const p = u(g),
          v = u(f)
        return p === v ? 0 : p < v ? -1 : 1
      })
      const h = [].concat(a)
      return (
        t.forEach((g) => {
          l.indexOf(g) >= 0 && h.push(g)
        }),
        l.forEach((g) => {
          h.indexOf(g) < 0 && h.push(g)
        }),
        t.forEach((g) => {
          h.indexOf(g) < 0 && i(g, !1)
        }),
        h.forEach((g) => {
          t.indexOf(g) < 0 && i(g, !0)
        }),
        h
      )
    }
    generateColumnStateForRowGroupAndPivotIndexes(e, t) {
      const i = {},
        s = (n, r, o, a, l, c) => {
          const u = this.columnModel.getColDefCols()
          if (!r.length || !u) return []
          const h = Object.keys(n),
            g = new Set(h),
            f = new Set(h),
            p = new Set(
              r
                .map((R) => {
                  const b = R.getColId()
                  return f.delete(b), b
                })
                .concat(h),
            ),
            v = [],
            m = {}
          let C = 0
          for (let R = 0; R < u.length; R++) {
            const b = u[R].getColId()
            p.has(b) && (v.push(b), (m[b] = C++))
          }
          let w = 1e3,
            S = !1,
            y = 0
          const F = (R) => {
            const b = m[R]
            for (let x = y; x < b; x++) {
              const D = v[x]
              f.has(D) && ((n[D][l] = w++), f.delete(D))
            }
            y = b
          }
          r.forEach((R) => {
            const b = R.getColId()
            if (g.has(b)) F(b), (n[b][l] = w++)
            else {
              const x = R.getColDef()
              ;(x[l] === null || (x[l] === void 0 && x[c] == null)) &&
                (S ||
                  (x[o] || (x[o] === void 0 && x[a])
                    ? F(b)
                    : (f.forEach((M) => {
                        n[M][l] = w + m[M]
                      }),
                      (w += v.length),
                      (S = !0))),
                i[b] || (i[b] = { colId: b }),
                (i[b][l] = w++))
            }
          })
        }
      return (
        s(
          e,
          this.rowGroupCols,
          'rowGroup',
          'initialRowGroup',
          'rowGroupIndex',
          'initialRowGroupIndex',
        ),
        s(
          t,
          this.pivotCols,
          'pivot',
          'initialPivot',
          'pivotIndex',
          'initialPivotIndex',
        ),
        Object.values(i)
      )
    }
  },
  Bx = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'columnApplyStateService')
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.eventDispatcher = e.columnEventDispatcher),
        (this.sortController = e.sortController),
        (this.columnGetStateService = e.columnGetStateService),
        (this.funcColsService = e.funcColsService),
        (this.visibleColsService = e.visibleColsService),
        (this.columnAnimationService = e.columnAnimationService),
        (this.pivotResultColsService = e.pivotResultColsService)
    }
    applyColumnState(e, t) {
      const i = this.columnModel.getColDefCols() || []
      if (Hi(i)) return !1
      if (e && e.state && !e.state.forEach)
        return (
          te(
            'applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state.',
          ),
          !1
        )
      const s = this.funcColsService.getModifyColumnsNoEventsCallbacks(),
        n = (a, l, c) => {
          const u = this.compareColumnStatesAndDispatchEvents(t),
            h = l.slice(),
            g = {},
            f = {},
            p = [],
            v = []
          let m = 0
          const C = this.funcColsService.getRowGroupColumns().slice(),
            w = this.funcColsService.getPivotColumns().slice()
          a.forEach((R) => {
            const b = R.colId || ''
            if (b.startsWith(ml)) {
              p.push(R), v.push(R)
              return
            }
            const D = c(b)
            D
              ? (this.syncColumnWithStateItem(
                  D,
                  R,
                  e.defaultState,
                  g,
                  f,
                  !1,
                  t,
                  s,
                ),
                Ri(h, D))
              : (v.push(R), (m += 1))
          })
          const S = (R) =>
            this.syncColumnWithStateItem(
              R,
              null,
              e.defaultState,
              g,
              f,
              !1,
              t,
              s,
            )
          h.forEach(S),
            this.funcColsService.sortRowGroupColumns(vg.bind(this, g, C)),
            this.funcColsService.sortPivotColumns(vg.bind(this, f, w)),
            this.columnModel.refreshCols(!1)
          const F = (this.columnModel.getAutoCols() || []).slice()
          return (
            p.forEach((R) => {
              const b = this.columnModel.getAutoCol(R.colId)
              Ri(F, b),
                this.syncColumnWithStateItem(
                  b,
                  R,
                  e.defaultState,
                  null,
                  null,
                  !0,
                  t,
                  s,
                )
            }),
            F.forEach(S),
            this.orderLiveColsLikeState(e),
            this.visibleColsService.refresh(t),
            this.eventDispatcher.everythingChanged(t),
            u(),
            { unmatchedAndAutoStates: v, unmatchedCount: m }
          )
        }
      this.columnAnimationService.start()
      let { unmatchedAndAutoStates: r, unmatchedCount: o } = n(
        e.state || [],
        i,
        (a) => this.columnModel.getColDefCol(a),
      )
      if (r.length > 0 || ue(e.defaultState)) {
        const a = this.pivotResultColsService.getPivotResultCols(),
          l = a == null ? void 0 : a.list
        o = n(r, l || [], (c) =>
          this.pivotResultColsService.getPivotResultCol(c),
        ).unmatchedCount
      }
      return this.columnAnimationService.finish(), o === 0
    }
    resetColumnState(e) {
      const t = this.columnModel.getColDefCols()
      if (Hi(t)) return
      const i = this.columnModel.getColDefColTree(),
        s = td(i),
        n = []
      let r = 1e3,
        o = 1e3,
        a = []
      const l = this.columnModel.getAutoCols()
      l && (a = a.concat(l)),
        s && (a = a.concat(s)),
        a.forEach((c) => {
          const u = this.getColumnStateFromColDef(c)
          ot(u.rowGroupIndex) && u.rowGroup && (u.rowGroupIndex = r++),
            ot(u.pivotIndex) && u.pivot && (u.pivotIndex = o++),
            n.push(u)
        }),
        this.applyColumnState({ state: n, applyOrder: !0 }, e)
    }
    getColumnStateFromColDef(e) {
      const t = (p, v) => p ?? v ?? null,
        i = e.getColDef(),
        s = t(i.sort, i.initialSort),
        n = t(i.sortIndex, i.initialSortIndex),
        r = t(i.hide, i.initialHide),
        o = t(i.pinned, i.initialPinned),
        a = t(i.width, i.initialWidth),
        l = t(i.flex, i.initialFlex)
      let c = t(i.rowGroupIndex, i.initialRowGroupIndex),
        u = t(i.rowGroup, i.initialRowGroup)
      c == null && (u == null || u == !1) && ((c = null), (u = null))
      let h = t(i.pivotIndex, i.initialPivotIndex),
        g = t(i.pivot, i.initialPivot)
      h == null && (g == null || g == !1) && ((h = null), (g = null))
      const f = t(i.aggFunc, i.initialAggFunc)
      return {
        colId: e.getColId(),
        sort: s,
        sortIndex: n,
        hide: r,
        pinned: o,
        width: a,
        flex: l,
        rowGroup: u,
        rowGroupIndex: c,
        pivot: g,
        pivotIndex: h,
        aggFunc: f,
      }
    }
    syncColumnWithStateItem(e, t, i, s, n, r, o, a) {
      if (!e) return
      const l = (y, F) => {
          const R = { value1: void 0, value2: void 0 }
          let b = !1
          return (
            t &&
              (t[y] !== void 0 && ((R.value1 = t[y]), (b = !0)),
              ue(F) && t[F] !== void 0 && ((R.value2 = t[F]), (b = !0))),
            !b &&
              i &&
              (i[y] !== void 0 && (R.value1 = i[y]),
              ue(F) && i[F] !== void 0 && (R.value2 = i[F])),
            R
          )
        },
        c = l('hide').value1
      c !== void 0 && e.setVisible(!c, o)
      const u = l('pinned').value1
      u !== void 0 && e.setPinned(u)
      const h =
          e.getColDef().minWidth ??
          this.gos.environment.getDefaultColumnMinWidth(),
        g = l('flex').value1
      if ((g !== void 0 && e.setFlex(g), g == null)) {
        const y = l('width').value1
        y != null && h != null && y >= h && e.setActualWidth(y, o)
      }
      const f = l('sort').value1
      f !== void 0 &&
        (f === 'desc' || f === 'asc' ? e.setSort(f, o) : e.setSort(void 0, o))
      const p = l('sortIndex').value1
      if ((p !== void 0 && e.setSortIndex(p), r || !e.isPrimary())) return
      const v = l('aggFunc').value1
      v !== void 0 &&
        (typeof v == 'string'
          ? (e.setAggFunc(v),
            e.isValueActive() || (e.setValueActive(!0, o), a.addValueCol(e)))
          : (ue(v) &&
              te(
                'stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON.',
              ),
            e.isValueActive() &&
              (e.setValueActive(!1, o), a.removeValueCol(e))))
      const { value1: m, value2: C } = l('rowGroup', 'rowGroupIndex')
      ;(m !== void 0 || C !== void 0) &&
        (typeof C == 'number' || m
          ? (e.isRowGroupActive() ||
              (e.setRowGroupActive(!0, o), a.addGroupCol(e)),
            s && typeof C == 'number' && (s[e.getId()] = C))
          : e.isRowGroupActive() &&
            (e.setRowGroupActive(!1, o), a.removeGroupCol(e)))
      const { value1: w, value2: S } = l('pivot', 'pivotIndex')
      ;(w !== void 0 || S !== void 0) &&
        (typeof S == 'number' || w
          ? (e.isPivotActive() || (e.setPivotActive(!0, o), a.addPivotCol(e)),
            n && typeof S == 'number' && (n[e.getId()] = S))
          : e.isPivotActive() && (e.setPivotActive(!1, o), a.removePivotCol(e)))
    }
    orderLiveColsLikeState(e) {
      if (!e.applyOrder || !e.state) return
      const t = []
      e.state.forEach((i) => {
        i.colId != null && t.push(i.colId)
      }),
        this.columnModel.sortColsLikeKeys(t)
    }
    compareColumnStatesAndDispatchEvents(e) {
      const t = {
          rowGroupColumns: this.funcColsService.getRowGroupColumns().slice(),
          pivotColumns: this.funcColsService.getPivotColumns().slice(),
          valueColumns: this.funcColsService.getValueColumns().slice(),
        },
        i = this.columnGetStateService.getColumnState(),
        s = {}
      return (
        i.forEach((n) => {
          s[n.colId] = n
        }),
        () => {
          const n = this.columnModel.getAllCols(),
            r = (v, m, C, w) => {
              const S = m.map(w),
                y = C.map(w)
              if (gn(S, y)) return
              const R = new Set(m)
              C.forEach((x) => {
                R.delete(x) || R.add(x)
              })
              const b = [...R]
              this.eventService.dispatchEvent({
                type: v,
                columns: b,
                column: b.length === 1 ? b[0] : null,
                source: e,
              })
            },
            o = (v) => {
              const m = []
              return (
                n.forEach((C) => {
                  const w = s[C.getColId()]
                  w && v(w, C) && m.push(C)
                }),
                m
              )
            },
            a = (v) => v.getColId()
          r(
            'columnRowGroupChanged',
            t.rowGroupColumns,
            this.funcColsService.getRowGroupColumns(),
            a,
          ),
            r(
              'columnPivotChanged',
              t.pivotColumns,
              this.funcColsService.getPivotColumns(),
              a,
            )
          const c = o((v, m) => {
            const C = v.aggFunc != null,
              w = C != m.isValueActive(),
              S = C && v.aggFunc != m.getAggFunc()
            return w || S
          })
          c.length > 0 &&
            this.eventDispatcher.columnChanged('columnValueChanged', c, e)
          const u = (v, m) => v.width != m.getActualWidth()
          this.eventDispatcher.columnResized(o(u), !0, e)
          const h = (v, m) => v.pinned != m.getPinned()
          this.eventDispatcher.columnPinned(o(h), e)
          const g = (v, m) => v.hide == m.isVisible()
          this.eventDispatcher.columnVisible(o(g), e)
          const p = o(
            (v, m) => v.sort != m.getSort() || v.sortIndex != m.getSortIndex(),
          )
          p.length > 0 && this.sortController.dispatchSortChangedEvents(e, p),
            this.normaliseColumnMovedEventForColumnState(i, e)
        }
      )
    }
    normaliseColumnMovedEventForColumnState(e, t) {
      const i = this.columnGetStateService.getColumnState(),
        s = {}
      i.forEach((l) => (s[l.colId] = l))
      const n = {}
      e.forEach((l) => {
        s[l.colId] && (n[l.colId] = !0)
      })
      const r = e.filter((l) => n[l.colId]),
        o = i.filter((l) => n[l.colId]),
        a = []
      o.forEach((l, c) => {
        const u = r && r[c]
        if (u && u.colId !== l.colId) {
          const h = this.columnModel.getCol(u.colId)
          h && a.push(h)
        }
      }),
        a.length &&
          this.eventDispatcher.columnMoved({
            movedColumns: a,
            source: t,
            finished: !0,
          })
    }
  },
  vg = (e, t, i, s) => {
    const n = e[i.getId()],
      r = e[s.getId()],
      o = n != null,
      a = r != null
    if (o && a) return n - r
    if (o) return -1
    if (a) return 1
    const l = t.indexOf(i),
      c = t.indexOf(s),
      u = l >= 0,
      h = c >= 0
    return u && h ? l - c : u ? -1 : 1
  },
  Vx = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'columnMoveService')
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.columnAnimationService = e.columnAnimationService),
        (this.eventDispatcher = e.columnEventDispatcher)
    }
    moveColumnByIndex(e, t, i) {
      const s = this.columnModel.getCols()
      if (!s) return
      const n = s[e]
      this.moveColumns([n], t, i)
    }
    moveColumns(e, t, i, s = !0) {
      const n = this.columnModel.getCols()
      if (!n) return
      if (t > n.length - e.length) {
        te('tried to insert columns in invalid location, toIndex = ', t),
          te(
            'remember that you should not count the moving columns when calculating the new index',
          )
        return
      }
      this.columnAnimationService.start()
      const r = this.columnModel.getColsForKeys(e)
      this.doesMovePassRules(r, t) &&
        (this.columnModel.moveInCols(r, t, i),
        this.eventDispatcher.columnMoved({
          movedColumns: r,
          source: i,
          toIndex: t,
          finished: s,
        })),
        this.columnAnimationService.finish()
    }
    doesMovePassRules(e, t) {
      const i = this.getProposedColumnOrder(e, t)
      return this.doesOrderPassRules(i)
    }
    doesOrderPassRules(e) {
      return !(
        !this.doesMovePassMarryChildren(e) ||
        !this.doesMovePassLockedPositions(e)
      )
    }
    getProposedColumnOrder(e, t) {
      const s = this.columnModel.getCols().slice()
      return Pm(s, e, t), s
    }
    doesMovePassLockedPositions(e) {
      const t = (r) => (r ? (r === 'left' || r === !0 ? -1 : 1) : 0),
        i = this.gos.get('enableRtl')
      let s = i ? 1 : -1,
        n = !0
      return (
        e.forEach((r) => {
          const o = t(r.getColDef().lockPosition)
          i ? o > s && (n = !1) : o < s && (n = !1), (s = o)
        }),
        n
      )
    }
    doesMovePassMarryChildren(e) {
      let t = !0
      const i = this.columnModel.getColTree()
      return (
        _s(null, i, (s) => {
          if (!wi(s)) return
          const n = s,
            r = n.getColGroupDef()
          if (!(r && r.marryChildren)) return
          const a = []
          n.getLeafColumns().forEach((g) => {
            const f = e.indexOf(g)
            a.push(f)
          })
          const l = Math.max.apply(Math, a),
            c = Math.min.apply(Math, a),
            u = l - c,
            h = n.getLeafColumns().length - 1
          u > h && (t = !1)
        }),
        t
      )
    }
    placeLockedColumns(e) {
      const t = [],
        i = [],
        s = []
      return (
        e.forEach((r) => {
          const o = r.getColDef().lockPosition
          o === 'right'
            ? s.push(r)
            : o === 'left' || o === !0
              ? t.push(r)
              : i.push(r)
        }),
        this.gos.get('enableRtl') ? [...s, ...i, ...t] : [...t, ...i, ...s]
      )
    }
  },
  _x = /[&<>"']/g,
  Wx = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }
function hs(e, t) {
  if (e == null) return null
  const i = e.toString().toString()
  return t ? i : i.replace(_x, (s) => Wx[s])
}
function $x(e) {
  if (!e || e == null) return null
  const t = /([a-z])([A-Z])/g,
    i = /([A-Z]+)([A-Z])([a-z])/g
  return e
    .replace(t, '$1 $2')
    .replace(i, '$1 $2$3')
    .replace(/\./g, ' ')
    .split(' ')
    .map(
      (n) =>
        n.substring(0, 1).toUpperCase() +
        (n.length > 1 ? n.substring(1, n.length) : ''),
    )
    .join(' ')
}
var zx = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'columnNameService')
    }
    wireBeans(e) {
      ;(this.expressionService = e.expressionService),
        (this.funcColsService = e.funcColsService),
        (this.columnModel = e.columnModel)
    }
    getDisplayNameForColumn(e, t, i = !1) {
      if (!e) return null
      const s = this.getHeaderName(e.getColDef(), e, null, null, t)
      return i ? this.wrapHeaderNameWithAggFunc(e, s) : s
    }
    getDisplayNameForProvidedColumnGroup(e, t, i) {
      const s = t ? t.getColGroupDef() : null
      return s ? this.getHeaderName(s, null, e, t, i) : null
    }
    getDisplayNameForColumnGroup(e, t) {
      return this.getDisplayNameForProvidedColumnGroup(
        e,
        e.getProvidedColumnGroup(),
        t,
      )
    }
    getHeaderName(e, t, i, s, n) {
      const r = e.headerValueGetter
      if (r) {
        const o = this.gos.addGridCommonParams({
          colDef: e,
          column: t,
          columnGroup: i,
          providedColumnGroup: s,
          location: n,
        })
        return typeof r == 'function'
          ? r(o)
          : typeof r == 'string'
            ? this.expressionService.evaluate(r, o)
            : (te('headerValueGetter must be a function or a string'), '')
      } else {
        if (e.headerName != null) return e.headerName
        if (e.field) return $x(e.field)
      }
      return ''
    }
    wrapHeaderNameWithAggFunc(e, t) {
      if (this.gos.get('suppressAggFuncInHeader')) return t
      const i = e.getColDef().pivotValueColumn,
        s = ue(i)
      let n = null,
        r
      if (s) {
        const o = this.funcColsService.getValueColumns(),
          a =
            this.gos.get('removePivotHeaderRowWhenSingleValueColumn') &&
            o.length === 1,
          l = e.getColDef().pivotTotalColumnIds !== void 0
        if (a && !l) return t
        ;(n = i ? i.getAggFunc() : null), (r = !0)
      } else {
        const o = e.isValueActive(),
          a =
            this.columnModel.isPivotMode() ||
            !this.funcColsService.isRowGroupEmpty()
        o && a ? ((n = e.getAggFunc()), (r = !0)) : (r = !1)
      }
      if (r) {
        const o = typeof n == 'string' ? n : 'func'
        return `${this.localeService.getLocaleTextFunc()(o, o)}(${t})`
      }
      return t
    }
  },
  Ux = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'pivotResultColsService')
    }
    wireBeans(e) {
      ;(this.context = e.context),
        (this.columnModel = e.columnModel),
        (this.columnFactory = e.columnFactory),
        (this.visibleColsService = e.visibleColsService)
    }
    destroy() {
      var e
      tn(this.context, (e = this.pivotResultCols) == null ? void 0 : e.tree),
        super.destroy()
    }
    isPivotResultColsPresent() {
      return this.pivotResultCols != null
    }
    lookupPivotResultCol(e, t) {
      if (this.pivotResultCols == null) return null
      const i = this.columnModel.getColDefCol(t)
      let s = null
      return (
        this.pivotResultCols.list.forEach((n) => {
          const r = n.getColDef().pivotKeys,
            o = n.getColDef().pivotValueColumn
          gn(r, e) && o === i && (s = n)
        }),
        s
      )
    }
    getPivotResultCols() {
      return this.pivotResultCols
    }
    getPivotResultCol(e) {
      return this.pivotResultCols
        ? this.columnModel.getColFromCollection(e, this.pivotResultCols)
        : null
    }
    setPivotResultCols(e, t) {
      var i, s
      if (
        this.columnModel.isReady() &&
        !(e == null && this.pivotResultCols == null)
      ) {
        if (e) {
          this.processPivotResultColDef(e)
          const n = this.columnFactory.createColumnTree(
            e,
            !1,
            ((i = this.pivotResultCols) == null ? void 0 : i.tree) ||
              this.previousPivotResultCols ||
              void 0,
            t,
          )
          tn(
            this.context,
            (s = this.pivotResultCols) == null ? void 0 : s.tree,
            n.columnTree,
          )
          const r = n.columnTree,
            o = n.treeDept,
            a = td(r),
            l = {}
          ;(this.pivotResultCols = { tree: r, treeDepth: o, list: a, map: l }),
            this.pivotResultCols.list.forEach(
              (u) => (this.pivotResultCols.map[u.getId()] = u),
            )
          const c = !!this.previousPivotResultCols
          ;(this.previousPivotResultCols = null),
            this.columnModel.refreshCols(!c)
        } else
          (this.previousPivotResultCols = this.pivotResultCols
            ? this.pivotResultCols.tree
            : null),
            (this.pivotResultCols = null),
            this.columnModel.refreshCols(!1)
        this.visibleColsService.refresh(t)
      }
    }
    processPivotResultColDef(e) {
      const t = this.gos.get('processPivotResultColDef'),
        i = this.gos.get('processPivotResultColGroupDef')
      if (!t && !i) return
      const s = (n) => {
        n.forEach((r) => {
          if (ue(r.children)) {
            const a = r
            i && i(a), s(a.children)
          } else t && t(r)
        })
      }
      e && s(e)
    }
  },
  jx = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'columnSizeService')
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.columnViewportService = e.columnViewportService),
        (this.eventDispatcher = e.columnEventDispatcher),
        (this.visibleColsService = e.visibleColsService),
        (this.ctrlsService = e.ctrlsService)
    }
    setColumnWidths(e, t, i, s) {
      const n = []
      e.forEach((r) => {
        const o =
          this.columnModel.getColDefCol(r.key) || this.columnModel.getCol(r.key)
        if (!o) return
        if (
          (n.push({ width: r.newWidth, ratios: [1], columns: [o] }),
          this.gos.get('colResizeDefault') === 'shift' && (t = !t),
          t)
        ) {
          const l = this.visibleColsService.getColAfter(o)
          if (!l) return
          const c = o.getActualWidth() - r.newWidth,
            u = l.getActualWidth() + c
          n.push({ width: u, ratios: [1], columns: [l] })
        }
      }),
        n.length !== 0 &&
          this.resizeColumnSets({ resizeSets: n, finished: i, source: s })
    }
    resizeColumnSets(e) {
      const { resizeSets: t, finished: i, source: s } = e
      if (!(!t || t.every((u) => this.checkMinAndMaxWidthsForSet(u)))) {
        if (i) {
          const u = t && t.length > 0 ? t[0].columns : null
          this.eventDispatcher.columnResized(u, i, s)
        }
        return
      }
      const r = [],
        o = []
      t.forEach((u) => {
        const { width: h, columns: g, ratios: f } = u,
          p = {},
          v = {}
        g.forEach((w) => o.push(w))
        let m = !0,
          C = 0
        for (; m; ) {
          if ((C++, C > 1e3)) {
            ht('infinite loop in resizeColumnSets')
            break
          }
          m = !1
          const w = []
          let S = 0,
            y = h
          g.forEach((R, b) => {
            if (v[R.getId()]) y -= p[R.getId()]
            else {
              w.push(R)
              const D = f[b]
              S += D
            }
          })
          const F = 1 / S
          w.forEach((R, b) => {
            const x = b === w.length - 1
            let D
            x ? (D = y) : ((D = Math.round(f[b] * h * F)), (y -= D))
            const O = R.getMinWidth(),
              M = R.getMaxWidth()
            D < O
              ? ((D = O), (v[R.getId()] = !0), (m = !0))
              : M > 0 && D > M && ((D = M), (v[R.getId()] = !0), (m = !0)),
              (p[R.getId()] = D)
          })
        }
        g.forEach((w) => {
          const S = p[w.getId()]
          w.getActualWidth() !== S && (w.setActualWidth(S, s), r.push(w))
        })
      })
      const a = r.length > 0
      let l = []
      a &&
        ((l = this.refreshFlexedColumns({ resizingCols: o, skipSetLeft: !0 })),
        this.visibleColsService.setLeftValues(s),
        this.visibleColsService.updateBodyWidths(),
        this.columnViewportService.checkViewportColumns())
      const c = o.concat(l)
      ;(a || i) && this.eventDispatcher.columnResized(c, i, s, l)
    }
    checkMinAndMaxWidthsForSet(e) {
      const { columns: t, width: i } = e
      let s = 0,
        n = 0,
        r = !0
      t.forEach((l) => {
        const c = l.getMinWidth()
        s += c || 0
        const u = l.getMaxWidth()
        u > 0 ? (n += u) : (r = !1)
      })
      const o = i >= s,
        a = !r || i <= n
      return o && a
    }
    refreshFlexedColumns(e = {}) {
      const t = e.source ? e.source : 'flex'
      if (
        (e.viewportWidth != null && (this.flexViewportWidth = e.viewportWidth),
        !this.flexViewportWidth)
      )
        return []
      const i = this.visibleColsService.getCenterCols()
      let s = -1
      if (e.resizingCols) {
        const g = new Set(e.resizingCols)
        for (let f = i.length - 1; f >= 0; f--)
          if (g.has(i[f])) {
            s = f
            break
          }
      }
      let n = 0,
        r = [],
        o = 0,
        a = 0
      for (let g = 0; g < i.length; g++)
        i[g].getFlex() && g > s
          ? (r.push(i[g]), (a += i[g].getFlex()), (o += i[g].getMinWidth()))
          : (n += i[g].getActualWidth())
      if (!r.length) return []
      let l = []
      n + o > this.flexViewportWidth &&
        (r.forEach((g) => g.setActualWidth(g.getMinWidth(), t)),
        (l = r),
        (r = []))
      const c = []
      let u
      e: for (;;) {
        u = this.flexViewportWidth - n
        const g = u / a
        for (let f = 0; f < r.length; f++) {
          const p = r[f],
            v = g * p.getFlex()
          let m = 0
          const C = p.getMinWidth(),
            w = p.getMaxWidth()
          if ((v < C ? (m = C) : v > w && (m = w), m)) {
            p.setActualWidth(m, t),
              Em(r, p),
              (a -= p.getFlex()),
              l.push(p),
              (n += p.getActualWidth())
            continue e
          }
          c[f] = Math.floor(v)
        }
        break
      }
      let h = u
      return (
        r.forEach((g, f) => {
          const p = f < r.length - 1 ? Math.min(c[f], h) : Math.max(c[f], h)
          g.setActualWidth(p, t), l.push(g), (h -= c[f])
        }),
        e.skipSetLeft || this.visibleColsService.setLeftValues(t),
        e.updateBodyWidths && this.visibleColsService.updateBodyWidths(),
        e.fireResizedEvent && this.eventDispatcher.columnResized(l, !0, t, r),
        r
      )
    }
    sizeColumnsToFit(e, t = 'sizeColumnsToFit', i, s) {
      var g
      if (this.columnModel.isShouldQueueResizeOperations()) {
        this.columnModel.pushResizeOperation(() =>
          this.sizeColumnsToFit(e, t, i, s),
        )
        return
      }
      const n = {}
      s &&
        ((g = s == null ? void 0 : s.columnLimits) == null ||
          g.forEach(({ key: f, ...p }) => {
            n[typeof f == 'string' ? f : f.getColId()] = p
          }))
      const r = this.visibleColsService.getAllCols(),
        o = e === xs(r)
      if (e <= 0 || !r.length || o) return
      const a = [],
        l = []
      r.forEach((f) => {
        f.getColDef().suppressSizeToFit === !0 ? l.push(f) : a.push(f)
      })
      const c = a.slice(0)
      let u = !1
      const h = (f) => {
        Ri(a, f), l.push(f)
      }
      for (
        a.forEach((f) => {
          f.resetActualWidth(t)
          const p = n == null ? void 0 : n[f.getId()],
            v =
              (p == null ? void 0 : p.minWidth) ??
              (s == null ? void 0 : s.defaultMinWidth),
            m =
              (p == null ? void 0 : p.maxWidth) ??
              (s == null ? void 0 : s.defaultMaxWidth),
            C = f.getActualWidth()
          typeof v == 'number' && C < v
            ? f.setActualWidth(v, t, !0)
            : typeof m == 'number' && C > m && f.setActualWidth(m, t, !0)
        });
        !u;

      ) {
        u = !0
        const f = e - xs(l)
        if (f <= 0)
          a.forEach((p) => {
            var m
            const v =
              ((m = n == null ? void 0 : n[p.getId()]) == null
                ? void 0
                : m.minWidth) ?? (s == null ? void 0 : s.defaultMinWidth)
            if (typeof v == 'number') {
              p.setActualWidth(v, t, !0)
              return
            }
            p.setMinimum(t)
          })
        else {
          const p = f / xs(a)
          let v = f
          for (let m = a.length - 1; m >= 0; m--) {
            const C = a[m],
              w = n == null ? void 0 : n[C.getId()],
              S =
                (w == null ? void 0 : w.minWidth) ??
                (s == null ? void 0 : s.defaultMinWidth),
              y =
                (w == null ? void 0 : w.maxWidth) ??
                (s == null ? void 0 : s.defaultMaxWidth),
              F = C.getMinWidth(),
              R = C.getMaxWidth(),
              b = typeof S == 'number' && S > F ? S : F,
              x = typeof y == 'number' && y < R ? y : R
            let D = Math.round(C.getActualWidth() * p)
            D < b
              ? ((D = b), h(C), (u = !1))
              : D > x
                ? ((D = x), h(C), (u = !1))
                : m === 0 && (D = v),
              C.setActualWidth(D, t, !0),
              (v -= D)
          }
        }
      }
      c.forEach((f) => {
        f.fireColumnWidthChangedEvent(t)
      }),
        this.visibleColsService.setLeftValues(t),
        this.visibleColsService.updateBodyWidths(),
        !i && this.eventDispatcher.columnResized(c, !0, t)
    }
    applyAutosizeStrategy() {
      const e = this.gos.get('autoSizeStrategy')
      if (!e) return
      const { type: t } = e
      setTimeout(() => {
        if (t === 'fitGridWidth') {
          const { columnLimits: i, defaultMinWidth: s, defaultMaxWidth: n } = e,
            r =
              i == null
                ? void 0
                : i.map(({ colId: o, minWidth: a, maxWidth: l }) => ({
                    key: o,
                    minWidth: a,
                    maxWidth: l,
                  }))
          this.ctrlsService
            .getGridBodyCtrl()
            .sizeColumnsToFit({
              defaultMinWidth: s,
              defaultMaxWidth: n,
              columnLimits: r,
            })
        } else
          t === 'fitProvidedWidth' &&
            this.sizeColumnsToFit(e.width, 'sizeColumnsToFit')
      })
    }
  }
function Am(e, t) {
  return e + '_' + t
}
function _t(e) {
  return e instanceof Om
}
var Om = class extends X {
    constructor(e, t, i, s) {
      super(),
        (this.isColumn = !1),
        (this.displayedChildren = []),
        (this.autoHeaderHeight = null),
        (this.parent = null),
        (this.groupId = t),
        (this.partId = i),
        (this.providedColumnGroup = e),
        (this.pinned = s)
    }
    reset() {
      ;(this.parent = null),
        (this.children = null),
        (this.displayedChildren = null)
    }
    getParent() {
      return this.parent
    }
    setParent(e) {
      this.parent = e
    }
    getUniqueId() {
      return Am(this.groupId, this.partId)
    }
    isEmptyGroup() {
      return this.displayedChildren.length === 0
    }
    isMoving() {
      const e = this.getProvidedColumnGroup().getLeafColumns()
      return !e || e.length === 0 ? !1 : e.every((t) => t.isMoving())
    }
    checkLeft() {
      if (
        (this.displayedChildren.forEach((e) => {
          _t(e) && e.checkLeft()
        }),
        this.displayedChildren.length > 0)
      )
        if (this.gos.get('enableRtl')) {
          const t = rt(this.displayedChildren).getLeft()
          this.setLeft(t)
        } else {
          const e = this.displayedChildren[0].getLeft()
          this.setLeft(e)
        }
      else this.setLeft(null)
    }
    getLeft() {
      return this.left
    }
    getOldLeft() {
      return this.oldLeft
    }
    setLeft(e) {
      ;(this.oldLeft = this.left),
        this.left !== e &&
          ((this.left = e), this.dispatchLocalEvent({ type: 'leftChanged' }))
    }
    getPinned() {
      return this.pinned
    }
    getGroupId() {
      return this.groupId
    }
    getPartId() {
      return this.partId
    }
    getActualWidth() {
      let e = 0
      return (
        this.displayedChildren &&
          this.displayedChildren.forEach((t) => {
            e += t.getActualWidth()
          }),
        e
      )
    }
    isResizable() {
      if (!this.displayedChildren) return !1
      let e = !1
      return (
        this.displayedChildren.forEach((t) => {
          t.isResizable() && (e = !0)
        }),
        e
      )
    }
    getMinWidth() {
      let e = 0
      return (
        this.displayedChildren.forEach((t) => {
          e += t.getMinWidth()
        }),
        e
      )
    }
    addChild(e) {
      this.children || (this.children = []), this.children.push(e)
    }
    getDisplayedChildren() {
      return this.displayedChildren
    }
    getLeafColumns() {
      const e = []
      return this.addLeafColumns(e), e
    }
    getDisplayedLeafColumns() {
      const e = []
      return this.addDisplayedLeafColumns(e), e
    }
    getDefinition() {
      return this.providedColumnGroup.getColGroupDef()
    }
    getColGroupDef() {
      return this.providedColumnGroup.getColGroupDef()
    }
    isPadding() {
      return this.providedColumnGroup.isPadding()
    }
    isExpandable() {
      return this.providedColumnGroup.isExpandable()
    }
    isExpanded() {
      return this.providedColumnGroup.isExpanded()
    }
    setExpanded(e) {
      this.providedColumnGroup.setExpanded(e)
    }
    isAutoHeaderHeight() {
      var e
      return !!((e = this.getColGroupDef()) != null && e.autoHeaderHeight)
    }
    getAutoHeaderHeight() {
      return this.autoHeaderHeight
    }
    setAutoHeaderHeight(e) {
      const t = e !== this.autoHeaderHeight
      return (this.autoHeaderHeight = e), t
    }
    addDisplayedLeafColumns(e) {
      this.displayedChildren.forEach((t) => {
        cn(t) ? e.push(t) : _t(t) && t.addDisplayedLeafColumns(e)
      })
    }
    addLeafColumns(e) {
      this.children.forEach((t) => {
        cn(t) ? e.push(t) : _t(t) && t.addLeafColumns(e)
      })
    }
    getChildren() {
      return this.children
    }
    getColumnGroupShow() {
      return this.providedColumnGroup.getColumnGroupShow()
    }
    getProvidedColumnGroup() {
      return this.providedColumnGroup
    }
    getPaddingLevel() {
      const e = this.getParent()
      return !this.isPadding() || !e || !e.isPadding()
        ? 0
        : 1 + e.getPaddingLevel()
    }
    calculateDisplayedColumns() {
      this.displayedChildren = []
      let e = this
      for (; e != null && e.isPadding(); ) e = e.getParent()
      if (!(e ? e.getProvidedColumnGroup().isExpandable() : !1)) {
        ;(this.displayedChildren = this.children),
          this.dispatchLocalEvent({ type: 'displayedChildrenChanged' })
        return
      }
      this.children.forEach((i) => {
        if (_t(i) && (!i.displayedChildren || !i.displayedChildren.length))
          return
        switch (i.getColumnGroupShow()) {
          case 'open':
            e.getProvidedColumnGroup().isExpanded() &&
              this.displayedChildren.push(i)
            break
          case 'closed':
            e.getProvidedColumnGroup().isExpanded() ||
              this.displayedChildren.push(i)
            break
          default:
            this.displayedChildren.push(i)
            break
        }
      }),
        this.dispatchLocalEvent({ type: 'displayedChildrenChanged' })
    }
  },
  Lm = class {
    constructor() {
      this.existingIds = {}
    }
    getInstanceIdForKey(e) {
      const t = this.existingIds[e]
      let i
      return (
        typeof t != 'number' ? (i = 0) : (i = t + 1),
        (this.existingIds[e] = i),
        i
      )
    }
  },
  Yx = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'visibleColsService'),
        (this.colsAndGroupsMap = {}),
        (this.columnsLeft = []),
        (this.columnsRight = []),
        (this.columnsCenter = []),
        (this.columns = []),
        (this.bodyWidth = 0),
        (this.leftWidth = 0),
        (this.rightWidth = 0),
        (this.bodyWidthDirty = !0)
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.columnSizeService = e.columnSizeService),
        (this.columnViewportService = e.columnViewportService),
        (this.eventDispatcher = e.columnEventDispatcher)
    }
    refresh(e, t = !1) {
      t || this.buildTrees(),
        this.updateOpenClosedVisibilityInColumnGroups(),
        (this.columnsLeft = lc(this.treeLeft)),
        (this.columnsCenter = lc(this.treeCenter)),
        (this.columnsRight = lc(this.treeRight)),
        this.joinColsAriaOrder(),
        this.joinCols(),
        this.setLeftValues(e),
        (this.autoHeightCols = this.columns.filter((i) => i.isAutoHeight())),
        this.columnSizeService.refreshFlexedColumns(),
        this.updateBodyWidths(),
        this.columnViewportService.checkViewportColumns(!1),
        this.setFirstRightAndLastLeftPinned(e),
        this.eventDispatcher.visibleCols(e)
    }
    updateBodyWidths() {
      const e = xs(this.columnsCenter),
        t = xs(this.columnsLeft),
        i = xs(this.columnsRight)
      ;(this.bodyWidthDirty = this.bodyWidth !== e),
        (this.bodyWidth !== e ||
          this.leftWidth !== t ||
          this.rightWidth !== i) &&
          ((this.bodyWidth = e),
          (this.leftWidth = t),
          (this.rightWidth = i),
          this.eventService.dispatchEvent({
            type: 'columnContainerWidthChanged',
          }),
          this.eventService.dispatchEvent({
            type: 'displayedColumnsWidthChanged',
          }))
    }
    setLeftValues(e) {
      this.setLeftValuesOfCols(e), this.setLeftValuesOfGroups()
    }
    setFirstRightAndLastLeftPinned(e) {
      let t, i
      this.gos.get('enableRtl')
        ? ((t = this.columnsLeft ? this.columnsLeft[0] : null),
          (i = this.columnsRight ? rt(this.columnsRight) : null))
        : ((t = this.columnsLeft ? rt(this.columnsLeft) : null),
          (i = this.columnsRight ? this.columnsRight[0] : null)),
        this.columnModel.getCols().forEach((s) => {
          s.setLastLeftPinned(s === t, e), s.setFirstRightPinned(s === i, e)
        })
    }
    buildTrees() {
      const e = this.columnModel.getColsToShow(),
        t = e.filter((r) => r.getPinned() == 'left'),
        i = e.filter((r) => r.getPinned() == 'right'),
        s = e.filter(
          (r) => r.getPinned() != 'left' && r.getPinned() != 'right',
        ),
        n = new Lm()
      ;(this.treeLeft = this.createGroups({
        columns: t,
        idCreator: n,
        pinned: 'left',
        oldDisplayedGroups: this.treeLeft,
      })),
        (this.treeRight = this.createGroups({
          columns: i,
          idCreator: n,
          pinned: 'right',
          oldDisplayedGroups: this.treeRight,
        })),
        (this.treeCenter = this.createGroups({
          columns: s,
          idCreator: n,
          pinned: null,
          oldDisplayedGroups: this.treeCenter,
        })),
        this.updateColsAndGroupsMap()
    }
    clear() {
      ;(this.columnsLeft = []),
        (this.columnsRight = []),
        (this.columnsCenter = []),
        (this.columns = []),
        (this.ariaOrderColumns = [])
    }
    joinColsAriaOrder() {
      const e = this.columnModel.getCols(),
        t = [],
        i = [],
        s = []
      for (const n of e) {
        const r = n.getPinned()
        r ? (r === !0 || r === 'left' ? t.push(n) : s.push(n)) : i.push(n)
      }
      this.ariaOrderColumns = t.concat(i).concat(s)
    }
    getAriaColIndex(e) {
      let t
      return (
        _t(e) ? (t = e.getLeafColumns()[0]) : (t = e),
        this.ariaOrderColumns.indexOf(t) + 1
      )
    }
    getAllAutoHeightCols() {
      return this.autoHeightCols
    }
    setLeftValuesOfGroups() {
      ;[this.treeLeft, this.treeRight, this.treeCenter].forEach((e) => {
        e.forEach((t) => {
          _t(t) && t.checkLeft()
        })
      })
    }
    setLeftValuesOfCols(e) {
      if (!this.columnModel.getColDefCols()) return
      const i = this.columnModel.getCols().slice(0),
        s = this.gos.get('enableRtl')
      ;[this.columnsLeft, this.columnsRight, this.columnsCenter].forEach(
        (n) => {
          if (s) {
            let r = xs(n)
            n.forEach((o) => {
              ;(r -= o.getActualWidth()), o.setLeft(r, e)
            })
          } else {
            let r = 0
            n.forEach((o) => {
              o.setLeft(r, e), (r += o.getActualWidth())
            })
          }
          bx(i, n)
        },
      ),
        i.forEach((n) => {
          n.setLeft(null, e)
        })
    }
    joinCols() {
      this.gos.get('enableRtl')
        ? (this.columns = this.columnsRight
            .concat(this.columnsCenter)
            .concat(this.columnsLeft))
        : (this.columns = this.columnsLeft
            .concat(this.columnsCenter)
            .concat(this.columnsRight))
    }
    getColsCenter() {
      return this.columnsCenter
    }
    getAllTrees() {
      return this.treeLeft && this.treeRight && this.treeCenter
        ? this.treeLeft.concat(this.treeCenter).concat(this.treeRight)
        : null
    }
    getTreeLeft() {
      return this.treeLeft
    }
    getTreeRight() {
      return this.treeRight
    }
    getTreeCenter() {
      return this.treeCenter
    }
    getAllCols() {
      return this.columns
    }
    isColDisplayed(e) {
      return this.getAllCols().indexOf(e) >= 0
    }
    getLeftColsForRow(e) {
      return this.columnModel.isColSpanActive()
        ? this.getColsForRow(e, this.columnsLeft)
        : this.columnsLeft
    }
    getRightColsForRow(e) {
      return this.columnModel.isColSpanActive()
        ? this.getColsForRow(e, this.columnsRight)
        : this.columnsRight
    }
    getColsForRow(e, t, i, s) {
      const n = []
      let r = null
      for (let o = 0; o < t.length; o++) {
        const a = t[o],
          l = t.length - o,
          c = Math.min(a.getColSpan(e), l),
          u = [a]
        if (c > 1) {
          const g = c - 1
          for (let f = 1; f <= g; f++) u.push(t[o + f])
          o += g
        }
        let h
        i
          ? ((h = !1),
            u.forEach((g) => {
              i(g) && (h = !0)
            }))
          : (h = !0),
          h && (n.length === 0 && r && s && s(a) && n.push(r), n.push(a)),
          (r = a)
      }
      return n
    }
    getBodyContainerWidth() {
      return this.bodyWidth
    }
    getContainerWidth(e) {
      switch (e) {
        case 'left':
          return this.leftWidth
        case 'right':
          return this.rightWidth
        default:
          return this.bodyWidth
      }
    }
    getCenterCols() {
      return this.columnsCenter
    }
    getLeftCols() {
      return this.columnsLeft
    }
    getRightCols() {
      return this.columnsRight
    }
    getColBefore(e) {
      const t = this.getAllCols(),
        i = t.indexOf(e)
      return i > 0 ? t[i - 1] : null
    }
    getGroupAtDirection(e, t) {
      const i = e.getProvidedColumnGroup().getLevel() + e.getPaddingLevel(),
        s = e.getDisplayedLeafColumns(),
        n = t === 'After' ? rt(s) : s[0],
        r = `getCol${t}`
      for (;;) {
        const o = this[r](n)
        if (!o) return null
        const a = this.getColGroupAtLevel(o, i)
        if (a !== e) return a
      }
    }
    getColGroupAtLevel(e, t) {
      let i = e.getParent(),
        s,
        n
      for (
        ;
        (s = i.getProvidedColumnGroup().getLevel()),
          (n = i.getPaddingLevel()),
          !(s + n <= t);

      )
        i = i.getParent()
      return i
    }
    isPinningLeft() {
      return this.columnsLeft.length > 0
    }
    isPinningRight() {
      return this.columnsRight.length > 0
    }
    updateColsAndGroupsMap() {
      this.colsAndGroupsMap = {}
      const e = (t) => {
        this.colsAndGroupsMap[t.getUniqueId()] = t
      }
      Rn(this.treeCenter, !1, e),
        Rn(this.treeLeft, !1, e),
        Rn(this.treeRight, !1, e)
    }
    isVisible(e) {
      return this.colsAndGroupsMap[e.getUniqueId()] === e
    }
    updateOpenClosedVisibilityInColumnGroups() {
      const e = this.getAllTrees()
      Rn(e, !1, (t) => {
        _t(t) && t.calculateDisplayedColumns()
      })
    }
    getFirstColumn() {
      const e = this.gos.get('enableRtl'),
        t = ['getLeftCols', 'getCenterCols', 'getRightCols']
      e && t.reverse()
      for (let i = 0; i < t.length; i++) {
        const s = this[t[i]]()
        if (s.length) return e ? rt(s) : s[0]
      }
      return null
    }
    getColumnGroup(e, t) {
      if (!e) return null
      if (_t(e)) return e
      const i = this.getAllTrees(),
        s = typeof t == 'number'
      let n = null
      return (
        Rn(i, !1, (r) => {
          if (_t(r)) {
            const o = r
            let a
            s
              ? (a = e === o.getGroupId() && t === o.getPartId())
              : (a = e === o.getGroupId()),
              a && (n = o)
          }
        }),
        n
      )
    }
    getColAfter(e) {
      const t = this.getAllCols(),
        i = t.indexOf(e)
      return i < t.length - 1 ? t[i + 1] : null
    }
    isBodyWidthDirty() {
      return this.bodyWidthDirty
    }
    setBodyWidthDirty() {
      this.bodyWidthDirty = !0
    }
    getColsLeftWidth() {
      return xs(this.columnsLeft)
    }
    getDisplayedColumnsRightWidth() {
      return xs(this.columnsRight)
    }
    isColAtEdge(e, t) {
      const i = this.getAllCols()
      if (!i.length) return !1
      const s = t === 'first'
      let n
      if (_t(e)) {
        const r = e.getDisplayedLeafColumns()
        if (!r.length) return !1
        n = s ? r[0] : rt(r)
      } else n = e
      return (s ? i[0] : rt(i)) === n
    }
    createGroups(e) {
      const {
          columns: t,
          idCreator: i,
          pinned: s,
          oldDisplayedGroups: n,
          isStandaloneStructure: r,
        } = e,
        o = this.mapOldGroupsById(n),
        a = []
      let l = t
      for (; l.length; ) {
        const c = l
        l = []
        let u = 0
        const h = (g) => {
          const f = u
          u = g
          const p = c[f],
            m = (_t(p) ? p.getProvidedColumnGroup() : p).getOriginalParent()
          if (m == null) {
            for (let w = f; w < g; w++) a.push(c[w])
            return
          }
          const C = this.createColGroup(m, i, o, s, r)
          for (let w = f; w < g; w++) C.addChild(c[w])
          l.push(C)
        }
        for (let g = 1; g < c.length; g++) {
          const f = c[g],
            v = (_t(f) ? f.getProvidedColumnGroup() : f).getOriginalParent(),
            m = c[u],
            w = (_t(m) ? m.getProvidedColumnGroup() : m).getOriginalParent()
          v !== w && h(g)
        }
        u < c.length && h(c.length)
      }
      return r || this.setupParentsIntoCols(a, null), a
    }
    createColGroup(e, t, i, s, n) {
      const r = e.getGroupId(),
        o = t.getInstanceIdForKey(r),
        a = Am(r, o)
      let l = i[a]
      return (
        l && l.getProvidedColumnGroup() !== e && (l = null),
        ue(l) ? l.reset() : ((l = new Om(e, r, o, s)), n || this.createBean(l)),
        l
      )
    }
    mapOldGroupsById(e) {
      const t = {},
        i = (s) => {
          s.forEach((n) => {
            if (_t(n)) {
              const r = n
              ;(t[n.getUniqueId()] = r), i(r.getChildren())
            }
          })
        }
      return e && i(e), t
    }
    setupParentsIntoCols(e, t) {
      e.forEach((i) => {
        if ((i.setParent(t), _t(i))) {
          const s = i
          this.setupParentsIntoCols(s.getChildren(), s)
        }
      })
    }
  }
function Rn(e, t, i) {
  if (e)
    for (let s = 0; s < e.length; s++) {
      const n = e[s]
      if (_t(n)) {
        const r = t ? n.getDisplayedChildren() : n.getChildren()
        Rn(r, t, i)
      }
      i(n)
    }
}
function lc(e) {
  const t = []
  return (
    Rn(e, !0, (i) => {
      cn(i) && t.push(i)
    }),
    t
  )
}
var km = [
    'columnEverythingChanged',
    'newColumnsLoaded',
    'columnPivotModeChanged',
    'pivotMaxColumnsExceeded',
    'columnRowGroupChanged',
    'expandOrCollapseAll',
    'columnPivotChanged',
    'gridColumnsChanged',
    'columnValueChanged',
    'columnMoved',
    'columnVisible',
    'columnPinned',
    'columnGroupOpened',
    'columnResized',
    'displayedColumnsChanged',
    'virtualColumnsChanged',
    'columnHeaderMouseOver',
    'columnHeaderMouseLeave',
    'columnHeaderClicked',
    'columnHeaderContextMenu',
    'asyncTransactionsFlushed',
    'rowGroupOpened',
    'rowDataUpdated',
    'pinnedRowDataChanged',
    'rangeSelectionChanged',
    'cellSelectionChanged',
    'chartCreated',
    'chartRangeSelectionChanged',
    'chartOptionsChanged',
    'chartDestroyed',
    'toolPanelVisibleChanged',
    'toolPanelSizeChanged',
    'modelUpdated',
    'cutStart',
    'cutEnd',
    'pasteStart',
    'pasteEnd',
    'fillStart',
    'fillEnd',
    'cellSelectionDeleteStart',
    'cellSelectionDeleteEnd',
    'rangeDeleteStart',
    'rangeDeleteEnd',
    'undoStarted',
    'undoEnded',
    'redoStarted',
    'redoEnded',
    'cellClicked',
    'cellDoubleClicked',
    'cellMouseDown',
    'cellContextMenu',
    'cellValueChanged',
    'cellEditRequest',
    'rowValueChanged',
    'headerFocused',
    'cellFocused',
    'rowSelected',
    'selectionChanged',
    'tooltipShow',
    'tooltipHide',
    'cellKeyDown',
    'cellMouseOver',
    'cellMouseOut',
    'filterChanged',
    'filterModified',
    'filterOpened',
    'advancedFilterBuilderVisibleChanged',
    'sortChanged',
    'virtualRowRemoved',
    'rowClicked',
    'rowDoubleClicked',
    'gridReady',
    'gridPreDestroyed',
    'gridSizeChanged',
    'viewportChanged',
    'firstDataRendered',
    'dragStarted',
    'dragStopped',
    'dragCancelled',
    'rowEditingStarted',
    'rowEditingStopped',
    'cellEditingStarted',
    'cellEditingStopped',
    'bodyScroll',
    'bodyScrollEnd',
    'paginationChanged',
    'componentStateChanged',
    'storeRefreshed',
    'stateUpdated',
    'columnMenuVisibleChanged',
    'contextMenuVisibleChanged',
    'rowDragEnter',
    'rowDragMove',
    'rowDragLeave',
    'rowDragEnd',
    'rowDragCancel',
  ],
  Kx = [
    'scrollbarWidthChanged',
    'keyShortcutChangedCellStart',
    'keyShortcutChangedCellEnd',
    'pinnedHeightChanged',
    'cellFocusCleared',
    'fullWidthRowFocused',
    'checkboxChanged',
    'heightScaleChanged',
    'suppressMovableColumns',
    'suppressMenuHide',
    'suppressFieldDotNotation',
    'columnPanelItemDragStart',
    'columnPanelItemDragEnd',
    'bodyHeightChanged',
    'columnContainerWidthChanged',
    'displayedColumnsWidthChanged',
    'scrollVisibilityChanged',
    'scrollGapChanged',
    'columnHoverChanged',
    'flashCells',
    'paginationPixelOffsetChanged',
    'displayedRowsChanged',
    'leftPinnedWidthChanged',
    'rightPinnedWidthChanged',
    'rowContainerHeightChanged',
    'headerHeightChanged',
    'columnGroupHeaderHeightChanged',
    'columnHeaderHeightChanged',
    'gridStylesChanged',
    'storeUpdated',
    'filterDestroyed',
    'rowDataUpdateStarted',
    'rowCountReady',
    'advancedFilterEnabledChanged',
    'dataTypesInferred',
    'fieldValueChanged',
    'fieldPickerValueSelected',
    'richSelectListRowSelected',
    'sideBarUpdated',
    'alignedGridScroll',
    'alignedGridColumn',
    'gridOptionsChanged',
    'chartTitleEdit',
    'recalculateRowBounds',
    'stickyTopOffsetChanged',
    'overlayExclusiveChanged',
  ],
  qx = [...km, ...Kx],
  Qx = {
    enableBrowserTooltips: !0,
    tooltipTrigger: !0,
    tooltipMouseTrack: !0,
    tooltipShowMode: !0,
    tooltipInteraction: !0,
    defaultColGroupDef: !0,
    suppressAutoSize: !0,
    skipHeaderOnAutoSize: !0,
    autoSizeStrategy: !0,
    components: !0,
    stopEditingWhenCellsLoseFocus: !0,
    undoRedoCellEditing: !0,
    undoRedoCellEditingLimit: !0,
    excelStyles: !0,
    cacheQuickFilter: !0,
    advancedFilterModel: !0,
    customChartThemes: !0,
    chartThemeOverrides: !0,
    chartToolPanelsDef: !0,
    loadingCellRendererSelector: !0,
    localeText: !0,
    keepDetailRows: !0,
    keepDetailRowsCount: !0,
    detailRowHeight: !0,
    detailRowAutoHeight: !0,
    tabIndex: !0,
    valueCache: !0,
    valueCacheNeverExpires: !0,
    enableCellExpressions: !0,
    suppressTouch: !0,
    suppressAsyncEvents: !0,
    suppressBrowserResizeObserver: !0,
    suppressPropertyNamesCheck: !0,
    debug: !0,
    dragAndDropImageComponent: !0,
    loadingOverlayComponent: !0,
    suppressLoadingOverlay: !0,
    noRowsOverlayComponent: !0,
    paginationPageSizeSelector: !0,
    paginateChildRows: !0,
    pivotPanelShow: !0,
    pivotSuppressAutoColumn: !0,
    suppressExpandablePivotGroups: !0,
    aggFuncs: !0,
    suppressAggFuncInHeader: !0,
    allowShowChangeAfterFilter: !0,
    ensureDomOrder: !0,
    enableRtl: !0,
    suppressColumnVirtualisation: !0,
    suppressMaxRenderedRowRestriction: !0,
    suppressRowVirtualisation: !0,
    rowDragText: !0,
    suppressGroupMaintainValueType: !0,
    groupLockGroupColumns: !0,
    rowGroupPanelSuppressSort: !0,
    suppressGroupRowsSticky: !0,
    rowModelType: !0,
    cacheOverflowSize: !0,
    infiniteInitialRowCount: !0,
    serverSideInitialRowCount: !0,
    suppressServerSideInfiniteScroll: !0,
    maxBlocksInCache: !0,
    maxConcurrentDatasourceRequests: !0,
    blockLoadDebounceMillis: !0,
    serverSideOnlyRefreshFilteredGroups: !0,
    serverSidePivotResultFieldSeparator: !0,
    viewportRowModelPageSize: !0,
    viewportRowModelBufferSize: !0,
    debounceVerticalScrollbar: !0,
    suppressAnimationFrame: !0,
    suppressPreventDefaultOnMouseWheel: !0,
    scrollbarWidth: !0,
    icons: !0,
    suppressRowTransform: !0,
    gridId: !0,
    enableGroupEdit: !0,
    initialState: !0,
    processUnpinnedColumns: !0,
    createChartContainer: !0,
    getLocaleText: !0,
    getRowId: !0,
    reactiveCustomComponents: !0,
    columnMenu: !0,
    suppressSetFilterByDefault: !0,
  },
  gi = class {}
gi.STRING_PROPERTIES = [
  'overlayLoadingTemplate',
  'overlayNoRowsTemplate',
  'gridId',
  'quickFilterText',
  'rowModelType',
  'editType',
  'domLayout',
  'clipboardDelimiter',
  'rowGroupPanelShow',
  'multiSortKey',
  'pivotColumnGroupTotals',
  'pivotRowTotals',
  'pivotPanelShow',
  'fillHandleDirection',
  'groupDisplayType',
  'treeDataDisplayType',
  'colResizeDefault',
  'tooltipTrigger',
  'serverSidePivotResultFieldSeparator',
  'columnMenu',
  'tooltipShowMode',
  'grandTotalRow',
]
gi.OBJECT_PROPERTIES = [
  'components',
  'rowStyle',
  'context',
  'autoGroupColumnDef',
  'localeText',
  'icons',
  'datasource',
  'dragAndDropImageComponentParams',
  'serverSideDatasource',
  'viewportDatasource',
  'groupRowRendererParams',
  'aggFuncs',
  'fullWidthCellRendererParams',
  'defaultColGroupDef',
  'defaultColDef',
  'defaultCsvExportParams',
  'defaultExcelExportParams',
  'columnTypes',
  'rowClassRules',
  'detailCellRendererParams',
  'loadingCellRendererParams',
  'loadingOverlayComponentParams',
  'noRowsOverlayComponentParams',
  'popupParent',
  'statusBar',
  'sideBar',
  'theme',
  'chartThemeOverrides',
  'customChartThemes',
  'chartToolPanelsDef',
  'dataTypeDefinitions',
  'advancedFilterModel',
  'advancedFilterParent',
  'advancedFilterBuilderParams',
  'initialState',
  'autoSizeStrategy',
  'cellSelection',
  'selectionColumnDef',
]
gi.ARRAY_PROPERTIES = [
  'sortingOrder',
  'alignedGrids',
  'rowData',
  'columnDefs',
  'excelStyles',
  'pinnedTopRowData',
  'pinnedBottomRowData',
  'chartThemes',
  'rowClass',
  'paginationPageSizeSelector',
]
gi.NUMBER_PROPERTIES = [
  'rowHeight',
  'detailRowHeight',
  'rowBuffer',
  'headerHeight',
  'groupHeaderHeight',
  'groupLockGroupColumns',
  'floatingFiltersHeight',
  'pivotHeaderHeight',
  'pivotGroupHeaderHeight',
  'groupDefaultExpanded',
  'pivotDefaultExpanded',
  'viewportRowModelPageSize',
  'viewportRowModelBufferSize',
  'autoSizePadding',
  'maxBlocksInCache',
  'maxConcurrentDatasourceRequests',
  'tooltipShowDelay',
  'tooltipHideDelay',
  'cacheOverflowSize',
  'paginationPageSize',
  'cacheBlockSize',
  'infiniteInitialRowCount',
  'serverSideInitialRowCount',
  'scrollbarWidth',
  'asyncTransactionWaitMillis',
  'blockLoadDebounceMillis',
  'keepDetailRowsCount',
  'undoRedoCellEditingLimit',
  'cellFlashDelay',
  'cellFadeDelay',
  'cellFlashDuration',
  'cellFadeDuration',
  'tabIndex',
  'pivotMaxGeneratedColumns',
]
gi.BOOLEAN_PROPERTIES = [
  'suppressMakeColumnVisibleAfterUnGroup',
  'suppressRowClickSelection',
  'suppressCellFocus',
  'suppressHeaderFocus',
  'suppressHorizontalScroll',
  'groupSelectsChildren',
  'alwaysShowHorizontalScroll',
  'alwaysShowVerticalScroll',
  'debug',
  'enableBrowserTooltips',
  'enableCellExpressions',
  'groupIncludeTotalFooter',
  'groupSuppressBlankHeader',
  'suppressMenuHide',
  'suppressRowDeselection',
  'unSortIcon',
  'suppressMultiSort',
  'alwaysMultiSort',
  'singleClickEdit',
  'suppressLoadingOverlay',
  'suppressNoRowsOverlay',
  'suppressAutoSize',
  'skipHeaderOnAutoSize',
  'suppressColumnMoveAnimation',
  'suppressMoveWhenColumnDragging',
  'suppressMovableColumns',
  'suppressFieldDotNotation',
  'enableRangeSelection',
  'enableRangeHandle',
  'enableFillHandle',
  'suppressClearOnFillReduction',
  'deltaSort',
  'suppressTouch',
  'suppressAsyncEvents',
  'allowContextMenuWithControlKey',
  'suppressContextMenu',
  'enableCellChangeFlash',
  'suppressDragLeaveHidesColumns',
  'suppressRowGroupHidesColumns',
  'suppressMiddleClickScrolls',
  'suppressPreventDefaultOnMouseWheel',
  'suppressCopyRowsToClipboard',
  'copyHeadersToClipboard',
  'copyGroupHeadersToClipboard',
  'pivotMode',
  'suppressAggFuncInHeader',
  'suppressColumnVirtualisation',
  'alwaysAggregateAtRootLevel',
  'suppressFocusAfterRefresh',
  'functionsReadOnly',
  'animateRows',
  'groupSelectsFiltered',
  'groupRemoveSingleChildren',
  'groupRemoveLowestSingleChildren',
  'enableRtl',
  'suppressClickEdit',
  'rowDragEntireRow',
  'rowDragManaged',
  'suppressRowDrag',
  'suppressMoveWhenRowDragging',
  'rowDragMultiRow',
  'enableGroupEdit',
  'embedFullWidthRows',
  'suppressPaginationPanel',
  'groupHideOpenParents',
  'groupAllowUnbalanced',
  'pagination',
  'paginationAutoPageSize',
  'suppressScrollOnNewData',
  'suppressScrollWhenPopupsAreOpen',
  'purgeClosedRowNodes',
  'cacheQuickFilter',
  'includeHiddenColumnsInQuickFilter',
  'ensureDomOrder',
  'accentedSort',
  'suppressChangeDetection',
  'valueCache',
  'valueCacheNeverExpires',
  'aggregateOnlyChangedColumns',
  'suppressAnimationFrame',
  'suppressExcelExport',
  'suppressCsvExport',
  'includeHiddenColumnsInAdvancedFilter',
  'suppressMultiRangeSelection',
  'enterNavigatesVerticallyAfterEdit',
  'enterNavigatesVertically',
  'suppressPropertyNamesCheck',
  'rowMultiSelectWithClick',
  'suppressRowHoverHighlight',
  'suppressRowTransform',
  'suppressClipboardPaste',
  'suppressLastEmptyLineOnPaste',
  'enableCharts',
  'suppressMaintainUnsortedOrder',
  'enableCellTextSelection',
  'suppressBrowserResizeObserver',
  'suppressMaxRenderedRowRestriction',
  'excludeChildrenWhenTreeDataFiltering',
  'tooltipMouseTrack',
  'tooltipInteraction',
  'keepDetailRows',
  'paginateChildRows',
  'preventDefaultOnContextMenu',
  'undoRedoCellEditing',
  'allowDragFromColumnsToolPanel',
  'pivotSuppressAutoColumn',
  'suppressExpandablePivotGroups',
  'debounceVerticalScrollbar',
  'detailRowAutoHeight',
  'serverSideSortAllLevels',
  'serverSideEnableClientSideSort',
  'serverSideOnlyRefreshFilteredGroups',
  'serverSideSortOnServer',
  'serverSideFilterOnServer',
  'suppressAggFilteredOnly',
  'showOpenedGroup',
  'suppressClipboardApi',
  'suppressModelUpdateAfterUpdateTransaction',
  'stopEditingWhenCellsLoseFocus',
  'groupMaintainOrder',
  'columnHoverHighlight',
  'readOnlyEdit',
  'suppressRowVirtualisation',
  'enableCellEditingOnBackspace',
  'resetRowDataOnUpdate',
  'removePivotHeaderRowWhenSingleValueColumn',
  'suppressCopySingleCellRanges',
  'suppressGroupRowsSticky',
  'suppressCutToClipboard',
  'suppressServerSideInfiniteScroll',
  'rowGroupPanelSuppressSort',
  'allowShowChangeAfterFilter',
  'enableAdvancedFilter',
  'masterDetail',
  'treeData',
  'suppressGroupMaintainValueType',
  'reactiveCustomComponents',
  'applyQuickFilterBeforePivotOrAgg',
  'suppressServerSideFullWidthLoadingRow',
  'suppressAdvancedFilterEval',
  'loading',
  'maintainColumnOrder',
  'enableStrictPivotColumnOrder',
  'suppressSetFilterByDefault',
]
gi.OTHER_PROPERTIES = [
  'suppressStickyTotalRow',
  'loadThemeGoogleFonts',
  'rowSelection',
]
gi.FUNCTION_PROPERTIES = [
  'doesExternalFilterPass',
  'processPivotResultColDef',
  'processPivotResultColGroupDef',
  'getBusinessKeyForNode',
  'isRowSelectable',
  'rowDragText',
  'groupRowRenderer',
  'dragAndDropImageComponent',
  'fullWidthCellRenderer',
  'loadingCellRenderer',
  'loadingOverlayComponent',
  'noRowsOverlayComponent',
  'detailCellRenderer',
  'quickFilterParser',
  'quickFilterMatcher',
  'getLocaleText',
  'isExternalFilterPresent',
  'getRowHeight',
  'getRowClass',
  'getRowStyle',
  'getContextMenuItems',
  'getMainMenuItems',
  'processRowPostCreate',
  'processCellForClipboard',
  'getGroupRowAgg',
  'isFullWidthRow',
  'sendToClipboard',
  'focusGridInnerElement',
  'navigateToNextHeader',
  'tabToNextHeader',
  'navigateToNextCell',
  'tabToNextCell',
  'processCellFromClipboard',
  'getDocument',
  'postProcessPopup',
  'getChildCount',
  'getDataPath',
  'isRowMaster',
  'postSortRows',
  'processHeaderForClipboard',
  'processUnpinnedColumns',
  'processGroupHeaderForClipboard',
  'paginationNumberFormatter',
  'processDataFromClipboard',
  'getServerSideGroupKey',
  'isServerSideGroup',
  'createChartContainer',
  'getChartToolbarItems',
  'fillOperation',
  'isApplyServerSideTransaction',
  'getServerSideGroupLevelParams',
  'isServerSideGroupOpenByDefault',
  'isGroupOpenByDefault',
  'initialGroupOrderComparator',
  'groupIncludeFooter',
  'loadingCellRendererSelector',
  'getRowId',
  'groupAggFiltering',
  'chartMenuItems',
  'groupTotalRow',
]
gi.ALL_PROPERTIES = [
  ...gi.ARRAY_PROPERTIES,
  ...gi.OBJECT_PROPERTIES,
  ...gi.STRING_PROPERTIES,
  ...gi.NUMBER_PROPERTIES,
  ...gi.FUNCTION_PROPERTIES,
  ...gi.BOOLEAN_PROPERTIES,
  ...gi.OTHER_PROPERTIES,
]
var Co = gi,
  Wi = class {
    static getCallbackForEvent(t) {
      return !t || t.length < 2 ? t : 'on' + t[0].toUpperCase() + t.substring(1)
    }
  }
Wi.VUE_OMITTED_PROPERTY = 'AG-VUE-OMITTED-PROPERTY'
Wi.PUBLIC_EVENTS = km
Wi.EVENT_CALLBACKS = qx.map((e) => Wi.getCallbackForEvent(e))
Wi.BOOLEAN_PROPERTIES = Co.BOOLEAN_PROPERTIES
Wi.ALL_PROPERTIES = Co.ALL_PROPERTIES
Wi.ALL_PROPERTIES_AND_CALLBACKS = [...Wi.ALL_PROPERTIES, ...Wi.EVENT_CALLBACKS]
Wi.ALL_PROPERTIES_AND_CALLBACKS_SET = new Set(Wi.ALL_PROPERTIES_AND_CALLBACKS)
var So = Wi
function Xx(e, t) {
  typeof e != 'object' && (e = {})
  const i = { ...e }
  return (
    So.ALL_PROPERTIES_AND_CALLBACKS.forEach((n) => {
      const r = t[n]
      typeof r < 'u' && r !== So.VUE_OMITTED_PROPERTY && (i[n] = r)
    }),
    i
  )
}
function Jx(e, t) {
  if (!e) return
  const i = {}
  let s = !1
  if (
    (Object.keys(e)
      .filter((o) => So.ALL_PROPERTIES_AND_CALLBACKS_SET.has(o))
      .forEach((o) => {
        ;(i[o] = e[o]), (s = !0)
      }),
    !s)
  )
    return
  const n = { type: 'gridOptionsChanged', options: i }
  t.dispatchEvent(n)
  const r = { type: 'componentStateChanged' }
  Qi(i, (o, a) => {
    r[o] = a
  }),
    t.dispatchEvent(r)
}
var Ir = class extends X {}
function ko(e, t, i) {
  return i && e.addDestroyFunc(() => t.destroyBean(i)), i ?? e
}
var Ho = class {
  constructor(e) {
    ;(this.cssClassStates = {}), (this.getGui = e)
  }
  addCssClass(e) {
    const t = (e || '').split(' ')
    if (t.length > 1) {
      t.forEach((s) => this.addCssClass(s))
      return
    }
    if (this.cssClassStates[e] !== !0 && e.length) {
      const s = this.getGui()
      s && s.classList.add(e), (this.cssClassStates[e] = !0)
    }
  }
  removeCssClass(e) {
    const t = (e || '').split(' ')
    if (t.length > 1) {
      t.forEach((s) => this.removeCssClass(s))
      return
    }
    if (this.cssClassStates[e] !== !1 && e.length) {
      const s = this.getGui()
      s && s.classList.remove(e), (this.cssClassStates[e] = !1)
    }
  }
  containsCssClass(e) {
    const t = this.getGui()
    return t ? t.classList.contains(e) : !1
  }
  addOrRemoveCssClass(e, t) {
    if (!e) return
    if (e.indexOf(' ') >= 0) {
      const s = (e || '').split(' ')
      if (s.length > 1) {
        s.forEach((n) => this.addOrRemoveCssClass(n, t))
        return
      }
    }
    if (this.cssClassStates[e] !== t && e.length) {
      const s = this.getGui()
      s && s.classList.toggle(e, t), (this.cssClassStates[e] = t)
    }
  }
}
function js(e, t, i) {
  i == null || (typeof i == 'string' && i == '') ? Hm(e, t) : vs(e, t, i)
}
function vs(e, t, i) {
  e.setAttribute(Nm(t), i.toString())
}
function Hm(e, t) {
  e.removeAttribute(Nm(t))
}
function Nm(e) {
  return `aria-${e}`
}
function es(e, t) {
  t ? e.setAttribute('role', t) : e.removeAttribute('role')
}
function Zx(e) {
  let t
  return (
    e === 'asc'
      ? (t = 'ascending')
      : e === 'desc'
        ? (t = 'descending')
        : e === 'mixed'
          ? (t = 'other')
          : (t = 'none'),
    t
  )
}
function eD(e) {
  return e.getAttribute('aria-label')
}
function mr(e, t) {
  js(e, 'label', t)
}
function wo(e, t) {
  js(e, 'labelledby', t)
}
function Gm(e, t) {
  js(e, 'live', t)
}
function tD(e, t) {
  js(e, 'atomic', t)
}
function iD(e, t) {
  js(e, 'relevant', t)
}
function sD(e, t) {
  js(e, 'disabled', t)
}
function Bm(e, t) {
  js(e, 'hidden', t)
}
function ka(e, t) {
  vs(e, 'expanded', t)
}
function nD(e, t) {
  vs(e, 'setsize', t)
}
function rD(e, t) {
  vs(e, 'posinset', t)
}
function oD(e, t) {
  vs(e, 'rowcount', t)
}
function aD(e, t) {
  vs(e, 'rowindex', t)
}
function lD(e, t) {
  vs(e, 'colcount', t)
}
function Vm(e, t) {
  vs(e, 'colindex', t)
}
function cD(e, t) {
  vs(e, 'colspan', t)
}
function uD(e, t) {
  vs(e, 'sort', t)
}
function dD(e) {
  Hm(e, 'sort')
}
function Ha(e, t) {
  js(e, 'selected', t)
}
function hD(e, t) {
  js(e, 'controls', t.id), wo(t, e.id)
}
function rd(e, t) {
  return t === void 0
    ? e('ariaIndeterminate', 'indeterminate')
    : t === !0
      ? e('ariaChecked', 'checked')
      : e('ariaUnchecked', 'unchecked')
}
var cc, Jo, uc, dc, hc, gc, Xc, Jc, fc
function gs() {
  return (
    cc === void 0 &&
      (cc = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)),
    cc
  )
}
function _m() {
  if (Jo === void 0)
    if (gs()) {
      const e = navigator.userAgent.match(/version\/(\d+)/i)
      e && (Jo = e[1] != null ? parseFloat(e[1]) : 0)
    } else Jo = 0
  return Jo
}
function od() {
  if (uc === void 0) {
    const e = window
    uc =
      (!!e.chrome && (!!e.chrome.webstore || !!e.chrome.runtime)) ||
      (/Chrome/.test(navigator.userAgent) &&
        /Google Inc/.test(navigator.vendor))
  }
  return uc
}
function ad() {
  return dc === void 0 && (dc = /(firefox)/i.test(navigator.userAgent)), dc
}
function Wm() {
  return (
    hc === void 0 && (hc = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)),
    hc
  )
}
function fn() {
  return (
    gc === void 0 &&
      (gc =
        /iPad|iPhone|iPod/.test(navigator.platform) ||
        (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)),
    gc
  )
}
function Cg() {
  return !gs() || _m() >= 15
}
function Zc(e) {
  if (!e) return null
  const t = e.tabIndex,
    i = e.getAttribute('tabIndex')
  return t === -1 && (i === null || (i === '' && !ad())) ? null : t.toString()
}
function gD() {
  if (fc !== void 0) return fc
  if (!document.body) return -1
  let e = 1e6
  const t = ad() ? 6e6 : 1e9,
    i = document.createElement('div')
  for (document.body.appendChild(i); ; ) {
    const s = e * 2
    if (((i.style.height = s + 'px'), s > t || i.clientHeight !== s)) break
    e = s
  }
  return document.body.removeChild(i), (fc = e), e
}
function fD() {
  var e, t
  return (
    ((e = document.body) == null ? void 0 : e.clientWidth) ??
    (window.innerHeight ||
      ((t = document.documentElement) == null ? void 0 : t.clientWidth) ||
      -1)
  )
}
function pD() {
  var e, t
  return (
    ((e = document.body) == null ? void 0 : e.clientHeight) ??
    (window.innerHeight ||
      ((t = document.documentElement) == null ? void 0 : t.clientHeight) ||
      -1)
  )
}
function mD() {
  return Jc == null && $m(), Jc
}
function $m() {
  const e = document.body,
    t = document.createElement('div')
  ;(t.style.width = t.style.height = '100px'),
    (t.style.opacity = '0'),
    (t.style.overflow = 'scroll'),
    (t.style.msOverflowStyle = 'scrollbar'),
    (t.style.position = 'absolute'),
    e.appendChild(t)
  let i = t.offsetWidth - t.clientWidth
  i === 0 && t.clientWidth === 0 && (i = null),
    t.parentNode && t.parentNode.removeChild(t),
    i != null && ((Jc = i), (Xc = i === 0))
}
function zm() {
  return Xc == null && $m(), Xc
}
var Zo,
  vD = '[tabindex], input, select, button, textarea, [href]',
  Um = '[disabled], .ag-disabled:not(.ag-button), .ag-disabled *'
function ld(e) {
  const t = Element.prototype.matches || Element.prototype.msMatchesSelector,
    s = t.call(e, 'input, select, button, textarea'),
    n = t.call(e, Um),
    r = fs(e)
  return s && !n && r
}
function Ot(e, t, i = {}) {
  const { skipAriaHidden: s } = i
  e.classList.toggle('ag-hidden', !t), s || Bm(e, !t)
}
function CD(e, t, i = {}) {
  const { skipAriaHidden: s } = i
  e.classList.toggle('ag-invisible', !t), s || Bm(e, !t)
}
function yo(e, t) {
  const i = 'disabled',
    s = t ? (n) => n.setAttribute(i, '') : (n) => n.removeAttribute(i)
  s(e), qm(e.querySelectorAll('input'), (n) => s(n))
}
function ar(e, t, i) {
  let s = 0
  for (; e; ) {
    if (e.classList.contains(t)) return !0
    if (((e = e.parentElement), typeof i == 'number')) {
      if (++s > i) break
    } else if (e === i) break
  }
  return !1
}
function Un(e) {
  const {
    height: t,
    width: i,
    borderTopWidth: s,
    borderRightWidth: n,
    borderBottomWidth: r,
    borderLeftWidth: o,
    paddingTop: a,
    paddingRight: l,
    paddingBottom: c,
    paddingLeft: u,
    marginTop: h,
    marginRight: g,
    marginBottom: f,
    marginLeft: p,
    boxSizing: v,
  } = window.getComputedStyle(e)
  return {
    height: parseFloat(t || '0'),
    width: parseFloat(i || '0'),
    borderTopWidth: parseFloat(s || '0'),
    borderRightWidth: parseFloat(n || '0'),
    borderBottomWidth: parseFloat(r || '0'),
    borderLeftWidth: parseFloat(o || '0'),
    paddingTop: parseFloat(a || '0'),
    paddingRight: parseFloat(l || '0'),
    paddingBottom: parseFloat(c || '0'),
    paddingLeft: parseFloat(u || '0'),
    marginTop: parseFloat(h || '0'),
    marginRight: parseFloat(g || '0'),
    marginBottom: parseFloat(f || '0'),
    marginLeft: parseFloat(p || '0'),
    boxSizing: v,
  }
}
function cd(e) {
  const t = Un(e)
  return t.boxSizing === 'border-box'
    ? t.height - t.paddingTop - t.paddingBottom
    : t.height
}
function No(e) {
  const t = Un(e)
  return t.boxSizing === 'border-box'
    ? t.width - t.paddingLeft - t.paddingRight
    : t.width
}
function jm(e) {
  const { height: t, marginBottom: i, marginTop: s } = Un(e)
  return Math.floor(t + i + s)
}
function Na(e) {
  const { width: t, marginLeft: i, marginRight: s } = Un(e)
  return Math.floor(t + i + s)
}
function Ym(e) {
  const t = e.getBoundingClientRect(),
    {
      borderTopWidth: i,
      borderLeftWidth: s,
      borderRightWidth: n,
      borderBottomWidth: r,
    } = Un(e)
  return {
    top: t.top + (i || 0),
    left: t.left + (s || 0),
    right: t.right + (n || 0),
    bottom: t.bottom + (r || 0),
  }
}
function Ga() {
  if (typeof Zo == 'boolean') return Zo
  const e = document.createElement('div')
  return (
    (e.style.direction = 'rtl'),
    (e.style.width = '1px'),
    (e.style.height = '1px'),
    (e.style.position = 'fixed'),
    (e.style.top = '0px'),
    (e.style.overflow = 'hidden'),
    (e.dir = 'rtl'),
    (e.innerHTML = `<div style="width: 2px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`),
    document.body.appendChild(e),
    (e.scrollLeft = 1),
    (Zo = Math.floor(e.scrollLeft) === 0),
    document.body.removeChild(e),
    Zo
  )
}
function Ba(e, t) {
  let i = e.scrollLeft
  return (
    t &&
      ((i = Math.abs(i)),
      od() &&
        !Ga() &&
        (i = e.scrollWidth - e.getBoundingClientRect().width - i)),
    i
  )
}
function Va(e, t, i) {
  i &&
    (Ga()
      ? (t *= -1)
      : (gs() || od()) &&
        (t = e.scrollWidth - e.getBoundingClientRect().width - t)),
    (e.scrollLeft = t)
}
function Ni(e) {
  for (; e && e.firstChild; ) e.removeChild(e.firstChild)
}
function Bn(e) {
  e && e.parentNode && e.parentNode.removeChild(e)
}
function Km(e) {
  return !!e.offsetParent
}
function fs(e) {
  const t = e
  return t.checkVisibility
    ? t.checkVisibility({ checkVisibilityCSS: !0 })
    : !(!Km(e) || window.getComputedStyle(e).visibility !== 'visible')
}
function bo(e) {
  const t = document.createElement('div')
  return (t.innerHTML = (e || '').trim()), t.firstChild
}
function SD(e) {
  return e.clientWidth < e.scrollWidth
}
function wD(e) {
  return e.clientHeight < e.scrollHeight
}
function _a(e, t) {
  t === 'flex'
    ? (e.style.removeProperty('width'),
      e.style.removeProperty('minWidth'),
      e.style.removeProperty('maxWidth'),
      (e.style.flex = '1 1 auto'))
    : Zi(e, t)
}
function Zi(e, t) {
  ;(t = ud(t)),
    (e.style.width = t.toString()),
    (e.style.maxWidth = t.toString()),
    (e.style.minWidth = t.toString())
}
function oo(e, t) {
  ;(t = ud(t)),
    (e.style.height = t.toString()),
    (e.style.maxHeight = t.toString()),
    (e.style.minHeight = t.toString())
}
function ud(e) {
  return typeof e == 'number' ? `${e}px` : e
}
function dd(e) {
  return e instanceof Node || e instanceof HTMLElement
}
function yD(e) {
  if (e == null) return []
  const t = []
  return qm(e, (i) => t.push(i)), t
}
function bD(e, t) {
  if (e)
    for (let i = 0; i < e.length; i++) {
      const s = e[i]
      t(s.name, s.value)
    }
}
function $i(e, t, i) {
  i == null || i === '' ? e.removeAttribute(t) : e.setAttribute(t, i.toString())
}
function qm(e, t) {
  if (e != null) for (let i = 0; i < e.length; i++) t(e[i])
}
var vr = class {
    constructor(e = 0, t = 1) {
      ;(this.nextValue = e), (this.step = t)
    }
    next() {
      const e = this.nextValue
      return (this.nextValue += this.step), e
    }
    peek() {
      return this.nextValue
    }
    skip(e) {
      this.nextValue += e
    }
  },
  RD = 1e3,
  FD = 1e3,
  Sg = 100,
  Qm = class Sn extends X {
    constructor(t, i, s, n) {
      super(),
        (this.parentComp = t),
        (this.tooltipShowDelayOverride = i),
        (this.tooltipHideDelayOverride = s),
        (this.shouldDisplayTooltip = n),
        (this.interactionEnabled = !1),
        (this.isInteractingWithTooltip = !1),
        (this.state = 0),
        (this.tooltipInstanceCount = 0),
        (this.tooltipMouseTrack = !1)
    }
    wireBeans(t) {
      ;(this.popupService = t.popupService),
        (this.userComponentFactory = t.userComponentFactory)
    }
    postConstruct() {
      this.gos.get('tooltipInteraction') && (this.interactionEnabled = !0),
        (this.tooltipTrigger = this.getTooltipTrigger()),
        (this.tooltipMouseTrack = this.gos.get('tooltipMouseTrack'))
      const t = this.parentComp.getGui()
      this.tooltipTrigger === 0 &&
        this.addManagedListeners(t, {
          mouseenter: this.onMouseEnter.bind(this),
          mouseleave: this.onMouseLeave.bind(this),
        }),
        this.tooltipTrigger === 1 &&
          this.addManagedListeners(t, {
            focusin: this.onFocusIn.bind(this),
            focusout: this.onFocusOut.bind(this),
          }),
        this.addManagedListeners(t, { mousemove: this.onMouseMove.bind(this) }),
        this.interactionEnabled ||
          this.addManagedListeners(t, {
            mousedown: this.onMouseDown.bind(this),
            keydown: this.onKeyDown.bind(this),
          })
    }
    getGridOptionsTooltipDelay(t) {
      const i = this.gos.get(t)
      return i < 0 && te(`${t} should not be lower than 0`), Math.max(200, i)
    }
    getTooltipDelay(t) {
      return t === 'show'
        ? (this.tooltipShowDelayOverride ??
            this.getGridOptionsTooltipDelay('tooltipShowDelay'))
        : (this.tooltipHideDelayOverride ??
            this.getGridOptionsTooltipDelay('tooltipHideDelay'))
    }
    destroy() {
      this.setToDoNothing(), super.destroy()
    }
    getTooltipTrigger() {
      const t = this.gos.get('tooltipTrigger')
      return !t || t === 'hover' ? 0 : 1
    }
    onMouseEnter(t) {
      this.interactionEnabled &&
        this.interactiveTooltipTimeoutId &&
        (this.unlockService(), this.startHideTimeout()),
        !fn() &&
          (Sn.isLocked
            ? (this.showTooltipTimeoutId = window.setTimeout(() => {
                this.prepareToShowTooltip(t)
              }, Sg))
            : this.prepareToShowTooltip(t))
    }
    onMouseMove(t) {
      this.lastMouseEvent && (this.lastMouseEvent = t),
        this.tooltipMouseTrack &&
          this.state === 2 &&
          this.tooltipComp &&
          this.positionTooltip()
    }
    onMouseDown() {
      this.setToDoNothing()
    }
    onMouseLeave() {
      this.interactionEnabled ? this.lockService() : this.setToDoNothing()
    }
    onFocusIn() {
      this.prepareToShowTooltip()
    }
    onFocusOut(t) {
      var r
      const i = t.relatedTarget,
        s = this.parentComp.getGui(),
        n = (r = this.tooltipComp) == null ? void 0 : r.getGui()
      this.isInteractingWithTooltip ||
        s.contains(i) ||
        (this.interactionEnabled && n != null && n.contains(i)) ||
        this.setToDoNothing()
    }
    onKeyDown() {
      this.isInteractingWithTooltip && (this.isInteractingWithTooltip = !1),
        this.setToDoNothing()
    }
    prepareToShowTooltip(t) {
      if (this.state != 0 || Sn.isLocked) return
      let i = 0
      t &&
        (i = this.isLastTooltipHiddenRecently()
          ? 200
          : this.getTooltipDelay('show')),
        (this.lastMouseEvent = t || null),
        (this.showTooltipTimeoutId = window.setTimeout(
          this.showTooltip.bind(this),
          i,
        )),
        (this.state = 1)
    }
    isLastTooltipHiddenRecently() {
      const t = new Date().getTime(),
        i = Sn.lastTooltipHideTime
      return t - i < RD
    }
    setToDoNothing(t) {
      !t && this.state === 2 && this.hideTooltip(),
        this.onBodyScrollEventCallback &&
          (this.onBodyScrollEventCallback(),
          (this.onBodyScrollEventCallback = void 0)),
        this.onColumnMovedEventCallback &&
          (this.onColumnMovedEventCallback(),
          (this.onColumnMovedEventCallback = void 0)),
        this.onDocumentKeyDownCallback &&
          (this.onDocumentKeyDownCallback(),
          (this.onDocumentKeyDownCallback = void 0)),
        this.clearTimeouts(),
        (this.state = 0),
        (this.lastMouseEvent = null)
    }
    showTooltip() {
      const t = { ...this.parentComp.getTooltipParams() }
      if (
        !ue(t.value) ||
        (this.shouldDisplayTooltip && !this.shouldDisplayTooltip())
      ) {
        this.setToDoNothing()
        return
      }
      ;(this.state = 2), this.tooltipInstanceCount++
      const i = this.newTooltipComponentCallback.bind(
        this,
        this.tooltipInstanceCount,
      )
      this.userComponentFactory
        .getTooltipCompDetails(t)
        .newAgStackInstance()
        .then(i)
    }
    hideTooltip(t) {
      ;(!t && this.isInteractingWithTooltip) ||
        (this.tooltipComp &&
          (this.destroyTooltipComp(),
          (Sn.lastTooltipHideTime = new Date().getTime())),
        this.eventService.dispatchEvent({
          type: 'tooltipHide',
          parentGui: this.parentComp.getGui(),
        }),
        t && (this.isInteractingWithTooltip = !1),
        this.setToDoNothing(!0))
    }
    newTooltipComponentCallback(t, i) {
      if (this.state !== 2 || this.tooltipInstanceCount !== t) {
        this.destroyBean(i)
        return
      }
      const n = i.getGui()
      ;(this.tooltipComp = i),
        n.classList.contains('ag-tooltip') ||
          n.classList.add('ag-tooltip-custom'),
        this.tooltipTrigger === 0 && n.classList.add('ag-tooltip-animate'),
        this.interactionEnabled && n.classList.add('ag-tooltip-interactive')
      const r = this.localeService.getLocaleTextFunc(),
        o = this.popupService.addPopup({
          eChild: n,
          ariaLabel: r('ariaLabelTooltip', 'Tooltip'),
        })
      if (
        (o && (this.tooltipPopupDestroyFunc = o.hideFunc),
        this.positionTooltip(),
        this.tooltipTrigger === 1)
      ) {
        const a = () => this.setToDoNothing()
        ;[this.onBodyScrollEventCallback, this.onColumnMovedEventCallback] =
          this.addManagedEventListeners({ bodyScroll: a, columnMoved: a })
      }
      this.interactionEnabled &&
        (([this.tooltipMouseEnterListener, this.tooltipMouseLeaveListener] =
          this.addManagedElementListeners(n, {
            mouseenter: this.onTooltipMouseEnter.bind(this),
            mouseleave: this.onTooltipMouseLeave.bind(this),
          })),
        ([this.onDocumentKeyDownCallback] = this.addManagedElementListeners(
          Gt(this.gos),
          {
            keydown: (a) => {
              n.contains(a == null ? void 0 : a.target) || this.onKeyDown()
            },
          },
        )),
        this.tooltipTrigger === 1 &&
          ([this.tooltipFocusInListener, this.tooltipFocusOutListener] =
            this.addManagedElementListeners(n, {
              focusin: this.onTooltipFocusIn.bind(this),
              focusout: this.onTooltipFocusOut.bind(this),
            }))),
        this.eventService.dispatchEvent({
          type: 'tooltipShow',
          tooltipGui: n,
          parentGui: this.parentComp.getGui(),
        }),
        this.startHideTimeout()
    }
    onTooltipMouseEnter() {
      ;(this.isInteractingWithTooltip = !0), this.unlockService()
    }
    onTooltipMouseLeave() {
      this.isTooltipFocused() ||
        ((this.isInteractingWithTooltip = !1), this.lockService())
    }
    onTooltipFocusIn() {
      this.isInteractingWithTooltip = !0
    }
    isTooltipFocused() {
      var s
      const t = (s = this.tooltipComp) == null ? void 0 : s.getGui(),
        i = Lt(this.gos)
      return !!t && t.contains(i)
    }
    onTooltipFocusOut(t) {
      const i = this.parentComp.getGui()
      this.isTooltipFocused() ||
        ((this.isInteractingWithTooltip = !1),
        i.contains(t.relatedTarget)
          ? this.startHideTimeout()
          : this.hideTooltip())
    }
    positionTooltip() {
      const t = {
        type: 'tooltip',
        ePopup: this.tooltipComp.getGui(),
        nudgeY: 18,
        skipObserver: this.tooltipMouseTrack,
      }
      this.lastMouseEvent
        ? this.popupService.positionPopupUnderMouseEvent({
            ...t,
            mouseEvent: this.lastMouseEvent,
          })
        : this.popupService.positionPopupByComponent({
            ...t,
            eventSource: this.parentComp.getGui(),
            position: 'under',
            keepWithinBounds: !0,
            nudgeY: 5,
          })
    }
    destroyTooltipComp() {
      this.tooltipComp.getGui().classList.add('ag-tooltip-hiding')
      const t = this.tooltipPopupDestroyFunc,
        i = this.tooltipComp,
        s = this.tooltipTrigger === 0 ? FD : 0
      window.setTimeout(() => {
        t(), this.destroyBean(i)
      }, s),
        this.clearTooltipListeners(),
        (this.tooltipPopupDestroyFunc = void 0),
        (this.tooltipComp = void 0)
    }
    clearTooltipListeners() {
      ;[
        this.tooltipMouseEnterListener,
        this.tooltipMouseLeaveListener,
        this.tooltipFocusInListener,
        this.tooltipFocusOutListener,
      ].forEach((t) => {
        t && t()
      }),
        (this.tooltipMouseEnterListener =
          this.tooltipMouseLeaveListener =
          this.tooltipFocusInListener =
          this.tooltipFocusOutListener =
            null)
    }
    lockService() {
      ;(Sn.isLocked = !0),
        (this.interactiveTooltipTimeoutId = window.setTimeout(() => {
          this.unlockService(), this.setToDoNothing()
        }, Sg))
    }
    unlockService() {
      ;(Sn.isLocked = !1), this.clearInteractiveTimeout()
    }
    startHideTimeout() {
      this.clearHideTimeout(),
        (this.hideTooltipTimeoutId = window.setTimeout(
          this.hideTooltip.bind(this),
          this.getTooltipDelay('hide'),
        ))
    }
    clearShowTimeout() {
      this.showTooltipTimeoutId &&
        (window.clearTimeout(this.showTooltipTimeoutId),
        (this.showTooltipTimeoutId = void 0))
    }
    clearHideTimeout() {
      this.hideTooltipTimeoutId &&
        (window.clearTimeout(this.hideTooltipTimeoutId),
        (this.hideTooltipTimeoutId = void 0))
    }
    clearInteractiveTimeout() {
      this.interactiveTooltipTimeoutId &&
        (window.clearTimeout(this.interactiveTooltipTimeoutId),
        (this.interactiveTooltipTimeoutId = void 0))
    }
    clearTimeouts() {
      this.clearShowTimeout(),
        this.clearHideTimeout(),
        this.clearInteractiveTimeout()
    }
  }
Qm.isLocked = !1
var ED = Qm,
  Tr = class extends X {
    constructor(e, t) {
      super(), (this.ctrl = e), t && (this.beans = t)
    }
    wireBeans(e) {
      this.beans = e
    }
    postConstruct() {
      this.refreshToolTip()
    }
    setBrowserTooltip(e) {
      const t = 'title',
        i = this.ctrl.getGui()
      i && (e != null && e != '' ? i.setAttribute(t, e) : i.removeAttribute(t))
    }
    updateTooltipText() {
      this.tooltip = this.ctrl.getTooltipValue()
    }
    createTooltipFeatureIfNeeded() {
      var t, i, s, n
      if (this.tooltipManager != null) return
      const e = {
        getTooltipParams: () => this.getTooltipParams(),
        getGui: () => this.ctrl.getGui(),
      }
      this.tooltipManager = this.createBean(
        new ED(
          e,
          (i = (t = this.ctrl).getTooltipShowDelayOverride) == null
            ? void 0
            : i.call(t),
          (n = (s = this.ctrl).getTooltipHideDelayOverride) == null
            ? void 0
            : n.call(s),
          this.ctrl.shouldDisplayTooltip,
        ),
        this.beans.context,
      )
    }
    refreshToolTip() {
      ;(this.browserTooltips = this.beans.gos.get('enableBrowserTooltips')),
        this.updateTooltipText(),
        this.browserTooltips
          ? (this.setBrowserTooltip(this.tooltip),
            this.tooltipManager &&
              (this.tooltipManager = this.destroyBean(
                this.tooltipManager,
                this.beans.context,
              )))
          : (this.setBrowserTooltip(null), this.createTooltipFeatureIfNeeded())
    }
    getTooltipParams() {
      var n, r, o, a, l
      const e = this.ctrl,
        t = (n = e.getColumn) == null ? void 0 : n.call(e),
        i = (r = e.getColDef) == null ? void 0 : r.call(e),
        s = (o = e.getRowNode) == null ? void 0 : o.call(e)
      return {
        location: e.getLocation(),
        colDef: i,
        column: t,
        rowIndex: (a = e.getRowIndex) == null ? void 0 : a.call(e),
        node: s,
        data: s == null ? void 0 : s.data,
        value: this.getTooltipText(),
        valueFormatted: (l = e.getValueFormatted) == null ? void 0 : l.call(e),
        hideTooltipCallback: () => {
          var c
          return (c = this.tooltipManager) == null ? void 0 : c.hideTooltip(!0)
        },
      }
    }
    getTooltipText() {
      return this.tooltip
    }
    destroy() {
      this.tooltipManager &&
        (this.tooltipManager = this.destroyBean(
          this.tooltipManager,
          this.beans.context,
        )),
        super.destroy()
    }
  },
  PD = new vr(),
  Le = null,
  yt = class Xm extends X {
    constructor(t, i) {
      super(),
        (this.suppressDataRefValidation = !1),
        (this.displayed = !0),
        (this.visible = !0),
        (this.compId = PD.next()),
        (this.cssClassManager = new Ho(() => this.eGui)),
        (this.componentSelectors = new Map(
          (i ?? []).map((s) => [s.selector, s]),
        )),
        t && this.setTemplate(t)
    }
    preWireBeans(t) {
      super.preWireBeans(t)
    }
    preConstruct() {
      ;(this.usingBrowserTooltips = this.gos.get('enableBrowserTooltips')),
        this.wireTemplate(this.getGui())
    }
    wireTemplate(t, i) {
      t &&
        this.gos &&
        (this.applyElementsToComponent(t),
        this.createChildComponentsFromTags(t, i))
    }
    getCompId() {
      return this.compId
    }
    getTooltipParams() {
      return { value: this.tooltipText, location: 'UNKNOWN' }
    }
    setTooltip(t) {
      const {
        newTooltipText: i,
        showDelayOverride: s,
        hideDelayOverride: n,
        location: r,
        shouldDisplayTooltip: o,
      } = t || {}
      this.tooltipFeature &&
        (this.tooltipFeature = this.destroyBean(this.tooltipFeature)),
        this.tooltipText !== i && (this.tooltipText = i)
      const a = () => this.tooltipText
      i != null &&
        (this.tooltipFeature = this.createBean(
          new Tr({
            getTooltipValue: a,
            getGui: () => this.getGui(),
            getLocation: () => r ?? 'UNKNOWN',
            getColDef: t == null ? void 0 : t.getColDef,
            getColumn: t == null ? void 0 : t.getColumn,
            getTooltipShowDelayOverride: s != null ? () => s : void 0,
            getTooltipHideDelayOverride: n != null ? () => n : void 0,
            shouldDisplayTooltip: o,
          }),
        ))
    }
    getDataRefAttribute(t) {
      return t.getAttribute ? t.getAttribute('data-ref') : null
    }
    applyElementsToComponent(t, i, s, n = null) {
      if ((i === void 0 && (i = this.getDataRefAttribute(t)), i)) {
        const r = this[i]
        if (r === Le) this[i] = n ?? t
        else {
          const o = s && s[i]
          !this.suppressDataRefValidation &&
            !o &&
            te(
              `Issue with data-ref: ${i} on ${this.constructor.name} with ${r}`,
            )
        }
      }
    }
    createChildComponentsFromTags(t, i) {
      yD(t.childNodes).forEach((n) => {
        if (!(n instanceof HTMLElement)) return
        const r = this.createComponentFromElement(
          n,
          (o) => {
            o.getGui() && this.copyAttributesFromNode(n, o.getGui())
          },
          i,
        )
        if (r) {
          if (r.addItems && n.children.length) {
            this.createChildComponentsFromTags(n, i)
            const o = Array.prototype.slice.call(n.children)
            r.addItems(o)
          }
          this.swapComponentForNode(r, t, n)
        } else n.childNodes && this.createChildComponentsFromTags(n, i)
      })
    }
    createComponentFromElement(t, i, s) {
      const n = t.nodeName,
        r = this.getDataRefAttribute(t),
        o = n.indexOf('AG-') === 0,
        a = o ? this.componentSelectors.get(n) : null
      let l = null
      if (a) {
        Xm.elementGettingCreated = t
        const c = s && r ? s[r] : void 0
        ;(l = new a.component(c)),
          l.setParentComponent(this),
          this.createBean(l, null, i)
      } else o && te(`Missing selector: ${n}`)
      return this.applyElementsToComponent(t, r, s, l), l
    }
    copyAttributesFromNode(t, i) {
      bD(t.attributes, (s, n) => i.setAttribute(s, n))
    }
    swapComponentForNode(t, i, s) {
      const n = t.getGui()
      i.replaceChild(n, s),
        i.insertBefore(document.createComment(s.nodeName), n),
        this.addDestroyFunc(this.destroyBean.bind(this, t))
    }
    activateTabIndex(t) {
      const i = this.gos.get('tabIndex')
      t || (t = []),
        t.length || t.push(this.getGui()),
        t.forEach((s) => s.setAttribute('tabindex', i.toString()))
    }
    setTemplate(t, i, s) {
      const n = bo(t)
      this.setTemplateFromElement(n, i, s)
    }
    setTemplateFromElement(t, i, s, n = !1) {
      if (((this.eGui = t), (this.suppressDataRefValidation = n), i))
        for (let r = 0; r < i.length; r++) {
          const o = i[r]
          this.componentSelectors.set(o.selector, o)
        }
      this.wireTemplate(t, s)
    }
    getGui() {
      return this.eGui
    }
    getFocusableElement() {
      return this.eGui
    }
    getAriaElement() {
      return this.getFocusableElement()
    }
    setParentComponent(t) {
      this.parentComponent = t
    }
    getParentComponent() {
      return this.parentComponent
    }
    setGui(t) {
      this.eGui = t
    }
    queryForHtmlElement(t) {
      return this.eGui.querySelector(t)
    }
    getContainerAndElement(t, i) {
      let s = i
      return t == null
        ? null
        : (s || (s = this.eGui),
          dd(t)
            ? { element: t, parent: s }
            : { element: t.getGui(), parent: s })
    }
    prependChild(t, i) {
      const { element: s, parent: n } = this.getContainerAndElement(t, i) || {}
      !s || !n || n.insertAdjacentElement('afterbegin', s)
    }
    appendChild(t, i) {
      const { element: s, parent: n } = this.getContainerAndElement(t, i) || {}
      !s || !n || n.appendChild(s)
    }
    isDisplayed() {
      return this.displayed
    }
    setVisible(t, i = {}) {
      if (t !== this.visible) {
        this.visible = t
        const { skipAriaHidden: s } = i
        CD(this.eGui, t, { skipAriaHidden: s })
      }
    }
    setDisplayed(t, i = {}) {
      if (t !== this.displayed) {
        this.displayed = t
        const { skipAriaHidden: s } = i
        Ot(this.eGui, t, { skipAriaHidden: s })
        const n = { type: 'displayChanged', visible: this.displayed }
        this.dispatchLocalEvent(n)
      }
    }
    destroy() {
      this.parentComponent && (this.parentComponent = void 0),
        this.tooltipFeature &&
          (this.tooltipFeature = this.destroyBean(this.tooltipFeature)),
        super.destroy()
    }
    addGuiEventListener(t, i, s) {
      this.eGui.addEventListener(t, i, s),
        this.addDestroyFunc(() => this.eGui.removeEventListener(t, i))
    }
    addCssClass(t) {
      this.cssClassManager.addCssClass(t)
    }
    removeCssClass(t) {
      this.cssClassManager.removeCssClass(t)
    }
    containsCssClass(t) {
      return this.cssClassManager.containsCssClass(t)
    }
    addOrRemoveCssClass(t, i) {
      this.cssClassManager.addOrRemoveCssClass(t, i)
    }
  },
  Jm = {
    columnGroupOpened: 'expanded',
    columnGroupClosed: 'contracted',
    columnSelectClosed: 'tree-closed',
    columnSelectOpen: 'tree-open',
    columnSelectIndeterminate: 'tree-indeterminate',
    columnMovePin: 'pin',
    columnMoveHide: 'eye-slash',
    columnMoveMove: 'arrows',
    columnMoveLeft: 'left',
    columnMoveRight: 'right',
    columnMoveGroup: 'group',
    columnMoveValue: 'aggregation',
    columnMovePivot: 'pivot',
    dropNotAllowed: 'not-allowed',
    groupContracted: 'tree-closed',
    groupExpanded: 'tree-open',
    setFilterGroupClosed: 'tree-closed',
    setFilterGroupOpen: 'tree-open',
    setFilterGroupIndeterminate: 'tree-indeterminate',
    chart: 'chart',
    close: 'cross',
    cancel: 'cancel',
    check: 'tick',
    first: 'first',
    previous: 'previous',
    next: 'next',
    last: 'last',
    linked: 'linked',
    unlinked: 'unlinked',
    colorPicker: 'color-picker',
    groupLoading: 'loading',
    menu: 'menu',
    menuAlt: 'menu-alt',
    filter: 'filter',
    columns: 'columns',
    maximize: 'maximize',
    minimize: 'minimize',
    menuPin: 'pin',
    menuValue: 'aggregation',
    menuAddRowGroup: 'group',
    menuRemoveRowGroup: 'group',
    clipboardCopy: 'copy',
    clipboardCut: 'cut',
    clipboardPaste: 'paste',
    pivotPanel: 'pivot',
    rowGroupPanel: 'group',
    valuePanel: 'aggregation',
    columnDrag: 'grip',
    rowDrag: 'grip',
    save: 'save',
    csvExport: 'csv',
    excelExport: 'excel',
    smallDown: 'small-down',
    smallLeft: 'small-left',
    smallRight: 'small-right',
    smallUp: 'small-up',
    sortAscending: 'asc',
    sortDescending: 'desc',
    sortUnSort: 'none',
    advancedFilterBuilder: 'group',
    advancedFilterBuilderDrag: 'grip',
    advancedFilterBuilderInvalid: 'not-allowed',
    advancedFilterBuilderMoveUp: 'up',
    advancedFilterBuilderMoveDown: 'down',
    advancedFilterBuilderAdd: 'plus',
    advancedFilterBuilderRemove: 'minus',
    chartsMenuEdit: 'chart',
    chartsMenuAdvancedSettings: 'settings',
    chartsMenuAdd: 'plus',
    checkboxChecked: 'checkbox-checked',
    checkboxIndeterminate: 'checkbox-indeterminate',
    checkboxUnchecked: 'checkbox-unchecked',
    radioButtonOn: 'radio-button-on',
    radioButtonOff: 'radio-button-off',
  },
  xD = (() => {
    const e = new Set(Object.values(Jm))
    return e.add('eye'), e
  })()
function DD(e, t, i) {
  const s = Li(e, t, i)
  if (s) {
    const { className: r } = s
    if (
      (typeof r == 'string' && r.indexOf('ag-icon') > -1) ||
      (typeof r == 'object' && r['ag-icon'])
    )
      return s
  }
  const n = document.createElement('span')
  return n.appendChild(s), n
}
function Li(e, t, i, s) {
  let n = null
  const r = i && i.getColDef().icons
  if ((r && (n = r[e]), t && !n)) {
    const o = t.get('icons')
    o && (n = o[e])
  }
  if (n) {
    let o
    if (typeof n == 'function') o = n()
    else if (typeof n == 'string') o = n
    else
      throw new Error(
        'icon from grid options needs to be a string or a function',
      )
    if (typeof o == 'string') return bo(o)
    if (dd(o)) return o
    te('iconRenderer should return back a string or a dom object')
  } else {
    const o = document.createElement('span')
    let a = Jm[e] ?? (xD.has(e) ? e : void 0)
    return (
      a || (te(`Did not find icon ${e}`), (a = '')),
      o.setAttribute('class', `ag-icon ag-icon-${a}`),
      o.setAttribute('unselectable', 'on'),
      es(o, 'presentation'),
      o
    )
  }
}
var MD = class extends yt {
  constructor() {
    super(...arguments),
      (this.dragSource = null),
      (this.eIcon = Le),
      (this.eLabel = Le)
  }
  postConstruct() {
    const e = (t) => DD(t, this.gos, null)
    this.dropIconMap = {
      pinned: e('columnMovePin'),
      hide: e('columnMoveHide'),
      move: e('columnMoveMove'),
      left: e('columnMoveLeft'),
      right: e('columnMoveRight'),
      group: e('columnMoveGroup'),
      aggregate: e('columnMoveValue'),
      pivot: e('columnMovePivot'),
      notAllowed: e('dropNotAllowed'),
    }
  }
  init(e) {
    ;(this.dragSource = e.dragSource),
      this.setTemplate(`<div class="ag-dnd-ghost ag-unselectable">
                <span data-ref="eIcon" class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
                <div data-ref="eLabel" class="ag-dnd-ghost-label"></div>
            </div>`)
  }
  destroy() {
    ;(this.dragSource = null), super.destroy()
  }
  setIcon(e, t = !1) {
    var s, n
    Ni(this.eIcon)
    let i = null
    e ||
      (e =
        (s = this.dragSource) != null && s.getDefaultIconName
          ? (n = this.dragSource) == null
            ? void 0
            : n.getDefaultIconName()
          : 'notAllowed'),
      (i = this.dropIconMap[e]),
      this.eIcon.classList.toggle('ag-shake-left-to-right', t),
      !(
        i === this.dropIconMap.hide &&
        this.gos.get('suppressDragLeaveHidesColumns')
      ) &&
        i &&
        this.eIcon.appendChild(i)
  }
  setLabel(e) {
    this.eLabel.textContent = hs(e)
  }
}
function Zm(e, t, i) {
  if (i === 0) return !1
  const s = Math.abs(e.clientX - t.clientX),
    n = Math.abs(e.clientY - t.clientY)
  return Math.max(s, n) <= i
}
var on = class {
  constructor(e, t = !1) {
    ;(this.DOUBLE_TAP_MILLIS = 500),
      (this.destroyFuncs = []),
      (this.touching = !1),
      (this.localEventService = new Dr()),
      (this.eElement = e),
      (this.preventMouseClick = t)
    const i = this.onTouchStart.bind(this),
      s = this.onTouchMove.bind(this),
      n = this.onTouchEnd.bind(this)
    this.eElement.addEventListener('touchstart', i, { passive: !0 }),
      this.eElement.addEventListener('touchmove', s, { passive: !0 }),
      this.eElement.addEventListener('touchend', n, { passive: !1 }),
      this.destroyFuncs.push(() => {
        this.eElement.removeEventListener('touchstart', i, { passive: !0 }),
          this.eElement.removeEventListener('touchmove', s, { passive: !0 }),
          this.eElement.removeEventListener('touchend', n, { passive: !1 })
      })
  }
  getActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier) return e[t]
    return null
  }
  addEventListener(e, t) {
    this.localEventService.addEventListener(e, t)
  }
  removeEventListener(e, t) {
    this.localEventService.removeEventListener(e, t)
  }
  onTouchStart(e) {
    if (this.touching) return
    ;(this.touchStart = e.touches[0]), (this.touching = !0), (this.moved = !1)
    const t = this.touchStart
    window.setTimeout(() => {
      const i = this.touchStart === t
      if (this.touching && i && !this.moved) {
        this.moved = !0
        const s = {
          type: 'longTap',
          touchStart: this.touchStart,
          touchEvent: e,
        }
        this.localEventService.dispatchEvent(s)
      }
    }, 500)
  }
  onTouchMove(e) {
    if (!this.touching) return
    const t = this.getActiveTouch(e.touches)
    if (!t) return
    !Zm(t, this.touchStart, 4) && (this.moved = !0)
  }
  onTouchEnd(e) {
    if (this.touching) {
      if (!this.moved) {
        const t = { type: 'tap', touchStart: this.touchStart }
        this.localEventService.dispatchEvent(t), this.checkForDoubleTap()
      }
      this.preventMouseClick && e.cancelable && e.preventDefault(),
        (this.touching = !1)
    }
  }
  checkForDoubleTap() {
    const e = new Date().getTime()
    if (this.lastTapTime && this.lastTapTime > 0)
      if (e - this.lastTapTime > this.DOUBLE_TAP_MILLIS) {
        const i = { type: 'doubleTap', touchStart: this.touchStart }
        this.localEventService.dispatchEvent(i), (this.lastTapTime = null)
      } else this.lastTapTime = e
    else this.lastTapTime = e
  }
  destroy() {
    this.destroyFuncs.forEach((e) => e())
  }
}
function Yr(e, t) {
  return `<span data-ref="eSort${e}" class="ag-sort-indicator-icon ag-sort-${t} ag-hidden" aria-hidden="true"></span>`
}
var ID = `<span class="ag-sort-indicator-container">
        ${Yr('Order', 'order')}
        ${Yr('Asc', 'ascending-icon')}
        ${Yr('Desc', 'descending-icon')}
        ${Yr('Mixed', 'mixed-icon')}
        ${Yr('None', 'none-icon')}
    </span>`,
  hd = class extends yt {
    constructor(e) {
      super(),
        (this.eSortOrder = Le),
        (this.eSortAsc = Le),
        (this.eSortDesc = Le),
        (this.eSortMixed = Le),
        (this.eSortNone = Le),
        e || this.setTemplate(ID)
    }
    wireBeans(e) {
      this.sortController = e.sortController
    }
    attachCustomElements(e, t, i, s, n) {
      ;(this.eSortOrder = e),
        (this.eSortAsc = t),
        (this.eSortDesc = i),
        (this.eSortMixed = s),
        (this.eSortNone = n)
    }
    setupSort(e, t = !1) {
      if (
        ((this.column = e),
        (this.suppressOrder = t),
        this.setupMultiSortIndicator(),
        !this.column.isSortable() && !this.column.getColDef().showRowGroup)
      )
        return
      this.addInIcon('sortAscending', this.eSortAsc, e),
        this.addInIcon('sortDescending', this.eSortDesc, e),
        this.addInIcon('sortUnSort', this.eSortNone, e)
      const i = this.updateIcons.bind(this),
        s = this.onSortChanged.bind(this)
      this.addManagedPropertyListener('unSortIcon', i),
        this.addManagedEventListeners({
          newColumnsLoaded: i,
          sortChanged: s,
          columnRowGroupChanged: s,
        }),
        this.onSortChanged()
    }
    addInIcon(e, t, i) {
      if (t == null) return
      const s = Li(e, this.gos, i)
      s && t.appendChild(s)
    }
    onSortChanged() {
      this.updateIcons(), this.suppressOrder || this.updateSortOrder()
    }
    updateIcons() {
      const e = this.sortController.getDisplaySortForColumn(this.column)
      if (this.eSortAsc) {
        const t = e === 'asc'
        Ot(this.eSortAsc, t, { skipAriaHidden: !0 })
      }
      if (this.eSortDesc) {
        const t = e === 'desc'
        Ot(this.eSortDesc, t, { skipAriaHidden: !0 })
      }
      if (this.eSortNone) {
        const t =
            !this.column.getColDef().unSortIcon && !this.gos.get('unSortIcon'),
          i = e == null
        Ot(this.eSortNone, !t && i, { skipAriaHidden: !0 })
      }
    }
    setupMultiSortIndicator() {
      this.addInIcon('sortUnSort', this.eSortMixed, this.column)
      const e = this.column.getColDef().showRowGroup
      cs(this.gos) &&
        e &&
        (this.addManagedEventListeners({
          sortChanged: this.updateMultiSortIndicator.bind(this),
          columnRowGroupChanged: this.updateMultiSortIndicator.bind(this),
        }),
        this.updateMultiSortIndicator())
    }
    updateMultiSortIndicator() {
      if (this.eSortMixed) {
        const e =
          this.sortController.getDisplaySortForColumn(this.column) === 'mixed'
        Ot(this.eSortMixed, e, { skipAriaHidden: !0 })
      }
    }
    updateSortOrder() {
      if (!this.eSortOrder) return
      const e = this.sortController.getColumnsWithSortingOrdered(),
        t = this.sortController.getDisplaySortIndexForColumn(this.column) ?? -1,
        i = e.some(
          (n) => this.sortController.getDisplaySortIndexForColumn(n) ?? !1,
        ),
        s = t >= 0 && i
      Ot(this.eSortOrder, s, { skipAriaHidden: !0 }),
        t >= 0
          ? (this.eSortOrder.textContent = (t + 1).toString())
          : Ni(this.eSortOrder)
    }
  },
  TD = { selector: 'AG-SORT-INDICATOR', component: hd },
  AD = `<div class="ag-cell-label-container" role="presentation">
        <span data-ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
        <span data-ref="eFilterButton" class="ag-header-icon ag-header-cell-filter-button" aria-hidden="true"></span>
        <div data-ref="eLabel" class="ag-header-cell-label" role="presentation">
            <span data-ref="eText" class="ag-header-cell-text"></span>
            <span data-ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
            <ag-sort-indicator data-ref="eSortIndicator"></ag-sort-indicator>
        </div>
    </div>`,
  eu = class extends yt {
    constructor() {
      super(...arguments),
        (this.eFilter = Le),
        (this.eFilterButton = Le),
        (this.eSortIndicator = Le),
        (this.eMenu = Le),
        (this.eLabel = Le),
        (this.eText = Le),
        (this.eSortOrder = Le),
        (this.eSortAsc = Le),
        (this.eSortDesc = Le),
        (this.eSortMixed = Le),
        (this.eSortNone = Le),
        (this.lastMovingChanged = 0)
    }
    wireBeans(e) {
      ;(this.sortController = e.sortController),
        (this.menuService = e.menuService),
        (this.funcColsService = e.funcColsService)
    }
    destroy() {
      super.destroy()
    }
    refresh(e) {
      const t = this.params
      return (
        (this.params = e),
        this.workOutTemplate() != this.currentTemplate ||
        this.workOutShowMenu() != this.currentShowMenu ||
        this.workOutSort() != this.currentSort ||
        this.shouldSuppressMenuHide() != this.currentSuppressMenuHide ||
        t.enableFilterButton != e.enableFilterButton ||
        t.enableFilterIcon != e.enableFilterIcon
          ? !1
          : (this.setDisplayName(e), !0)
      )
    }
    workOutTemplate() {
      let e = this.params.template ?? AD
      return (e = e && e.trim ? e.trim() : e), e
    }
    init(e) {
      ;(this.params = e),
        (this.currentTemplate = this.workOutTemplate()),
        this.setTemplate(this.currentTemplate, [TD]),
        this.setupTap(),
        this.setMenu(),
        this.setupSort(),
        this.setupFilterIcon(),
        this.setupFilterButton(),
        this.setDisplayName(e)
    }
    setDisplayName(e) {
      if (this.currentDisplayName != e.displayName) {
        this.currentDisplayName = e.displayName
        const t = hs(this.currentDisplayName, !0)
        this.eText && (this.eText.textContent = t)
      }
    }
    addInIcon(e, t, i) {
      if (t == null) return
      const s = Li(e, this.gos, i)
      s && t.appendChild(s)
    }
    setupTap() {
      const { gos: e } = this
      if (e.get('suppressTouch')) return
      const t = new on(this.getGui(), !0),
        i = this.shouldSuppressMenuHide(),
        s = i && ue(this.eMenu),
        n = s ? new on(this.eMenu, !0) : t
      if (this.params.enableMenu) {
        const r = s ? 'tap' : 'longTap',
          o = (a) => this.params.showColumnMenuAfterMouseClick(a.touchStart)
        this.addManagedListeners(n, { [r]: o })
      }
      if (this.params.enableSorting) {
        const r = (o) => {
          var l, c
          const a = o.touchStart.target
          ;(i &&
            (((l = this.eMenu) != null && l.contains(a)) ||
              ((c = this.eFilterButton) != null && c.contains(a)))) ||
            this.sortController.progressSort(
              this.params.column,
              !1,
              'uiColumnSorted',
            )
        }
        this.addManagedListeners(t, { tap: r })
      }
      if (this.params.enableFilterButton) {
        const r = new on(this.eFilterButton, !0)
        this.addManagedListeners(r, {
          tap: () => this.params.showFilter(this.eFilterButton),
        }),
          this.addDestroyFunc(() => r.destroy())
      }
      this.addDestroyFunc(() => t.destroy()),
        s && this.addDestroyFunc(() => n.destroy())
    }
    workOutShowMenu() {
      return (
        this.params.enableMenu && this.menuService.isHeaderMenuButtonEnabled()
      )
    }
    shouldSuppressMenuHide() {
      return this.menuService.isHeaderMenuButtonAlwaysShowEnabled()
    }
    setMenu() {
      if (!this.eMenu) return
      if (
        ((this.currentShowMenu = this.workOutShowMenu()), !this.currentShowMenu)
      ) {
        Bn(this.eMenu), (this.eMenu = void 0)
        return
      }
      const e = this.menuService.isLegacyMenuEnabled()
      this.addInIcon(e ? 'menu' : 'menuAlt', this.eMenu, this.params.column),
        this.eMenu.classList.toggle('ag-header-menu-icon', !e),
        (this.currentSuppressMenuHide = this.shouldSuppressMenuHide()),
        this.addManagedElementListeners(this.eMenu, {
          click: () => this.params.showColumnMenu(this.eMenu),
        }),
        this.eMenu.classList.toggle(
          'ag-header-menu-always-show',
          this.currentSuppressMenuHide,
        )
    }
    onMenuKeyboardShortcut(e) {
      const t = this.params.column,
        i = this.menuService.isLegacyMenuEnabled()
      if (e && !i) {
        if (this.menuService.isFilterMenuInHeaderEnabled(t))
          return (
            this.params.showFilter(
              this.eFilterButton ?? this.eMenu ?? this.getGui(),
            ),
            !0
          )
      } else if (this.params.enableMenu)
        return (
          this.params.showColumnMenu(
            this.eMenu ?? this.eFilterButton ?? this.getGui(),
          ),
          !0
        )
      return !1
    }
    workOutSort() {
      return this.params.enableSorting
    }
    setupSort() {
      if (
        ((this.currentSort = this.params.enableSorting),
        this.eSortIndicator ||
          ((this.eSortIndicator = this.createBean(new hd(!0))),
          this.eSortIndicator.attachCustomElements(
            this.eSortOrder,
            this.eSortAsc,
            this.eSortDesc,
            this.eSortMixed,
            this.eSortNone,
          )),
        this.eSortIndicator.setupSort(this.params.column),
        !this.currentSort)
      )
        return
      this.addManagedListeners(this.params.column, {
        movingChanged: () => {
          this.lastMovingChanged = new Date().getTime()
        },
      }),
        this.eLabel &&
          this.addManagedElementListeners(this.eLabel, {
            click: (t) => {
              const i = this.params.column.isMoving(),
                n = new Date().getTime() - this.lastMovingChanged < 50
              if (!(i || n)) {
                const a =
                  this.gos.get('multiSortKey') === 'ctrl'
                    ? t.ctrlKey || t.metaKey
                    : t.shiftKey
                this.params.progressSort(a)
              }
            },
          })
      const e = () => {
        const t = this.params.column.getSort()
        if (
          (this.addOrRemoveCssClass('ag-header-cell-sorted-asc', t === 'asc'),
          this.addOrRemoveCssClass('ag-header-cell-sorted-desc', t === 'desc'),
          this.addOrRemoveCssClass('ag-header-cell-sorted-none', !t),
          this.params.column.getColDef().showRowGroup)
        ) {
          const i = this.funcColsService.getSourceColumnsForGroupColumn(
              this.params.column,
            ),
            n = !(i == null
              ? void 0
              : i.every((r) => this.params.column.getSort() == r.getSort()))
          this.addOrRemoveCssClass('ag-header-cell-sorted-mixed', n)
        }
      }
      this.addManagedEventListeners({
        sortChanged: e,
        columnRowGroupChanged: e,
      })
    }
    setupFilterIcon() {
      this.eFilter &&
        this.configureFilter(
          this.params.enableFilterIcon,
          this.eFilter,
          this.onFilterChangedIcon.bind(this),
        )
    }
    setupFilterButton() {
      if (!this.eFilterButton) return
      this.configureFilter(
        this.params.enableFilterButton,
        this.eFilterButton,
        this.onFilterChangedButton.bind(this),
      )
        ? this.addManagedElementListeners(this.eFilterButton, {
            click: () => this.params.showFilter(this.eFilterButton),
          })
        : (this.eFilterButton = void 0)
    }
    configureFilter(e, t, i) {
      if (!e) return Bn(t), !1
      const s = this.params.column
      return (
        this.addInIcon('filter', t, s),
        this.addManagedListeners(s, { filterChanged: i }),
        i(),
        !0
      )
    }
    onFilterChangedIcon() {
      const e = this.params.column.isFilterActive()
      Ot(this.eFilter, e, { skipAriaHidden: !0 })
    }
    onFilterChangedButton() {
      const e = this.params.column.isFilterActive()
      this.eFilterButton.classList.toggle('ag-filter-active', e)
    }
    getAnchorElementForMenu(e) {
      return e
        ? (this.eFilterButton ?? this.eMenu ?? this.getGui())
        : (this.eMenu ?? this.eFilterButton ?? this.getGui())
    }
  },
  OD = class extends yt {
    constructor() {
      super(`<div class="ag-header-group-cell-label" role="presentation">
            <span data-ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span data-ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span data-ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`),
        (this.agOpened = Le),
        (this.agClosed = Le),
        (this.agLabel = Le)
    }
    wireBeans(e) {
      this.columnModel = e.columnModel
    }
    destroy() {
      super.destroy()
    }
    init(e) {
      ;(this.params = e),
        this.checkWarnings(),
        this.setupLabel(),
        this.addGroupExpandIcon(),
        this.setupExpandIcons()
    }
    checkWarnings() {
      this.params.template &&
        te(
          'A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)',
        )
    }
    setupExpandIcons() {
      this.addInIcon('columnGroupOpened', this.agOpened),
        this.addInIcon('columnGroupClosed', this.agClosed)
      const e = (n) => {
        if (Os(n)) return
        const r = !this.params.columnGroup.isExpanded()
        this.columnModel.setColumnGroupOpened(
          this.params.columnGroup.getProvidedColumnGroup(),
          r,
          'uiColumnExpanded',
        )
      }
      this.addTouchAndClickListeners(this.agClosed, e),
        this.addTouchAndClickListeners(this.agOpened, e)
      const t = (n) => {
        pr(n)
      }
      this.addManagedElementListeners(this.agClosed, { dblclick: t }),
        this.addManagedElementListeners(this.agOpened, { dblclick: t }),
        this.addManagedElementListeners(this.getGui(), { dblclick: e }),
        this.updateIconVisibility()
      const i = this.params.columnGroup.getProvidedColumnGroup(),
        s = this.updateIconVisibility.bind(this)
      this.addManagedListeners(i, { expandedChanged: s, expandableChanged: s })
    }
    addTouchAndClickListeners(e, t) {
      const i = new on(e, !0)
      this.addManagedListeners(i, { tap: t }),
        this.addDestroyFunc(() => i.destroy()),
        this.addManagedElementListeners(e, { click: t })
    }
    updateIconVisibility() {
      if (this.params.columnGroup.isExpandable()) {
        const t = this.params.columnGroup.isExpanded()
        Ot(this.agOpened, t), Ot(this.agClosed, !t)
      } else Ot(this.agOpened, !1), Ot(this.agClosed, !1)
    }
    addInIcon(e, t) {
      const i = Li(e, this.gos, null)
      i && t.appendChild(i)
    }
    addGroupExpandIcon() {
      if (!this.params.columnGroup.isExpandable()) {
        Ot(this.agOpened, !1), Ot(this.agClosed, !1)
        return
      }
    }
    setupLabel() {
      var i
      const { displayName: e, columnGroup: t } = this.params
      if (ue(e)) {
        const s = hs(e, !0)
        this.agLabel.textContent = s
      }
      this.addOrRemoveCssClass(
        'ag-sticky-label',
        !((i = t.getColGroupDef()) != null && i.suppressStickyLabel),
      )
    }
  },
  LD = '',
  kD = '',
  HD = class extends yt {
    constructor() {
      super(), (this.refreshCount = 0)
      const e = document.createElement('span'),
        t = document.createElement('span')
      t.setAttribute('class', 'ag-value-change-delta')
      const i = document.createElement('span')
      i.setAttribute('class', 'ag-value-change-value'),
        e.appendChild(t),
        e.appendChild(i),
        this.setTemplateFromElement(e)
    }
    wireBeans(e) {
      this.filterManager = e.filterManager
    }
    init(e) {
      ;(this.eValue = this.queryForHtmlElement('.ag-value-change-value')),
        (this.eDelta = this.queryForHtmlElement('.ag-value-change-delta')),
        this.refresh(e, !0)
    }
    showDelta(e, t) {
      const i = Math.abs(t),
        s = e.formatValue(i),
        n = ue(s) ? s : i,
        r = t >= 0
      r
        ? (this.eDelta.textContent = LD + n)
        : (this.eDelta.textContent = kD + n),
        this.eDelta.classList.toggle('ag-value-change-delta-up', r),
        this.eDelta.classList.toggle('ag-value-change-delta-down', !r)
    }
    setTimerToRemoveDelta() {
      this.refreshCount++
      const e = this.refreshCount
      this.getFrameworkOverrides().wrapIncoming(() => {
        window.setTimeout(() => {
          e === this.refreshCount && this.hideDeltaValue()
        }, 2e3)
      })
    }
    hideDeltaValue() {
      this.eValue.classList.remove('ag-value-change-value-highlight'),
        Ni(this.eDelta)
    }
    refresh(e, t = !1) {
      var s
      const i = e.value
      if (
        i === this.lastValue ||
        (ue(e.valueFormatted)
          ? (this.eValue.textContent = e.valueFormatted)
          : ue(e.value)
            ? (this.eValue.textContent = i)
            : Ni(this.eValue),
        (s = this.filterManager) != null &&
          s.isSuppressFlashingCellsBecauseFiltering())
      )
        return !1
      if (typeof i == 'number' && typeof this.lastValue == 'number') {
        const n = i - this.lastValue
        this.showDelta(e, n)
      }
      return (
        this.lastValue &&
          this.eValue.classList.add('ag-value-change-value-highlight'),
        t || this.setTimerToRemoveDelta(),
        (this.lastValue = i),
        !0
      )
    }
  },
  ND = class extends yt {
    constructor() {
      super(), (this.refreshCount = 0)
      const e = document.createElement('span'),
        t = document.createElement('span')
      t.setAttribute('class', 'ag-value-slide-current'),
        e.appendChild(t),
        this.setTemplateFromElement(e),
        (this.eCurrent = this.queryForHtmlElement('.ag-value-slide-current'))
    }
    wireBeans(e) {
      this.filterManager = e.filterManager
    }
    init(e) {
      this.refresh(e, !0)
    }
    addSlideAnimation() {
      this.refreshCount++
      const e = this.refreshCount
      this.ePrevious && this.getGui().removeChild(this.ePrevious)
      const t = document.createElement('span')
      t.setAttribute('class', 'ag-value-slide-previous ag-value-slide-out'),
        (this.ePrevious = t),
        (this.ePrevious.textContent = this.eCurrent.textContent),
        this.getGui().insertBefore(this.ePrevious, this.eCurrent),
        this.getFrameworkOverrides().wrapIncoming(() => {
          window.setTimeout(() => {
            e === this.refreshCount &&
              this.ePrevious.classList.add('ag-value-slide-out-end')
          }, 50),
            window.setTimeout(() => {
              e === this.refreshCount &&
                (this.getGui().removeChild(this.ePrevious),
                (this.ePrevious = null))
            }, 3e3)
        })
    }
    refresh(e, t = !1) {
      var s
      let i = e.value
      return (
        ot(i) && (i = ''),
        i === this.lastValue ||
        ((s = this.filterManager) != null &&
          s.isSuppressFlashingCellsBecauseFiltering())
          ? !1
          : (t || this.addSlideAnimation(),
            (this.lastValue = i),
            ue(e.valueFormatted)
              ? (this.eCurrent.textContent = e.valueFormatted)
              : ue(e.value)
                ? (this.eCurrent.textContent = i)
                : Ni(this.eCurrent),
            !0)
      )
    }
  },
  Y = class {}
Y.BACKSPACE = 'Backspace'
Y.TAB = 'Tab'
Y.ENTER = 'Enter'
Y.ESCAPE = 'Escape'
Y.SPACE = ' '
Y.LEFT = 'ArrowLeft'
Y.UP = 'ArrowUp'
Y.RIGHT = 'ArrowRight'
Y.DOWN = 'ArrowDown'
Y.DELETE = 'Delete'
Y.F2 = 'F2'
Y.PAGE_UP = 'PageUp'
Y.PAGE_DOWN = 'PageDown'
Y.PAGE_HOME = 'Home'
Y.PAGE_END = 'End'
Y.A = 'KeyA'
Y.C = 'KeyC'
Y.D = 'KeyD'
Y.V = 'KeyV'
Y.X = 'KeyX'
Y.Y = 'KeyY'
Y.Z = 'KeyZ'
var GD = class extends yt {
    constructor(e, t, i) {
      super(t, i),
        (this.labelSeparator = ''),
        (this.labelAlignment = 'left'),
        (this.disabled = !1),
        (this.label = ''),
        (this.config = e || {})
    }
    postConstruct() {
      this.addCssClass('ag-labeled'), this.eLabel.classList.add('ag-label')
      const {
        labelSeparator: e,
        label: t,
        labelWidth: i,
        labelAlignment: s,
        disabled: n,
      } = this.config
      n != null && this.setDisabled(n),
        e != null && this.setLabelSeparator(e),
        t != null && this.setLabel(t),
        i != null && this.setLabelWidth(i),
        this.setLabelAlignment(s || this.labelAlignment),
        this.refreshLabel()
    }
    refreshLabel() {
      Ni(this.eLabel),
        typeof this.label == 'string'
          ? (this.eLabel.innerText = this.label + this.labelSeparator)
          : this.label && this.eLabel.appendChild(this.label),
        this.label === ''
          ? (Ot(this.eLabel, !1), es(this.eLabel, 'presentation'))
          : (Ot(this.eLabel, !0), es(this.eLabel, null))
    }
    setLabelSeparator(e) {
      return this.labelSeparator === e
        ? this
        : ((this.labelSeparator = e),
          this.label != null && this.refreshLabel(),
          this)
    }
    getLabelId() {
      return (
        (this.eLabel.id = this.eLabel.id || `ag-${this.getCompId()}-label`),
        this.eLabel.id
      )
    }
    getLabel() {
      return this.label
    }
    setLabel(e) {
      return this.label === e
        ? this
        : ((this.label = e), this.refreshLabel(), this)
    }
    setLabelAlignment(e) {
      const i = this.getGui().classList
      return (
        i.toggle('ag-label-align-left', e === 'left'),
        i.toggle('ag-label-align-right', e === 'right'),
        i.toggle('ag-label-align-top', e === 'top'),
        this
      )
    }
    setLabelEllipsis(e) {
      return this.eLabel.classList.toggle('ag-label-ellipsis', e), this
    }
    setLabelWidth(e) {
      return this.label == null ? this : (_a(this.eLabel, e), this)
    }
    setDisabled(e) {
      e = !!e
      const t = this.getGui()
      return (
        yo(t, e),
        t.classList.toggle('ag-disabled', e),
        (this.disabled = e),
        this
      )
    }
    isDisabled() {
      return !!this.disabled
    }
  },
  ev = class extends GD {
    constructor(e, t, i, s) {
      super(e, t, i), (this.className = s)
    }
    postConstruct() {
      super.postConstruct()
      const { width: e, value: t, onValueChange: i } = this.config
      e != null && this.setWidth(e),
        t != null && this.setValue(t),
        i != null && this.onValueChange(i),
        this.className && this.addCssClass(this.className),
        this.refreshAriaLabelledBy()
    }
    setLabel(e) {
      return super.setLabel(e), this.refreshAriaLabelledBy(), this
    }
    refreshAriaLabelledBy() {
      const e = this.getAriaElement(),
        t = this.getLabelId(),
        i = this.getLabel()
      i == null || i == '' || eD(e) !== null ? wo(e, '') : wo(e, t ?? '')
    }
    setAriaLabel(e) {
      return mr(this.getAriaElement(), e), this.refreshAriaLabelledBy(), this
    }
    onValueChange(e) {
      return (
        this.addManagedListeners(this, {
          fieldValueChanged: () => e(this.getValue()),
        }),
        this
      )
    }
    getWidth() {
      return this.getGui().clientWidth
    }
    setWidth(e) {
      return Zi(this.getGui(), e), this
    }
    getPreviousValue() {
      return this.previousValue
    }
    getValue() {
      return this.value
    }
    setValue(e, t) {
      return this.value === e
        ? this
        : ((this.previousValue = this.value),
          (this.value = e),
          t || this.dispatchLocalEvent({ type: 'fieldValueChanged' }),
          this)
    }
  },
  Pn = class extends ev {
    constructor(e, t, i = 'text', s = 'input') {
      super(
        e,
        (e == null ? void 0 : e.template) ??
          `
            <div role="presentation">
                <div data-ref="eLabel" class="ag-input-field-label"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <${s} data-ref="eInput" class="ag-input-field-input"></${s}>
                </div>
            </div>`,
        [],
        t,
      ),
        (this.inputType = i),
        (this.displayFieldTag = s),
        (this.eLabel = Le),
        (this.eWrapper = Le),
        (this.eInput = Le)
    }
    postConstruct() {
      super.postConstruct(),
        this.setInputType(),
        this.eLabel.classList.add(`${this.className}-label`),
        this.eWrapper.classList.add(`${this.className}-input-wrapper`),
        this.eInput.classList.add(`${this.className}-input`),
        this.addCssClass('ag-input-field'),
        (this.eInput.id = this.eInput.id || `ag-${this.getCompId()}-input`)
      const { inputName: e, inputWidth: t } = this.config
      e != null && this.setInputName(e),
        t != null && this.setInputWidth(t),
        this.addInputListeners(),
        this.activateTabIndex([this.eInput])
    }
    addInputListeners() {
      this.addManagedElementListeners(this.eInput, {
        input: (e) => this.setValue(e.target.value),
      })
    }
    setInputType() {
      this.displayFieldTag === 'input' &&
        this.eInput.setAttribute('type', this.inputType)
    }
    getInputElement() {
      return this.eInput
    }
    setInputWidth(e) {
      return _a(this.eWrapper, e), this
    }
    setInputName(e) {
      return this.getInputElement().setAttribute('name', e), this
    }
    getFocusableElement() {
      return this.eInput
    }
    setMaxLength(e) {
      const t = this.eInput
      return (t.maxLength = e), this
    }
    setInputPlaceholder(e) {
      return $i(this.eInput, 'placeholder', e), this
    }
    setInputAriaLabel(e) {
      return mr(this.eInput, e), this.refreshAriaLabelledBy(), this
    }
    setDisabled(e) {
      return yo(this.eInput, e), super.setDisabled(e)
    }
    setAutoComplete(e) {
      if (e === !0) $i(this.eInput, 'autocomplete', null)
      else {
        const t = typeof e == 'string' ? e : 'off'
        $i(this.eInput, 'autocomplete', t)
      }
      return this
    }
  },
  gd = class extends Pn {
    constructor(e, t = 'ag-checkbox', i = 'checkbox') {
      super(e, t, i),
        (this.labelAlignment = 'right'),
        (this.selected = !1),
        (this.readOnly = !1),
        (this.passive = !1)
    }
    postConstruct() {
      super.postConstruct()
      const { readOnly: e, passive: t } = this.config
      typeof e == 'boolean' && this.setReadOnly(e),
        typeof t == 'boolean' && this.setPassive(t)
    }
    addInputListeners() {
      this.addManagedElementListeners(this.eInput, {
        click: this.onCheckboxClick.bind(this),
      }),
        this.addManagedElementListeners(this.eLabel, {
          click: this.toggle.bind(this),
        })
    }
    getNextValue() {
      return this.selected === void 0 ? !0 : !this.selected
    }
    setPassive(e) {
      this.passive = e
    }
    isReadOnly() {
      return this.readOnly
    }
    setReadOnly(e) {
      this.eWrapper.classList.toggle('ag-disabled', e),
        (this.eInput.disabled = e),
        (this.readOnly = e)
    }
    setDisabled(e) {
      return (
        this.eWrapper.classList.toggle('ag-disabled', e), super.setDisabled(e)
      )
    }
    toggle() {
      if (this.eInput.disabled) return
      const e = this.isSelected(),
        t = this.getNextValue()
      this.passive ? this.dispatchChange(t, e) : this.setValue(t)
    }
    getValue() {
      return this.isSelected()
    }
    setValue(e, t) {
      return this.refreshSelectedClass(e), this.setSelected(e, t), this
    }
    setName(e) {
      const t = this.getInputElement()
      return (t.name = e), this
    }
    isSelected() {
      return this.selected
    }
    setSelected(e, t) {
      this.isSelected() !== e &&
        ((this.previousValue = this.isSelected()),
        (e = this.selected = typeof e == 'boolean' ? e : void 0),
        (this.eInput.checked = e),
        (this.eInput.indeterminate = e === void 0),
        t || this.dispatchChange(this.selected, this.previousValue))
    }
    dispatchChange(e, t, i) {
      this.dispatchLocalEvent({
        type: 'fieldValueChanged',
        selected: e,
        previousValue: t,
        event: i,
      })
      const s = this.getInputElement()
      this.eventService.dispatchEvent({
        type: 'checkboxChanged',
        id: s.id,
        name: s.name,
        selected: e,
        previousValue: t,
      })
    }
    onCheckboxClick(e) {
      if (this.passive || this.eInput.disabled) return
      const t = this.isSelected(),
        i = (this.selected = e.target.checked)
      this.refreshSelectedClass(i), this.dispatchChange(i, t, e)
    }
    refreshSelectedClass(e) {
      this.eWrapper.classList.toggle('ag-checked', e === !0),
        this.eWrapper.classList.toggle('ag-indeterminate', e == null)
    }
  },
  fd = { selector: 'AG-CHECKBOX', component: gd },
  BD = class extends yt {
    constructor() {
      super(
        `
            <div class="ag-cell-wrapper ag-checkbox-cell" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
        [fd],
      ),
        (this.eCheckbox = Le)
    }
    init(e) {
      this.refresh(e)
      const t = this.eCheckbox.getInputElement()
      t.setAttribute('tabindex', '-1'),
        Gm(t, 'polite'),
        this.addManagedListeners(t, {
          click: (i) => {
            if ((pr(i), this.eCheckbox.isDisabled())) return
            const s = this.eCheckbox.getValue()
            this.onCheckboxChanged(s)
          },
          dblclick: (i) => {
            pr(i)
          },
        }),
        this.addManagedElementListeners(this.params.eGridCell, {
          keydown: (i) => {
            if (i.key === Y.SPACE && !this.eCheckbox.isDisabled()) {
              this.params.eGridCell === Lt(this.gos) && this.eCheckbox.toggle()
              const s = this.eCheckbox.getValue()
              this.onCheckboxChanged(s), i.preventDefault()
            }
          },
        })
    }
    refresh(e) {
      return (this.params = e), this.updateCheckbox(e), !0
    }
    updateCheckbox(e) {
      var a
      let t,
        i = !0
      if (e.node.group && e.column)
        if (typeof e.value == 'boolean') t = e.value
        else {
          const l = e.column.getColId()
          l.startsWith(ml)
            ? (t =
                e.value == null || e.value === '' ? void 0 : e.value === 'true')
            : e.node.aggData && e.node.aggData[l] !== void 0
              ? (t = e.value ?? void 0)
              : (i = !1)
        }
      else t = e.value ?? void 0
      if (!i) {
        this.eCheckbox.setDisplayed(!1)
        return
      }
      this.eCheckbox.setValue(t)
      const s =
        e.disabled != null
          ? e.disabled
          : !((a = e.column) != null && a.isCellEditable(e.node))
      this.eCheckbox.setDisabled(s)
      const n = this.localeService.getLocaleTextFunc(),
        r = rd(n, t),
        o = s
          ? r
          : `${n('ariaToggleCellValue', 'Press SPACE to toggle cell value')} (${r})`
      this.eCheckbox.setInputAriaLabel(o)
    }
    onCheckboxChanged(e) {
      const { column: t, node: i, value: s } = this.params
      this.eventService.dispatchEvent({
        type: 'cellEditingStarted',
        column: t,
        colDef: t == null ? void 0 : t.getColDef(),
        data: i.data,
        node: i,
        rowIndex: i.rowIndex,
        rowPinned: i.rowPinned,
        value: s,
      })
      const n = this.params.node.setDataValue(this.params.column, e, 'edit')
      this.eventService.dispatchEvent({
        type: 'cellEditingStopped',
        column: t,
        colDef: t == null ? void 0 : t.getColDef(),
        data: i.data,
        node: i,
        rowIndex: i.rowIndex,
        rowPinned: i.rowPinned,
        value: s,
        oldValue: s,
        newValue: e,
        valueChanged: n,
      }),
        n || this.updateCheckbox(this.params)
    }
  },
  VD = class extends yt {
    constructor() {
      super(`<div class="ag-loading">
            <span class="ag-loading-icon" data-ref="eLoadingIcon"></span>
            <span class="ag-loading-text" data-ref="eLoadingText"></span>
        </div>`),
        (this.eLoadingIcon = Le),
        (this.eLoadingText = Le)
    }
    init(e) {
      e.node.failedLoad ? this.setupFailed() : this.setupLoading()
    }
    setupFailed() {
      const e = this.localeService.getLocaleTextFunc()
      this.eLoadingText.innerText = e('loadingError', 'ERR')
    }
    setupLoading() {
      const e = Li('groupLoading', this.gos, null)
      e && this.eLoadingIcon.appendChild(e)
      const t = this.localeService.getLocaleTextFunc()
      this.eLoadingText.innerText = t('loadingOoo', 'Loading')
    }
    refresh(e) {
      return !1
    }
    destroy() {
      super.destroy()
    }
  },
  _D = class extends yt {
    constructor() {
      super('<div class="ag-skeleton-container"></div>')
    }
    init(e) {
      const t = `ag-cell-skeleton-renderer-${this.getCompId()}`
      this.getGui().setAttribute('id', t),
        this.addDestroyFunc(() => wo(e.eParentOfValue)),
        wo(e.eParentOfValue, t),
        e.node.failedLoad ? this.setupFailed() : this.setupLoading(e)
    }
    setupFailed() {
      const e = this.localeService.getLocaleTextFunc()
      this.getGui().innerText = e('loadingError', 'ERR')
      const t = e('ariaSkeletonCellLoadingFailed', 'Row failed to load')
      mr(this.getGui(), t)
    }
    setupLoading(e) {
      const i = Gt(this.gos).createElement('div')
      i.classList.add('ag-skeleton-effect')
      const s = e.node.rowIndex
      if (s != null) {
        const o = 75 + 25 * (s % 2 === 0 ? Math.sin(s) : Math.cos(s))
        i.style.width = `${o}%`
      }
      this.getGui().appendChild(i)
      const r = this.localeService.getLocaleTextFunc()(
        'ariaSkeletonCellLoading',
        'Row data is loading',
      )
      mr(this.getGui(), r)
    }
    refresh(e) {
      return !1
    }
    destroy() {
      super.destroy()
    }
  },
  tv = class extends yt {
    constructor() {
      super()
    }
    destroy() {
      super.destroy()
    }
  },
  WD = class extends tv {
    init() {
      var t
      const e = As(
        (t = this.gos.get('overlayLoadingTemplate')) == null
          ? void 0
          : t.trim(),
      )
      if (
        (this.setTemplate(
          e ??
            '<span aria-live="polite" aria-atomic="true" class="ag-overlay-loading-center"></span>',
        ),
        !e)
      ) {
        const i = this.localeService.getLocaleTextFunc()
        setTimeout(() => {
          this.getGui().textContent = i('loadingOoo', 'Loading...')
        })
      }
    }
  },
  $D = class extends tv {
    init() {
      var t
      const e = As(
        (t = this.gos.get('overlayNoRowsTemplate')) == null ? void 0 : t.trim(),
      )
      if (
        (this.setTemplate(
          e ?? '<span class="ag-overlay-no-rows-center"></span>',
        ),
        !e)
      ) {
        const i = this.localeService.getLocaleTextFunc()
        setTimeout(() => {
          this.getGui().textContent = i('noRowsToShow', 'No Rows To Show')
        })
      }
    }
  },
  Ar = class extends yt {
    isPopup() {
      return !0
    }
    setParentComponent(e) {
      e.addCssClass('ag-has-popup'), super.setParentComponent(e)
    }
    destroy() {
      const e = this.parentComponent
      e && e.isAlive() && e.getGui().classList.remove('ag-has-popup'),
        super.destroy()
    }
  },
  zD = class extends Ar {
    constructor() {
      super('<div class="ag-tooltip"></div>')
    }
    init(e) {
      const { value: t } = e
      this.getGui().textContent = hs(t, !0)
    }
  }
function iv(e) {
  const {
    inputValue: t,
    allSuggestions: i,
    hideIrrelevant: s,
    filterByPercentageOfBestMatch: n,
    addSequentialWeight: r,
  } = e
  let o = i.map((c, u) => ({
    value: c,
    relevance: jD(t.toLowerCase(), c.toLocaleLowerCase(), r),
    idx: u,
  }))
  if (
    (o.sort((c, u) => u.relevance - c.relevance),
    s && (o = o.filter((c) => c.relevance !== 0)),
    o.length > 0 && n && n > 0)
  ) {
    const u = o[0].relevance * n
    o = o.filter((h) => u - h.relevance < 0)
  }
  const a = [],
    l = []
  for (const c of o) a.push(c.value), l.push(c.idx)
  return { values: a, indices: l }
}
function UD(e) {
  const t = [],
    i = e.length
  for (let s = 1; s <= i; s++)
    for (let n = 0; n <= i - s; n++) {
      const r = n + s - 1
      t.push(e.slice(n, r + 1))
    }
  return t
}
function jD(e, t, i = !1) {
  const s = e.replace(/\s/g, ''),
    n = t.replace(/\s/g, ''),
    r = s.length,
    o = n.length,
    a = new Array(r + 1).fill(null).map(() => new Array(o + 1).fill(0))
  for (let h = 0; h <= r; h += 1) a[h][0] = h
  for (let h = 0; h <= o; h += 1) a[0][h] = h
  for (let h = 1; h <= r; h++)
    for (let g = 1; g <= o; g++)
      s[h - 1] === n[g - 1]
        ? (a[h][g] = a[h - 1][g - 1])
        : (a[h][g] =
            1 + Math.min(a[h][g - 1], Math.min(a[h - 1][g], a[h - 1][g - 1])))
  const l = a[r][o]
  let u = Math.max(r, o) - l
  if (i) {
    const h = UD(s)
    for (let g = 0; g < h.length; g++) {
      const f = h[g]
      n.indexOf(f) !== -1 && ((u += 1), (u *= f.length))
    }
  }
  return u
}
var YD = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'userComponentRegistry'),
        (this.agGridDefaults = {
          agDragAndDropImage: MD,
          agColumnHeader: eu,
          agColumnGroupHeader: OD,
          agSortIndicator: hd,
          agAnimateShowChangeCellRenderer: HD,
          agAnimateSlideCellRenderer: ND,
          agLoadingCellRenderer: VD,
          agSkeletonCellRenderer: _D,
          agCheckboxCellRenderer: BD,
          agLoadingOverlay: WD,
          agNoRowsOverlay: $D,
          agTooltipComponent: zD,
        }),
        (this.agGridDefaultParams = {}),
        (this.enterpriseAgDefaultCompsModule = {
          agSetColumnFilter: '@ag-grid-enterprise/set-filter',
          agSetColumnFloatingFilter: '@ag-grid-enterprise/set-filter',
          agMultiColumnFilter: '@ag-grid-enterprise/multi-filter',
          agMultiColumnFloatingFilter: '@ag-grid-enterprise/multi-filter',
          agGroupColumnFilter: '@ag-grid-enterprise/row-grouping',
          agGroupColumnFloatingFilter: '@ag-grid-enterprise/row-grouping',
          agGroupCellRenderer: '@ag-grid-enterprise/row-grouping',
          agGroupRowRenderer: '@ag-grid-enterprise/row-grouping',
          agRichSelect: '@ag-grid-enterprise/rich-select',
          agRichSelectCellEditor: '@ag-grid-enterprise/rich-select',
          agDetailCellRenderer: '@ag-grid-enterprise/master-detail',
          agSparklineCellRenderer: '@ag-grid-enterprise/sparklines',
        }),
        (this.jsComps = {})
    }
    postConstruct() {
      const e = this.gos.get('components')
      e != null && Qi(e, (t, i) => this.registerJsComponent(t, i))
    }
    registerDefaultComponent(e, t, i) {
      ;(this.agGridDefaults[e] = t), i && (this.agGridDefaultParams[e] = i)
    }
    registerJsComponent(e, t) {
      this.jsComps[e] = t
    }
    retrieve(e, t) {
      const i = (a, l, c) => ({
          componentFromFramework: l,
          component: a,
          params: c,
        }),
        s = this.getFrameworkOverrides().frameworkComponent(
          t,
          this.gos.get('components'),
        )
      if (s != null) return i(s, !0)
      const n = this.jsComps[t]
      if (n) {
        const a = this.getFrameworkOverrides().isFrameworkComponent(n)
        return i(n, a)
      }
      const r = this.agGridDefaults[t]
      if (r) return i(r, !1, this.agGridDefaultParams[t])
      const o = this.enterpriseAgDefaultCompsModule[t]
      return (
        o
          ? this.gos.assertModuleRegistered(o, `AG Grid '${e}' component: ${t}`)
          : Xu(() => {
              this.warnAboutMissingComponent(e, t)
            }, 'MissingComp' + t),
        null
      )
    }
    warnAboutMissingComponent(e, t) {
      const i = [
          ...Object.keys(this.agGridDefaults).filter(
            (n) =>
              ![
                'agCellEditor',
                'agGroupRowRenderer',
                'agSortIndicator',
              ].includes(n),
          ),
          ...Object.keys(this.jsComps),
        ],
        s = iv({
          inputValue: t,
          allSuggestions: i,
          hideIrrelevant: !0,
          filterByPercentageOfBestMatch: 0.8,
        }).values
      te(
        `Could not find '${t}' component. It was configured as "${e}: '${t}'" but it wasn't found in the list of registered components.`,
      ),
        s.length > 0 && te(`         Did you mean: [${s.slice(0, 3)}]?`),
        te(
          `If using a custom component check it has been registered as described in: ${this.getFrameworkOverrides().getDocLink('components/')}`,
        )
    }
  },
  Nt = class to {
    constructor(t) {
      ;(this.status = 0),
        (this.resolution = null),
        (this.waiters = []),
        t(
          (i) => this.onDone(i),
          (i) => this.onReject(i),
        )
    }
    static all(t) {
      return t.length
        ? new to((i) => {
            let s = t.length
            const n = new Array(s)
            t.forEach((r, o) => {
              r.then((a) => {
                ;(n[o] = a), s--, s === 0 && i(n)
              })
            })
          })
        : to.resolve()
    }
    static resolve(t = null) {
      return new to((i) => i(t))
    }
    then(t) {
      return new to((i) => {
        this.status === 1
          ? i(t(this.resolution))
          : this.waiters.push((s) => i(t(s)))
      })
    }
    onDone(t) {
      ;(this.status = 1),
        (this.resolution = t),
        this.waiters.forEach((i) => i(t))
    }
    onReject(t) {}
  },
  KD = { propertyName: 'dateComponent', cellRenderer: !1 },
  qD = { propertyName: 'dragAndDropImageComponent', cellRenderer: !1 },
  QD = { propertyName: 'headerComponent', cellRenderer: !1 },
  XD = { propertyName: 'headerGroupComponent', cellRenderer: !1 },
  wg = { propertyName: 'cellRenderer', cellRenderer: !0 },
  JD = { propertyName: 'cellRenderer', cellRenderer: !1 },
  ZD = { propertyName: 'loadingCellRenderer', cellRenderer: !0 },
  eM = { propertyName: 'cellEditor', cellRenderer: !1 },
  yg = { propertyName: 'innerRenderer', cellRenderer: !0 },
  tM = { propertyName: 'loadingOverlayComponent', cellRenderer: !1 },
  iM = { propertyName: 'noRowsOverlayComponent', cellRenderer: !1 },
  sM = { propertyName: 'tooltipComponent', cellRenderer: !1 },
  pd = { propertyName: 'filter', cellRenderer: !1 },
  nM = { propertyName: 'floatingFilterComponent', cellRenderer: !1 },
  rM = { propertyName: 'toolPanel', cellRenderer: !1 },
  oM = { propertyName: 'statusPanel', cellRenderer: !1 },
  aM = { propertyName: 'fullWidthCellRenderer', cellRenderer: !0 },
  lM = { propertyName: 'loadingCellRenderer', cellRenderer: !0 },
  cM = { propertyName: 'groupRowRenderer', cellRenderer: !0 },
  uM = { propertyName: 'detailCellRenderer', cellRenderer: !0 },
  dM = { propertyName: 'menuItem', cellRenderer: !1 },
  sv = class nv extends X {
    constructor() {
      super(...arguments), (this.beanName = 'userComponentFactory')
    }
    wireBeans(t) {
      ;(this.agComponentUtils = t.agComponentUtils),
        (this.componentMetadataProvider = t.componentMetadataProvider),
        (this.userComponentRegistry = t.userComponentRegistry),
        (this.frameworkComponentWrapper = t.frameworkComponentWrapper),
        (this.gridOptions = t.gridOptions)
    }
    getDragAndDropImageCompDetails(t) {
      return this.getCompDetails(
        this.gridOptions,
        qD,
        'agDragAndDropImage',
        t,
        !0,
      )
    }
    getHeaderCompDetails(t, i) {
      return this.getCompDetails(t, QD, 'agColumnHeader', i)
    }
    getHeaderGroupCompDetails(t) {
      const i = t.columnGroup.getColGroupDef()
      return this.getCompDetails(i, XD, 'agColumnGroupHeader', t)
    }
    getFullWidthCellRendererDetails(t) {
      return this.getCompDetails(this.gridOptions, aM, null, t, !0)
    }
    getFullWidthLoadingCellRendererDetails(t) {
      return this.getCompDetails(
        this.gridOptions,
        lM,
        'agLoadingCellRenderer',
        t,
        !0,
      )
    }
    getFullWidthGroupCellRendererDetails(t) {
      return this.getCompDetails(
        this.gridOptions,
        cM,
        'agGroupRowRenderer',
        t,
        !0,
      )
    }
    getFullWidthDetailCellRendererDetails(t) {
      return this.getCompDetails(
        this.gridOptions,
        uM,
        'agDetailCellRenderer',
        t,
        !0,
      )
    }
    getInnerRendererDetails(t, i) {
      return this.getCompDetails(t, yg, null, i)
    }
    getFullWidthGroupRowInnerCellRenderer(t, i) {
      return this.getCompDetails(t, yg, null, i)
    }
    getCellRendererDetails(t, i) {
      return this.getCompDetails(t, wg, null, i)
    }
    getEditorRendererDetails(t, i) {
      return this.getCompDetails(t, JD, null, i)
    }
    getLoadingCellRendererDetails(t, i) {
      return this.getCompDetails(t, ZD, 'agSkeletonCellRenderer', i, !0)
    }
    getCellEditorDetails(t, i) {
      return this.getCompDetails(t, eM, 'agCellEditor', i, !0)
    }
    getFilterDetails(t, i, s) {
      return this.getCompDetails(t, pd, s, i, !0)
    }
    getDateCompDetails(t) {
      return this.getCompDetails(this.gridOptions, KD, 'agDateInput', t, !0)
    }
    getLoadingOverlayCompDetails(t) {
      return this.getCompDetails(
        this.gridOptions,
        tM,
        'agLoadingOverlay',
        t,
        !0,
      )
    }
    getNoRowsOverlayCompDetails(t) {
      return this.getCompDetails(this.gridOptions, iM, 'agNoRowsOverlay', t, !0)
    }
    getTooltipCompDetails(t) {
      return this.getCompDetails(t.colDef, sM, 'agTooltipComponent', t, !0)
    }
    getSetFilterCellRendererDetails(t, i) {
      return this.getCompDetails(t, wg, null, i)
    }
    getFloatingFilterCompDetails(t, i, s) {
      return this.getCompDetails(t, nM, s, i)
    }
    getToolPanelCompDetails(t, i) {
      return this.getCompDetails(t, rM, null, i, !0)
    }
    getStatusPanelCompDetails(t, i) {
      return this.getCompDetails(t, oM, null, i, !0)
    }
    getMenuItemCompDetails(t, i) {
      return this.getCompDetails(t, dM, 'agMenuItem', i, !0)
    }
    getCompDetails(t, i, s, n, r = !1) {
      const { propertyName: o, cellRenderer: a } = i
      let {
          compName: l,
          jsComp: c,
          fwComp: u,
          paramsFromSelector: h,
          popupFromSelector: g,
          popupPositionFromSelector: f,
        } = nv.getCompKeys(this.frameworkOverrides, t, i, n),
        p
      const v = (S) => {
        const y = this.userComponentRegistry.retrieve(o, S)
        y &&
          ((c = y.componentFromFramework ? void 0 : y.component),
          (u = y.componentFromFramework ? y.component : void 0),
          (p = y.params))
      }
      if (
        (l != null && v(l),
        c == null && u == null && s != null && v(s),
        c &&
          a &&
          !this.agComponentUtils.doesImplementIComponent(c) &&
          (c = this.agComponentUtils.adaptFunction(o, c)),
        !c && !u)
      ) {
        r &&
          ht(
            `Could not find component ${l}, did you forget to configure this component?`,
          )
        return
      }
      const m = this.mergeParamsWithApplicationProvidedParams(t, i, n, h, p),
        C = c == null,
        w = c || u
      return {
        componentFromFramework: C,
        componentClass: w,
        params: m,
        type: i,
        popupFromSelector: g,
        popupPositionFromSelector: f,
        newAgStackInstance: () => this.newAgStackInstance(w, C, m, i),
      }
    }
    static getCompKeys(t, i, s, n) {
      const { propertyName: r } = s
      let o, a, l, c, u, h
      if (i) {
        const g = i,
          f = g[r + 'Selector'],
          p = f ? f(n) : null,
          v = (m) => {
            typeof m == 'string'
              ? (o = m)
              : m != null &&
                m !== !0 &&
                (t.isFrameworkComponent(m) ? (l = m) : (a = m))
          }
        p
          ? (v(p.component),
            (c = p.params),
            (u = p.popup),
            (h = p.popupPosition))
          : v(g[r])
      }
      return {
        compName: o,
        jsComp: a,
        fwComp: l,
        paramsFromSelector: c,
        popupFromSelector: u,
        popupPositionFromSelector: h,
      }
    }
    newAgStackInstance(t, i, s, n) {
      const r = n.propertyName,
        o = !i
      let a
      if (o) a = new t()
      else {
        const c = this.componentMetadataProvider.retrieve(r)
        a = this.frameworkComponentWrapper.wrap(
          t,
          c.mandatoryMethodList,
          c.optionalMethodList,
          n,
        )
      }
      const l = this.initComponent(a, s)
      return l == null ? Nt.resolve(a) : l.then(() => a)
    }
    mergeParamsWithApplicationProvidedParams(t, i, s, n = null, r) {
      const o = this.gos.getGridCommonParams()
      yi(o, s), r && yi(o, r)
      const a = t,
        l = a && a[i.propertyName + 'Params']
      if (typeof l == 'function') {
        const c = l(s)
        yi(o, c)
      } else typeof l == 'object' && yi(o, l)
      return yi(o, n), o
    }
    initComponent(t, i) {
      if ((this.createBean(t), t.init != null)) return t.init(i)
    }
  }
function ao(e) {
  const t = e
  return t != null && t.getFrameworkComponentInstance != null
    ? t.getFrameworkComponentInstance()
    : e
}
var vl = class dt {
  static register(t) {
    dt.__register(t, !0, void 0)
  }
  static registerModules(t) {
    dt.__registerModules(t, !0, void 0)
  }
  static __register(t, i, s) {
    dt.runVersionChecks(t),
      s !== void 0
        ? ((dt.areGridScopedModules = !0),
          dt.gridModulesMap[s] === void 0 && (dt.gridModulesMap[s] = {}),
          (dt.gridModulesMap[s][t.moduleName] = t))
        : (dt.globalModulesMap[t.moduleName] = t),
      dt.setModuleBased(i)
  }
  static __unRegisterGridModules(t) {
    delete dt.gridModulesMap[t]
  }
  static __registerModules(t, i, s) {
    dt.setModuleBased(i), t && t.forEach((n) => dt.__register(n, i, s))
  }
  static isValidModuleVersion(t) {
    const [i, s] = t.version.split('.') || [],
      [n, r] = dt.currentModuleVersion.split('.') || []
    return i === n && s === r
  }
  static runVersionChecks(t) {
    dt.currentModuleVersion || (dt.currentModuleVersion = t.version)
    const i = (s) =>
      `You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. ${s} Please update all modules to the same version.`
    if (
      (t.version
        ? dt.isValidModuleVersion(t) ||
          ht(
            i(
              `'${t.moduleName}' is version ${t.version} but the other modules are version ${dt.currentModuleVersion}.`,
            ),
          )
        : ht(i(`'${t.moduleName}' is incompatible.`)),
      t.validate)
    ) {
      const s = t.validate()
      s.isValid || ht(`${s.message}`)
    }
  }
  static setModuleBased(t) {
    dt.moduleBased === void 0
      ? (dt.moduleBased = t)
      : dt.moduleBased !== t &&
        (ht(
          'AG Grid: You are mixing modules (i.e. @ag-grid-community/core) and packages (ag-grid-community) - you can only use one or the other of these mechanisms.',
        ),
        ht(
          'Please see https://www.ag-grid.com/javascript-grid/modules/ for more information.',
        ))
  }
  static __setIsBundled() {
    dt.isBundled = !0
  }
  static __assertRegistered(t, i, s) {
    var r
    if (this.__isRegistered(t, s)) return !0
    let n
    if (dt.isBundled)
      n = `AG Grid: unable to use ${i} as 'ag-grid-enterprise' has not been loaded. Check you are using the Enterprise bundle:
        
        <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@AG_GRID_VERSION/dist/ag-grid-enterprise.min.js"><\/script>
        
For more info see: https://ag-grid.com/javascript-data-grid/getting-started/#getting-started-with-ag-grid-enterprise`
    else if (dt.moduleBased || dt.moduleBased === void 0) {
      const o =
        (r = Object.entries(pm).find(([a, l]) => l === t)) == null
          ? void 0
          : r[0]
      n = `AG Grid: unable to use ${i} as the ${o} is not registered${dt.areGridScopedModules ? ` for gridId: ${s}` : ''}. Check if you have registered the module:
           
    import { ModuleRegistry } from '@ag-grid-community/core';
    import { ${o} } from '${t}';
    
    ModuleRegistry.registerModules([ ${o} ]);

For more info see: https://www.ag-grid.com/javascript-grid/modules/`
    } else
      n = `AG Grid: unable to use ${i} as package 'ag-grid-enterprise' has not been imported. Check that you have imported the package:
            
    import 'ag-grid-enterprise';`
    return ht(n), !1
  }
  static __isRegistered(t, i) {
    var s
    return (
      !!dt.globalModulesMap[t] || !!((s = dt.gridModulesMap[i]) != null && s[t])
    )
  }
  static __getRegisteredModules(t) {
    return [...ua(dt.globalModulesMap), ...ua(dt.gridModulesMap[t] || {})]
  }
  static __getGridRegisteredModules(t) {
    return ua(dt.gridModulesMap[t] ?? {}) || []
  }
  static __isPackageBased() {
    return !dt.moduleBased
  }
}
vl.globalModulesMap = {}
vl.gridModulesMap = {}
vl.areGridScopedModules = !1
var us = vl,
  hM = class {
    constructor(e) {
      ;(this.beans = {}),
        (this.createdBeans = []),
        (this.destroyed = !1),
        !(!e || !e.beanClasses) &&
          ((this.beanDestroyComparator = e.beanDestroyComparator), this.init(e))
    }
    init(e) {
      var t
      Object.entries(e.providedBeanInstances).forEach(([i, s]) => {
        this.beans[i] = s
      }),
        e.beanClasses.forEach((i) => {
          const s = new i()
          s.beanName
            ? (this.beans[s.beanName] = s)
            : console.error(`Bean ${i.name} is missing beanName`),
            this.createdBeans.push(s)
        }),
        (t = e.derivedBeans) == null ||
          t.forEach((i) => {
            const { beanName: s, bean: n } = i(this)
            ;(this.beans[s] = n), this.createdBeans.push(n)
          }),
        e.beanInitComparator && this.createdBeans.sort(e.beanInitComparator),
        this.initBeans(this.createdBeans)
    }
    getBeanInstances() {
      return Object.values(this.beans)
    }
    createBean(e, t) {
      if (!e) throw Error("Can't wire to bean since it is null")
      return this.initBeans([e], t), e
    }
    initBeans(e, t) {
      e.forEach((i) => {
        var s, n
        ;(s = i.preWireBeans) == null || s.call(i, this.beans),
          (n = i.wireBeans) == null || n.call(i, this.beans)
      }),
        e.forEach((i) => {
          var s
          return (s = i.preConstruct) == null ? void 0 : s.call(i)
        }),
        t && e.forEach(t),
        e.forEach((i) => {
          var s
          return (s = i.postConstruct) == null ? void 0 : s.call(i)
        })
    }
    getBeans() {
      return this.beans
    }
    getBean(e) {
      return this.beans[e]
    }
    destroy() {
      if (this.destroyed) return
      this.destroyed = !0
      const e = this.getBeanInstances()
      this.beanDestroyComparator && e.sort(this.beanDestroyComparator),
        this.destroyBeans(e),
        (this.beans = {}),
        (this.createdBeans = [])
    }
    destroyBean(e) {
      var t
      ;(t = e == null ? void 0 : e.destroy) == null || t.call(e)
    }
    destroyBeans(e) {
      if (e) for (let t = 0; t < e.length; t++) this.destroyBean(e[t])
      return []
    }
    isDestroyed() {
      return this.destroyed
    }
  },
  gM = class extends hM {
    init(e) {
      ;(this.gridId = e.gridId), (this.beans.context = this), super.init(e)
    }
    destroy() {
      super.destroy(), us.__unRegisterGridModules(this.gridId)
    }
    getGridId() {
      return this.gridId
    }
  },
  rv = ((e) => ((e[(e.Left = 0)] = 'Left'), (e[(e.Right = 1)] = 'Right'), e))(
    rv || {},
  ),
  fM = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'dragAndDropService'),
        (this.dragSourceAndParamsList = []),
        (this.dropTargets = [])
    }
    wireBeans(e) {
      ;(this.ctrlsService = e.ctrlsService),
        (this.dragService = e.dragService),
        (this.mouseEventService = e.mouseEventService),
        (this.environment = e.environment),
        (this.userComponentFactory = e.userComponentFactory)
    }
    addDragSource(e, t = !1) {
      const i = {
        eElement: e.eElement,
        dragStartPixels: e.dragStartPixels,
        onDragStart: this.onDragStart.bind(this, e),
        onDragStop: this.onDragStop.bind(this),
        onDragging: this.onDragging.bind(this),
        onDragCancel: this.onDragCancel.bind(this),
        includeTouch: t,
      }
      this.dragSourceAndParamsList.push({ params: i, dragSource: e }),
        this.dragService.addDragSource(i)
    }
    getDragAndDropImageComponent() {
      const { dragAndDropImageComp: e } = this
      return !e || !e.comp ? null : e.comp
    }
    removeDragSource(e) {
      const t = this.dragSourceAndParamsList.find((i) => i.dragSource === e)
      t &&
        (this.dragService.removeDragSource(t.params),
        Ri(this.dragSourceAndParamsList, t))
    }
    destroy() {
      this.dragSourceAndParamsList.forEach((e) =>
        this.dragService.removeDragSource(e.params),
      ),
        (this.dragSourceAndParamsList.length = 0),
        (this.dropTargets.length = 0),
        this.clearDragAndDropProperties(),
        super.destroy()
    }
    nudge() {
      this.dragging && this.onDragging(this.eventLastTime, !0)
    }
    onDragStart(e, t) {
      var i, s
      ;(this.dragging = !0),
        (this.dragSource = e),
        (this.eventLastTime = t),
        (this.dragItem = this.dragSource.getDragItem()),
        (s = (i = this.dragSource).onDragStarted) == null || s.call(i),
        this.createDragAndDropImageComponent()
    }
    onDragStop(e) {
      var t, i, s
      if (
        ((i = (t = this.dragSource) == null ? void 0 : t.onDragStopped) ==
          null || i.call(t),
        (s = this.lastDropTarget) != null && s.onDragStop)
      ) {
        const n = this.createDropTargetEvent(
          this.lastDropTarget,
          e,
          null,
          null,
          !1,
        )
        this.lastDropTarget.onDragStop(n)
      }
      this.clearDragAndDropProperties()
    }
    onDragCancel() {
      var e, t, i
      ;(t = (e = this.dragSource) == null ? void 0 : e.onDragCancelled) ==
        null || t.call(e),
        (i = this.lastDropTarget) != null &&
          i.onDragCancel &&
          this.lastDropTarget.onDragCancel(
            this.createDropTargetEvent(
              this.lastDropTarget,
              this.eventLastTime,
              null,
              null,
              !1,
            ),
          ),
        this.clearDragAndDropProperties()
    }
    clearDragAndDropProperties() {
      ;(this.eventLastTime = null),
        (this.dragging = !1),
        (this.lastDropTarget = void 0),
        (this.dragItem = null),
        (this.dragSource = null),
        this.removeDragAndDropImageComponent()
    }
    onDragging(e, t = !1) {
      var o, a, l, c
      const i = this.getHorizontalDirection(e),
        s = this.getVerticalDirection(e)
      ;(this.eventLastTime = e), this.positionDragAndDropImageComp(e)
      const n = this.dropTargets.filter((u) => this.isMouseOnDropTarget(e, u)),
        r = this.findCurrentDropTarget(e, n)
      if (r !== this.lastDropTarget) {
        if (
          (this.leaveLastTargetIfExists(e, i, s, t),
          this.lastDropTarget !== null &&
            r === null &&
            ((a = (o = this.dragSource) == null ? void 0 : o.onGridExit) ==
              null ||
              a.call(o, this.dragItem)),
          this.lastDropTarget === null &&
            r !== null &&
            ((c = (l = this.dragSource) == null ? void 0 : l.onGridEnter) ==
              null ||
              c.call(l, this.dragItem)),
          this.enterDragTargetIfExists(r, e, i, s, t),
          r && this.dragAndDropImageComp)
        ) {
          const { comp: u, promise: h } = this.dragAndDropImageComp
          u
            ? u.setIcon(r.getIconName ? r.getIconName() : null)
            : h.then((g) => {
                g && g.setIcon(r.getIconName ? r.getIconName() : null)
              })
        }
        this.lastDropTarget = r
      } else if (r && r.onDragging) {
        const u = this.createDropTargetEvent(r, e, i, s, t)
        r.onDragging(u)
      }
    }
    getAllContainersFromDropTarget(e) {
      const t = e.getSecondaryContainers ? e.getSecondaryContainers() : null,
        i = [[e.getContainer()]]
      return t ? i.concat(t) : i
    }
    allContainersIntersect(e, t) {
      for (const i of t) {
        const {
          width: s,
          height: n,
          left: r,
          right: o,
          top: a,
          bottom: l,
        } = i.getBoundingClientRect()
        if (s === 0 || n === 0) return !1
        const c = e.clientX >= r && e.clientX < o,
          u = e.clientY >= a && e.clientY < l
        if (!c || !u) return !1
      }
      return !0
    }
    isMouseOnDropTarget(e, t) {
      const i = this.getAllContainersFromDropTarget(t)
      let s = !1
      for (const o of i)
        if (this.allContainersIntersect(e, o)) {
          s = !0
          break
        }
      const { eElement: n, type: r } = this.dragSource
      return t.targetContainsSource && !t.getContainer().contains(n)
        ? !1
        : s && t.isInterestedIn(r, n)
    }
    findCurrentDropTarget(e, t) {
      const i = t.length
      if (i === 0) return null
      if (i === 1) return t[0]
      const n = vo(this.gos).elementsFromPoint(e.clientX, e.clientY)
      for (const r of n)
        for (const o of t)
          if (Fx(this.getAllContainersFromDropTarget(o)).indexOf(r) !== -1)
            return o
      return null
    }
    enterDragTargetIfExists(e, t, i, s, n) {
      if (e && e.onDragEnter) {
        const r = this.createDropTargetEvent(e, t, i, s, n)
        e.onDragEnter(r)
      }
    }
    leaveLastTargetIfExists(e, t, i, s) {
      if (!this.lastDropTarget) return
      if (this.lastDropTarget.onDragLeave) {
        const r = this.createDropTargetEvent(this.lastDropTarget, e, t, i, s)
        this.lastDropTarget.onDragLeave(r)
      }
      const n = this.getDragAndDropImageComponent()
      n && n.setIcon(null)
    }
    addDropTarget(e) {
      this.dropTargets.push(e)
    }
    removeDropTarget(e) {
      this.dropTargets = this.dropTargets.filter(
        (t) => t.getContainer() !== e.getContainer(),
      )
    }
    hasExternalDropZones() {
      return this.dropTargets.some((e) => e.external)
    }
    findExternalZone(e) {
      return (
        this.dropTargets
          .filter((i) => i.external)
          .find((i) => i.getContainer() === e.getContainer()) || null
      )
    }
    isDropZoneWithinThisGrid(e) {
      const i = this.ctrlsService.getGridBodyCtrl().getGui(),
        { dropZoneTarget: s } = e
      return i.contains(s)
    }
    getHorizontalDirection(e) {
      const t = this.eventLastTime && this.eventLastTime.clientX,
        i = e.clientX
      return t === i ? null : t > i ? 0 : 1
    }
    getVerticalDirection(e) {
      const t = this.eventLastTime && this.eventLastTime.clientY,
        i = e.clientY
      return t === i ? null : t > i ? 0 : 1
    }
    createDropTargetEvent(e, t, i, s, n) {
      const r = e.getContainer(),
        o = r.getBoundingClientRect(),
        { dragItem: a, dragSource: l } = this,
        c = t.clientX - o.left,
        u = t.clientY - o.top
      return this.gos.addGridCommonParams({
        event: t,
        x: c,
        y: u,
        vDirection: s,
        hDirection: i,
        dragSource: l,
        fromNudge: n,
        dragItem: a,
        dropZoneTarget: r,
      })
    }
    positionDragAndDropImageComp(e) {
      const t = this.getDragAndDropImageComponent()
      if (!t) return
      const i = t.getGui(),
        n = i.getBoundingClientRect().height,
        r = fD() - 2,
        o = pD() - 2
      if (!i.offsetParent) return
      const l = Ym(i.offsetParent),
        { clientY: c, clientX: u } = e
      let h = c - l.top - n / 2,
        g = u - l.left - 10
      const f = Gt(this.gos),
        p = f.defaultView || window,
        v = p.pageYOffset || f.documentElement.scrollTop,
        m = p.pageXOffset || f.documentElement.scrollLeft
      r > 0 && g + i.clientWidth > r + m && (g = r + m - i.clientWidth),
        g < 0 && (g = 0),
        o > 0 && h + i.clientHeight > o + v && (h = o + v - i.clientHeight),
        h < 0 && (h = 0),
        (i.style.left = `${g}px`),
        (i.style.top = `${h}px`)
    }
    removeDragAndDropImageComponent() {
      if (this.dragAndDropImageComp) {
        const { comp: e } = this.dragAndDropImageComp
        if (e) {
          const t = e.getGui()
          this.dragAndDropImageParent &&
            this.dragAndDropImageParent.removeChild(t),
            this.destroyBean(e)
        }
      }
      this.dragAndDropImageComp = null
    }
    createDragAndDropImageComponent() {
      const { dragSource: e } = this
      if (!e) return
      const i = this.userComponentFactory
        .getDragAndDropImageCompDetails({ dragSource: e })
        .newAgStackInstance()
      ;(this.dragAndDropImageComp = { promise: i }),
        i.then((s) => {
          !s ||
            !this.isAlive() ||
            (this.processDragAndDropImageComponent(s),
            (this.dragAndDropImageComp.comp = s))
        })
    }
    processDragAndDropImageComponent(e) {
      const { dragSource: t, mouseEventService: i, environment: s } = this
      if (!t) return
      const n = e.getGui()
      n.style.setProperty('position', 'absolute'),
        n.style.setProperty('z-index', '9999'),
        i.stampTopLevelGridCompWithGridInstance(n),
        s.applyThemeClasses(n),
        e.setIcon(null)
      let { dragItemName: r } = t
      Ju(r) && (r = r()),
        e.setLabel(r || ''),
        (n.style.top = '20px'),
        (n.style.left = '20px')
      const o = Gt(this.gos)
      let a = null,
        l = null
      try {
        a = o.fullscreenElement
      } catch {
      } finally {
        a || (a = vo(this.gos))
        const c = a.querySelector('body')
        c
          ? (l = c)
          : a instanceof ShadowRoot
            ? (l = a)
            : a instanceof Document
              ? (l = a == null ? void 0 : a.documentElement)
              : (l = a)
      }
      ;(this.dragAndDropImageParent = l),
        l
          ? l.appendChild(n)
          : te('Could not find document body, it is needed for drag and drop.')
    }
  },
  pM = class {
    constructor(e) {
      ;(this.tickingInterval = null),
        (this.onScrollCallback = null),
        (this.scrollContainer = e.scrollContainer),
        (this.scrollHorizontally = e.scrollAxis.indexOf('x') !== -1),
        (this.scrollVertically = e.scrollAxis.indexOf('y') !== -1),
        (this.scrollByTick = e.scrollByTick != null ? e.scrollByTick : 20),
        e.onScrollCallback && (this.onScrollCallback = e.onScrollCallback),
        this.scrollVertically &&
          ((this.getVerticalPosition = e.getVerticalPosition),
          (this.setVerticalPosition = e.setVerticalPosition)),
        this.scrollHorizontally &&
          ((this.getHorizontalPosition = e.getHorizontalPosition),
          (this.setHorizontalPosition = e.setHorizontalPosition)),
        (this.shouldSkipVerticalScroll =
          e.shouldSkipVerticalScroll || (() => !1)),
        (this.shouldSkipHorizontalScroll =
          e.shouldSkipHorizontalScroll || (() => !1))
    }
    check(e, t = !1) {
      const i = t || this.shouldSkipVerticalScroll()
      if (i && this.shouldSkipHorizontalScroll()) return
      const s = this.scrollContainer.getBoundingClientRect(),
        n = this.scrollByTick
      ;(this.tickLeft = e.clientX < s.left + n),
        (this.tickRight = e.clientX > s.right - n),
        (this.tickUp = e.clientY < s.top + n && !i),
        (this.tickDown = e.clientY > s.bottom - n && !i),
        this.tickLeft || this.tickRight || this.tickUp || this.tickDown
          ? this.ensureTickingStarted()
          : this.ensureCleared()
    }
    ensureTickingStarted() {
      this.tickingInterval === null &&
        ((this.tickingInterval = window.setInterval(
          this.doTick.bind(this),
          100,
        )),
        (this.tickCount = 0))
    }
    doTick() {
      this.tickCount++
      const e = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40
      if (this.scrollVertically) {
        const t = this.getVerticalPosition()
        this.tickUp && this.setVerticalPosition(t - e),
          this.tickDown && this.setVerticalPosition(t + e)
      }
      if (this.scrollHorizontally) {
        const t = this.getHorizontalPosition()
        this.tickLeft && this.setHorizontalPosition(t - e),
          this.tickRight && this.setHorizontalPosition(t + e)
      }
      this.onScrollCallback && this.onScrollCallback()
    }
    ensureCleared() {
      this.tickingInterval &&
        (window.clearInterval(this.tickingInterval),
        (this.tickingInterval = null))
    }
  },
  mM = class extends X {
    wireBeans(e) {
      ;(this.dragAndDropService = e.dragAndDropService),
        (this.rowModel = e.rowModel),
        (this.pageBoundsService = e.pageBoundsService),
        (this.focusService = e.focusService),
        (this.sortController = e.sortController),
        (this.filterManager = e.filterManager),
        (this.selectionService = e.selectionService),
        (this.mouseEventService = e.mouseEventService),
        (this.ctrlsService = e.ctrlsService),
        (this.funcColsService = e.funcColsService),
        (this.rangeService = e.rangeService)
    }
    constructor(e) {
      super(), (this.eContainer = e)
    }
    postConstruct() {
      Pt(this.gos) && (this.clientSideRowModel = this.rowModel),
        this.ctrlsService.whenReady(this, (e) => {
          const t = e.gridBodyCtrl
          this.autoScrollService = new pM({
            scrollContainer: t.getBodyViewportElement(),
            scrollAxis: 'y',
            getVerticalPosition: () =>
              t.getScrollFeature().getVScrollPosition().top,
            setVerticalPosition: (i) =>
              t.getScrollFeature().setVerticalScrollPosition(i),
            onScrollCallback: () => {
              this.onDragging(this.lastDraggingEvent)
            },
          })
        })
    }
    getContainer() {
      return this.eContainer
    }
    isInterestedIn(e) {
      return e === 2
    }
    getIconName() {
      return this.gos.get('rowDragManaged') && this.shouldPreventRowMove()
        ? 'notAllowed'
        : 'move'
    }
    shouldPreventRowMove() {
      var s
      return !!(
        this.funcColsService.getRowGroupColumns().length ||
        ((s = this.filterManager) == null ? void 0 : s.isAnyFilterPresent()) ||
        this.sortController.isSortActive()
      )
    }
    getRowNodes(e) {
      if (!this.isFromThisGrid(e)) return e.dragItem.rowNodes || []
      const t = e.dragItem.rowNode
      if (this.gos.get('rowDragMultiRow')) {
        const s = [...this.selectionService.getSelectedNodes()].sort((n, r) =>
          n.rowIndex == null || r.rowIndex == null
            ? 0
            : this.getRowIndexNumber(n) - this.getRowIndexNumber(r),
        )
        if (s.indexOf(t) !== -1) return s
      }
      return [t]
    }
    onDragEnter(e) {
      ;(e.dragItem.rowNodes = this.getRowNodes(e)),
        this.dispatchGridEvent('rowDragEnter', e),
        this.getRowNodes(e).forEach((t) => {
          t.setDragging(!0)
        }),
        this.onEnterOrDragging(e)
    }
    onDragging(e) {
      this.onEnterOrDragging(e)
    }
    isFromThisGrid(e) {
      const { dragSourceDomDataKey: t } = e.dragSource
      return t === this.gos.getDomDataKey()
    }
    onEnterOrDragging(e) {
      this.dispatchGridEvent('rowDragMove', e), (this.lastDraggingEvent = e)
      const t = this.mouseEventService.getNormalisedPosition(e).y
      this.gos.get('rowDragManaged') && this.doManagedDrag(e, t),
        this.autoScrollService.check(e.event)
    }
    doManagedDrag(e, t) {
      const i = this.isFromThisGrid(e),
        s = this.gos.get('rowDragManaged'),
        n = e.dragItem.rowNodes
      ;(s && this.shouldPreventRowMove()) ||
        (this.gos.get('suppressMoveWhenRowDragging') || !i
          ? this.dragAndDropService.isDropZoneWithinThisGrid(e) &&
            this.clientSideRowModel.highlightRowAtPixel(n[0], t)
          : this.moveRows(n, t))
    }
    getRowIndexNumber(e) {
      const t = e.getRowIndexString()
      return parseInt(rt(t.split('-')), 10)
    }
    moveRowAndClearHighlight(e) {
      const t = this.clientSideRowModel.getLastHighlightedRowNode(),
        i = t && t.highlighted === 1,
        s = this.mouseEventService.getNormalisedPosition(e).y,
        n = e.dragItem.rowNodes
      let r = i ? 1 : 0
      if (this.isFromThisGrid(e))
        n.forEach((o) => {
          o.rowTop < s && (r -= 1)
        }),
          this.moveRows(n, s, r)
      else {
        const o = Mr(this.gos)
        let a = this.clientSideRowModel.getRowIndexAtPixel(s) + 1
        this.clientSideRowModel.getHighlightPosition(s) === 0 && a--,
          this.clientSideRowModel.updateRowData({
            add: n
              .filter(
                (l) =>
                  !this.clientSideRowModel.getRowNode(
                    (o == null
                      ? void 0
                      : o({
                          data: l.data,
                          level: 0,
                          rowPinned: l.rowPinned,
                        })) ?? l.data.id,
                  ),
              )
              .map((l) => l.data),
            addIndex: a,
          })
      }
      this.clearRowHighlight()
    }
    clearRowHighlight() {
      this.clientSideRowModel.highlightRowAtPixel(null)
    }
    moveRows(e, t, i = 0) {
      var n
      this.clientSideRowModel.ensureRowsAtPixel(e, t, i) &&
        (this.focusService.clearFocusedCell(),
        (n = this.rangeService) == null || n.removeAllCellRanges())
    }
    addRowDropZone(e) {
      if (!e.getContainer()) {
        te('addRowDropZone - A container target needs to be provided')
        return
      }
      if (this.dragAndDropService.findExternalZone(e)) {
        te(
          'addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.',
        )
        return
      }
      let t = { getContainer: e.getContainer }
      e.fromGrid
        ? (t = e)
        : (e.onDragEnter &&
            (t.onDragEnter = (s) => {
              e.onDragEnter(this.draggingToRowDragEvent('rowDragEnter', s))
            }),
          e.onDragLeave &&
            (t.onDragLeave = (s) => {
              e.onDragLeave(this.draggingToRowDragEvent('rowDragLeave', s))
            }),
          e.onDragging &&
            (t.onDragging = (s) => {
              e.onDragging(this.draggingToRowDragEvent('rowDragMove', s))
            }),
          e.onDragStop &&
            (t.onDragStop = (s) => {
              e.onDragStop(this.draggingToRowDragEvent('rowDragEnd', s))
            }),
          e.onDragCancel &&
            (t.onDragCancel = (s) => {
              e.onDragCancel(this.draggingToRowDragEvent('rowDragCancel', s))
            }))
      const i = {
        isInterestedIn: (s) => s === 2,
        getIconName: () => 'move',
        external: !0,
        ...t,
      }
      this.dragAndDropService.addDropTarget(i),
        this.addDestroyFunc(() => this.dragAndDropService.removeDropTarget(i))
    }
    getRowDropZone(e) {
      const t = this.getContainer.bind(this),
        i = this.onDragEnter.bind(this),
        s = this.onDragLeave.bind(this),
        n = this.onDragging.bind(this),
        r = this.onDragStop.bind(this),
        o = this.onDragCancel.bind(this)
      let a
      return (
        e
          ? (a = {
              getContainer: t,
              onDragEnter: e.onDragEnter
                ? (l) => {
                    i(l),
                      e.onDragEnter(
                        this.draggingToRowDragEvent('rowDragEnter', l),
                      )
                  }
                : i,
              onDragLeave: e.onDragLeave
                ? (l) => {
                    s(l),
                      e.onDragLeave(
                        this.draggingToRowDragEvent('rowDragLeave', l),
                      )
                  }
                : s,
              onDragging: e.onDragging
                ? (l) => {
                    n(l),
                      e.onDragging(
                        this.draggingToRowDragEvent('rowDragMove', l),
                      )
                  }
                : n,
              onDragStop: e.onDragStop
                ? (l) => {
                    r(l),
                      e.onDragStop(this.draggingToRowDragEvent('rowDragEnd', l))
                  }
                : r,
              onDragCancel: e.onDragCancel
                ? (l) => {
                    o(l),
                      e.onDragCancel(
                        this.draggingToRowDragEvent('rowDragCancel', l),
                      )
                  }
                : o,
              fromGrid: !0,
            })
          : (a = {
              getContainer: t,
              onDragEnter: i,
              onDragLeave: s,
              onDragging: n,
              onDragStop: r,
              onDragCancel: o,
              fromGrid: !0,
            }),
        a
      )
    }
    draggingToRowDragEvent(e, t) {
      const i = this.mouseEventService.getNormalisedPosition(t).y,
        s = i > this.pageBoundsService.getCurrentPageHeight()
      let n = -1,
        r
      s ||
        ((n = this.rowModel.getRowIndexAtPixel(i)),
        (r = this.rowModel.getRow(n)))
      let o
      switch (t.vDirection) {
        case 1:
          o = 'down'
          break
        case 0:
          o = 'up'
          break
        default:
          o = null
          break
      }
      return this.gos.addGridCommonParams({
        type: e,
        event: t.event,
        node: t.dragItem.rowNode,
        nodes: t.dragItem.rowNodes,
        overIndex: n,
        overNode: r,
        y: i,
        vDirection: o,
      })
    }
    dispatchGridEvent(e, t) {
      const i = this.draggingToRowDragEvent(e, t)
      this.eventService.dispatchEvent(i)
    }
    onDragLeave(e) {
      this.dispatchGridEvent('rowDragLeave', e),
        this.stopDragging(e),
        this.gos.get('rowDragManaged') && this.clearRowHighlight()
    }
    onDragStop(e) {
      this.dispatchGridEvent('rowDragEnd', e),
        this.stopDragging(e),
        this.gos.get('rowDragManaged') &&
          (this.gos.get('suppressMoveWhenRowDragging') ||
            !this.isFromThisGrid(e)) &&
          this.dragAndDropService.isDropZoneWithinThisGrid(e) &&
          this.moveRowAndClearHighlight(e)
    }
    onDragCancel(e) {
      this.dispatchGridEvent('rowDragCancel', e),
        this.stopDragging(e),
        this.gos.get('rowDragManaged') &&
          (this.gos.get('suppressMoveWhenRowDragging') ||
            !this.isFromThisGrid(e)) &&
          this.dragAndDropService.isDropZoneWithinThisGrid(e) &&
          this.clearRowHighlight()
    }
    stopDragging(e) {
      this.autoScrollService.ensureCleared(),
        this.getRowNodes(e).forEach((t) => {
          t.setDragging(!1)
        })
    }
  },
  vM = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'dragService'),
        (this.dragEndFunctions = []),
        (this.dragSources = [])
    }
    wireBeans(e) {
      this.mouseEventService = e.mouseEventService
    }
    destroy() {
      this.dragSources.forEach(this.removeListener.bind(this)),
        (this.dragSources.length = 0),
        super.destroy()
    }
    removeListener(e) {
      const t = e.dragSource.eElement,
        i = e.mouseDownListener
      if ((t.removeEventListener('mousedown', i), e.touchEnabled)) {
        const s = e.touchStartListener
        t.removeEventListener('touchstart', s, { passive: !0 })
      }
    }
    removeDragSource(e) {
      const t = this.dragSources.find((i) => i.dragSource === e)
      t && (this.removeListener(t), Ri(this.dragSources, t))
    }
    isDragging() {
      return this.dragging
    }
    addDragSource(e) {
      const t = this.onMouseDown.bind(this, e),
        { eElement: i, includeTouch: s, stopPropagationForTouch: n } = e
      i.addEventListener('mousedown', t)
      let r = null
      const o = this.gos.get('suppressTouch')
      s &&
        !o &&
        ((r = (a) => {
          ld(a.target) || (n && a.stopPropagation(), this.onTouchStart(e, a))
        }),
        i.addEventListener('touchstart', r, { passive: !1 })),
        this.dragSources.push({
          dragSource: e,
          mouseDownListener: t,
          touchStartListener: r,
          touchEnabled: !!s,
        })
    }
    getStartTarget() {
      return this.startTarget
    }
    onTouchStart(e, t) {
      ;(this.currentDragParams = e), (this.dragging = !1)
      const i = t.touches[0]
      ;(this.touchLastTime = i), (this.touchStart = i)
      const s = (l) => this.onTouchMove(l, e.eElement),
        n = (l) => this.onTouchUp(l, e.eElement),
        r = (l) => {
          l.cancelable && l.preventDefault()
        },
        o = t.target,
        a = [
          {
            target: vo(this.gos),
            type: 'touchmove',
            listener: r,
            options: { passive: !1 },
          },
          {
            target: o,
            type: 'touchmove',
            listener: s,
            options: { passive: !0 },
          },
          {
            target: o,
            type: 'touchend',
            listener: n,
            options: { passive: !0 },
          },
          {
            target: o,
            type: 'touchcancel',
            listener: n,
            options: { passive: !0 },
          },
        ]
      this.addTemporaryEvents(a),
        e.dragStartPixels === 0 &&
          this.onCommonMove(i, this.touchStart, e.eElement)
    }
    onMouseDown(e, t) {
      const i = t
      if (
        (e.skipMouseEvent && e.skipMouseEvent(t)) ||
        i._alreadyProcessedByDragService ||
        ((i._alreadyProcessedByDragService = !0), t.button !== 0)
      )
        return
      this.shouldPreventMouseEvent(t) && t.preventDefault(),
        (this.currentDragParams = e),
        (this.dragging = !1),
        (this.mouseStartEvent = t),
        (this.startTarget = t.target)
      const s = (c) => this.onMouseMove(c, e.eElement),
        n = (c) => this.onMouseUp(c, e.eElement),
        r = (c) => c.preventDefault(),
        o = (c) => {
          c.key === Y.ESCAPE && this.cancelDrag(e.eElement)
        },
        a = vo(this.gos),
        l = [
          { target: a, type: 'mousemove', listener: s },
          { target: a, type: 'mouseup', listener: n },
          { target: a, type: 'contextmenu', listener: r },
          { target: a, type: 'keydown', listener: o },
        ]
      this.addTemporaryEvents(l),
        e.dragStartPixels === 0 && this.onMouseMove(t, e.eElement)
    }
    addTemporaryEvents(e) {
      e.forEach((t) => {
        const { target: i, type: s, listener: n, options: r } = t
        i.addEventListener(s, n, r)
      }),
        this.dragEndFunctions.push(() => {
          e.forEach((t) => {
            const { target: i, type: s, listener: n, options: r } = t
            i.removeEventListener(s, n, r)
          })
        })
    }
    isEventNearStartEvent(e, t) {
      const { dragStartPixels: i } = this.currentDragParams,
        s = ue(i) ? i : 4
      return Zm(e, t, s)
    }
    getFirstActiveTouch(e) {
      for (let t = 0; t < e.length; t++)
        if (e[t].identifier === this.touchStart.identifier) return e[t]
      return null
    }
    onCommonMove(e, t, i) {
      var s
      if (!this.dragging) {
        if (this.isEventNearStartEvent(e, t)) return
        if (
          ((this.dragging = !0),
          this.eventService.dispatchEvent({ type: 'dragStarted', target: i }),
          this.currentDragParams.onDragStart(t),
          !this.currentDragParams)
        ) {
          this.dragging = !1
          return
        }
        this.currentDragParams.onDragging(t)
      }
      ;(s = this.currentDragParams) == null || s.onDragging(e)
    }
    onTouchMove(e, t) {
      const i = this.getFirstActiveTouch(e.touches)
      i && this.onCommonMove(i, this.touchStart, t)
    }
    onMouseMove(e, t) {
      var i
      gs() &&
        ((i = Gt(this.gos).getSelection()) == null || i.removeAllRanges()),
        this.shouldPreventMouseEvent(e) && e.preventDefault(),
        this.onCommonMove(e, this.mouseStartEvent, t)
    }
    shouldPreventMouseEvent(e) {
      const t = this.gos.get('enableCellTextSelection'),
        i = e.type === 'mousemove'
      return (
        t &&
        i &&
        e.cancelable &&
        this.mouseEventService.isEventFromThisGrid(e) &&
        !this.isOverFormFieldElement(e)
      )
    }
    isOverFormFieldElement(e) {
      const t = e.target,
        i = t == null ? void 0 : t.tagName.toLocaleLowerCase()
      return !!(i != null && i.match('^a$|textarea|input|select|button'))
    }
    onTouchUp(e, t) {
      let i = this.getFirstActiveTouch(e.changedTouches)
      i || (i = this.touchLastTime), this.onUpCommon(i, t)
    }
    onMouseUp(e, t) {
      this.onUpCommon(e, t)
    }
    onUpCommon(e, t) {
      this.dragging &&
        ((this.dragging = !1),
        this.currentDragParams.onDragStop(e),
        this.eventService.dispatchEvent({ type: 'dragStopped', target: t })),
        this.resetDragProperties()
    }
    cancelDrag(e) {
      var t, i
      this.eventService.dispatchEvent({ type: 'dragCancelled', target: e }),
        (i = (t = this.currentDragParams) == null ? void 0 : t.onDragCancel) ==
          null || i.call(t),
        this.resetDragProperties()
    }
    resetDragProperties() {
      ;(this.mouseStartEvent = null),
        (this.startTarget = null),
        (this.touchStart = null),
        (this.touchLastTime = null),
        (this.currentDragParams = null),
        this.dragEndFunctions.forEach((e) => e()),
        (this.dragEndFunctions.length = 0)
    }
  },
  tu = class extends yt {
    constructor(e, t, i, s, n, r) {
      super(),
        (this.cellValueFn = e),
        (this.rowNode = t),
        (this.column = i),
        (this.customGui = s),
        (this.dragStartPixels = n),
        (this.suppressVisibilityChange = r),
        (this.dragSource = null)
    }
    wireBeans(e) {
      this.beans = e
    }
    isCustomGui() {
      return this.customGui != null
    }
    postConstruct() {
      if (
        (this.customGui
          ? this.setDragElement(this.customGui, this.dragStartPixels)
          : (this.setTemplate(
              '<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>',
            ),
            this.getGui().appendChild(Li('rowDrag', this.gos, null)),
            this.addDragSource()),
        this.checkCompatibility(),
        !this.suppressVisibilityChange)
      ) {
        const e = this.gos.get('rowDragManaged')
          ? new SM(this, this.beans, this.rowNode, this.column)
          : new CM(this, this.beans, this.rowNode, this.column)
        this.createManagedBean(e, this.beans.context)
      }
    }
    setDragElement(e, t) {
      this.setTemplateFromElement(e, void 0, void 0, !0), this.addDragSource(t)
    }
    getSelectedNodes() {
      if (!this.gos.get('rowDragMultiRow')) return [this.rowNode]
      const t = this.beans.selectionService.getSelectedNodes()
      return t.indexOf(this.rowNode) !== -1 ? t : [this.rowNode]
    }
    checkCompatibility() {
      const e = this.gos.get('rowDragManaged')
      this.gos.get('treeData') &&
        e &&
        te(
          'If using row drag with tree data, you cannot have rowDragManaged=true',
        )
    }
    getDragItem() {
      return {
        rowNode: this.rowNode,
        rowNodes: this.getSelectedNodes(),
        columns: this.column ? [this.column] : void 0,
        defaultTextValue: this.cellValueFn(),
      }
    }
    getRowDragText(e) {
      if (e) {
        const t = e.getColDef()
        if (t.rowDragText) return t.rowDragText
      }
      return this.gos.get('rowDragText')
    }
    addDragSource(e = 4) {
      this.dragSource && this.removeDragSource()
      const t = this.getGui()
      this.gos.get('enableCellTextSelection') &&
        (this.removeMouseDownListener(),
        (this.mouseDownListener = this.addManagedElementListeners(t, {
          mousedown: (s) => {
            s == null || s.preventDefault()
          },
        })[0]))
      const i = this.localeService.getLocaleTextFunc()
      ;(this.dragSource = {
        type: 2,
        eElement: t,
        dragItemName: () => {
          var o
          const s = this.getDragItem(),
            n = ((o = s.rowNodes) == null ? void 0 : o.length) || 1,
            r = this.getRowDragText(this.column)
          return r
            ? r(s, n)
            : n === 1
              ? this.cellValueFn()
              : `${n} ${i('rowDragRows', 'rows')}`
        },
        getDragItem: () => this.getDragItem(),
        dragStartPixels: e,
        dragSourceDomDataKey: this.gos.getDomDataKey(),
      }),
        this.beans.dragAndDropService.addDragSource(this.dragSource, !0)
    }
    destroy() {
      this.removeDragSource(), this.removeMouseDownListener(), super.destroy()
    }
    removeDragSource() {
      this.dragSource &&
        (this.beans.dragAndDropService.removeDragSource(this.dragSource),
        (this.dragSource = null))
    }
    removeMouseDownListener() {
      this.mouseDownListener &&
        (this.mouseDownListener(), (this.mouseDownListener = void 0))
    }
  },
  ov = class extends X {
    constructor(e, t, i) {
      super(), (this.parent = e), (this.rowNode = t), (this.column = i)
    }
    setDisplayedOrVisible(e) {
      const t = { skipAriaHidden: !0 }
      if (e) this.parent.setDisplayed(!1, t)
      else {
        let i = !0,
          s = !1
        this.column &&
          ((i =
            this.column.isRowDrag(this.rowNode) || this.parent.isCustomGui()),
          (s = Ju(this.column.getColDef().rowDrag))),
          s
            ? (this.parent.setDisplayed(!0, t), this.parent.setVisible(i, t))
            : (this.parent.setDisplayed(i, t), this.parent.setVisible(!0, t))
      }
    }
  },
  CM = class extends ov {
    constructor(e, t, i, s) {
      super(e, i, s), (this.beans = t)
    }
    postConstruct() {
      this.addManagedPropertyListener(
        'suppressRowDrag',
        this.onSuppressRowDrag.bind(this),
      )
      const e = this.workOutVisibility.bind(this)
      this.addManagedListeners(this.rowNode, {
        dataChanged: e,
        cellChanged: e,
      }),
        this.addManagedListeners(this.beans.eventService, {
          newColumnsLoaded: e,
        }),
        this.workOutVisibility()
    }
    onSuppressRowDrag() {
      this.workOutVisibility()
    }
    workOutVisibility() {
      const e = this.gos.get('suppressRowDrag')
      this.setDisplayedOrVisible(e)
    }
  },
  SM = class extends ov {
    constructor(e, t, i, s) {
      super(e, i, s), (this.beans = t)
    }
    postConstruct() {
      const e = this.workOutVisibility.bind(this)
      this.addManagedListeners(this.beans.eventService, {
        sortChanged: e,
        filterChanged: e,
        columnRowGroupChanged: e,
        newColumnsLoaded: e,
      }),
        this.addManagedListeners(this.rowNode, {
          dataChanged: e,
          cellChanged: e,
        }),
        this.addManagedPropertyListener(
          'suppressRowDrag',
          this.onSuppressRowDrag.bind(this),
        ),
        this.workOutVisibility()
    }
    onSuppressRowDrag() {
      this.workOutVisibility()
    }
    workOutVisibility() {
      const t = this.beans.ctrlsService.getGridBodyCtrl().getRowDragFeature(),
        i = t && t.shouldPreventRowMove(),
        s = this.gos.get('suppressRowDrag'),
        n = this.beans.dragAndDropService.hasExternalDropZones(),
        r = (i && !n) || s
      this.setDisplayedOrVisible(r)
    }
  },
  wM = new Set([
    'localEventService',
    '__objectId',
    'sticky',
    '__autoHeights',
    'checkAutoHeightsDebounced',
  ]),
  Go = class en {
    constructor(t) {
      ;(this.rowIndex = null),
        (this.key = null),
        (this.sourceRowIndex = -1),
        (this.childrenMapped = {}),
        (this.treeNode = null),
        (this.treeNodeFlags = 0),
        (this.displayed = !1),
        (this.rowTop = null),
        (this.oldRowTop = null),
        (this.selectable = !0),
        (this.__objectId = en.OBJECT_ID_SEQUENCE++),
        (this.__autoHeights = {}),
        (this.alreadyRendered = !1),
        (this.highlighted = null),
        (this.hovered = !1),
        (this.selected = !1),
        (this.beans = t)
    }
    setData(t) {
      this.setDataCommon(t, !1)
    }
    updateData(t) {
      this.setDataCommon(t, !0)
    }
    setDataCommon(t, i) {
      var r
      const s = this.data
      ;(this.data = t),
        this.beans.valueCache.onDataChanged(),
        this.updateDataOnDetailNode(),
        this.checkRowSelectable(),
        this.resetQuickFilterAggregateText()
      const n = this.createDataChangedEvent(t, s, i)
      ;(r = this.localEventService) == null || r.dispatchEvent(n)
    }
    updateDataOnDetailNode() {
      this.detailNode && (this.detailNode.data = this.data)
    }
    createDataChangedEvent(t, i, s) {
      return {
        type: 'dataChanged',
        node: this,
        oldData: i,
        newData: t,
        update: s,
      }
    }
    getRowIndexString() {
      return this.rowIndex == null
        ? (ht(
            'Could not find rowIndex, this means tasks are being executed on a rowNode that has been removed from the grid.',
          ),
          null)
        : this.rowPinned === 'top'
          ? en.ID_PREFIX_TOP_PINNED + this.rowIndex
          : this.rowPinned === 'bottom'
            ? en.ID_PREFIX_BOTTOM_PINNED + this.rowIndex
            : this.rowIndex.toString()
    }
    createDaemonNode() {
      const t = new en(this.beans)
      return (
        (t.id = this.id),
        (t.data = this.data),
        (t.__daemon = !0),
        (t.selected = this.selected),
        (t.level = this.level),
        t
      )
    }
    setDataAndId(t, i) {
      var o
      const s = ue(this.id) ? this.createDaemonNode() : null,
        n = this.data
      ;(this.data = t),
        this.updateDataOnDetailNode(),
        this.setId(i),
        this.checkRowSelectable(),
        this.beans.selectionService.syncInRowNode(this, s)
      const r = this.createDataChangedEvent(t, n, !1)
      ;(o = this.localEventService) == null || o.dispatchEvent(r)
    }
    checkRowSelectable() {
      const t = Zu(this.beans.gos)
      this.setRowSelectable(t ? t(this) : !0)
    }
    setRowSelectable(t, i) {
      if (this.selectable !== t) {
        if (
          ((this.selectable = t), this.dispatchRowEvent('selectableChanged'), i)
        )
          return
        if (Gn(this.beans.gos)) {
          const n = this.calculateSelectedFromChildren()
          this.setSelectedParams({
            newValue: n ?? !1,
            source: 'selectableChanged',
          })
          return
        }
        this.isSelected() &&
          !this.selectable &&
          this.setSelectedParams({ newValue: !1, source: 'selectableChanged' })
      }
    }
    setId(t) {
      var s
      const i = Mr(this.beans.gos)
      if (i)
        if (this.data) {
          const n = ((s = this.parent) == null ? void 0 : s.getRoute()) ?? []
          ;(this.id = i({
            data: this.data,
            parentKeys: n.length > 0 ? n : void 0,
            level: this.level,
            rowPinned: this.rowPinned,
          })),
            this.id.startsWith(en.ID_PREFIX_ROW_GROUP) &&
              ht(
                `Row IDs cannot start with ${en.ID_PREFIX_ROW_GROUP}, this is a reserved prefix for AG Grid's row grouping feature.`,
              )
        } else this.id = void 0
      else this.id = t
    }
    setRowTop(t) {
      ;(this.oldRowTop = this.rowTop),
        this.rowTop !== t &&
          ((this.rowTop = t),
          this.dispatchRowEvent('topChanged'),
          this.setDisplayed(t !== null))
    }
    clearRowTopAndRowIndex() {
      ;(this.oldRowTop = null), this.setRowTop(null), this.setRowIndex(null)
    }
    setHovered(t) {
      this.hovered = t
    }
    isHovered() {
      return this.hovered
    }
    setMaster(t) {
      this.master !== t &&
        (this.master && !t && (this.expanded = !1),
        (this.master = t),
        this.dispatchRowEvent('masterChanged'))
    }
    setGroup(t) {
      this.group !== t &&
        (this.group && !t && (this.expanded = !1),
        (this.group = t),
        this.updateHasChildren(),
        this.checkRowSelectable(),
        this.dispatchRowEvent('groupChanged'))
    }
    setRowHeight(t, i = !1) {
      ;(this.rowHeight = t),
        (this.rowHeightEstimated = i),
        this.dispatchRowEvent('heightChanged')
    }
    setRowAutoHeight(t, i) {
      this.__autoHeights || (this.__autoHeights = {}),
        (this.__autoHeights[i.getId()] = t),
        t != null &&
          (this.checkAutoHeightsDebounced == null &&
            (this.checkAutoHeightsDebounced = bi(
              this.checkAutoHeights.bind(this),
              1,
            )),
          this.checkAutoHeightsDebounced())
    }
    checkAutoHeights() {
      var a
      let t = !1,
        i = !0,
        s = 0
      const n = this.__autoHeights
      if (
        n == null ||
        (this.beans.visibleColsService.getAllAutoHeightCols().forEach((l) => {
          let c = n[l.getId()]
          if (c == null)
            if (this.beans.columnModel.isColSpanActive()) {
              let u = []
              switch (l.getPinned()) {
                case 'left':
                  u = this.beans.visibleColsService.getLeftColsForRow(this)
                  break
                case 'right':
                  u = this.beans.visibleColsService.getRightColsForRow(this)
                  break
                case null:
                  u =
                    this.beans.columnViewportService.getColsWithinViewport(this)
                  break
              }
              if (u.includes(l)) {
                t = !0
                return
              }
              c = -1
            } else {
              t = !0
              return
            }
          else i = !1
          c > s && (s = c)
        }),
        t) ||
        ((i || s < 10) && (s = ln(this.beans.gos, this).height),
        s == this.rowHeight)
      )
        return
      this.setRowHeight(s)
      const o = this.beans.rowModel
      ;(a = o.onRowHeightChangedDebounced) == null || a.call(o)
    }
    setExpanded(t, i, s) {
      if (this.expanded === t) return
      ;(this.expanded = t), this.dispatchRowEvent('expandedChanged')
      const n = {
        ...this.createGlobalRowEvent('rowGroupOpened'),
        expanded: t,
        event: i || null,
      }
      this.beans.rowNodeEventThrottle.dispatchExpanded(n, s),
        this.beans.rowRenderer.refreshCells({ rowNodes: [this] })
    }
    createGlobalRowEvent(t) {
      return this.beans.gos.addGridCommonParams({
        type: t,
        node: this,
        data: this.data,
        rowIndex: this.rowIndex,
        rowPinned: this.rowPinned,
      })
    }
    setDataValue(t, i, s) {
      const r =
          typeof t != 'string'
            ? t
            : (this.beans.columnModel.getCol(t) ??
              this.beans.columnModel.getColDefCol(t)),
        o = this.beans.valueService.getValueForDisplay(r, this)
      if (this.beans.gos.get('readOnlyEdit'))
        return (
          this.beans.eventService.dispatchEvent({
            type: 'cellEditRequest',
            event: null,
            rowIndex: this.rowIndex,
            rowPinned: this.rowPinned,
            column: r,
            colDef: r.getColDef(),
            data: this.data,
            node: this,
            oldValue: o,
            newValue: i,
            value: i,
            source: s,
          }),
          !1
        )
      const a = this.beans.valueService.setValue(this, r, i, s)
      return (
        this.dispatchCellChangedEvent(r, i, o), this.checkRowSelectable(), a
      )
    }
    setGroupValue(t, i) {
      const s = this.beans.columnModel.getCol(t)
      ot(this.groupData) && (this.groupData = {})
      const n = s.getColId(),
        r = this.groupData[n]
      r !== i &&
        ((this.groupData[n] = i), this.dispatchCellChangedEvent(s, i, r))
    }
    setAggData(t) {
      const i = this.aggData
      if (((this.aggData = t), this.localEventService)) {
        const s = (n) => {
          const r = this.aggData ? this.aggData[n] : void 0,
            o = i ? i[n] : void 0
          if (r === o) return
          const a = this.beans.columnModel.getCol(n)
          a && this.dispatchCellChangedEvent(a, r, o)
        }
        for (const n in i) s(n)
        for (const n in t) (!i || !(n in i)) && s(n)
      }
    }
    updateHasChildren() {
      let t =
        (this.group && !this.footer) ||
        (this.childrenAfterGroup && this.childrenAfterGroup.length > 0)
      if (ms(this.beans.gos)) {
        const s = this.beans.gos.get('treeData'),
          n = this.beans.gos.get('isServerSideGroup')
        t =
          !this.stub && !this.footer && (s ? !!n && n(this.data) : !!this.group)
      }
      t !== this.__hasChildren &&
        ((this.__hasChildren = !!t),
        this.dispatchRowEvent('hasChildrenChanged'))
    }
    hasChildren() {
      return (
        this.__hasChildren == null && this.updateHasChildren(),
        this.__hasChildren
      )
    }
    dispatchCellChangedEvent(t, i, s) {
      var r
      const n = {
        type: 'cellChanged',
        node: this,
        column: t,
        newValue: i,
        oldValue: s,
      }
      ;(r = this.localEventService) == null || r.dispatchEvent(n)
    }
    resetQuickFilterAggregateText() {
      this.quickFilterAggregateText = null
    }
    isExpandable() {
      return this.footer
        ? !1
        : this.beans.columnModel.isPivotMode()
          ? this.hasChildren() && !this.leafGroup
          : this.hasChildren() || !!this.master
    }
    isSelected() {
      return this.footer ? this.sibling.isSelected() : this.selected
    }
    depthFirstSearch(t) {
      this.childrenAfterGroup &&
        this.childrenAfterGroup.forEach((i) => i.depthFirstSearch(t)),
        t(this)
    }
    calculateSelectedFromChildren() {
      var s
      let t = !1,
        i = !1
      if (!((s = this.childrenAfterGroup) != null && s.length))
        return this.selectable ? this.selected : null
      for (let n = 0; n < this.childrenAfterGroup.length; n++) {
        const r = this.childrenAfterGroup[n]
        let o = r.isSelected()
        if (!r.selectable) {
          const a = r.calculateSelectedFromChildren()
          if (a === null) continue
          o = a
        }
        switch (o) {
          case !0:
            t = !0
            break
          case !1:
            i = !0
            break
          default:
            return
        }
      }
      if (!(t && i))
        return t ? !0 : i ? !1 : this.selectable ? this.selected : null
    }
    setSelectedInitialValue(t) {
      this.selected = t
    }
    dispatchRowEvent(t) {
      var i
      ;(i = this.localEventService) == null ||
        i.dispatchEvent({ type: t, node: this })
    }
    selectThisNode(t, i, s = 'api') {
      const n = !this.selectable && t,
        r = this.selected === t
      if (n || r) return !1
      ;(this.selected = t), this.dispatchRowEvent('rowSelected')
      const o = this.sibling
      return (
        o &&
          o.footer &&
          o.localEventService &&
          o.dispatchRowEvent('rowSelected'),
        this.beans.eventService.dispatchEvent({
          ...this.createGlobalRowEvent('rowSelected'),
          event: i || null,
          source: s,
        }),
        !0
      )
    }
    setSelected(t, i = !1, s = 'api') {
      if (typeof s == 'boolean') {
        te(
          'since version v30, rowNode.setSelected() property `suppressFinishActions` has been removed, please use `gridApi.setNodesSelected()` for bulk actions, and the event `source` property for ignoring events instead.',
        )
        return
      }
      this.setSelectedParams({
        newValue: t,
        clearSelection: i,
        rangeSelect: !1,
        source: s,
      })
    }
    setSelectedParams(t) {
      return this.rowPinned
        ? (te('cannot select pinned rows'), 0)
        : this.id === void 0
          ? (te('cannot select node until id for node is known'), 0)
          : this.beans.selectionService.setNodesSelected({
              ...t,
              nodes: [this.footer ? this.sibling : this],
            })
    }
    isRowPinned() {
      return !!this.rowPinned
    }
    addEventListener(t, i) {
      var n
      this.localEventService || (this.localEventService = new Dr()),
        this.beans.frameworkOverrides.shouldWrapOutgoing &&
          !this.frameworkEventListenerService &&
          (this.localEventService.setFrameworkOverrides(
            this.beans.frameworkOverrides,
          ),
          (this.frameworkEventListenerService = new id(
            this.beans.frameworkOverrides,
          )))
      const s =
        ((n = this.frameworkEventListenerService) == null
          ? void 0
          : n.wrap(i)) ?? i
      this.localEventService.addEventListener(t, s)
    }
    removeEventListener(t, i) {
      var n
      if (!this.localEventService) return
      const s =
        ((n = this.frameworkEventListenerService) == null
          ? void 0
          : n.unwrap(i)) ?? i
      this.localEventService.removeEventListener(t, s),
        this.localEventService.noRegisteredListenersExist() &&
          (this.localEventService = null)
    }
    onMouseEnter() {
      this.dispatchRowEvent('mouseEnter')
    }
    onMouseLeave() {
      this.dispatchRowEvent('mouseLeave')
    }
    isFullWidthCell() {
      if (
        (te(
          'since version v32.2.0, rowNode.isFullWidthCell() has been deprecated. Instead check `rowNode.detail` followed by the user provided `isFullWidthRow` grid option.',
        ),
        this.detail)
      )
        return !0
      const t = this.beans.gos.getCallback('isFullWidthRow')
      return t ? t({ rowNode: this }) : !1
    }
    getRoute() {
      if (this.level === -1) return []
      if (this.key == null) return
      const t = []
      let i = this
      for (; i && i.key != null; ) t.push(i.key), (i = i.parent)
      return t.reverse()
    }
    createFooter() {
      if (this.sibling) return
      const t = new en(this.beans)
      Object.keys(this).forEach((i) => {
        wM.has(i) || (t[i] = this[i])
      }),
        (t.footer = !0),
        t.setRowTop(null),
        t.setRowIndex(null),
        (t.oldRowTop = null),
        (t.id = 'rowGroupFooter_' + this.id),
        (t.sibling = this),
        (this.sibling = t)
    }
    destroyFooter() {
      this.sibling &&
        (this.sibling.setRowTop(null),
        this.sibling.setRowIndex(null),
        (this.sibling = void 0))
    }
    setFirstChild(t) {
      this.firstChild !== t &&
        ((this.firstChild = t), this.dispatchRowEvent('firstChildChanged'))
    }
    setLastChild(t) {
      this.lastChild !== t &&
        ((this.lastChild = t), this.dispatchRowEvent('lastChildChanged'))
    }
    setChildIndex(t) {
      this.childIndex !== t &&
        ((this.childIndex = t), this.dispatchRowEvent('childIndexChanged'))
    }
    setDisplayed(t) {
      this.displayed !== t &&
        ((this.displayed = t), this.dispatchRowEvent('displayedChanged'))
    }
    setDragging(t) {
      this.dragging !== t &&
        ((this.dragging = t), this.dispatchRowEvent('draggingChanged'))
    }
    setHighlighted(t) {
      this.highlighted !== t &&
        ((this.highlighted = t), this.dispatchRowEvent('rowHighlightChanged'))
    }
    setAllChildrenCount(t) {
      this.allChildrenCount !== t &&
        ((this.allChildrenCount = t),
        this.dispatchRowEvent('allChildrenCountChanged'))
    }
    setRowIndex(t) {
      this.rowIndex !== t &&
        ((this.rowIndex = t), this.dispatchRowEvent('rowIndexChanged'))
    }
    setUiLevel(t) {
      this.uiLevel !== t &&
        ((this.uiLevel = t), this.dispatchRowEvent('uiLevelChanged'))
    }
  }
Go.ID_PREFIX_ROW_GROUP = 'row-group-'
Go.ID_PREFIX_TOP_PINNED = 't-'
Go.ID_PREFIX_BOTTOM_PINNED = 'b-'
Go.OBJECT_ID_SEQUENCE = 0
var Ls = Go,
  yM = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'filterManager'),
        (this.advancedFilterModelUpdateQueue = [])
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.dataTypeService = e.dataTypeService),
        (this.quickFilterService = e.quickFilterService),
        (this.advancedFilterService = e.advancedFilterService),
        (this.columnFilterService = e.columnFilterService)
    }
    postConstruct() {
      const e = this.refreshFiltersForAggregations.bind(this),
        t = this.updateAdvancedFilterColumns.bind(this)
      this.addManagedEventListeners({
        columnValueChanged: e,
        columnPivotChanged: e,
        columnPivotModeChanged: e,
        newColumnsLoaded: t,
        columnVisible: t,
        advancedFilterEnabledChanged: ({ enabled: i }) =>
          this.onAdvancedFilterEnabledChanged(i),
        dataTypesInferred: this.processFilterModelUpdateQueue.bind(this),
      }),
        (this.externalFilterPresent = this.isExternalFilterPresentCallback()),
        this.addManagedPropertyListeners(
          ['isExternalFilterPresent', 'doesExternalFilterPass'],
          () => {
            this.onFilterChanged({ source: 'api' })
          },
        ),
        this.updateAggFiltering(),
        this.addManagedPropertyListener('groupAggFiltering', () => {
          this.updateAggFiltering(), this.onFilterChanged()
        }),
        this.addManagedPropertyListener('advancedFilterModel', (i) =>
          this.setAdvancedFilterModel(i.currentValue),
        ),
        this.quickFilterService &&
          this.addManagedListeners(this.quickFilterService, {
            quickFilterChanged: () =>
              this.onFilterChanged({ source: 'quickFilter' }),
          })
    }
    isExternalFilterPresentCallback() {
      const e = this.gos.getCallback('isExternalFilterPresent')
      return typeof e == 'function' ? e({}) : !1
    }
    doesExternalFilterPass(e) {
      const t = this.gos.get('doesExternalFilterPass')
      return typeof t == 'function' ? t(e) : !1
    }
    setFilterModel(e, t = 'api') {
      var i
      if (this.isAdvancedFilterEnabled()) {
        this.warnAdvancedFilters()
        return
      }
      ;(i = this.columnFilterService) == null || i.setFilterModel(e, t)
    }
    getFilterModel() {
      var e
      return (
        ((e = this.columnFilterService) == null
          ? void 0
          : e.getFilterModel()) ?? {}
      )
    }
    isColumnFilterPresent() {
      var e
      return !!(
        (e = this.columnFilterService) != null && e.isColumnFilterPresent()
      )
    }
    isAggregateFilterPresent() {
      var e
      return !!(
        (e = this.columnFilterService) != null && e.isAggregateFilterPresent()
      )
    }
    isExternalFilterPresent() {
      return this.externalFilterPresent
    }
    isChildFilterPresent() {
      return (
        this.isColumnFilterPresent() ||
        this.isQuickFilterPresent() ||
        this.isExternalFilterPresent() ||
        this.isAdvancedFilterPresent()
      )
    }
    isAdvancedFilterPresent() {
      return (
        this.isAdvancedFilterEnabled() &&
        this.advancedFilterService.isFilterPresent()
      )
    }
    onAdvancedFilterEnabledChanged(e) {
      var t, i
      e
        ? (t = this.columnFilterService) != null &&
          t.disableColumnFilters() &&
          this.onFilterChanged({ source: 'advancedFilter' })
        : (i = this.advancedFilterService) != null &&
          i.isFilterPresent() &&
          (this.advancedFilterService.setModel(null),
          this.onFilterChanged({ source: 'advancedFilter' }))
    }
    isAdvancedFilterEnabled() {
      var e
      return !!((e = this.advancedFilterService) != null && e.isEnabled())
    }
    isAdvancedFilterHeaderActive() {
      return (
        this.isAdvancedFilterEnabled() &&
        this.advancedFilterService.isHeaderActive()
      )
    }
    isAnyFilterPresent() {
      return (
        this.isQuickFilterPresent() ||
        this.isColumnFilterPresent() ||
        this.isAggregateFilterPresent() ||
        this.isExternalFilterPresent() ||
        this.isAdvancedFilterPresent()
      )
    }
    resetQuickFilterCache() {
      var e
      ;(e = this.quickFilterService) == null || e.resetQuickFilterCache()
    }
    refreshFiltersForAggregations() {
      Uc(this.gos) && this.onFilterChanged()
    }
    onFilterChanged(e = {}) {
      const { source: t, additionalEventAttributes: i, columns: s = [] } = e
      ;(this.externalFilterPresent = this.isExternalFilterPresentCallback()),
        (this.columnFilterService
          ? this.columnFilterService.updateBeforeFilterChanged(e)
          : Nt.resolve()
        ).then(() => {
          var r
          const n = { source: t, type: 'filterChanged', columns: s }
          i && yi(n, i),
            this.eventService.dispatchEvent(n),
            (r = this.columnFilterService) == null ||
              r.updateAfterFilterChanged()
        })
    }
    isSuppressFlashingCellsBecauseFiltering() {
      var e
      return !!(
        (e = this.columnFilterService) != null &&
        e.isSuppressFlashingCellsBecauseFiltering()
      )
    }
    isQuickFilterPresent() {
      var e
      return !!(
        (e = this.quickFilterService) != null && e.isQuickFilterPresent()
      )
    }
    updateAggFiltering() {
      this.aggFiltering = !!Uc(this.gos)
    }
    isAggregateQuickFilterPresent() {
      return (
        this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg()
      )
    }
    isNonAggregateQuickFilterPresent() {
      return (
        this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg()
      )
    }
    shouldApplyQuickFilterAfterAgg() {
      return (
        (this.aggFiltering || this.columnModel.isPivotMode()) &&
        !this.gos.get('applyQuickFilterBeforePivotOrAgg')
      )
    }
    doesRowPassOtherFilters(e, t) {
      return this.doesRowPassFilter({ rowNode: t, filterInstanceToSkip: e })
    }
    doesRowPassAggregateFilters(e) {
      return !(
        (this.isAggregateQuickFilterPresent() &&
          !this.quickFilterService.doesRowPassQuickFilter(e.rowNode)) ||
        (this.isAggregateFilterPresent() &&
          !this.columnFilterService.doAggregateFiltersPass(
            e.rowNode,
            e.filterInstanceToSkip,
          ))
      )
    }
    doesRowPassFilter(e) {
      return !(
        (this.isNonAggregateQuickFilterPresent() &&
          !this.quickFilterService.doesRowPassQuickFilter(e.rowNode)) ||
        (this.isExternalFilterPresent() &&
          !this.doesExternalFilterPass(e.rowNode)) ||
        (this.isColumnFilterPresent() &&
          !this.columnFilterService.doColumnFiltersPass(
            e.rowNode,
            e.filterInstanceToSkip,
          )) ||
        (this.isAdvancedFilterPresent() &&
          !this.advancedFilterService.doesFilterPass(e.rowNode))
      )
    }
    isFilterActive(e) {
      var t
      return !!((t = this.columnFilterService) != null && t.isFilterActive(e))
    }
    getOrCreateFilterWrapper(e) {
      var t
      return (
        ((t = this.columnFilterService) == null
          ? void 0
          : t.getOrCreateFilterWrapper(e)) ?? null
      )
    }
    getDefaultFloatingFilter(e) {
      return this.columnFilterService.getDefaultFloatingFilter(e)
    }
    createFilterParams(e, t) {
      return this.columnFilterService.createFilterParams(e, t)
    }
    isFilterAllowed(e) {
      var t
      return this.isAdvancedFilterEnabled()
        ? !1
        : !!((t = this.columnFilterService) != null && t.isFilterAllowed(e))
    }
    getFloatingFilterCompDetails(e, t) {
      var i
      return (i = this.columnFilterService) == null
        ? void 0
        : i.getFloatingFilterCompDetails(e, t)
    }
    getCurrentFloatingFilterParentModel(e) {
      var t
      return (t = this.columnFilterService) == null
        ? void 0
        : t.getCurrentFloatingFilterParentModel(e)
    }
    destroyFilter(e, t = 'api') {
      var i
      ;(i = this.columnFilterService) == null || i.destroyFilter(e, t)
    }
    areFilterCompsDifferent(e, t) {
      var i
      return !!(
        (i = this.columnFilterService) != null &&
        i.areFilterCompsDifferent(e, t)
      )
    }
    getAdvancedFilterModel() {
      return this.isAdvancedFilterEnabled()
        ? this.advancedFilterService.getModel()
        : null
    }
    setAdvancedFilterModel(e) {
      var t
      if (this.isAdvancedFilterEnabled()) {
        if ((t = this.dataTypeService) != null && t.isPendingInference()) {
          this.advancedFilterModelUpdateQueue.push(e)
          return
        }
        this.advancedFilterService.setModel(e ?? null),
          this.onFilterChanged({ source: 'advancedFilter' })
      }
    }
    toggleAdvancedFilterBuilder(e, t) {
      this.isAdvancedFilterEnabled() &&
        this.advancedFilterService
          .getCtrl()
          .toggleFilterBuilder({ source: t, force: e })
    }
    updateAdvancedFilterColumns() {
      this.isAdvancedFilterEnabled() &&
        this.advancedFilterService.updateValidity() &&
        this.onFilterChanged({ source: 'advancedFilter' })
    }
    hasFloatingFilters() {
      var e
      return this.isAdvancedFilterEnabled()
        ? !1
        : !!((e = this.columnFilterService) != null && e.hasFloatingFilters())
    }
    getFilterInstance(e, t) {
      var i
      if (this.isAdvancedFilterEnabled()) {
        this.warnAdvancedFilters()
        return
      }
      return (i = this.columnFilterService) == null
        ? void 0
        : i.getFilterInstance(e, t)
    }
    getColumnFilterInstance(e) {
      var t
      return this.isAdvancedFilterEnabled()
        ? (this.warnAdvancedFilters(), Promise.resolve(void 0))
        : (((t = this.columnFilterService) == null
            ? void 0
            : t.getColumnFilterInstance(e)) ?? Promise.resolve(void 0))
    }
    warnAdvancedFilters() {
      te(
        'Column Filter API methods have been disabled as Advanced Filters are enabled.',
      )
    }
    setupAdvancedFilterHeaderComp(e) {
      var t
      ;(t = this.advancedFilterService) == null ||
        t.getCtrl().setupHeaderComp(e)
    }
    getHeaderRowCount() {
      return this.isAdvancedFilterHeaderActive() ? 1 : 0
    }
    getHeaderHeight() {
      return this.isAdvancedFilterHeaderActive()
        ? this.advancedFilterService.getCtrl().getHeaderHeight()
        : 0
    }
    processFilterModelUpdateQueue() {
      this.advancedFilterModelUpdateQueue.forEach((e) =>
        this.setAdvancedFilterModel(e),
      ),
        (this.advancedFilterModelUpdateQueue = [])
    }
    getColumnFilterModel(e) {
      var t
      return (t = this.columnFilterService) == null
        ? void 0
        : t.getColumnFilterModel(e)
    }
    setColumnFilterModel(e, t) {
      var i
      return this.isAdvancedFilterEnabled()
        ? (this.warnAdvancedFilters(), Promise.resolve())
        : (((i = this.columnFilterService) == null
            ? void 0
            : i.setColumnFilterModel(e, t)) ?? Promise.resolve())
    }
    setColDefPropertiesForDataType(e, t, i) {
      var s
      ;(s = this.columnFilterService) == null ||
        s.setColDefPropertiesForDataType(e, t, i)
    }
  },
  bM = class extends yt {
    constructor(e, t) {
      super('<div class="ag-filter"></div>'),
        (this.column = e),
        (this.source = t),
        (this.filterWrapper = null)
    }
    wireBeans(e) {
      ;(this.filterManager = e.filterManager),
        (this.columnModel = e.columnModel)
    }
    postConstruct() {
      this.createFilter(!0),
        this.addManagedEventListeners({
          filterDestroyed: this.onFilterDestroyed.bind(this),
        })
    }
    hasFilter() {
      return !!this.filterWrapper
    }
    getFilter() {
      var e
      return (
        ((e = this.filterWrapper) == null ? void 0 : e.filterPromise) ?? null
      )
    }
    afterInit() {
      var e, t
      return (
        ((t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) ==
        null
          ? void 0
          : t.then(() => {})) ?? Nt.resolve()
      )
    }
    afterGuiAttached(e) {
      var t, i
      ;(i = (t = this.filterWrapper) == null ? void 0 : t.filterPromise) ==
        null ||
        i.then((s) => {
          var n
          ;(n = s == null ? void 0 : s.afterGuiAttached) == null || n.call(s, e)
        })
    }
    afterGuiDetached() {
      var e, t
      ;(t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) ==
        null ||
        t.then((i) => {
          var s
          ;(s = i == null ? void 0 : i.afterGuiDetached) == null || s.call(i)
        })
    }
    createFilter(e) {
      var s, n
      const { column: t, source: i } = this
      ;(this.filterWrapper =
        ((s = this.filterManager) == null
          ? void 0
          : s.getOrCreateFilterWrapper(t)) ?? null),
        (n = this.filterWrapper) != null &&
          n.filterPromise &&
          this.filterWrapper.filterPromise.then((r) => {
            const o = r.getGui()
            ue(o) ||
              te(
                `getGui method from filter returned ${o}; it should be a DOM element.`,
              ),
              this.appendChild(o),
              e &&
                this.eventService.dispatchEvent({
                  type: 'filterOpened',
                  column: t,
                  source: i,
                  eGui: this.getGui(),
                })
          })
    }
    onFilterDestroyed(e) {
      ;(e.source === 'api' || e.source === 'paramsUpdated') &&
        e.column.getId() === this.column.getId() &&
        this.columnModel.getColDefCol(this.column) &&
        (Ni(this.getGui()), this.createFilter())
    }
    destroy() {
      ;(this.filterWrapper = null), super.destroy()
    }
  },
  av = 'ag-resizer-wrapper',
  Js = (e, t) =>
    `<div data-ref="${e}Resizer" class="ag-resizer ag-resizer-${t}"></div>`,
  RM = `<div class="${av}">
        ${Js('eTopLeft', 'topLeft')}
        ${Js('eTop', 'top')}
        ${Js('eTopRight', 'topRight')}
        ${Js('eRight', 'right')}
        ${Js('eBottomRight', 'bottomRight')}
        ${Js('eBottom', 'bottom')}
        ${Js('eBottomLeft', 'bottomLeft')}
        ${Js('eLeft', 'left')}
    </div>`,
  FM = class extends X {
    constructor(e, t) {
      super(),
        (this.element = e),
        (this.dragStartPosition = { x: 0, y: 0 }),
        (this.position = { x: 0, y: 0 }),
        (this.lastSize = { width: -1, height: -1 }),
        (this.positioned = !1),
        (this.resizersAdded = !1),
        (this.resizeListeners = []),
        (this.boundaryEl = null),
        (this.isResizing = !1),
        (this.isMoving = !1),
        (this.resizable = {}),
        (this.movable = !1),
        (this.currentResizer = null),
        (this.config = Object.assign({}, { popup: !1 }, t))
    }
    wireBeans(e) {
      ;(this.popupService = e.popupService),
        (this.resizeObserverService = e.resizeObserverService),
        (this.dragService = e.dragService)
    }
    center() {
      const { clientHeight: e, clientWidth: t } = this.offsetParent,
        i = t / 2 - this.getWidth() / 2,
        s = e / 2 - this.getHeight() / 2
      this.offsetElement(i, s)
    }
    initialisePosition() {
      if (this.positioned) return
      const {
        centered: e,
        forcePopupParentAsOffsetParent: t,
        minWidth: i,
        width: s,
        minHeight: n,
        height: r,
        x: o,
        y: a,
      } = this.config
      this.offsetParent || this.setOffsetParent()
      let l = 0,
        c = 0
      const u = fs(this.element)
      if (u) {
        const h = this.findBoundaryElement(),
          g = window.getComputedStyle(h)
        if (g.minWidth != null) {
          const f = h.offsetWidth - this.element.offsetWidth
          c = parseInt(g.minWidth, 10) - f
        }
        if (g.minHeight != null) {
          const f = h.offsetHeight - this.element.offsetHeight
          l = parseInt(g.minHeight, 10) - f
        }
      }
      if (
        ((this.minHeight = n || l),
        (this.minWidth = i || c),
        s && this.setWidth(s),
        r && this.setHeight(r),
        (!s || !r) && this.refreshSize(),
        e)
      )
        this.center()
      else if (o || a) this.offsetElement(o, a)
      else if (u && t) {
        let h = this.boundaryEl,
          g = !0
        if ((h || ((h = this.findBoundaryElement()), (g = !1)), h)) {
          const f = parseFloat(h.style.top),
            p = parseFloat(h.style.left)
          g
            ? this.offsetElement(isNaN(p) ? 0 : p, isNaN(f) ? 0 : f)
            : this.setPosition(p, f)
        }
      }
      this.positioned = !!this.offsetParent
    }
    isPositioned() {
      return this.positioned
    }
    getPosition() {
      return this.position
    }
    setMovable(e, t) {
      if (!this.config.popup || e === this.movable) return
      this.movable = e
      const i = this.moveElementDragListener || {
        eElement: t,
        onDragStart: this.onMoveStart.bind(this),
        onDragging: this.onMove.bind(this),
        onDragStop: this.onMoveEnd.bind(this),
      }
      e
        ? (this.dragService.addDragSource(i),
          (this.moveElementDragListener = i))
        : (this.dragService.removeDragSource(i),
          (this.moveElementDragListener = void 0))
    }
    setResizable(e) {
      if (
        (this.clearResizeListeners(),
        e ? this.addResizers() : this.removeResizers(),
        typeof e == 'boolean')
      ) {
        if (e === !1) return
        e = {
          topLeft: e,
          top: e,
          topRight: e,
          right: e,
          bottomRight: e,
          bottom: e,
          bottomLeft: e,
          left: e,
        }
      }
      Object.keys(e).forEach((t) => {
        const s = !!e[t],
          n = this.getResizerElement(t),
          r = {
            dragStartPixels: 0,
            eElement: n,
            onDragStart: (o) => this.onResizeStart(o, t),
            onDragging: this.onResize.bind(this),
            onDragStop: (o) => this.onResizeEnd(o, t),
          }
        ;(s || (!this.isAlive() && !s)) &&
          (s
            ? (this.dragService.addDragSource(r),
              this.resizeListeners.push(r),
              (n.style.pointerEvents = 'all'))
            : (n.style.pointerEvents = 'none'),
          (this.resizable[t] = s))
      })
    }
    removeSizeFromEl() {
      this.element.style.removeProperty('height'),
        this.element.style.removeProperty('width'),
        this.element.style.removeProperty('flex')
    }
    restoreLastSize() {
      this.element.style.flex = '0 0 auto'
      const { height: e, width: t } = this.lastSize
      t !== -1 && (this.element.style.width = `${t}px`),
        e !== -1 && (this.element.style.height = `${e}px`)
    }
    getHeight() {
      return this.element.offsetHeight
    }
    setHeight(e) {
      const { popup: t } = this.config,
        i = this.element
      let s = !1
      if (typeof e == 'string' && e.indexOf('%') !== -1)
        oo(i, e), (e = jm(i)), (s = !0)
      else if (((e = Math.max(this.minHeight, e)), this.positioned)) {
        const n = this.getAvailableHeight()
        n && e > n && (e = n)
      }
      this.getHeight() !== e &&
        (s
          ? ((i.style.maxHeight = 'unset'), (i.style.minHeight = 'unset'))
          : t
            ? oo(i, e)
            : ((i.style.height = `${e}px`),
              (i.style.flex = '0 0 auto'),
              (this.lastSize.height =
                typeof e == 'number' ? e : parseFloat(e))))
    }
    getAvailableHeight() {
      const { popup: e, forcePopupParentAsOffsetParent: t } = this.config
      this.positioned || this.initialisePosition()
      const { clientHeight: i } = this.offsetParent
      if (!i) return null
      const s = this.element.getBoundingClientRect(),
        n = this.offsetParent.getBoundingClientRect(),
        r = e ? this.position.y : s.top,
        o = e ? 0 : n.top
      let a = 0
      if (t) {
        const c = this.element.parentElement
        if (c) {
          const { bottom: u } = c.getBoundingClientRect()
          a = u - s.bottom
        }
      }
      return i + o - r - a
    }
    getWidth() {
      return this.element.offsetWidth
    }
    setWidth(e) {
      const t = this.element,
        { popup: i } = this.config
      let s = !1
      if (typeof e == 'string' && e.indexOf('%') !== -1)
        Zi(t, e), (e = Na(t)), (s = !0)
      else if (this.positioned) {
        e = Math.max(this.minWidth, e)
        const { clientWidth: n } = this.offsetParent,
          r = i ? this.position.x : this.element.getBoundingClientRect().left
        n && e + r > n && (e = n - r)
      }
      this.getWidth() !== e &&
        (s
          ? ((t.style.maxWidth = 'unset'), (t.style.minWidth = 'unset'))
          : this.config.popup
            ? Zi(t, e)
            : ((t.style.width = `${e}px`),
              (t.style.flex = ' unset'),
              (this.lastSize.width = typeof e == 'number' ? e : parseFloat(e))))
    }
    offsetElement(e = 0, t = 0) {
      const { forcePopupParentAsOffsetParent: i } = this.config,
        s = i ? this.boundaryEl : this.element
      s &&
        (this.popupService.positionPopup({
          ePopup: s,
          keepWithinBounds: !0,
          skipObserver: this.movable || this.isResizable(),
          updatePosition: () => ({ x: e, y: t }),
        }),
        this.setPosition(parseFloat(s.style.left), parseFloat(s.style.top)))
    }
    constrainSizeToAvailableHeight(e) {
      if (!this.config.forcePopupParentAsOffsetParent) return
      const t = () => {
        const i = this.getAvailableHeight()
        this.element.style.setProperty('max-height', `${i}px`)
      }
      e
        ? (this.resizeObserverSubscriber =
            this.resizeObserverService.observeResize(
              this.popupService.getPopupParent(),
              t,
            ))
        : (this.element.style.removeProperty('max-height'),
          this.resizeObserverSubscriber &&
            (this.resizeObserverSubscriber(),
            (this.resizeObserverSubscriber = void 0)))
    }
    setPosition(e, t) {
      ;(this.position.x = e), (this.position.y = t)
    }
    updateDragStartPosition(e, t) {
      this.dragStartPosition = { x: e, y: t }
    }
    calculateMouseMovement(e) {
      const { e: t, isLeft: i, isTop: s, anywhereWithin: n, topBuffer: r } = e,
        o = t.clientX - this.dragStartPosition.x,
        a = t.clientY - this.dragStartPosition.y,
        l = this.shouldSkipX(t, !!i, !!n, o) ? 0 : o,
        c = this.shouldSkipY(t, !!s, r, a) ? 0 : a
      return { movementX: l, movementY: c }
    }
    shouldSkipX(e, t, i, s) {
      const n = this.element.getBoundingClientRect(),
        r = this.offsetParent.getBoundingClientRect(),
        o = this.boundaryEl.getBoundingClientRect(),
        a = this.config.popup ? this.position.x : n.left
      let l =
        (a <= 0 && r.left >= e.clientX) ||
        (r.right <= e.clientX && r.right <= o.right)
      return l
        ? !0
        : (t
            ? (l =
                (s < 0 && e.clientX > a + r.left) ||
                (s > 0 && e.clientX < a + r.left))
            : i
              ? (l =
                  (s < 0 && e.clientX > o.right) ||
                  (s > 0 && e.clientX < a + r.left))
              : (l =
                  (s < 0 && e.clientX > o.right) ||
                  (s > 0 && e.clientX < o.right)),
          l)
    }
    shouldSkipY(e, t, i = 0, s) {
      const n = this.element.getBoundingClientRect(),
        r = this.offsetParent.getBoundingClientRect(),
        o = this.boundaryEl.getBoundingClientRect(),
        a = this.config.popup ? this.position.y : n.top
      let l =
        (a <= 0 && r.top >= e.clientY) ||
        (r.bottom <= e.clientY && r.bottom <= o.bottom)
      return l
        ? !0
        : (t
            ? (l =
                (s < 0 && e.clientY > a + r.top + i) ||
                (s > 0 && e.clientY < a + r.top))
            : (l =
                (s < 0 && e.clientY > o.bottom) ||
                (s > 0 && e.clientY < o.bottom)),
          l)
    }
    createResizeMap() {
      const e = this.element
      this.resizerMap = {
        topLeft: { element: e.querySelector('[data-ref=eTopLeftResizer]') },
        top: { element: e.querySelector('[data-ref=eTopResizer]') },
        topRight: { element: e.querySelector('[data-ref=eTopRightResizer]') },
        right: { element: e.querySelector('[data-ref=eRightResizer]') },
        bottomRight: {
          element: e.querySelector('[data-ref=eBottomRightResizer]'),
        },
        bottom: { element: e.querySelector('[data-ref=eBottomResizer]') },
        bottomLeft: {
          element: e.querySelector('[data-ref=eBottomLeftResizer]'),
        },
        left: { element: e.querySelector('[data-ref=eLeftResizer]') },
      }
    }
    addResizers() {
      if (this.resizersAdded) return
      const e = this.element
      if (!e) return
      const i = new DOMParser().parseFromString(RM, 'text/html').body
      e.appendChild(i.firstChild),
        this.createResizeMap(),
        (this.resizersAdded = !0)
    }
    removeResizers() {
      this.resizerMap = void 0
      const e = this.element.querySelector(`.${av}`)
      e && this.element.removeChild(e), (this.resizersAdded = !1)
    }
    getResizerElement(e) {
      return this.resizerMap[e].element
    }
    onResizeStart(e, t) {
      ;(this.boundaryEl = this.findBoundaryElement()),
        this.positioned || this.initialisePosition(),
        (this.currentResizer = {
          isTop: !!t.match(/top/i),
          isRight: !!t.match(/right/i),
          isBottom: !!t.match(/bottom/i),
          isLeft: !!t.match(/left/i),
        }),
        this.element.classList.add('ag-resizing'),
        this.resizerMap[t].element.classList.add('ag-active')
      const { popup: i, forcePopupParentAsOffsetParent: s } = this.config
      !i &&
        !s &&
        this.applySizeToSiblings(
          this.currentResizer.isBottom || this.currentResizer.isTop,
        ),
        (this.isResizing = !0),
        this.updateDragStartPosition(e.clientX, e.clientY)
    }
    getSiblings() {
      const t = this.element.parentElement
      return t
        ? Array.prototype.slice
            .call(t.children)
            .filter((i) => !i.classList.contains('ag-hidden'))
        : null
    }
    getMinSizeOfSiblings() {
      const e = this.getSiblings() || []
      let t = 0,
        i = 0
      for (let s = 0; s < e.length; s++) {
        const n = e[s],
          r = !!n.style.flex && n.style.flex !== '0 0 auto'
        if (n === this.element) continue
        let o = this.minHeight || 0,
          a = this.minWidth || 0
        if (r) {
          const l = window.getComputedStyle(n)
          l.minHeight && (o = parseInt(l.minHeight, 10)),
            l.minWidth && (a = parseInt(l.minWidth, 10))
        } else (o = n.offsetHeight), (a = n.offsetWidth)
        ;(t += o), (i += a)
      }
      return { height: t, width: i }
    }
    applySizeToSiblings(e) {
      let t = null
      const i = this.getSiblings()
      if (i) {
        for (let s = 0; s < i.length; s++) {
          const n = i[s]
          n !== t &&
            (e
              ? (n.style.height = `${n.offsetHeight}px`)
              : (n.style.width = `${n.offsetWidth}px`),
            (n.style.flex = '0 0 auto'),
            n === this.element && (t = i[s + 1]))
        }
        t &&
          (t.style.removeProperty('height'),
          t.style.removeProperty('min-height'),
          t.style.removeProperty('max-height'),
          (t.style.flex = '1 1 auto'))
      }
    }
    isResizable() {
      return Object.values(this.resizable).some((e) => e)
    }
    onResize(e) {
      if (!this.isResizing || !this.currentResizer) return
      const { popup: t, forcePopupParentAsOffsetParent: i } = this.config,
        { isTop: s, isRight: n, isBottom: r, isLeft: o } = this.currentResizer,
        a = n || o,
        l = r || s,
        { movementX: c, movementY: u } = this.calculateMouseMovement({
          e,
          isLeft: o,
          isTop: s,
        }),
        h = this.position.x,
        g = this.position.y
      let f = 0,
        p = 0
      if (a && c) {
        const v = o ? -1 : 1,
          m = this.getWidth(),
          C = m + c * v
        let w = !1
        o &&
          ((f = m - C),
          (h + f <= 0 || C <= this.minWidth) && ((w = !0), (f = 0))),
          w || this.setWidth(C)
      }
      if (l && u) {
        const v = s ? -1 : 1,
          m = this.getHeight(),
          C = m + u * v
        let w = !1
        s
          ? ((p = m - C),
            (g + p <= 0 || C <= this.minHeight) && ((w = !0), (p = 0)))
          : !this.config.popup &&
            !this.config.forcePopupParentAsOffsetParent &&
            m < C &&
            this.getMinSizeOfSiblings().height + C >
              this.element.parentElement.offsetHeight &&
            (w = !0),
          w || this.setHeight(C)
      }
      this.updateDragStartPosition(e.clientX, e.clientY),
        (((t || i) && f) || p) && this.offsetElement(h + f, g + p)
    }
    onResizeEnd(e, t) {
      ;(this.isResizing = !1),
        (this.currentResizer = null),
        (this.boundaryEl = null),
        this.element.classList.remove('ag-resizing'),
        this.resizerMap[t].element.classList.remove('ag-active'),
        this.dispatchLocalEvent({ type: 'resize' })
    }
    refreshSize() {
      const e = this.element
      this.config.popup &&
        (this.config.width || this.setWidth(e.offsetWidth),
        this.config.height || this.setHeight(e.offsetHeight))
    }
    onMoveStart(e) {
      ;(this.boundaryEl = this.findBoundaryElement()),
        this.positioned || this.initialisePosition(),
        (this.isMoving = !0),
        this.element.classList.add('ag-moving'),
        this.updateDragStartPosition(e.clientX, e.clientY)
    }
    onMove(e) {
      if (!this.isMoving) return
      const { x: t, y: i } = this.position
      let s
      this.config.calculateTopBuffer && (s = this.config.calculateTopBuffer())
      const { movementX: n, movementY: r } = this.calculateMouseMovement({
        e,
        isTop: !0,
        anywhereWithin: !0,
        topBuffer: s,
      })
      this.offsetElement(t + n, i + r),
        this.updateDragStartPosition(e.clientX, e.clientY)
    }
    onMoveEnd() {
      ;(this.isMoving = !1),
        (this.boundaryEl = null),
        this.element.classList.remove('ag-moving')
    }
    setOffsetParent() {
      this.config.forcePopupParentAsOffsetParent
        ? (this.offsetParent = this.popupService.getPopupParent())
        : (this.offsetParent = this.element.offsetParent)
    }
    findBoundaryElement() {
      let e = this.element
      for (; e; ) {
        if (window.getComputedStyle(e).position !== 'static') return e
        e = e.parentElement
      }
      return this.element
    }
    clearResizeListeners() {
      for (; this.resizeListeners.length; ) {
        const e = this.resizeListeners.pop()
        this.dragService.removeDragSource(e)
      }
    }
    destroy() {
      super.destroy(),
        this.moveElementDragListener &&
          this.dragService.removeDragSource(this.moveElementDragListener),
        this.constrainSizeToAvailableHeight(!1),
        this.clearResizeListeners(),
        this.removeResizers()
    }
  },
  lv = class cv extends X {
    constructor(t, i = {}) {
      super(),
        (this.eFocusableElement = t),
        (this.callbacks = i),
        (this.callbacks = {
          shouldStopEventPropagation: () => !1,
          onTabKeyDown: (s) => {
            if (s.defaultPrevented) return
            const n = this.focusService.findNextFocusableElement(
              this.eFocusableElement,
              !1,
              s.shiftKey,
            )
            n && (n.focus(), s.preventDefault())
          },
          ...i,
        })
    }
    wireBeans(t) {
      this.focusService = t.focusService
    }
    postConstruct() {
      this.eFocusableElement.classList.add(cv.FOCUS_MANAGED_CLASS),
        this.addKeyDownListeners(this.eFocusableElement),
        this.callbacks.onFocusIn &&
          this.addManagedElementListeners(this.eFocusableElement, {
            focusin: this.callbacks.onFocusIn,
          }),
        this.callbacks.onFocusOut &&
          this.addManagedElementListeners(this.eFocusableElement, {
            focusout: this.callbacks.onFocusOut,
          })
    }
    addKeyDownListeners(t) {
      this.addManagedElementListeners(t, {
        keydown: (i) => {
          if (!(i.defaultPrevented || Os(i))) {
            if (this.callbacks.shouldStopEventPropagation(i)) {
              pr(i)
              return
            }
            i.key === Y.TAB
              ? this.callbacks.onTabKeyDown(i)
              : this.callbacks.handleKeyDown && this.callbacks.handleKeyDown(i)
          }
        },
      })
    }
  }
lv.FOCUS_MANAGED_CLASS = 'ag-focus-managed'
var jn = lv,
  uv = {
    applyFilter: 'Apply',
    clearFilter: 'Clear',
    resetFilter: 'Reset',
    cancelFilter: 'Cancel',
    textFilter: 'Text Filter',
    numberFilter: 'Number Filter',
    dateFilter: 'Date Filter',
    setFilter: 'Set Filter',
    filterOoo: 'Filter...',
    empty: 'Choose one',
    equals: 'Equals',
    notEqual: 'Does not equal',
    lessThan: 'Less than',
    greaterThan: 'Greater than',
    inRange: 'Between',
    inRangeStart: 'From',
    inRangeEnd: 'To',
    lessThanOrEqual: 'Less than or equal to',
    greaterThanOrEqual: 'Greater than or equal to',
    contains: 'Contains',
    notContains: 'Does not contain',
    startsWith: 'Begins with',
    endsWith: 'Ends with',
    blank: 'Blank',
    notBlank: 'Not blank',
    before: 'Before',
    after: 'After',
    andCondition: 'AND',
    orCondition: 'OR',
    dateFormatOoo: 'yyyy-mm-dd',
  }
function md(e, t) {
  return Wa(e)
    ? (e.debounceMs != null &&
        te('debounceMs is ignored when apply button is present'),
      0)
    : e.debounceMs != null
      ? e.debounceMs
      : t
}
function Wa(e) {
  return !!e.buttons && e.buttons.indexOf('apply') >= 0
}
var EM = class extends yt {
    constructor(e) {
      super(),
        (this.filterNameKey = e),
        (this.applyActive = !1),
        (this.hidePopup = null),
        (this.debouncePending = !1),
        (this.appliedModel = null),
        (this.eFilterBody = Le),
        (this.buttonListeners = [])
    }
    wireBeans(e) {
      this.rowModel = e.rowModel
    }
    postConstruct() {
      this.resetTemplate(),
        this.createManagedBean(
          new jn(this.getFocusableElement(), {
            handleKeyDown: this.handleKeyDown.bind(this),
          }),
        ),
        (this.positionableFeature = new FM(this.getPositionableElement(), {
          forcePopupParentAsOffsetParent: !0,
        })),
        this.createBean(this.positionableFeature)
    }
    handleKeyDown(e) {}
    getFilterTitle() {
      return this.translate(this.filterNameKey)
    }
    isFilterActive() {
      return !!this.appliedModel
    }
    resetTemplate(e) {
      let t = this.getGui()
      t && t.removeEventListener('submit', this.onFormSubmit)
      const i = `
            <form class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper" data-ref="eFilterBody">
                    ${this.createBodyTemplate()}
                </div>
            </form>`
      this.setTemplate(i, this.getAgComponents(), e),
        (t = this.getGui()),
        t && t.addEventListener('submit', this.onFormSubmit)
    }
    isReadOnly() {
      return !!this.providedFilterParams.readOnly
    }
    init(e) {
      this.setParams(e),
        this.resetUiToDefaults(!0).then(() => {
          this.updateUiVisibility(), this.setupOnBtApplyDebounce()
        })
    }
    setParams(e) {
      ;(this.providedFilterParams = e),
        (this.applyActive = Wa(e)),
        this.resetButtonsPanel(e)
    }
    updateParams(e) {
      ;(this.providedFilterParams = e),
        (this.applyActive = Wa(e)),
        this.resetUiToActiveModel(this.getModel(), () => {
          this.updateUiVisibility(), this.setupOnBtApplyDebounce()
        })
    }
    resetButtonsPanel(e, t) {
      const { buttons: i, readOnly: s } = t ?? {},
        { buttons: n, readOnly: r } = e
      if (s === r && po(i, n)) return
      const o = n && n.length > 0 && !this.isReadOnly()
      if (
        (this.eButtonsPanel
          ? (Ni(this.eButtonsPanel),
            this.buttonListeners.forEach((c) => c()),
            (this.buttonListeners = []))
          : o &&
            ((this.eButtonsPanel = document.createElement('div')),
            this.eButtonsPanel.classList.add('ag-filter-apply-panel')),
        !o)
      ) {
        this.eButtonsPanel && Bn(this.eButtonsPanel)
        return
      }
      const a = document.createDocumentFragment(),
        l = (c) => {
          let u, h
          switch (c) {
            case 'apply':
              ;(u = this.translate('applyFilter')),
                (h = (p) => this.onBtApply(!1, !1, p))
              break
            case 'clear':
              ;(u = this.translate('clearFilter')), (h = () => this.onBtClear())
              break
            case 'reset':
              ;(u = this.translate('resetFilter')), (h = () => this.onBtReset())
              break
            case 'cancel':
              ;(u = this.translate('cancelFilter')),
                (h = (p) => {
                  this.onBtCancel(p)
                })
              break
            default:
              te('Unknown button type specified')
              return
          }
          const f = bo(`<button
                    type="${c === 'apply' ? 'submit' : 'button'}"
                    data-ref="${c}FilterButton"
                    class="ag-button ag-standard-button ag-filter-apply-panel-button"
                >${u}
                </button>`)
          this.buttonListeners.push(
            ...this.addManagedElementListeners(f, { click: h }),
          ),
            a.append(f)
        }
      n.forEach((c) => l(c)),
        this.eButtonsPanel.append(a),
        this.getGui().appendChild(this.eButtonsPanel)
    }
    getDefaultDebounceMs() {
      return 0
    }
    setupOnBtApplyDebounce() {
      const e = md(this.providedFilterParams, this.getDefaultDebounceMs()),
        t = bi(this.checkApplyDebounce.bind(this), e)
      this.onBtApplyDebounce = () => {
        ;(this.debouncePending = !0), t()
      }
    }
    checkApplyDebounce() {
      this.debouncePending && ((this.debouncePending = !1), this.onBtApply())
    }
    getModel() {
      return this.appliedModel ? this.appliedModel : null
    }
    setModel(e) {
      return (
        e != null ? this.setModelIntoUi(e) : this.resetUiToDefaults()
      ).then(() => {
        this.updateUiVisibility(), this.applyModel('api')
      })
    }
    onBtCancel(e) {
      this.resetUiToActiveModel(this.getModel(), () => {
        this.handleCancelEnd(e)
      })
    }
    handleCancelEnd(e) {
      this.providedFilterParams.closeOnApply && this.close(e)
    }
    resetUiToActiveModel(e, t) {
      const i = () => {
        this.onUiChanged(!1, 'prevent'), t == null || t()
      }
      e != null
        ? this.setModelIntoUi(e).then(i)
        : this.resetUiToDefaults().then(i)
    }
    onBtClear() {
      this.resetUiToDefaults().then(() => this.onUiChanged())
    }
    onBtReset() {
      this.onBtClear(), this.onBtApply()
    }
    applyModel(e = 'api') {
      const t = this.getModelFromUi()
      if (!this.isModelValid(t)) return !1
      const i = this.appliedModel
      return (this.appliedModel = t), !this.areModelsEqual(i, t)
    }
    isModelValid(e) {
      return !0
    }
    onFormSubmit(e) {
      e.preventDefault()
    }
    onBtApply(e = !1, t = !1, i) {
      i && i.preventDefault(),
        this.applyModel(t ? 'rowDataUpdated' : 'ui') &&
          this.providedFilterParams.filterChangedCallback({
            afterFloatingFilter: e,
            afterDataChange: t,
            source: 'columnFilter',
          })
      const { closeOnApply: s } = this.providedFilterParams
      s && this.applyActive && !e && !t && this.close(i)
    }
    onNewRowsLoaded() {}
    close(e) {
      if (!this.hidePopup) return
      const t = e,
        i = t && t.key
      let s
      ;(i === 'Enter' || i === 'Space') && (s = { keyboardEvent: t }),
        this.hidePopup(s),
        (this.hidePopup = null)
    }
    onUiChanged(e = !1, t) {
      if (
        (this.updateUiVisibility(),
        this.providedFilterParams.filterModifiedCallback(),
        this.applyActive && !this.isReadOnly())
      ) {
        const i = this.isModelValid(this.getModelFromUi()),
          s = this.queryForHtmlElement('[data-ref="applyFilterButton"]')
        s && yo(s, !i)
      }
      ;(e && !t) || t === 'immediately'
        ? this.onBtApply(e)
        : ((!this.applyActive && !t) || t === 'debounce') &&
          this.onBtApplyDebounce()
    }
    afterGuiAttached(e) {
      e && (this.hidePopup = e.hidePopup),
        this.refreshFilterResizer(e == null ? void 0 : e.container)
    }
    refreshFilterResizer(e) {
      if (!this.positionableFeature || e === 'toolPanel') return
      const t = e === 'floatingFilter' || e === 'columnFilter',
        { positionableFeature: i, gos: s } = this
      t
        ? (i.restoreLastSize(),
          i.setResizable(
            s.get('enableRtl')
              ? { bottom: !0, bottomLeft: !0, left: !0 }
              : { bottom: !0, bottomRight: !0, right: !0 },
          ))
        : (this.positionableFeature.removeSizeFromEl(),
          this.positionableFeature.setResizable(!1)),
        this.positionableFeature.constrainSizeToAvailableHeight(!0)
    }
    afterGuiDetached() {
      this.checkApplyDebounce(),
        this.positionableFeature &&
          this.positionableFeature.constrainSizeToAvailableHeight(!1)
    }
    refresh(e) {
      const t = this.providedFilterParams
      return (this.providedFilterParams = e), this.resetButtonsPanel(e, t), !0
    }
    destroy() {
      const e = this.getGui()
      e && e.removeEventListener('submit', this.onFormSubmit),
        (this.hidePopup = null),
        this.positionableFeature &&
          (this.positionableFeature = this.destroyBean(
            this.positionableFeature,
          )),
        (this.appliedModel = null),
        super.destroy()
    }
    translate(e) {
      return this.localeService.getLocaleTextFunc()(e, uv[e])
    }
    getCellValue(e) {
      return this.providedFilterParams.getValue(e)
    }
    getPositionableElement() {
      return this.eFilterBody
    }
  },
  PM = class extends gd {
    constructor(e) {
      super(e, 'ag-radio-button', 'radio')
    }
    isSelected() {
      return this.eInput.checked
    }
    toggle() {
      this.eInput.disabled || this.isSelected() || this.setValue(!0)
    }
    addInputListeners() {
      super.addInputListeners(),
        this.addManagedEventListeners({
          checkboxChanged: this.onChange.bind(this),
        })
    }
    onChange(e) {
      e.selected &&
        e.name &&
        this.eInput.name &&
        this.eInput.name === e.name &&
        e.id &&
        this.eInput.id !== e.id &&
        this.setValue(!1, !0)
    }
  },
  xM = class extends yt {
    constructor(e = 'default', t = !1) {
      super(`<div class="ag-list ag-${e}-list" role="listbox"></div>`),
        (this.cssIdentifier = e),
        (this.unFocusable = t),
        (this.activeClass = 'ag-active-item'),
        (this.options = []),
        (this.itemEls = [])
    }
    postConstruct() {
      const e = this.getGui()
      this.addManagedElementListeners(e, {
        mouseleave: () => this.clearHighlighted(),
      }),
        !this.unFocusable &&
          this.addManagedElementListeners(e, {
            keydown: this.handleKeyDown.bind(this),
          })
    }
    handleKeyDown(e) {
      const t = e.key
      switch (t) {
        case Y.ENTER:
          if (!this.highlightedEl) this.setValue(this.getValue())
          else {
            const i = this.itemEls.indexOf(this.highlightedEl)
            this.setValueByIndex(i)
          }
          break
        case Y.DOWN:
        case Y.UP:
          e.preventDefault(), this.navigate(t)
          break
        case Y.PAGE_DOWN:
        case Y.PAGE_UP:
        case Y.PAGE_HOME:
        case Y.PAGE_END:
          e.preventDefault(), this.navigateToPage(t)
          break
      }
    }
    navigate(e) {
      const t = e === Y.DOWN
      let i
      if (!this.highlightedEl) i = this.itemEls[t ? 0 : this.itemEls.length - 1]
      else {
        let n = this.itemEls.indexOf(this.highlightedEl) + (t ? 1 : -1)
        ;(n = Math.min(Math.max(n, 0), this.itemEls.length - 1)),
          (i = this.itemEls[n])
      }
      this.highlightItem(i)
    }
    navigateToPage(e) {
      if (!this.highlightedEl || this.itemEls.length === 0) return
      const t = this.itemEls.indexOf(this.highlightedEl),
        i = this.options.length - 1,
        s = this.itemEls[0].clientHeight,
        n = Math.floor(this.getGui().clientHeight / s)
      let r = -1
      e === Y.PAGE_HOME
        ? (r = 0)
        : e === Y.PAGE_END
          ? (r = i)
          : e === Y.PAGE_DOWN
            ? (r = Math.min(t + n, i))
            : e === Y.PAGE_UP && (r = Math.max(t - n, 0)),
        r !== -1 && this.highlightItem(this.itemEls[r])
    }
    addOptions(e) {
      return e.forEach((t) => this.addOption(t)), this
    }
    addOption(e) {
      const { value: t, text: i } = e,
        s = i || t
      return (
        this.options.push({ value: t, text: s }),
        this.renderOption(t, s),
        this.updateIndices(),
        this
      )
    }
    clearOptions() {
      ;(this.options = []),
        this.reset(!0),
        this.itemEls.forEach((e) => {
          Bn(e)
        }),
        (this.itemEls = [])
    }
    updateIndices() {
      const e = this.getGui().querySelectorAll('.ag-list-item')
      e.forEach((t, i) => {
        rD(t, i + 1), nD(t, e.length)
      })
    }
    renderOption(e, t) {
      const i = Gt(this.gos),
        s = i.createElement('div')
      es(s, 'option'),
        s.classList.add('ag-list-item', `ag-${this.cssIdentifier}-list-item`)
      const n = i.createElement('span')
      s.appendChild(n),
        (n.textContent = t),
        this.unFocusable || (s.tabIndex = -1),
        this.itemEls.push(s),
        this.addManagedListeners(s, {
          mouseover: () => this.highlightItem(s),
          mousedown: (r) => {
            r.preventDefault(), r.stopPropagation(), this.setValue(e)
          },
        }),
        this.createManagedBean(
          new Tr({
            getTooltipValue: () => t,
            getGui: () => s,
            getLocation: () => 'UNKNOWN',
            shouldDisplayTooltip: () => n.scrollWidth > n.clientWidth,
          }),
        ),
        this.getGui().appendChild(s)
    }
    setValue(e, t) {
      if (this.value === e) return this.fireItemSelected(), this
      if (e == null) return this.reset(t), this
      const i = this.options.findIndex((s) => s.value === e)
      if (i !== -1) {
        const s = this.options[i]
        ;(this.value = s.value),
          (this.displayValue = s.text),
          this.highlightItem(this.itemEls[i]),
          t || this.fireChangeEvent()
      }
      return this
    }
    setValueByIndex(e) {
      return this.setValue(this.options[e].value)
    }
    getValue() {
      return this.value
    }
    getDisplayValue() {
      return this.displayValue
    }
    refreshHighlighted() {
      this.clearHighlighted()
      const e = this.options.findIndex((t) => t.value === this.value)
      e !== -1 && this.highlightItem(this.itemEls[e])
    }
    reset(e) {
      ;(this.value = null),
        (this.displayValue = null),
        this.clearHighlighted(),
        e || this.fireChangeEvent()
    }
    highlightItem(e) {
      if (!fs(e)) return
      this.clearHighlighted(),
        (this.highlightedEl = e),
        this.highlightedEl.classList.add(this.activeClass),
        Ha(this.highlightedEl, !0)
      const t = this.getGui(),
        { scrollTop: i, clientHeight: s } = t,
        { offsetTop: n, offsetHeight: r } = e
      ;(n + r > i + s || n < i) &&
        this.highlightedEl.scrollIntoView({ block: 'nearest' }),
        this.unFocusable || this.highlightedEl.focus()
    }
    clearHighlighted() {
      !this.highlightedEl ||
        !fs(this.highlightedEl) ||
        (this.highlightedEl.classList.remove(this.activeClass),
        Ha(this.highlightedEl, !1),
        (this.highlightedEl = null))
    }
    fireChangeEvent() {
      this.dispatchLocalEvent({ type: 'fieldValueChanged' }),
        this.fireItemSelected()
    }
    fireItemSelected() {
      this.dispatchLocalEvent({ type: 'selectedItem' })
    }
  },
  DM = class extends ev {
    constructor(e) {
      if (
        (super(
          e,
          (e == null ? void 0 : e.template) ||
            `
            <div class="ag-picker-field" role="presentation">
                <div data-ref="eLabel"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-picker-collapsed">
                    <div data-ref="eDisplayField" class="ag-picker-field-display"></div>
                    <div data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                </div>
            </div>`,
          (e == null ? void 0 : e.agComponents) || [],
          e == null ? void 0 : e.className,
        ),
        (this.isPickerDisplayed = !1),
        (this.skipClick = !1),
        (this.pickerGap = 4),
        (this.hideCurrentPicker = null),
        (this.eLabel = Le),
        (this.eWrapper = Le),
        (this.eDisplayField = Le),
        (this.eIcon = Le),
        (this.ariaRole = e == null ? void 0 : e.ariaRole),
        (this.onPickerFocusIn = this.onPickerFocusIn.bind(this)),
        (this.onPickerFocusOut = this.onPickerFocusOut.bind(this)),
        !e)
      )
        return
      const {
        pickerGap: t,
        maxPickerHeight: i,
        variableWidth: s,
        minPickerWidth: n,
        maxPickerWidth: r,
      } = e
      t != null && (this.pickerGap = t),
        (this.variableWidth = !!s),
        i != null && this.setPickerMaxHeight(i),
        n != null && this.setPickerMinWidth(n),
        r != null && this.setPickerMaxWidth(r)
    }
    wireBeans(e) {
      this.popupService = e.popupService
    }
    postConstruct() {
      super.postConstruct(), this.setupAria()
      const e = `ag-${this.getCompId()}-display`
      this.eDisplayField.setAttribute('id', e)
      const t = this.getAriaElement()
      this.addManagedElementListeners(t, {
        keydown: this.onKeyDown.bind(this),
      }),
        this.addManagedElementListeners(this.eLabel, {
          mousedown: this.onLabelOrWrapperMouseDown.bind(this),
        }),
        this.addManagedElementListeners(this.eWrapper, {
          mousedown: this.onLabelOrWrapperMouseDown.bind(this),
        })
      const { pickerIcon: i, inputWidth: s } = this.config
      if (i) {
        const n = Li(i, this.gos)
        n && this.eIcon.appendChild(n)
      }
      s != null && this.setInputWidth(s)
    }
    setupAria() {
      const e = this.getAriaElement()
      e.setAttribute('tabindex', this.gos.get('tabIndex').toString()),
        ka(e, !1),
        this.ariaRole && es(e, this.ariaRole)
    }
    onLabelOrWrapperMouseDown(e) {
      if (e) {
        const t = this.getFocusableElement()
        if (t !== this.eWrapper && (e == null ? void 0 : e.target) === t) return
        e.preventDefault(), this.getFocusableElement().focus()
      }
      if (this.skipClick) {
        this.skipClick = !1
        return
      }
      this.isDisabled() ||
        (this.isPickerDisplayed ? this.hidePicker() : this.showPicker())
    }
    onKeyDown(e) {
      switch (e.key) {
        case Y.UP:
        case Y.DOWN:
        case Y.ENTER:
        case Y.SPACE:
          e.preventDefault(), this.onLabelOrWrapperMouseDown()
          break
        case Y.ESCAPE:
          this.isPickerDisplayed &&
            (e.preventDefault(),
            e.stopPropagation(),
            this.hideCurrentPicker && this.hideCurrentPicker())
          break
      }
    }
    showPicker() {
      ;(this.isPickerDisplayed = !0),
        this.pickerComponent ||
          (this.pickerComponent = this.createPickerComponent())
      const e = this.pickerComponent.getGui()
      e.addEventListener('focusin', this.onPickerFocusIn),
        e.addEventListener('focusout', this.onPickerFocusOut),
        (this.hideCurrentPicker = this.renderAndPositionPicker()),
        this.toggleExpandedStyles(!0)
    }
    renderAndPositionPicker() {
      const e = this.pickerComponent.getGui()
      this.gos.get('suppressScrollWhenPopupsAreOpen') ||
        ([this.destroyMouseWheelFunc] = this.addManagedEventListeners({
          bodyScroll: () => {
            this.hidePicker()
          },
        }))
      const t = this.localeService.getLocaleTextFunc(),
        {
          pickerAriaLabelKey: i,
          pickerAriaLabelValue: s,
          modalPicker: n = !0,
        } = this.config,
        r = {
          modal: n,
          eChild: e,
          closeOnEsc: !0,
          closedCallback: () => {
            const g = Sm(this.gos)
            this.beforeHidePicker(),
              g && this.isAlive() && this.getFocusableElement().focus()
          },
          ariaLabel: t(i, s),
          anchorToElement: this.eWrapper,
        }
      e.style.position = 'absolute'
      const o = this.popupService.addPopup(r),
        {
          maxPickerHeight: a,
          minPickerWidth: l,
          maxPickerWidth: c,
          variableWidth: u,
        } = this
      u
        ? (l && (e.style.minWidth = l),
          (e.style.width = ud(Na(this.eWrapper))),
          c && (e.style.maxWidth = c))
        : _a(e, c ?? Na(this.eWrapper))
      const h = a ?? `${cd(this.popupService.getPopupParent())}px`
      return (
        e.style.setProperty('max-height', h),
        this.alignPickerToComponent(),
        o.hideFunc
      )
    }
    alignPickerToComponent() {
      if (!this.pickerComponent) return
      const { pickerType: e } = this.config,
        { pickerGap: t } = this,
        i = this.gos.get('enableRtl') ? 'right' : 'left'
      this.popupService.positionPopupByComponent({
        type: e,
        eventSource: this.eWrapper,
        ePopup: this.pickerComponent.getGui(),
        position: 'under',
        alignSide: i,
        keepWithinBounds: !0,
        nudgeY: t,
      })
    }
    beforeHidePicker() {
      this.destroyMouseWheelFunc &&
        (this.destroyMouseWheelFunc(), (this.destroyMouseWheelFunc = void 0)),
        this.toggleExpandedStyles(!1)
      const e = this.pickerComponent.getGui()
      e.removeEventListener('focusin', this.onPickerFocusIn),
        e.removeEventListener('focusout', this.onPickerFocusOut),
        (this.isPickerDisplayed = !1),
        (this.pickerComponent = void 0),
        (this.hideCurrentPicker = null)
    }
    toggleExpandedStyles(e) {
      if (!this.isAlive()) return
      const t = this.getAriaElement()
      ka(t, e),
        this.eWrapper.classList.toggle('ag-picker-expanded', e),
        this.eWrapper.classList.toggle('ag-picker-collapsed', !e)
    }
    onPickerFocusIn() {
      this.togglePickerHasFocus(!0)
    }
    onPickerFocusOut(e) {
      var t
      ;((t = this.pickerComponent) != null &&
        t.getGui().contains(e.relatedTarget)) ||
        this.togglePickerHasFocus(!1)
    }
    togglePickerHasFocus(e) {
      this.pickerComponent &&
        this.eWrapper.classList.toggle('ag-picker-has-focus', e)
    }
    hidePicker() {
      this.hideCurrentPicker && this.hideCurrentPicker()
    }
    setInputWidth(e) {
      return _a(this.eWrapper, e), this
    }
    getFocusableElement() {
      return this.eWrapper
    }
    setPickerGap(e) {
      return (this.pickerGap = e), this
    }
    setPickerMinWidth(e) {
      return (
        typeof e == 'number' && (e = `${e}px`),
        (this.minPickerWidth = e ?? void 0),
        this
      )
    }
    setPickerMaxWidth(e) {
      return (
        typeof e == 'number' && (e = `${e}px`),
        (this.maxPickerWidth = e ?? void 0),
        this
      )
    }
    setPickerMaxHeight(e) {
      return (
        typeof e == 'number' && (e = `${e}px`),
        (this.maxPickerHeight = e ?? void 0),
        this
      )
    }
    destroy() {
      this.hidePicker(), super.destroy()
    }
  },
  vd = class extends DM {
    constructor(e) {
      super({
        pickerAriaLabelKey: 'ariaLabelSelectField',
        pickerAriaLabelValue: 'Select Field',
        pickerType: 'ag-list',
        className: 'ag-select',
        pickerIcon: 'smallDown',
        ariaRole: 'combobox',
        ...e,
      })
    }
    postConstruct() {
      super.postConstruct(),
        this.createListComponent(),
        (this.eWrapper.tabIndex = this.gos.get('tabIndex'))
      const { options: e, value: t, placeholder: i } = this.config
      e != null && this.addOptions(e),
        t != null && this.setValue(t, !0),
        i && t == null && (this.eDisplayField.textContent = i),
        this.addManagedElementListeners(this.eWrapper, {
          focusout: this.onWrapperFocusOut.bind(this),
        })
    }
    onWrapperFocusOut(e) {
      this.eWrapper.contains(e.relatedTarget) || this.hidePicker()
    }
    createListComponent() {
      ;(this.listComponent = this.createBean(new xM('select', !0))),
        this.listComponent.setParentComponent(this)
      const e = this.listComponent.getAriaElement(),
        t = `ag-select-list-${this.listComponent.getCompId()}`
      e.setAttribute('id', t),
        hD(this.getAriaElement(), e),
        this.listComponent.addManagedListeners(this.listComponent, {
          selectedItem: () => {
            this.hidePicker(), this.dispatchLocalEvent({ type: 'selectedItem' })
          },
        }),
        this.listComponent.addManagedListeners(this.listComponent, {
          fieldValueChanged: () => {
            this.listComponent &&
              (this.setValue(this.listComponent.getValue(), !1, !0),
              this.hidePicker())
          },
        })
    }
    createPickerComponent() {
      return this.listComponent
    }
    onKeyDown(e) {
      var i
      const { key: t } = e
      switch ((t === Y.TAB && this.hidePicker(), t)) {
        case Y.ENTER:
        case Y.UP:
        case Y.DOWN:
        case Y.PAGE_UP:
        case Y.PAGE_DOWN:
        case Y.PAGE_HOME:
        case Y.PAGE_END:
          e.preventDefault(),
            this.isPickerDisplayed
              ? (i = this.listComponent) == null || i.handleKeyDown(e)
              : super.onKeyDown(e)
          break
        case Y.ESCAPE:
          super.onKeyDown(e)
          break
        case Y.SPACE:
          this.isPickerDisplayed ? e.preventDefault() : super.onKeyDown(e)
          break
      }
    }
    showPicker() {
      this.listComponent &&
        (super.showPicker(), this.listComponent.refreshHighlighted())
    }
    addOptions(e) {
      return e.forEach((t) => this.addOption(t)), this
    }
    addOption(e) {
      return this.listComponent.addOption(e), this
    }
    clearOptions() {
      var e
      return (e = this.listComponent) == null || e.clearOptions(), this
    }
    setValue(e, t, i) {
      if (this.value === e || !this.listComponent) return this
      if (
        (i || this.listComponent.setValue(e, !0),
        this.listComponent.getValue() === this.getValue())
      )
        return this
      let n = this.listComponent.getDisplayValue()
      return (
        n == null && this.config.placeholder && (n = this.config.placeholder),
        (this.eDisplayField.textContent = n),
        this.setTooltip({
          newTooltipText: n ?? null,
          shouldDisplayTooltip: () =>
            this.eDisplayField.scrollWidth > this.eDisplayField.clientWidth,
        }),
        super.setValue(e, t)
      )
    }
    destroy() {
      this.listComponent &&
        (this.listComponent = this.destroyBean(this.listComponent)),
        super.destroy()
    }
  },
  MM = { selector: 'AG-SELECT', component: vd },
  dv = class {
    constructor() {
      this.customFilterOptions = {}
    }
    init(e, t) {
      ;(this.filterOptions = e.filterOptions || t),
        this.mapCustomOptions(),
        this.selectDefaultItem(e)
    }
    getFilterOptions() {
      return this.filterOptions
    }
    mapCustomOptions() {
      this.filterOptions &&
        this.filterOptions.forEach((e) => {
          if (typeof e == 'string') return
          const t = [['displayKey'], ['displayName'], ['predicate', 'test']],
            i = (s) =>
              s.some((n) => e[n] != null)
                ? !0
                : (te(
                    `ignoring FilterOptionDef as it doesn't contain one of '${s}'`,
                  ),
                  !1)
          if (!t.every(i)) {
            this.filterOptions = this.filterOptions.filter((s) => s === e) || []
            return
          }
          this.customFilterOptions[e.displayKey] = e
        })
    }
    selectDefaultItem(e) {
      if (e.defaultOption) this.defaultOption = e.defaultOption
      else if (this.filterOptions.length >= 1) {
        const t = this.filterOptions[0]
        typeof t == 'string'
          ? (this.defaultOption = t)
          : t.displayKey
            ? (this.defaultOption = t.displayKey)
            : te(
                "invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'",
              )
      } else te('no filter options for filter')
    }
    getDefaultOption() {
      return this.defaultOption
    }
    getCustomOption(e) {
      return this.customFilterOptions[e]
    }
  },
  hv = class extends EM {
    constructor() {
      super(...arguments),
        (this.eTypes = []),
        (this.eJoinOperatorPanels = []),
        (this.eJoinOperatorsAnd = []),
        (this.eJoinOperatorsOr = []),
        (this.eConditionBodies = []),
        (this.listener = () => this.onUiChanged()),
        (this.lastUiCompletePosition = null),
        (this.joinOperatorId = 0)
    }
    getNumberOfInputs(e) {
      const t = this.optionsFactory.getCustomOption(e)
      if (t) {
        const { numberOfInputs: s } = t
        return s ?? 1
      }
      return e && ['empty', 'notBlank', 'blank'].indexOf(e) >= 0
        ? 0
        : e === 'inRange'
          ? 2
          : 1
    }
    onFloatingFilterChanged(e, t) {
      this.setTypeFromFloatingFilter(e),
        this.setValueFromFloatingFilter(t),
        this.onUiChanged(!0)
    }
    setTypeFromFloatingFilter(e) {
      this.eTypes.forEach((t, i) => {
        i === 0
          ? t.setValue(e, !0)
          : t.setValue(this.optionsFactory.getDefaultOption(), !0)
      })
    }
    getModelFromUi() {
      const e = this.getUiCompleteConditions()
      return e.length === 0
        ? null
        : this.maxNumConditions > 1 && e.length > 1
          ? {
              filterType: this.getFilterType(),
              operator: this.getJoinOperator(),
              conditions: e,
            }
          : e[0]
    }
    getConditionTypes() {
      return this.eTypes.map((e) => e.getValue())
    }
    getConditionType(e) {
      return this.eTypes[e].getValue()
    }
    getJoinOperator() {
      return this.eJoinOperatorsOr.length === 0
        ? this.defaultJoinOperator
        : this.eJoinOperatorsOr[0].getValue() === !0
          ? 'OR'
          : 'AND'
    }
    areModelsEqual(e, t) {
      if (!e && !t) return !0
      if ((!e && t) || (e && !t)) return !1
      const i = !e.operator,
        s = !t.operator
      if ((!i && s) || (i && !s)) return !1
      let r
      if (i) {
        const o = e,
          a = t
        r = this.areSimpleModelsEqual(o, a)
      } else {
        const o = e,
          a = t
        r =
          o.operator === a.operator &&
          gn(o.conditions, a.conditions, (l, c) =>
            this.areSimpleModelsEqual(l, c),
          )
      }
      return r
    }
    shouldRefresh(e) {
      var r
      const t = this.getModel(),
        i = t ? (t.conditions ?? [t]) : null,
        s =
          ((r = e.filterOptions) == null
            ? void 0
            : r.map((o) => (typeof o == 'string' ? o : o.displayKey))) ??
          this.getDefaultFilterOptions()
      return !(
        !(!i || i.every((o) => s.find((a) => a === o.type) !== void 0)) ||
        (typeof e.maxNumConditions == 'number' &&
          i &&
          i.length > e.maxNumConditions)
      )
    }
    refresh(e) {
      return !this.shouldRefresh(e) || !super.refresh(e)
        ? !1
        : (this.setParams(e),
          this.removeConditionsAndOperators(0),
          this.createOption(),
          this.setModel(this.getModel()),
          !0)
    }
    setModelIntoUi(e) {
      if (e.operator) {
        const i = e
        let s = i.conditions
        s == null && ((s = []), te("Filter model is missing 'conditions'"))
        const n = this.validateAndUpdateConditions(s),
          r = this.getNumConditions()
        if (n < r) this.removeConditionsAndOperators(n)
        else if (n > r)
          for (let a = r; a < n; a++)
            this.createJoinOperatorPanel(), this.createOption()
        const o = i.operator === 'OR'
        this.eJoinOperatorsAnd.forEach((a) => a.setValue(!o, !0)),
          this.eJoinOperatorsOr.forEach((a) => a.setValue(o, !0)),
          s.forEach((a, l) => {
            this.eTypes[l].setValue(a.type, !0), this.setConditionIntoUi(a, l)
          })
      } else {
        const i = e
        this.getNumConditions() > 1 && this.removeConditionsAndOperators(1),
          this.eTypes[0].setValue(i.type, !0),
          this.setConditionIntoUi(i, 0)
      }
      return (
        (this.lastUiCompletePosition = this.getNumConditions() - 1),
        this.createMissingConditionsAndOperators(),
        this.onUiChanged(),
        Nt.resolve()
      )
    }
    validateAndUpdateConditions(e) {
      let t = e.length
      return (
        t > this.maxNumConditions &&
          (e.splice(this.maxNumConditions),
          te(
            'Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.',
          ),
          (t = this.maxNumConditions)),
        t
      )
    }
    doesFilterPass(e) {
      const t = this.getModel()
      if (t == null) return !0
      const { operator: i } = t,
        s = []
      if (i) {
        const r = t
        s.push(...(r.conditions ?? []))
      } else s.push(t)
      return s[i && i === 'OR' ? 'some' : 'every']((r) =>
        this.individualConditionPasses(e, r),
      )
    }
    setParams(e) {
      super.setParams(e),
        this.setNumConditions(e),
        (this.defaultJoinOperator = this.getDefaultJoinOperator(
          e.defaultJoinOperator,
        )),
        (this.filterPlaceholder = e.filterPlaceholder),
        (this.optionsFactory = new dv()),
        this.optionsFactory.init(e, this.getDefaultFilterOptions()),
        this.createFilterListOptions(),
        this.createOption(),
        this.createMissingConditionsAndOperators(),
        this.isReadOnly() && this.eFilterBody.setAttribute('tabindex', '-1')
    }
    setNumConditions(e) {
      ;(this.maxNumConditions = e.maxNumConditions ?? 2),
        this.maxNumConditions < 1 &&
          (te(
            '"filterParams.maxNumConditions" must be greater than or equal to zero.',
          ),
          (this.maxNumConditions = 1)),
        (this.numAlwaysVisibleConditions = e.numAlwaysVisibleConditions ?? 1),
        this.numAlwaysVisibleConditions < 1 &&
          (te(
            '"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.',
          ),
          (this.numAlwaysVisibleConditions = 1)),
        this.numAlwaysVisibleConditions > this.maxNumConditions &&
          (te(
            '"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".',
          ),
          (this.numAlwaysVisibleConditions = this.maxNumConditions))
    }
    createOption() {
      const e = this.createManagedBean(new vd())
      this.eTypes.push(e),
        e.addCssClass('ag-filter-select'),
        this.eFilterBody.appendChild(e.getGui())
      const t = this.createValueElement()
      this.eConditionBodies.push(t),
        this.eFilterBody.appendChild(t),
        this.putOptionsIntoDropdown(e),
        this.resetType(e)
      const i = this.getNumConditions() - 1
      this.forEachPositionInput(i, (s) => this.resetInput(s)),
        this.addChangedListeners(e, i)
    }
    createJoinOperatorPanel() {
      const e = document.createElement('div')
      this.eJoinOperatorPanels.push(e), e.classList.add('ag-filter-condition')
      const t = this.createJoinOperator(this.eJoinOperatorsAnd, e, 'and'),
        i = this.createJoinOperator(this.eJoinOperatorsOr, e, 'or')
      this.eFilterBody.appendChild(e)
      const s = this.eJoinOperatorPanels.length - 1,
        n = this.joinOperatorId++
      this.resetJoinOperatorAnd(t, s, n),
        this.resetJoinOperatorOr(i, s, n),
        this.isReadOnly() ||
          (t.onValueChange(this.listener), i.onValueChange(this.listener))
    }
    createJoinOperator(e, t, i) {
      const s = this.createManagedBean(new PM())
      return (
        e.push(s),
        s.addCssClass('ag-filter-condition-operator'),
        s.addCssClass(`ag-filter-condition-operator-${i}`),
        t.appendChild(s.getGui()),
        s
      )
    }
    getDefaultJoinOperator(e) {
      return e === 'AND' || e === 'OR' ? e : 'AND'
    }
    createFilterListOptions() {
      const e = this.optionsFactory.getFilterOptions()
      this.filterListOptions = e.map((t) =>
        typeof t == 'string'
          ? this.createBoilerplateListOption(t)
          : this.createCustomListOption(t),
      )
    }
    putOptionsIntoDropdown(e) {
      this.filterListOptions.forEach((t) => {
        e.addOption(t)
      }),
        e.setDisabled(this.filterListOptions.length <= 1)
    }
    createBoilerplateListOption(e) {
      return { value: e, text: this.translate(e) }
    }
    createCustomListOption(e) {
      const { displayKey: t } = e,
        i = this.optionsFactory.getCustomOption(e.displayKey)
      return {
        value: t,
        text: i
          ? this.localeService.getLocaleTextFunc()(i.displayKey, i.displayName)
          : this.translate(t),
      }
    }
    createBodyTemplate() {
      return ''
    }
    getAgComponents() {
      return []
    }
    getCssIdentifier() {
      return 'simple-filter'
    }
    updateUiVisibility() {
      const e = this.getJoinOperator()
      this.updateNumConditions(),
        this.updateConditionStatusesAndValues(this.lastUiCompletePosition, e)
    }
    updateNumConditions() {
      let e = -1,
        t = !0
      for (let i = 0; i < this.getNumConditions(); i++)
        this.isConditionUiComplete(i) ? (e = i) : (t = !1)
      if (this.shouldAddNewConditionAtEnd(t))
        this.createJoinOperatorPanel(), this.createOption()
      else {
        const i = this.lastUiCompletePosition ?? this.getNumConditions() - 2
        if (e < i) {
          this.removeConditionsAndOperators(i + 1)
          const s = e + 1,
            n = i - s
          n > 0 && this.removeConditionsAndOperators(s, n),
            this.createMissingConditionsAndOperators()
        }
      }
      this.lastUiCompletePosition = e
    }
    updateConditionStatusesAndValues(e, t) {
      this.eTypes.forEach((s, n) => {
        const r = this.isConditionDisabled(n, e)
        s.setDisabled(r || this.filterListOptions.length <= 1),
          n === 1 &&
            (yo(this.eJoinOperatorPanels[0], r),
            this.eJoinOperatorsAnd[0].setDisabled(r),
            this.eJoinOperatorsOr[0].setDisabled(r))
      }),
        this.eConditionBodies.forEach((s, n) => {
          Ot(s, this.isConditionBodyVisible(n))
        })
      const i = (t ?? this.getJoinOperator()) === 'OR'
      this.eJoinOperatorsAnd.forEach((s) => {
        s.setValue(!i, !0)
      }),
        this.eJoinOperatorsOr.forEach((s) => {
          s.setValue(i, !0)
        }),
        this.forEachInput((s, n, r, o) => {
          this.setElementDisplayed(s, n < o),
            this.setElementDisabled(s, this.isConditionDisabled(r, e))
        }),
        this.resetPlaceholder()
    }
    shouldAddNewConditionAtEnd(e) {
      return (
        e &&
        this.getNumConditions() < this.maxNumConditions &&
        !this.isReadOnly()
      )
    }
    removeConditionsAndOperators(e, t) {
      if (e >= this.getNumConditions()) return
      this.removeComponents(this.eTypes, e, t),
        this.removeElements(this.eConditionBodies, e, t),
        this.removeValueElements(e, t)
      const i = Math.max(e - 1, 0)
      this.removeElements(this.eJoinOperatorPanels, i, t),
        this.removeComponents(this.eJoinOperatorsAnd, i, t),
        this.removeComponents(this.eJoinOperatorsOr, i, t)
    }
    removeElements(e, t, i) {
      this.removeItems(e, t, i).forEach((n) => Bn(n))
    }
    removeComponents(e, t, i) {
      this.removeItems(e, t, i).forEach((n) => {
        Bn(n.getGui()), this.destroyBean(n)
      })
    }
    removeItems(e, t, i) {
      return i == null ? e.splice(t) : e.splice(t, i)
    }
    afterGuiAttached(e) {
      if (
        (super.afterGuiAttached(e),
        this.resetPlaceholder(),
        !(e != null && e.suppressFocus))
      )
        if (this.isReadOnly()) this.eFilterBody.focus()
        else {
          const t = this.getInputs(0)[0]
          if (!t) return
          t instanceof Pn && t.getInputElement().focus()
        }
    }
    afterGuiDetached() {
      super.afterGuiDetached()
      const e = this.getModel()
      this.resetUiToActiveModel(e)
      let t = -1,
        i = -1,
        s = !1
      const n = this.getJoinOperator()
      for (let o = this.getNumConditions() - 1; o >= 0; o--)
        if (this.isConditionUiComplete(o)) t === -1 && ((t = o), (i = o))
        else {
          const a =
              o >= this.numAlwaysVisibleConditions &&
              !this.isConditionUiComplete(o - 1),
            l = o < t
          ;(a || l) &&
            (this.removeConditionsAndOperators(o, 1), (s = !0), l && i--)
        }
      let r = !1
      this.getNumConditions() < this.numAlwaysVisibleConditions &&
        (this.createMissingConditionsAndOperators(), (r = !0)),
        this.shouldAddNewConditionAtEnd(i === this.getNumConditions() - 1) &&
          (this.createJoinOperatorPanel(), this.createOption(), (r = !0)),
        r && this.updateConditionStatusesAndValues(i, n),
        s && this.updateJoinOperatorsDisabled(),
        (this.lastUiCompletePosition = i)
    }
    getPlaceholderText(e, t) {
      let i = this.translate(e)
      if (Ju(this.filterPlaceholder)) {
        const s = this.filterPlaceholder,
          n = this.eTypes[t].getValue(),
          r = this.translate(n)
        i = s({ filterOptionKey: n, filterOption: r, placeholder: i })
      } else
        typeof this.filterPlaceholder == 'string' &&
          (i = this.filterPlaceholder)
      return i
    }
    resetPlaceholder() {
      const e = this.localeService.getLocaleTextFunc()
      this.forEachInput((t, i, s, n) => {
        if (!(t instanceof Pn)) return
        const r =
            i === 0 && n > 1
              ? 'inRangeStart'
              : i === 0
                ? 'filterOoo'
                : 'inRangeEnd',
          o =
            i === 0 && n > 1
              ? e('ariaFilterFromValue', 'Filter from value')
              : i === 0
                ? e('ariaFilterValue', 'Filter Value')
                : e('ariaFilterToValue', 'Filter to Value')
        t.setInputPlaceholder(this.getPlaceholderText(r, s)),
          t.setInputAriaLabel(o)
      })
    }
    setElementValue(e, t, i) {
      e instanceof Pn && e.setValue(t != null ? String(t) : null, !0)
    }
    setElementDisplayed(e, t) {
      e instanceof yt && Ot(e.getGui(), t)
    }
    setElementDisabled(e, t) {
      e instanceof yt && yo(e.getGui(), t)
    }
    attachElementOnChange(e, t) {
      e instanceof Pn && e.onValueChange(t)
    }
    forEachInput(e) {
      this.getConditionTypes().forEach((t, i) => {
        this.forEachPositionTypeInput(i, t, e)
      })
    }
    forEachPositionInput(e, t) {
      const i = this.getConditionType(e)
      this.forEachPositionTypeInput(e, i, t)
    }
    forEachPositionTypeInput(e, t, i) {
      const s = this.getNumberOfInputs(t),
        n = this.getInputs(e)
      for (let r = 0; r < n.length; r++) {
        const o = n[r]
        o != null && i(o, r, e, s)
      }
    }
    isConditionDisabled(e, t) {
      return this.isReadOnly() ? !0 : e === 0 ? !1 : e > t + 1
    }
    isConditionBodyVisible(e) {
      const t = this.getConditionType(e)
      return this.getNumberOfInputs(t) > 0
    }
    isConditionUiComplete(e) {
      return !(
        e >= this.getNumConditions() ||
        this.getConditionType(e) === 'empty' ||
        this.getValues(e).some((i) => i == null)
      )
    }
    getNumConditions() {
      return this.eTypes.length
    }
    getUiCompleteConditions() {
      const e = []
      for (let t = 0; t < this.getNumConditions(); t++)
        this.isConditionUiComplete(t) && e.push(this.createCondition(t))
      return e
    }
    createMissingConditionsAndOperators() {
      if (!this.isReadOnly())
        for (
          let e = this.getNumConditions();
          e < this.numAlwaysVisibleConditions;
          e++
        )
          this.createJoinOperatorPanel(), this.createOption()
    }
    resetUiToDefaults(e) {
      return (
        this.removeConditionsAndOperators(
          this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions,
        ),
        this.eTypes.forEach((t) => this.resetType(t)),
        this.eJoinOperatorsAnd.forEach((t, i) =>
          this.resetJoinOperatorAnd(t, i, this.joinOperatorId + i),
        ),
        this.eJoinOperatorsOr.forEach((t, i) =>
          this.resetJoinOperatorOr(t, i, this.joinOperatorId + i),
        ),
        this.joinOperatorId++,
        this.forEachInput((t) => this.resetInput(t)),
        this.resetPlaceholder(),
        this.createMissingConditionsAndOperators(),
        (this.lastUiCompletePosition = null),
        e || this.onUiChanged(),
        Nt.resolve()
      )
    }
    resetType(e) {
      const i = this.localeService.getLocaleTextFunc()(
        'ariaFilteringOperator',
        'Filtering operator',
      )
      e.setValue(this.optionsFactory.getDefaultOption(), !0)
        .setAriaLabel(i)
        .setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1)
    }
    resetJoinOperatorAnd(e, t, i) {
      this.resetJoinOperator(
        e,
        t,
        this.isDefaultOperator('AND'),
        this.translate('andCondition'),
        i,
      )
    }
    resetJoinOperatorOr(e, t, i) {
      this.resetJoinOperator(
        e,
        t,
        this.isDefaultOperator('OR'),
        this.translate('orCondition'),
        i,
      )
    }
    resetJoinOperator(e, t, i, s, n) {
      this.updateJoinOperatorDisabled(
        e
          .setValue(i, !0)
          .setName(`ag-simple-filter-and-or-${this.getCompId()}-${n}`)
          .setLabel(s),
        t,
      )
    }
    updateJoinOperatorsDisabled() {
      this.eJoinOperatorsAnd.forEach((e, t) =>
        this.updateJoinOperatorDisabled(e, t),
      ),
        this.eJoinOperatorsOr.forEach((e, t) =>
          this.updateJoinOperatorDisabled(e, t),
        )
    }
    updateJoinOperatorDisabled(e, t) {
      e.setDisabled(this.isReadOnly() || t > 0)
    }
    resetInput(e) {
      this.setElementValue(e, null),
        this.setElementDisabled(e, this.isReadOnly())
    }
    setConditionIntoUi(e, t) {
      const i = this.mapValuesFromModel(e)
      this.forEachInput((s, n, r) => {
        r === t && this.setElementValue(s, i[n] != null ? i[n] : null)
      })
    }
    setValueFromFloatingFilter(e) {
      this.forEachInput((t, i, s) => {
        this.setElementValue(t, i === 0 && s === 0 ? e : null, !0)
      })
    }
    isDefaultOperator(e) {
      return e === this.defaultJoinOperator
    }
    addChangedListeners(e, t) {
      this.isReadOnly() ||
        (e.onValueChange(this.listener),
        this.forEachPositionInput(t, (i) => {
          this.attachElementOnChange(i, this.listener)
        }))
    }
    individualConditionPasses(e, t) {
      const i = this.getCellValue(e.node),
        s = this.mapValuesFromModel(t),
        n = this.optionsFactory.getCustomOption(t.type),
        r = this.evaluateCustomFilter(n, s, i)
      return (
        r ??
        (i == null
          ? this.evaluateNullValue(t.type)
          : this.evaluateNonNullValue(s, i, t, e))
      )
    }
    evaluateCustomFilter(e, t, i) {
      if (e == null) return
      const { predicate: s } = e
      if (s != null && !t.some((n) => n == null)) return s(t, i)
    }
    isBlank(e) {
      return e == null || (typeof e == 'string' && e.trim().length === 0)
    }
    hasInvalidInputs() {
      return !1
    }
  },
  gv = class extends hv {
    setParams(e) {
      super.setParams(e), (this.scalarFilterParams = e)
    }
    evaluateNullValue(e) {
      switch (e) {
        case 'equals':
          if (this.scalarFilterParams.includeBlanksInEquals) return !0
          break
        case 'notEqual':
          if (this.scalarFilterParams.includeBlanksInNotEqual) return !0
          break
        case 'greaterThan':
        case 'greaterThanOrEqual':
          if (this.scalarFilterParams.includeBlanksInGreaterThan) return !0
          break
        case 'lessThan':
        case 'lessThanOrEqual':
          if (this.scalarFilterParams.includeBlanksInLessThan) return !0
          break
        case 'inRange':
          if (this.scalarFilterParams.includeBlanksInRange) return !0
          break
        case 'blank':
          return !0
        case 'notBlank':
          return !1
      }
      return !1
    }
    evaluateNonNullValue(e, t, i) {
      const s = this.comparator(),
        n = e[0] != null ? s(e[0], t) : 0
      switch (i.type) {
        case 'equals':
          return n === 0
        case 'notEqual':
          return n !== 0
        case 'greaterThan':
          return n > 0
        case 'greaterThanOrEqual':
          return n >= 0
        case 'lessThan':
          return n < 0
        case 'lessThanOrEqual':
          return n <= 0
        case 'inRange': {
          const r = s(e[1], t)
          return this.scalarFilterParams.inRangeInclusive
            ? n >= 0 && r <= 0
            : n > 0 && r < 0
        }
        case 'blank':
          return this.isBlank(t)
        case 'notBlank':
          return !this.isBlank(t)
        default:
          return (
            te(
              'Unexpected type of filter "' +
                i.type +
                '", it looks like the filter was configured with incorrect Filter Options',
            ),
            !0
          )
      }
    }
  },
  IM = 65,
  TM = 67,
  AM = 86,
  OM = 68,
  LM = 90,
  kM = 89
function fv(e) {
  var i
  return e.altKey || e.ctrlKey || e.metaKey
    ? !1
    : ((i = e.key) == null ? void 0 : i.length) === 1
}
function iu(e, t, i, s, n) {
  const r = s ? s.getColDef().suppressKeyboardEvent : void 0
  if (!r) return !1
  const o = e.addGridCommonParams({
    event: t,
    editing: n,
    column: s,
    node: i,
    data: i.data,
    colDef: s.getColDef(),
  })
  return !!(r && r(o))
}
function HM(e, t, i, s) {
  const n = s.getDefinition(),
    r = n && n.suppressHeaderKeyboardEvent
  if (!ue(r)) return !1
  const o = e.addGridCommonParams({
    colDef: n,
    column: s,
    headerRowIndex: i,
    event: t,
  })
  return !!r(o)
}
function NM(e) {
  const { keyCode: t } = e
  let i
  switch (t) {
    case IM:
      i = Y.A
      break
    case TM:
      i = Y.C
      break
    case AM:
      i = Y.V
      break
    case OM:
      i = Y.D
      break
    case LM:
      i = Y.Z
      break
    case kM:
      i = Y.Y
      break
    default:
      i = e.code
  }
  return i
}
function GM(e, t = !1) {
  return e === Y.DELETE ? !0 : !t && e === Y.BACKSPACE ? Wm() : !1
}
var Yn = class extends Pn {
    constructor(e, t = 'ag-text-field', i = 'text') {
      super(e, t, i)
    }
    postConstruct() {
      super.postConstruct(),
        this.config.allowedCharPattern && this.preventDisallowedCharacters()
    }
    setValue(e, t) {
      return (
        this.eInput.value !== e && (this.eInput.value = ue(e) ? e : ''),
        super.setValue(e, t)
      )
    }
    setStartValue(e) {
      this.setValue(e, !0)
    }
    preventDisallowedCharacters() {
      const e = new RegExp(`[${this.config.allowedCharPattern}]`),
        t = (i) => {
          fv(i) && i.key && !e.test(i.key) && i.preventDefault()
        }
      this.addManagedListeners(this.eInput, {
        keydown: t,
        paste: (i) => {
          var n
          const s = (n = i.clipboardData) == null ? void 0 : n.getData('text')
          s && s.split('').some((r) => !e.test(r)) && i.preventDefault()
        },
      })
    }
  },
  Cl = { selector: 'AG-INPUT-TEXT-FIELD', component: Yn },
  Cd = class extends Yn {
    constructor(e) {
      super(e, 'ag-number-field', 'number')
    }
    postConstruct() {
      super.postConstruct(),
        this.addManagedListeners(this.eInput, {
          blur: () => {
            const n = parseFloat(this.eInput.value),
              r = isNaN(n) ? '' : this.normalizeValue(n.toString())
            this.value !== r && this.setValue(r)
          },
          wheel: this.onWheel.bind(this),
        }),
        (this.eInput.step = 'any')
      const { precision: e, min: t, max: i, step: s } = this.config
      typeof e == 'number' && this.setPrecision(e),
        typeof t == 'number' && this.setMin(t),
        typeof i == 'number' && this.setMax(i),
        typeof s == 'number' && this.setStep(s)
    }
    onWheel(e) {
      Lt(this.gos) === this.eInput && e.preventDefault()
    }
    normalizeValue(e) {
      if (e === '') return ''
      this.precision != null && (e = this.adjustPrecision(e))
      const t = parseFloat(e)
      return (
        this.min != null && t < this.min
          ? (e = this.min.toString())
          : this.max != null && t > this.max && (e = this.max.toString()),
        e
      )
    }
    adjustPrecision(e, t) {
      if (this.precision == null) return e
      if (t) {
        const s = parseFloat(e).toFixed(this.precision)
        return parseFloat(s).toString()
      }
      const i = String(e).split('.')
      if (i.length > 1) {
        if (i[1].length <= this.precision) return e
        if (this.precision > 0)
          return `${i[0]}.${i[1].slice(0, this.precision)}`
      }
      return i[0]
    }
    setMin(e) {
      return this.min === e
        ? this
        : ((this.min = e), $i(this.eInput, 'min', e), this)
    }
    setMax(e) {
      return this.max === e
        ? this
        : ((this.max = e), $i(this.eInput, 'max', e), this)
    }
    setPrecision(e) {
      return (this.precision = e), this
    }
    setStep(e) {
      return this.step === e
        ? this
        : ((this.step = e), $i(this.eInput, 'step', e), this)
    }
    setValue(e, t) {
      return this.setValueOrInputValue(
        (i) => super.setValue(i, t),
        () => this,
        e,
      )
    }
    setStartValue(e) {
      return this.setValueOrInputValue(
        (t) => super.setValue(t, !0),
        (t) => {
          this.eInput.value = t
        },
        e,
      )
    }
    setValueOrInputValue(e, t, i) {
      if (ue(i)) {
        let s = this.isScientificNotation(i)
        if (s && this.eInput.validity.valid) return e(i)
        if (!s) {
          i = this.adjustPrecision(i)
          const n = this.normalizeValue(i)
          s = i != n
        }
        if (s) return t(i)
      }
      return e(i)
    }
    getValue() {
      if (!this.eInput.validity.valid) return
      const e = this.eInput.value
      return this.isScientificNotation(e)
        ? this.adjustPrecision(e, !0)
        : super.getValue()
    }
    isScientificNotation(e) {
      return typeof e == 'string' && e.includes('e')
    }
  },
  BM = { selector: 'AG-INPUT-NUMBER-FIELD', component: Cd },
  pv = [
    'equals',
    'notEqual',
    'greaterThan',
    'greaterThanOrEqual',
    'lessThan',
    'lessThanOrEqual',
    'inRange',
    'blank',
    'notBlank',
  ],
  Sd = class {
    constructor(e, t, i) {
      ;(this.localeService = e),
        (this.optionsFactory = t),
        (this.valueFormatter = i)
    }
    getModelAsString(e) {
      if (!e) return null
      const t = e.operator != null,
        i = this.localeService.getLocaleTextFunc()
      if (t) {
        const s = e,
          r = (s.conditions ?? []).map((a) => this.getModelAsString(a)),
          o = s.operator === 'AND' ? 'andCondition' : 'orCondition'
        return r.join(` ${i(o, uv[o])} `)
      } else {
        if (e.type === 'blank' || e.type === 'notBlank')
          return i(e.type, e.type)
        {
          const s = e,
            n = this.optionsFactory.getCustomOption(s.type),
            { displayKey: r, displayName: o, numberOfInputs: a } = n || {}
          return r && o && a === 0 ? (i(r, o), o) : this.conditionToString(s, n)
        }
      }
    }
    updateParams(e) {
      this.optionsFactory = e.optionsFactory
    }
    formatValue(e) {
      return this.valueFormatter
        ? (this.valueFormatter(e ?? null) ?? '')
        : String(e)
    }
  },
  mv = class extends Sd {
    conditionToString(e, t) {
      const { numberOfInputs: i } = t || {}
      return e.type == 'inRange' || i === 2
        ? `${this.formatValue(e.filter)}-${this.formatValue(e.filterTo)}`
        : e.filter != null
          ? this.formatValue(e.filter)
          : `${e.type}`
    }
  }
function su(e) {
  const { allowedCharPattern: t } = e ?? {}
  return t ?? null
}
var VM = class extends gv {
    constructor() {
      super('numberFilter'), (this.eValuesFrom = []), (this.eValuesTo = [])
    }
    refresh(e) {
      return this.numberFilterParams.allowedCharPattern !== e.allowedCharPattern
        ? !1
        : super.refresh(e)
    }
    mapValuesFromModel(e) {
      const { filter: t, filterTo: i, type: s } = e || {}
      return [this.processValue(t), this.processValue(i)].slice(
        0,
        this.getNumberOfInputs(s),
      )
    }
    getDefaultDebounceMs() {
      return 500
    }
    comparator() {
      return (e, t) => (e === t ? 0 : e < t ? 1 : -1)
    }
    setParams(e) {
      ;(this.numberFilterParams = e),
        super.setParams(e),
        (this.filterModelFormatter = new mv(
          this.localeService,
          this.optionsFactory,
          this.numberFilterParams.numberFormatter,
        ))
    }
    getDefaultFilterOptions() {
      return pv
    }
    setElementValue(e, t, i) {
      const s =
        !i && this.numberFilterParams.numberFormatter
          ? this.numberFilterParams.numberFormatter(t ?? null)
          : t
      super.setElementValue(e, s)
    }
    createValueElement() {
      const e = su(this.numberFilterParams),
        t = document.createElement('div')
      return (
        t.classList.add('ag-filter-body'),
        es(t, 'presentation'),
        this.createFromToElement(t, this.eValuesFrom, 'from', e),
        this.createFromToElement(t, this.eValuesTo, 'to', e),
        t
      )
    }
    createFromToElement(e, t, i, s) {
      const n = this.createManagedBean(
        s ? new Yn({ allowedCharPattern: s }) : new Cd(),
      )
      n.addCssClass(`ag-filter-${i}`),
        n.addCssClass('ag-filter-filter'),
        t.push(n),
        e.appendChild(n.getGui())
    }
    removeValueElements(e, t) {
      this.removeComponents(this.eValuesFrom, e, t),
        this.removeComponents(this.eValuesTo, e, t)
    }
    getValues(e) {
      const t = []
      return (
        this.forEachPositionInput(e, (i, s, n, r) => {
          s < r && t.push(this.processValue(this.stringToFloat(i.getValue())))
        }),
        t
      )
    }
    areSimpleModelsEqual(e, t) {
      return (
        e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type
      )
    }
    getFilterType() {
      return 'number'
    }
    processValue(e) {
      return e == null || isNaN(e) ? null : e
    }
    stringToFloat(e) {
      if (typeof e == 'number') return e
      let t = As(e)
      return (
        t != null && t.trim() === '' && (t = null),
        this.numberFilterParams.numberParser
          ? this.numberFilterParams.numberParser(t)
          : t == null || t.trim() === '-'
            ? null
            : parseFloat(t)
      )
    }
    createCondition(e) {
      const t = this.getConditionType(e),
        i = { filterType: this.getFilterType(), type: t },
        s = this.getValues(e)
      return (
        s.length > 0 && (i.filter = s[0]),
        s.length > 1 && (i.filterTo = s[1]),
        i
      )
    }
    getInputs(e) {
      return e >= this.eValuesFrom.length
        ? [null, null]
        : [this.eValuesFrom[e], this.eValuesTo[e]]
    }
    getModelAsString(e) {
      return this.filterModelFormatter.getModelAsString(e) ?? ''
    }
    hasInvalidInputs() {
      let e = !1
      return (
        this.forEachInput((t) => {
          if (!t.getInputElement().validity.valid) {
            e = !0
            return
          }
        }),
        e
      )
    }
  },
  vv = [
    'contains',
    'notContains',
    'equals',
    'notEqual',
    'startsWith',
    'endsWith',
    'blank',
    'notBlank',
  ],
  Cv = class extends Sd {
    conditionToString(e, t) {
      const { numberOfInputs: i } = t || {}
      return e.type == 'inRange' || i === 2
        ? `${e.filter}-${e.filterTo}`
        : e.filter != null
          ? `${e.filter}`
          : `${e.type}`
    }
  }
function Sv(e) {
  const t = e && e.trim()
  return t === '' ? e : t
}
var _M = class extends hv {
  constructor() {
    super('textFilter'),
      (this.defaultFormatter = (e) => e),
      (this.defaultLowercaseFormatter = (e) =>
        e == null ? null : e.toString().toLowerCase()),
      (this.defaultMatcher = ({ filterOption: e, value: t, filterText: i }) => {
        if (i == null) return !1
        switch (e) {
          case 'contains':
            return t.indexOf(i) >= 0
          case 'notContains':
            return t.indexOf(i) < 0
          case 'equals':
            return t === i
          case 'notEqual':
            return t != i
          case 'startsWith':
            return t.indexOf(i) === 0
          case 'endsWith': {
            const s = t.lastIndexOf(i)
            return s >= 0 && s === t.length - i.length
          }
          default:
            return !1
        }
      }),
      (this.eValuesFrom = []),
      (this.eValuesTo = [])
  }
  getDefaultDebounceMs() {
    return 500
  }
  setParams(e) {
    ;(this.textFilterParams = e),
      super.setParams(e),
      (this.matcher = this.getTextMatcher()),
      (this.formatter =
        this.textFilterParams.textFormatter ||
        (this.textFilterParams.caseSensitive
          ? this.defaultFormatter
          : this.defaultLowercaseFormatter)),
      (this.filterModelFormatter = new Cv(
        this.localeService,
        this.optionsFactory,
      ))
  }
  getTextMatcher() {
    const e = this.textFilterParams.textCustomComparator
    return e
      ? (te('textCustomComparator is deprecated, use textMatcher instead.'),
        ({ filterOption: t, value: i, filterText: s }) => e(t, i, s))
      : this.textFilterParams.textMatcher || this.defaultMatcher
  }
  createCondition(e) {
    const t = this.getConditionType(e),
      i = { filterType: this.getFilterType(), type: t },
      s = this.getValuesWithSideEffects(e, !0)
    return (
      s.length > 0 && (i.filter = s[0]), s.length > 1 && (i.filterTo = s[1]), i
    )
  }
  getFilterType() {
    return 'text'
  }
  areSimpleModelsEqual(e, t) {
    return (
      e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type
    )
  }
  getInputs(e) {
    return e >= this.eValuesFrom.length
      ? [null, null]
      : [this.eValuesFrom[e], this.eValuesTo[e]]
  }
  getValues(e) {
    return this.getValuesWithSideEffects(e, !1)
  }
  getValuesWithSideEffects(e, t) {
    const i = []
    return (
      this.forEachPositionInput(e, (s, n, r, o) => {
        if (n < o) {
          let a = As(s.getValue())
          t &&
            this.textFilterParams.trimInput &&
            ((a = Sv(a) ?? null), s.setValue(a, !0)),
            i.push(a)
        }
      }),
      i
    )
  }
  getDefaultFilterOptions() {
    return vv
  }
  createValueElement() {
    const e = document.createElement('div')
    return (
      e.classList.add('ag-filter-body'),
      es(e, 'presentation'),
      this.createFromToElement(e, this.eValuesFrom, 'from'),
      this.createFromToElement(e, this.eValuesTo, 'to'),
      e
    )
  }
  createFromToElement(e, t, i) {
    const s = this.createManagedBean(new Yn())
    s.addCssClass(`ag-filter-${i}`),
      s.addCssClass('ag-filter-filter'),
      t.push(s),
      e.appendChild(s.getGui())
  }
  removeValueElements(e, t) {
    this.removeComponents(this.eValuesFrom, e, t),
      this.removeComponents(this.eValuesTo, e, t)
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: i, type: s } = e || {}
    return [t || null, i || null].slice(0, this.getNumberOfInputs(s))
  }
  evaluateNullValue(e) {
    return e ? ['notEqual', 'notContains', 'blank'].indexOf(e) >= 0 : !1
  }
  evaluateNonNullValue(e, t, i, s) {
    const n = e.map((g) => this.formatter(g)) || [],
      r = this.formatter(t),
      {
        api: o,
        colDef: a,
        column: l,
        context: c,
        textFormatter: u,
      } = this.textFilterParams
    if (i.type === 'blank') return this.isBlank(t)
    if (i.type === 'notBlank') return !this.isBlank(t)
    const h = {
      api: o,
      colDef: a,
      column: l,
      context: c,
      node: s.node,
      data: s.data,
      filterOption: i.type,
      value: r,
      textFormatter: u,
    }
    return n.some((g) => this.matcher({ ...h, filterText: g }))
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? ''
  }
}
function wv(e) {
  if (typeof e == 'number') return e
  if (typeof e == 'string') {
    const t = parseInt(e)
    return isNaN(t) ? void 0 : t
  }
}
function ls(e, t = Number.MAX_VALUE) {
  return (i) => {
    const s = wv(i)
    if (!(s == null || s < e || s > t)) return s
  }
}
function lo(e, t) {
  return e.toString().padStart(t, '0')
}
function WM(e, t) {
  const i = []
  for (let s = e; s <= t; s++) i.push(s)
  return i
}
function $M(e, t, i) {
  return typeof e != 'number'
    ? ''
    : e
        .toString()
        .replace('.', i)
        .replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${t}`)
}
function zi(e, t = !0, i = '-') {
  if (!e) return null
  let s = [e.getFullYear(), e.getMonth() + 1, e.getDate()]
    .map((n) => lo(n, 2))
    .join(i)
  return (
    t &&
      (s +=
        ' ' +
        [e.getHours(), e.getMinutes(), e.getSeconds()]
          .map((n) => lo(n, 2))
          .join(':')),
    s
  )
}
var pc = (e) => {
  if (e > 3 && e < 21) return 'th'
  switch (e % 10) {
    case 1:
      return 'st'
    case 2:
      return 'nd'
    case 3:
      return 'rd'
  }
  return 'th'
}
function co(e, t = 'YYYY-MM-DD') {
  const i = lo(e.getFullYear(), 4),
    s = [
      'January',
      'February',
      'March',
      'April',
      'May',
      'June',
      'July',
      'August',
      'September',
      'October',
      'November',
      'December',
    ],
    n = [
      'Sunday',
      'Monday',
      'Tuesday',
      'Wednesday',
      'Thursday',
      'Friday',
      'Saturday',
    ],
    r = {
      YYYY: () => i.slice(i.length - 4, i.length),
      YY: () => i.slice(i.length - 2, i.length),
      Y: () => `${e.getFullYear()}`,
      MMMM: () => s[e.getMonth()],
      MMM: () => s[e.getMonth()].slice(0, 3),
      MM: () => lo(e.getMonth() + 1, 2),
      Mo: () => `${e.getMonth() + 1}${pc(e.getMonth() + 1)}`,
      M: () => `${e.getMonth() + 1}`,
      Do: () => `${e.getDate()}${pc(e.getDate())}`,
      DD: () => lo(e.getDate(), 2),
      D: () => `${e.getDate()}`,
      dddd: () => n[e.getDay()],
      ddd: () => n[e.getDay()].slice(0, 3),
      dd: () => n[e.getDay()].slice(0, 2),
      do: () => `${e.getDay()}${pc(e.getDay())}`,
      d: () => `${e.getDay()}`,
    },
    o = new RegExp(Object.keys(r).join('|'), 'g')
  return t.replace(o, (a) => (a in r ? r[a]() : a))
}
function Mi(e) {
  if (!e) return null
  const [t, i] = e.split(' ')
  if (!t) return null
  const s = t.split('-').map((h) => parseInt(h, 10))
  if (s.filter((h) => !isNaN(h)).length !== 3) return null
  const [n, r, o] = s,
    a = new Date(n, r - 1, o)
  if (a.getFullYear() !== n || a.getMonth() !== r - 1 || a.getDate() !== o)
    return null
  if (!i || i === '00:00:00') return a
  const [l, c, u] = i.split(':').map((h) => parseInt(h, 10))
  return (
    l >= 0 && l < 24 && a.setHours(l),
    c >= 0 && c < 60 && a.setMinutes(c),
    u >= 0 && u < 60 && a.setSeconds(u),
    a
  )
}
var yv = class {
    constructor(e, t, i, s, n) {
      ;(this.alive = !0),
        (this.context = e),
        (this.eParent = s),
        t
          .getDateCompDetails(i)
          .newAgStackInstance()
          .then((a) => {
            if (!this.alive) {
              e.destroyBean(a)
              return
            }
            ;(this.dateComp = a),
              a &&
                (s.appendChild(a.getGui()),
                a.afterGuiAttached && a.afterGuiAttached(),
                this.tempValue && a.setDate(this.tempValue),
                this.disabled != null &&
                  this.setDateCompDisabled(this.disabled),
                n == null || n(this))
          })
    }
    destroy() {
      ;(this.alive = !1),
        (this.dateComp = this.context.destroyBean(this.dateComp))
    }
    getDate() {
      return this.dateComp ? this.dateComp.getDate() : this.tempValue
    }
    setDate(e) {
      this.dateComp ? this.dateComp.setDate(e) : (this.tempValue = e)
    }
    setDisabled(e) {
      this.dateComp ? this.setDateCompDisabled(e) : (this.disabled = e)
    }
    setDisplayed(e) {
      Ot(this.eParent, e)
    }
    setInputPlaceholder(e) {
      this.dateComp &&
        this.dateComp.setInputPlaceholder &&
        this.dateComp.setInputPlaceholder(e)
    }
    setInputAriaLabel(e) {
      this.dateComp &&
        this.dateComp.setInputAriaLabel &&
        this.dateComp.setInputAriaLabel(e)
    }
    afterGuiAttached(e) {
      this.dateComp &&
        typeof this.dateComp.afterGuiAttached == 'function' &&
        this.dateComp.afterGuiAttached(e)
    }
    updateParams(e) {
      var i, s
      let t = !1
      ;(i = this.dateComp) != null &&
        i.refresh &&
        typeof this.dateComp.refresh == 'function' &&
        this.dateComp.refresh(e) !== null &&
        (t = !0),
        !t &&
          (s = this.dateComp) != null &&
          s.onParamsUpdated &&
          typeof this.dateComp.onParamsUpdated == 'function' &&
          this.dateComp.onParamsUpdated(e) !== null &&
          te(
            "Custom date component method 'onParamsUpdated' is deprecated. Use 'refresh' instead.",
          )
    }
    setDateCompDisabled(e) {
      this.dateComp != null &&
        this.dateComp.setDisabled != null &&
        this.dateComp.setDisabled(e)
    }
  },
  bv = [
    'equals',
    'notEqual',
    'lessThan',
    'greaterThan',
    'inRange',
    'blank',
    'notBlank',
  ],
  Rv = class extends Sd {
    constructor(e, t, i) {
      super(t, i), (this.dateFilterParams = e)
    }
    conditionToString(e, t) {
      const { type: i } = e,
        { numberOfInputs: s } = t || {},
        n = i == 'inRange' || s === 2,
        r = Mi(e.dateFrom),
        o = Mi(e.dateTo),
        a = this.dateFilterParams.inRangeFloatingFilterDateFormat
      if (n) {
        const l = r !== null ? co(r, a) : 'null',
          c = o !== null ? co(o, a) : 'null'
        return `${l}-${c}`
      }
      return r != null ? co(r, a) : `${i}`
    }
    updateParams(e) {
      super.updateParams(e), (this.dateFilterParams = e.dateFilterParams)
    }
  },
  bg = 1e3,
  Rg = 1 / 0,
  zM = class extends gv {
    constructor() {
      super('dateFilter'),
        (this.eConditionPanelsFrom = []),
        (this.eConditionPanelsTo = []),
        (this.dateConditionFromComps = []),
        (this.dateConditionToComps = []),
        (this.minValidYear = bg),
        (this.maxValidYear = Rg),
        (this.minValidDate = null),
        (this.maxValidDate = null)
    }
    wireBeans(e) {
      super.wireBeans(e),
        (this.context = e.context),
        (this.userComponentFactory = e.userComponentFactory)
    }
    afterGuiAttached(e) {
      super.afterGuiAttached(e),
        this.dateConditionFromComps[0].afterGuiAttached(e)
    }
    mapValuesFromModel(e) {
      const { dateFrom: t, dateTo: i, type: s } = e || {}
      return [(t && Mi(t)) || null, (i && Mi(i)) || null].slice(
        0,
        this.getNumberOfInputs(s),
      )
    }
    comparator() {
      return this.dateFilterParams.comparator
        ? this.dateFilterParams.comparator
        : this.defaultComparator.bind(this)
    }
    defaultComparator(e, t) {
      const i = t
      return t == null || i < e ? -1 : i > e ? 1 : 0
    }
    setParams(e) {
      ;(this.dateFilterParams = e), super.setParams(e)
      const t = (i, s) => {
        if (e[i] != null)
          if (isNaN(e[i])) te(`DateFilter ${i} is not a number`)
          else return e[i] == null ? s : Number(e[i])
        return s
      }
      ;(this.minValidYear = t('minValidYear', bg)),
        (this.maxValidYear = t('maxValidYear', Rg)),
        this.minValidYear > this.maxValidYear &&
          te('DateFilter minValidYear should be <= maxValidYear'),
        e.minValidDate
          ? (this.minValidDate =
              e.minValidDate instanceof Date
                ? e.minValidDate
                : Mi(e.minValidDate))
          : (this.minValidDate = null),
        e.maxValidDate
          ? (this.maxValidDate =
              e.maxValidDate instanceof Date
                ? e.maxValidDate
                : Mi(e.maxValidDate))
          : (this.maxValidDate = null),
        this.minValidDate &&
          this.maxValidDate &&
          this.minValidDate > this.maxValidDate &&
          te('DateFilter minValidDate should be <= maxValidDate'),
        (this.filterModelFormatter = new Rv(
          this.dateFilterParams,
          this.localeService,
          this.optionsFactory,
        ))
    }
    createDateCompWrapper(e) {
      const t = new yv(
        this.context,
        this.userComponentFactory,
        {
          onDateChanged: () => this.onUiChanged(),
          filterParams: this.dateFilterParams,
        },
        e,
      )
      return this.addDestroyFunc(() => t.destroy()), t
    }
    setElementValue(e, t) {
      e.setDate(t)
    }
    setElementDisplayed(e, t) {
      e.setDisplayed(t)
    }
    setElementDisabled(e, t) {
      e.setDisabled(t)
    }
    getDefaultFilterOptions() {
      return bv
    }
    createValueElement() {
      const t = Gt(this.gos).createElement('div')
      return (
        t.classList.add('ag-filter-body'),
        this.createFromToElement(
          t,
          this.eConditionPanelsFrom,
          this.dateConditionFromComps,
          'from',
        ),
        this.createFromToElement(
          t,
          this.eConditionPanelsTo,
          this.dateConditionToComps,
          'to',
        ),
        t
      )
    }
    createFromToElement(e, t, i, s) {
      const r = Gt(this.gos).createElement('div')
      r.classList.add(`ag-filter-${s}`),
        r.classList.add(`ag-filter-date-${s}`),
        t.push(r),
        e.appendChild(r),
        i.push(this.createDateCompWrapper(r))
    }
    removeValueElements(e, t) {
      this.removeDateComps(this.dateConditionFromComps, e, t),
        this.removeDateComps(this.dateConditionToComps, e, t),
        this.removeItems(this.eConditionPanelsFrom, e, t),
        this.removeItems(this.eConditionPanelsTo, e, t)
    }
    removeDateComps(e, t, i) {
      this.removeItems(e, t, i).forEach((n) => n.destroy())
    }
    isValidDateValue(e) {
      if (e === null) return !1
      if (this.minValidDate) {
        if (e < this.minValidDate) return !1
      } else if (e.getUTCFullYear() < this.minValidYear) return !1
      if (this.maxValidDate) {
        if (e > this.maxValidDate) return !1
      } else if (e.getUTCFullYear() > this.maxValidYear) return !1
      return !0
    }
    isConditionUiComplete(e) {
      if (!super.isConditionUiComplete(e)) return !1
      let t = !0
      return (
        this.forEachInput((i, s, n, r) => {
          n !== e ||
            !t ||
            s >= r ||
            (t = t && this.isValidDateValue(i.getDate()))
        }),
        t
      )
    }
    areSimpleModelsEqual(e, t) {
      return (
        e.dateFrom === t.dateFrom && e.dateTo === t.dateTo && e.type === t.type
      )
    }
    getFilterType() {
      return 'date'
    }
    createCondition(e) {
      const t = this.getConditionType(e),
        i = {},
        s = this.getValues(e)
      return (
        s.length > 0 && (i.dateFrom = zi(s[0])),
        s.length > 1 && (i.dateTo = zi(s[1])),
        {
          dateFrom: null,
          dateTo: null,
          filterType: this.getFilterType(),
          type: t,
          ...i,
        }
      )
    }
    resetPlaceholder() {
      const e = this.localeService.getLocaleTextFunc(),
        t = this.translate('dateFormatOoo'),
        i = e('ariaFilterValue', 'Filter Value')
      this.forEachInput((s) => {
        s.setInputPlaceholder(t), s.setInputAriaLabel(i)
      })
    }
    getInputs(e) {
      return e >= this.dateConditionFromComps.length
        ? [null, null]
        : [this.dateConditionFromComps[e], this.dateConditionToComps[e]]
    }
    getValues(e) {
      const t = []
      return (
        this.forEachPositionInput(e, (i, s, n, r) => {
          s < r && t.push(i.getDate())
        }),
        t
      )
    }
    translate(e) {
      return e === 'lessThan'
        ? super.translate('before')
        : e === 'greaterThan'
          ? super.translate('after')
          : super.translate(e)
    }
    getModelAsString(e) {
      return this.filterModelFormatter.getModelAsString(e) ?? ''
    }
  },
  wd = class extends X {
    constructor(e, t, i, s) {
      super(),
        (this.columnOrGroup = e),
        (this.columnOrGroup = e),
        (this.eCell = t),
        (this.ariaEl =
          this.eCell.querySelector('[role=columnheader]') || this.eCell),
        (this.colsSpanning = s),
        (this.beans = i)
    }
    setColsSpanning(e) {
      ;(this.colsSpanning = e), this.onLeftChanged()
    }
    getColumnOrGroup() {
      return this.beans.gos.get('enableRtl') && this.colsSpanning
        ? rt(this.colsSpanning)
        : this.columnOrGroup
    }
    postConstruct() {
      const e = this.onLeftChanged.bind(this)
      this.addManagedListeners(this.columnOrGroup, { leftChanged: e }),
        this.setLeftFirstTime(),
        this.addManagedEventListeners({ displayedColumnsWidthChanged: e }),
        this.addManagedPropertyListener('domLayout', e)
    }
    setLeftFirstTime() {
      const e = this.beans.gos.get('suppressColumnMoveAnimation'),
        t = ue(this.columnOrGroup.getOldLeft())
      this.beans.columnAnimationService.isActive() && t && !e
        ? this.animateInLeft()
        : this.onLeftChanged()
    }
    animateInLeft() {
      const e = this.getColumnOrGroup(),
        t = e.getLeft(),
        i = e.getOldLeft(),
        s = this.modifyLeftForPrintLayout(e, i),
        n = this.modifyLeftForPrintLayout(e, t)
      this.setLeft(s),
        (this.actualLeft = n),
        this.beans.columnAnimationService.executeNextVMTurn(() => {
          this.actualLeft === n && this.setLeft(n)
        })
    }
    onLeftChanged() {
      const e = this.getColumnOrGroup(),
        t = e.getLeft()
      ;(this.actualLeft = this.modifyLeftForPrintLayout(e, t)),
        this.setLeft(this.actualLeft)
    }
    modifyLeftForPrintLayout(e, t) {
      if (!ci(this.beans.gos, 'print') || e.getPinned() === 'left') return t
      const s = this.beans.visibleColsService.getColsLeftWidth()
      if (e.getPinned() === 'right') {
        const n = this.beans.visibleColsService.getBodyContainerWidth()
        return s + n + t
      }
      return s + t
    }
    setLeft(e) {
      if (
        (ue(e) && (this.eCell.style.left = `${e}px`), _t(this.columnOrGroup))
      ) {
        const t = this.columnOrGroup.getLeafColumns()
        if (!t.length) return
        t.length > 1 && cD(this.ariaEl, t.length)
      }
    }
  },
  UM = 'ag-column-first',
  jM = 'ag-column-last'
function Fv(e, t, i, s) {
  return ot(e) ? [] : KM(e.headerClass, e, t, i, s)
}
function Ev(e, t, i) {
  e.addOrRemoveCssClass(UM, i.isColAtEdge(t, 'first')),
    e.addOrRemoveCssClass(jM, i.isColAtEdge(t, 'last'))
}
function YM(e, t, i, s) {
  return t.addGridCommonParams({ colDef: e, column: i, columnGroup: s })
}
function KM(e, t, i, s, n) {
  if (ot(e)) return []
  let r
  if (typeof e == 'function') {
    const o = YM(t, i, s, n)
    r = e(o)
  } else r = e
  return typeof r == 'string' ? [r] : Array.isArray(r) ? [...r] : []
}
var qM = 0,
  Pv = class xv extends X {
    constructor(t, i, s) {
      super(),
        (this.resizeToggleTimeout = 0),
        (this.resizeMultiplier = 1),
        (this.resizeFeature = null),
        (this.lastFocusEvent = null),
        (this.dragSource = null),
        (this.columnGroupChild = t),
        (this.parentRowCtrl = s),
        (this.beans = i),
        (this.instanceId = t.getUniqueId() + '-' + qM++)
    }
    wireBeans(t) {
      ;(this.pinnedWidthService = t.pinnedWidthService),
        (this.focusService = t.focusService),
        (this.userComponentFactory = t.userComponentFactory),
        (this.ctrlsService = t.ctrlsService),
        (this.dragAndDropService = t.dragAndDropService),
        (this.menuService = t.menuService)
    }
    postConstruct() {
      const t = this.refreshTabIndex.bind(this)
      this.addManagedPropertyListeners(['suppressHeaderFocus'], t),
        this.addManagedEventListeners({ overlayExclusiveChanged: t })
    }
    shouldStopEventPropagation(t) {
      const { headerRowIndex: i, column: s } =
        this.focusService.getFocusedHeader()
      return HM(this.gos, t, i, s)
    }
    getWrapperHasFocus() {
      return Lt(this.gos) === this.eGui
    }
    setGui(t, i) {
      ;(this.eGui = t),
        this.addDomData(i),
        i.addManagedListeners(this.beans.eventService, {
          displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
        }),
        i.addManagedElementListeners(this.eGui, {
          focus: this.onGuiFocus.bind(this),
        }),
        this.onDisplayedColumnsChanged(),
        this.refreshTabIndex()
    }
    onGuiFocus() {
      this.eventService.dispatchEvent({
        type: 'headerFocused',
        column: this.column,
      })
    }
    setupAutoHeight(t) {
      const { wrapperElement: i, checkMeasuringCallback: s, compBean: n } = t,
        {
          animationFrameService: r,
          resizeObserverService: o,
          columnModel: a,
          gos: l,
        } = this.beans,
        c = (v) => {
          if (!this.isAlive() || !n.isAlive()) return
          const {
              paddingTop: m,
              paddingBottom: C,
              borderBottomWidth: w,
              borderTopWidth: S,
            } = Un(this.getGui()),
            y = m + C + w + S,
            R = i.offsetHeight + y
          if (v < 5) {
            const b = Gt(l),
              x = !b || !b.contains(i),
              D = R == 0
            if (x || D) {
              r.requestAnimationFrame(() => c(v + 1))
              return
            }
          }
          a.setColHeaderHeight(this.column, R)
        }
      let u = !1,
        h
      const g = () => {
          const v = this.column.isAutoHeaderHeight()
          v && !u && f(), !v && u && p()
        },
        f = () => {
          ;(u = !0),
            c(0),
            this.comp.addOrRemoveCssClass('ag-header-cell-auto-height', !0),
            (h = o.observeResize(i, () => c(0)))
        },
        p = () => {
          ;(u = !1),
            h && h(),
            this.comp.addOrRemoveCssClass('ag-header-cell-auto-height', !1),
            (h = void 0)
        }
      g(),
        n.addDestroyFunc(() => p()),
        n.addManagedListeners(this.column, { widthChanged: () => u && c(0) }),
        n.addManagedEventListeners({
          sortChanged: () => {
            u && window.setTimeout(() => c(0))
          },
        }),
        s && s(g)
    }
    onDisplayedColumnsChanged() {
      const { comp: t, column: i, beans: s, eGui: n } = this
      !t ||
        !i ||
        !n ||
        (Ev(t, i, s.visibleColsService),
        Vm(n, s.visibleColsService.getAriaColIndex(i)))
    }
    addResizeAndMoveKeyboardListeners(t) {
      this.resizeFeature &&
        t.addManagedListeners(this.eGui, {
          keydown: this.onGuiKeyDown.bind(this),
          keyup: this.onGuiKeyUp.bind(this),
        })
    }
    refreshTabIndex() {
      const t = this.focusService.isHeaderFocusSuppressed()
      this.eGui && $i(this.eGui, 'tabindex', t ? null : '-1')
    }
    onGuiKeyDown(t) {
      var o
      const i = Lt(this.gos),
        s = t.key === Y.LEFT || t.key === Y.RIGHT
      if (
        (this.isResizing && (t.preventDefault(), t.stopImmediatePropagation()),
        i !== this.eGui ||
          (!t.shiftKey && !t.altKey) ||
          ((this.isResizing || s) &&
            (t.preventDefault(), t.stopImmediatePropagation()),
          !s))
      )
        return
      const n = (t.key === Y.LEFT) !== this.gos.get('enableRtl'),
        r = rv[n ? 'Left' : 'Right']
      if (t.altKey) {
        ;(this.isResizing = !0), (this.resizeMultiplier += 1)
        const a = this.getViewportAdjustedResizeDiff(t)
        this.resizeHeader(a, t.shiftKey),
          (o = this.resizeFeature) == null || o.toggleColumnResizing(!0)
      } else this.moveHeader(r)
    }
    getViewportAdjustedResizeDiff(t) {
      let i = this.getResizeDiff(t)
      if (this.column.getPinned()) {
        const n = this.pinnedWidthService.getPinnedLeftWidth(),
          r = this.pinnedWidthService.getPinnedRightWidth(),
          o =
            No(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) -
            50
        if (n + r + i > o)
          if (o > n + r) i = o - n - r
          else return 0
      }
      return i
    }
    getResizeDiff(t) {
      let i = (t.key === Y.LEFT) !== this.gos.get('enableRtl')
      const s = this.column.getPinned(),
        n = this.gos.get('enableRtl')
      return (
        s && n !== (s === 'right') && (i = !i),
        (i ? -1 : 1) * this.resizeMultiplier
      )
    }
    onGuiKeyUp() {
      this.isResizing &&
        (this.resizeToggleTimeout &&
          (window.clearTimeout(this.resizeToggleTimeout),
          (this.resizeToggleTimeout = 0)),
        (this.isResizing = !1),
        (this.resizeMultiplier = 1),
        (this.resizeToggleTimeout = window.setTimeout(() => {
          var t
          ;(t = this.resizeFeature) == null || t.toggleColumnResizing(!1)
        }, 150)))
    }
    handleKeyDown(t) {
      const i = this.getWrapperHasFocus()
      switch (t.key) {
        case Y.PAGE_DOWN:
        case Y.PAGE_UP:
        case Y.PAGE_HOME:
        case Y.PAGE_END:
          i && t.preventDefault()
      }
    }
    addDomData(t) {
      const i = xv.DOM_DATA_KEY_HEADER_CTRL
      Nn(this.gos, this.eGui, i, this),
        t.addDestroyFunc(() => Nn(this.gos, this.eGui, i, null))
    }
    getGui() {
      return this.eGui
    }
    focus(t) {
      return this.eGui
        ? ((this.lastFocusEvent = t || null), this.eGui.focus(), !0)
        : !1
    }
    getRowIndex() {
      return this.parentRowCtrl.getRowIndex()
    }
    getParentRowCtrl() {
      return this.parentRowCtrl
    }
    getPinned() {
      return this.parentRowCtrl.getPinned()
    }
    getColumnGroupChild() {
      return this.columnGroupChild
    }
    removeDragSource() {
      this.dragSource &&
        (this.dragAndDropService.removeDragSource(this.dragSource),
        (this.dragSource = null))
    }
    handleContextMenuMouseEvent(t, i, s) {
      const n = t ?? i
      this.gos.get('preventDefaultOnContextMenu') && n.preventDefault(),
        this.menuService.isHeaderContextMenuEnabled(s) &&
          this.menuService.showHeaderContextMenu(s, t, i),
        this.dispatchColumnMouseEvent('columnHeaderContextMenu', s)
    }
    dispatchColumnMouseEvent(t, i) {
      this.eventService.dispatchEvent({ type: t, column: i })
    }
    clearComponent() {
      this.removeDragSource(),
        (this.resizeFeature = null),
        (this.comp = null),
        (this.eGui = null)
    }
    destroy() {
      super.destroy(),
        (this.column = null),
        (this.lastFocusEvent = null),
        (this.columnGroupChild = null),
        (this.parentRowCtrl = null)
    }
  }
Pv.DOM_DATA_KEY_HEADER_CTRL = 'headerCtrl'
var Sl = Pv,
  yd = class extends X {
    wireBeans(e) {
      this.columnHoverService = e.columnHoverService
    }
    constructor(e, t) {
      super(), (this.columns = e), (this.element = t)
    }
    postConstruct() {
      this.gos.get('columnHoverHighlight') && this.addMouseHoverListeners()
    }
    addMouseHoverListeners() {
      this.addManagedListeners(this.element, {
        mouseout: this.onMouseOut.bind(this),
        mouseover: this.onMouseOver.bind(this),
      })
    }
    onMouseOut() {
      this.columnHoverService.clearMouseOver()
    }
    onMouseOver() {
      this.columnHoverService.setMouseOver(this.columns)
    }
  },
  QM = class extends Sl {
    constructor(e, t, i) {
      super(e, t, i), (this.iconCreated = !1), (this.column = e)
    }
    setComp(e, t, i, s, n) {
      ;(this.comp = e),
        (n = ko(this, this.beans.context, n)),
        (this.eButtonShowMainFilter = i),
        (this.eFloatingFilterBody = s),
        this.setGui(t, n),
        this.setupActive(),
        this.setupWidth(n),
        this.setupLeft(n),
        this.setupHover(n),
        this.setupFocus(n),
        this.setupAria(),
        this.setupFilterButton(),
        this.setupUserComp(),
        this.setupSyncWithFilter(n),
        this.setupUi(),
        n.addManagedElementListeners(this.eButtonShowMainFilter, {
          click: this.showParentFilter.bind(this),
        }),
        this.setupFilterChangedListener(n),
        n.addManagedListeners(this.column, {
          colDefChanged: () => this.onColDefChanged(n),
        }),
        n.addDestroyFunc(() => {
          ;(this.eButtonShowMainFilter = null),
            (this.eFloatingFilterBody = null),
            (this.userCompDetails = null),
            this.clearComponent()
        })
    }
    resizeHeader() {}
    moveHeader() {}
    setupActive() {
      const e = this.column.getColDef(),
        t = !!e.filter,
        i = !!e.floatingFilter
      this.active = t && i
    }
    setupUi() {
      if (
        (this.comp.setButtonWrapperDisplayed(
          !this.suppressFilterButton && this.active,
        ),
        this.comp.addOrRemoveBodyCssClass(
          'ag-floating-filter-full-body',
          this.suppressFilterButton,
        ),
        this.comp.addOrRemoveBodyCssClass(
          'ag-floating-filter-body',
          !this.suppressFilterButton,
        ),
        !this.active || this.iconCreated)
      )
        return
      const e = Li('filter', this.gos, this.column)
      e && ((this.iconCreated = !0), this.eButtonShowMainFilter.appendChild(e))
    }
    setupFocus(e) {
      e.createManagedBean(
        new jn(this.eGui, {
          shouldStopEventPropagation:
            this.shouldStopEventPropagation.bind(this),
          onTabKeyDown: this.onTabKeyDown.bind(this),
          handleKeyDown: this.handleKeyDown.bind(this),
          onFocusIn: this.onFocusIn.bind(this),
        }),
      )
    }
    setupAria() {
      const e = this.localeService.getLocaleTextFunc()
      mr(
        this.eButtonShowMainFilter,
        e('ariaFilterMenuOpen', 'Open Filter Menu'),
      )
    }
    onTabKeyDown(e) {
      if (Lt(this.gos) === this.eGui) return
      const s = this.focusService.findNextFocusableElement(
        this.eGui,
        null,
        e.shiftKey,
      )
      if (s) {
        this.beans.headerNavigationService.scrollToColumn(this.column),
          e.preventDefault(),
          s.focus()
        return
      }
      const n = this.findNextColumnWithFloatingFilter(e.shiftKey)
      n &&
        this.focusService.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: this.getParentRowCtrl().getRowIndex(),
            column: n,
          },
          event: e,
        }) &&
        e.preventDefault()
    }
    findNextColumnWithFloatingFilter(e) {
      const t = this.beans.visibleColsService
      let i = this.column
      do if (((i = e ? t.getColBefore(i) : t.getColAfter(i)), !i)) break
      while (!i.getColDef().filter || !i.getColDef().floatingFilter)
      return i
    }
    handleKeyDown(e) {
      super.handleKeyDown(e)
      const t = this.getWrapperHasFocus()
      switch (e.key) {
        case Y.UP:
        case Y.DOWN:
          t || e.preventDefault()
        case Y.LEFT:
        case Y.RIGHT:
          if (t) return
          e.stopPropagation()
        case Y.ENTER:
          t && this.focusService.focusInto(this.eGui) && e.preventDefault()
          break
        case Y.ESCAPE:
          t || this.eGui.focus()
      }
    }
    onFocusIn(e) {
      if (this.eGui.contains(e.relatedTarget)) return
      const i =
          !!e.relatedTarget &&
          !e.relatedTarget.classList.contains('ag-floating-filter'),
        s = !!e.relatedTarget && ar(e.relatedTarget, 'ag-floating-filter')
      if (i && s && e.target === this.eGui) {
        const r = this.lastFocusEvent,
          o = !!(r && r.key === Y.TAB)
        if (r && o) {
          const a = r.shiftKey
          this.focusService.focusInto(this.eGui, a)
        }
      }
      const n = this.getRowIndex()
      this.beans.focusService.setFocusedHeader(n, this.column)
    }
    setupHover(e) {
      e.createManagedBean(new yd([this.column], this.eGui))
      const t = () => {
        if (!this.gos.get('columnHoverHighlight')) return
        const i = this.beans.columnHoverService.isHovered(this.column)
        this.comp.addOrRemoveCssClass('ag-column-hover', i)
      }
      e.addManagedEventListeners({ columnHoverChanged: t }), t()
    }
    setupLeft(e) {
      const t = new wd(this.column, this.eGui, this.beans)
      e.createManagedBean(t)
    }
    setupFilterButton() {
      ;(this.suppressFilterButton =
        !this.menuService.isFloatingFilterButtonEnabled(this.column)),
        (this.highlightFilterButtonWhenActive =
          !this.menuService.isLegacyMenuEnabled())
    }
    setupUserComp() {
      var t
      if (!this.active) return
      const e =
        (t = this.beans.filterManager) == null
          ? void 0
          : t.getFloatingFilterCompDetails(this.column, () =>
              this.showParentFilter(),
            )
      e && this.setCompDetails(e)
    }
    setCompDetails(e) {
      ;(this.userCompDetails = e), this.comp.setCompDetails(e)
    }
    showParentFilter() {
      const e = this.suppressFilterButton
        ? this.eFloatingFilterBody
        : this.eButtonShowMainFilter
      this.menuService.showFilterMenu({
        column: this.column,
        buttonElement: e,
        containerType: 'floatingFilter',
        positionBy: 'button',
      })
    }
    setupSyncWithFilter(e) {
      if (!this.active) return
      const { filterManager: t } = this.beans,
        i = (s) => {
          if (
            (s == null ? void 0 : s.source) === 'filterDestroyed' &&
            !this.isAlive()
          )
            return
          const n = this.comp.getFloatingFilterComp()
          n &&
            n.then((r) => {
              if (r) {
                const o =
                    t == null
                      ? void 0
                      : t.getCurrentFloatingFilterParentModel(this.column),
                  a = s
                    ? {
                        ...s,
                        columns: s.columns ?? [],
                        source: s.source === 'api' ? 'api' : 'columnFilter',
                      }
                    : null
                r.onParentModelChanged(o, a)
              }
            })
        }
      ;([this.destroySyncListener] = e.addManagedListeners(this.column, {
        filterChanged: i,
      })),
        t != null && t.isFilterActive(this.column) && i(null)
    }
    setupWidth(e) {
      const t = () => {
        const i = `${this.column.getActualWidth()}px`
        this.comp.setWidth(i)
      }
      e.addManagedListeners(this.column, { widthChanged: t }), t()
    }
    setupFilterChangedListener(e) {
      this.active &&
        (([this.destroyFilterChangedListener] = e.addManagedListeners(
          this.column,
          { filterChanged: this.updateFilterButton.bind(this) },
        )),
        this.updateFilterButton())
    }
    updateFilterButton() {
      var e
      if (!this.suppressFilterButton && this.comp) {
        const t = !!(
          (e = this.beans.filterManager) != null &&
          e.isFilterAllowed(this.column)
        )
        this.comp.setButtonWrapperDisplayed(t),
          this.highlightFilterButtonWhenActive &&
            t &&
            this.eButtonShowMainFilter.classList.toggle(
              'ag-filter-active',
              this.column.isFilterActive(),
            )
      }
    }
    onColDefChanged(e) {
      var r
      const t = this.active
      this.setupActive()
      const i = !t && this.active
      t &&
        !this.active &&
        (this.destroySyncListener(), this.destroyFilterChangedListener())
      const s = this.active
          ? (r = this.beans.filterManager) == null
            ? void 0
            : r.getFloatingFilterCompDetails(this.column, () =>
                this.showParentFilter(),
              )
          : null,
        n = this.comp.getFloatingFilterComp()
      !n || !s
        ? this.updateCompDetails(e, s, i)
        : n.then((o) => {
            var a
            !o ||
            ((a = this.beans.filterManager) != null &&
              a.areFilterCompsDifferent(this.userCompDetails ?? null, s))
              ? this.updateCompDetails(e, s, i)
              : this.updateFloatingFilterParams(s)
          })
    }
    updateCompDetails(e, t, i) {
      this.isAlive() &&
        (this.setCompDetails(t),
        this.setupFilterButton(),
        this.setupUi(),
        i && (this.setupSyncWithFilter(e), this.setupFilterChangedListener(e)))
    }
    updateFloatingFilterParams(e) {
      var i
      if (!e) return
      const t = e.params
      ;(i = this.comp.getFloatingFilterComp()) == null ||
        i.then((s) => {
          let n = !1
          s != null &&
            s.refresh &&
            typeof s.refresh == 'function' &&
            s.refresh(t) !== null &&
            (n = !0),
            !n &&
              s != null &&
              s.onParamsUpdated &&
              typeof s.onParamsUpdated == 'function' &&
              s.onParamsUpdated(t) !== null &&
              te(
                "Custom floating filter method 'onParamsUpdated' is deprecated. Use 'refresh' instead.",
              )
        })
    }
    destroy() {
      super.destroy(),
        (this.destroySyncListener = null),
        (this.destroyFilterChangedListener = null)
    }
  }
var je = '32.3.3'
function XM(e) {
  var t, i
  return (
    !!((t = e.filterManager) != null && t.isColumnFilterPresent()) ||
    !!((i = e.filterManager) != null && i.isAggregateFilterPresent())
  )
}
function JM(e, t, i) {
  var s
  return (s = e.filterManager) == null ? void 0 : s.getFilterInstance(t, i)
}
function ZM(e, t) {
  var i
  return (
    ((i = e.filterManager) == null ? void 0 : i.getColumnFilterInstance(t)) ??
    Promise.resolve(void 0)
  )
}
function eI(e, t) {
  var s
  const i = e.columnModel.getColDefCol(t)
  if (i)
    return (s = e.filterManager) == null ? void 0 : s.destroyFilter(i, 'api')
}
function tI(e, t) {
  e.frameworkOverrides.wrapIncoming(() => {
    var i
    return (i = e.filterManager) == null ? void 0 : i.setFilterModel(t)
  })
}
function iI(e) {
  var t
  return ((t = e.filterManager) == null ? void 0 : t.getFilterModel()) ?? {}
}
function sI(e, t) {
  var i
  return (
    ((i = e.filterManager) == null ? void 0 : i.getColumnFilterModel(t)) ?? null
  )
}
function nI(e, t, i) {
  var s
  return (
    ((s = e.filterManager) == null ? void 0 : s.setColumnFilterModel(t, i)) ??
    Promise.resolve()
  )
}
function rI(e, t) {
  const i = e.columnModel.getCol(t)
  if (!i) {
    ht(`column '${t}' not found`)
    return
  }
  e.menuService.showFilterMenu({
    column: i,
    containerType: 'columnFilter',
    positionBy: 'auto',
  })
}
function oI(e, t, i) {
  if (t == null) return null
  let s = null
  const { compName: n, jsComp: r, fwComp: o } = sv.getCompKeys(e, t, pd)
  return (
    n
      ? (s = {
          set: 'agSetColumnFloatingFilter',
          agSetColumnFilter: 'agSetColumnFloatingFilter',
          multi: 'agMultiColumnFloatingFilter',
          agMultiColumnFilter: 'agMultiColumnFloatingFilter',
          group: 'agGroupColumnFloatingFilter',
          agGroupColumnFilter: 'agGroupColumnFloatingFilter',
          number: 'agNumberColumnFloatingFilter',
          agNumberColumnFilter: 'agNumberColumnFloatingFilter',
          date: 'agDateColumnFloatingFilter',
          agDateColumnFilter: 'agDateColumnFloatingFilter',
          text: 'agTextColumnFloatingFilter',
          agTextColumnFilter: 'agTextColumnFloatingFilter',
        }[n])
      : r == null && o == null && t.filter === !0 && (s = i()),
    s
  )
}
var Fg = {
    january: 'January',
    february: 'February',
    march: 'March',
    april: 'April',
    may: 'May',
    june: 'June',
    july: 'July',
    august: 'August',
    september: 'September',
    october: 'October',
    november: 'November',
    december: 'December',
  },
  Eg = [
    'january',
    'february',
    'march',
    'april',
    'may',
    'june',
    'july',
    'august',
    'september',
    'october',
    'november',
    'december',
  ],
  aI = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'columnFilterService'),
        (this.allColumnFilters = new Map()),
        (this.allColumnListeners = new Map()),
        (this.activeAggregateFilters = []),
        (this.activeColumnFilters = []),
        (this.processingFilterChange = !1),
        (this.filterModelUpdateQueue = []),
        (this.columnFilterModelUpdateQueue = [])
    }
    wireBeans(e) {
      ;(this.valueService = e.valueService),
        (this.columnModel = e.columnModel),
        (this.rowModel = e.rowModel),
        (this.userComponentFactory = e.userComponentFactory),
        (this.rowRenderer = e.rowRenderer),
        (this.dataTypeService = e.dataTypeService),
        (this.filterManager = e.filterManager)
    }
    postConstruct() {
      var e, t
      this.addManagedEventListeners({
        gridColumnsChanged: this.onColumnsChanged.bind(this),
        rowDataUpdated: () => this.onNewRowsLoaded('rowDataUpdated'),
        dataTypesInferred: this.processFilterModelUpdateQueue.bind(this),
      }),
        (this.initialFilterModel = {
          ...(((t =
            (e = this.gos.get('initialState')) == null ? void 0 : e.filter) ==
          null
            ? void 0
            : t.filterModel) ?? {}),
        })
    }
    setFilterModel(e, t = 'api') {
      var n
      if ((n = this.dataTypeService) != null && n.isPendingInference()) {
        this.filterModelUpdateQueue.push({ model: e, source: t })
        return
      }
      const i = [],
        s = this.getFilterModel(!0)
      if (e) {
        const r = new Set(Object.keys(e))
        this.allColumnFilters.forEach((o, a) => {
          const l = e[a]
          i.push(this.setModelOnFilterWrapper(o.filterPromise, l)), r.delete(a)
        }),
          r.forEach((o) => {
            const a =
              this.columnModel.getColDefCol(o) || this.columnModel.getCol(o)
            if (!a) {
              te('setFilterModel() - no column found for colId: ' + o)
              return
            }
            if (!a.isFilterAllowed()) {
              te(
                'setFilterModel() - unable to fully apply model, filtering disabled for colId: ' +
                  o,
              )
              return
            }
            const l = this.getOrCreateFilterWrapper(a)
            if (!l) {
              te(
                'setFilterModel() - unable to fully apply model, unable to create filter for colId: ' +
                  o,
              )
              return
            }
            i.push(this.setModelOnFilterWrapper(l.filterPromise, e[o]))
          })
      } else
        this.allColumnFilters.forEach((r) => {
          i.push(this.setModelOnFilterWrapper(r.filterPromise, null))
        })
      Nt.all(i).then(() => {
        var a
        const r = this.getFilterModel(!0),
          o = []
        this.allColumnFilters.forEach((l, c) => {
          const u = s ? s[c] : null,
            h = r ? r[c] : null
          po(u, h) || o.push(l.column)
        }),
          o.length > 0 &&
            ((a = this.filterManager) == null ||
              a.onFilterChanged({ columns: o, source: t }))
      })
    }
    setModelOnFilterWrapper(e, t) {
      return new Nt((i) => {
        e.then((s) => {
          typeof s.setModel != 'function' &&
            (te(
              'filter missing setModel method, which is needed for setFilterModel',
            ),
            i()),
            (s.setModel(t) || Nt.resolve()).then(() => i())
        })
      })
    }
    getFilterModel(e) {
      const t = {},
        { allColumnFilters: i, initialFilterModel: s } = this
      return (
        i.forEach((n, r) => {
          const o = this.getModelFromFilterWrapper(n)
          ue(o) && (t[r] = o)
        }),
        e ||
          Object.entries(s).forEach(([n, r]) => {
            var o
            ue(r) &&
              !i.has(n) &&
              (o = this.columnModel.getCol(n)) != null &&
              o.isFilterAllowed() &&
              (t[n] = r)
          }),
        t
      )
    }
    getModelFromFilterWrapper(e) {
      const { filter: t } = e
      return t
        ? typeof t.getModel != 'function'
          ? (te(
              'filter API missing getModel method, which is needed for getFilterModel',
            ),
            null)
          : t.getModel()
        : this.getModelFromInitialState(e.column)
    }
    getModelFromInitialState(e) {
      return this.initialFilterModel[e.getColId()] ?? null
    }
    isColumnFilterPresent() {
      return this.activeColumnFilters.length > 0
    }
    isAggregateFilterPresent() {
      return !!this.activeAggregateFilters.length
    }
    disableColumnFilters() {
      return this.allColumnFilters.size
        ? (this.allColumnFilters.forEach((e) =>
            this.disposeFilterWrapper(e, 'advancedFilterEnabled'),
          ),
          !0)
        : !1
    }
    doAggregateFiltersPass(e, t) {
      return this.doColumnFiltersPass(e, t, !0)
    }
    updateActiveFilters() {
      const e = (r) =>
          r
            ? r.isFilterActive
              ? r.isFilterActive()
              : (te('Filter is missing isFilterActive() method'), !1)
            : !1,
        t = !!Uc(this.gos),
        i = (r) => {
          if (!r.isPrimary()) return !0
          const a = !this.columnModel.isPivotActive()
          return !r.isValueActive() || !a
            ? !1
            : this.columnModel.isPivotMode()
              ? !0
              : t
        },
        s = [],
        n = []
      return this.forEachColumnFilter((r, o) => {
        e(r) && (i(o.column) ? s.push(r) : n.push(r))
      }).then(() => {
        ;(this.activeAggregateFilters = s), (this.activeColumnFilters = n)
      })
    }
    updateFilterFlagInColumns(e, t) {
      return this.forEachColumnFilter((i, s) =>
        s.column.setFilterActive(i.isFilterActive(), e, t),
      )
    }
    forEachColumnFilter(e) {
      return Nt.all(
        Array.from(this.allColumnFilters.values()).map((t) =>
          t.filterPromise.then((i) => e(i, t)),
        ),
      )
    }
    doColumnFiltersPass(e, t, i) {
      const { data: s, aggData: n } = e,
        r = i ? this.activeAggregateFilters : this.activeColumnFilters,
        o = i ? n : s
      for (let a = 0; a < r.length; a++) {
        const l = r[a]
        if (!(l == null || l === t)) {
          if (typeof l.doesFilterPass != 'function')
            throw new Error('Filter is missing method doesFilterPass')
          if (!l.doesFilterPass({ node: e, data: o })) return !1
        }
      }
      return !0
    }
    callOnFilterChangedOutsideRenderCycle(e) {
      const t = () => {
        var i
        return (i = this.filterManager) == null ? void 0 : i.onFilterChanged(e)
      }
      this.rowRenderer.isRefreshInProgress() ? setTimeout(t, 0) : t()
    }
    updateBeforeFilterChanged(e = {}) {
      const { filterInstance: t, additionalEventAttributes: i } = e
      return (
        this.updateDependentFilters(),
        this.updateActiveFilters().then(() =>
          this.updateFilterFlagInColumns('filterChanged', i).then(() => {
            this.allColumnFilters.forEach((s) => {
              s.filterPromise &&
                s.filterPromise.then((n) => {
                  n && n !== t && n.onAnyFilterChanged && n.onAnyFilterChanged()
                })
            }),
              (this.processingFilterChange = !0)
          }),
        )
      )
    }
    updateAfterFilterChanged() {
      this.processingFilterChange = !1
    }
    isSuppressFlashingCellsBecauseFiltering() {
      return (
        !(this.gos.get('allowShowChangeAfterFilter') ?? !1) &&
        this.processingFilterChange
      )
    }
    onNewRowsLoaded(e) {
      this.forEachColumnFilter((t) => {
        t.onNewRowsLoaded && t.onNewRowsLoaded()
      })
        .then(() => this.updateFilterFlagInColumns(e, { afterDataChange: !0 }))
        .then(() => this.updateActiveFilters())
    }
    createValueGetter(e) {
      return ({ node: t }) => this.valueService.getValue(e, t, !0)
    }
    createGetValue(e) {
      return (t, i) => {
        const s = i ? this.columnModel.getCol(i) : e
        return s ? this.valueService.getValue(s, t, !0) : void 0
      }
    }
    isFilterActive(e) {
      const { filter: t } = this.cachedFilter(e) ?? {}
      return t ? t.isFilterActive() : this.getModelFromInitialState(e) != null
    }
    getOrCreateFilterWrapper(e) {
      if (!e.isFilterAllowed()) return null
      let t = this.cachedFilter(e)
      return (
        t ||
          ((t = this.createFilterWrapper(e)),
          this.setColumnFilterWrapper(e, t)),
        t
      )
    }
    cachedFilter(e) {
      return this.allColumnFilters.get(e.getColId())
    }
    getDefaultFilter(e) {
      var i
      let t
      if (oc(this.gos)) t = 'agSetColumnFilter'
      else {
        const s =
          (i = this.dataTypeService) == null ? void 0 : i.getBaseDataType(e)
        s === 'number'
          ? (t = 'agNumberColumnFilter')
          : s === 'date' || s === 'dateString'
            ? (t = 'agDateColumnFilter')
            : (t = 'agTextColumnFilter')
      }
      return t
    }
    getDefaultFloatingFilter(e) {
      var i
      let t
      if (oc(this.gos)) t = 'agSetColumnFloatingFilter'
      else {
        const s =
          (i = this.dataTypeService) == null ? void 0 : i.getBaseDataType(e)
        s === 'number'
          ? (t = 'agNumberColumnFloatingFilter')
          : s === 'date' || s === 'dateString'
            ? (t = 'agDateColumnFloatingFilter')
            : (t = 'agTextColumnFloatingFilter')
      }
      return t
    }
    createFilterInstance(e, t) {
      const i = this.getDefaultFilter(e),
        s = e.getColDef()
      let n
      const r = {
          ...this.createFilterParams(e, s),
          filterModifiedCallback: () =>
            this.filterModifiedCallbackFactory(n, e)(),
          filterChangedCallback: (a) =>
            this.filterChangedCallbackFactory(n, e)(a),
          doesRowPassOtherFilter: (a) =>
            this.filterManager
              ? this.filterManager.doesRowPassOtherFilters(n, a)
              : !0,
        },
        o = this.userComponentFactory.getFilterDetails(s, r, i)
      return o
        ? {
            filterPromise: () => {
              const a = o.newAgStackInstance()
              return (
                a != null &&
                  a.then((l) => {
                    ;(n = l), t && (t.filter = l)
                  }),
                a
              )
            },
            compDetails: o,
          }
        : { filterPromise: null, compDetails: null }
    }
    createFilterParams(e, t) {
      return this.gos.addGridCommonParams({
        column: e,
        colDef: Im(t),
        rowModel: this.rowModel,
        filterChangedCallback: () => {},
        filterModifiedCallback: () => {},
        valueGetter: this.createValueGetter(e),
        getValue: this.createGetValue(e),
        doesRowPassOtherFilter: () => !0,
      })
    }
    createFilterWrapper(e) {
      const t = {
          column: e,
          filterPromise: null,
          compiledElement: null,
          compDetails: null,
        },
        { filterPromise: i, compDetails: s } = this.createFilterInstance(e, t)
      return (
        (t.filterPromise = (i == null ? void 0 : i()) ?? null),
        (t.compDetails = s),
        t
      )
    }
    onColumnsChanged() {
      var i
      const e = []
      this.allColumnFilters.forEach((s, n) => {
        let r
        s.column.isPrimary()
          ? (r = this.columnModel.getColDefCol(n))
          : (r = this.columnModel.getCol(n)),
          !(r && r === s.column) &&
            (e.push(s.column),
            this.disposeFilterWrapper(s, 'columnChanged'),
            this.disposeColumnListener(n))
      })
      const t = e.every((s) => s.getColDef().filter === 'agGroupColumnFilter')
      e.length > 0 && !t
        ? (i = this.filterManager) == null ||
          i.onFilterChanged({ columns: e, source: 'api' })
        : this.updateDependentFilters()
    }
    updateDependentFilters() {
      const e = this.columnModel.getAutoCols()
      e == null ||
        e.forEach((t) => {
          t.getColDef().filter === 'agGroupColumnFilter' &&
            this.getOrCreateFilterWrapper(t)
        })
    }
    isFilterAllowed(e) {
      if (!e.isFilterAllowed()) return !1
      const { filter: i } = this.allColumnFilters.get(e.getColId()) ?? {}
      return i && typeof (i == null ? void 0 : i.isFilterAllowed) == 'function'
        ? i.isFilterAllowed()
        : !0
    }
    getFloatingFilterCompDetails(e, t) {
      const i = (l) => {
          var u
          const c =
            (u = this.getOrCreateFilterWrapper(e)) == null
              ? void 0
              : u.filterPromise
          c != null &&
            c.then((h) => {
              l(ao(h))
            })
        },
        s = e.getColDef(),
        n = {
          ...this.createFilterParams(e, s),
          filterChangedCallback: () =>
            i((l) => this.filterChangedCallbackFactory(l, e)()),
        },
        r = this.userComponentFactory.mergeParamsWithApplicationProvidedParams(
          s,
          pd,
          n,
        )
      let o = oI(this.frameworkOverrides, s, () =>
        this.getDefaultFloatingFilter(e),
      )
      o == null && (o = 'agReadOnlyFloatingFilter')
      const a = {
        column: e,
        filterParams: r,
        currentParentModel: () => this.getCurrentFloatingFilterParentModel(e),
        parentFilterInstance: i,
        showParentFilter: t,
        suppressFilterButton: !1,
      }
      return this.userComponentFactory.getFloatingFilterCompDetails(s, a, o)
    }
    getCurrentFloatingFilterParentModel(e) {
      return this.getModelFromFilterWrapper(
        this.cachedFilter(e) ?? { column: e },
      )
    }
    destroyFilter(e, t = 'api') {
      var n
      const i = e.getColId(),
        s = this.allColumnFilters.get(i)
      this.disposeColumnListener(i),
        delete this.initialFilterModel[i],
        s &&
          (this.disposeFilterWrapper(s, t),
          (n = this.filterManager) == null ||
            n.onFilterChanged({ columns: [e], source: 'api' }))
    }
    disposeColumnListener(e) {
      const t = this.allColumnListeners.get(e)
      t && (this.allColumnListeners.delete(e), t())
    }
    disposeFilterWrapper(e, t) {
      e.filterPromise.then((i) => {
        this.destroyBean(i),
          e.column.setFilterActive(!1, 'filterDestroyed'),
          this.allColumnFilters.delete(e.column.getColId()),
          this.eventService.dispatchEvent({
            type: 'filterDestroyed',
            source: t,
            column: e.column,
          })
      })
    }
    filterModifiedCallbackFactory(e, t) {
      return () => {
        this.eventService.dispatchEvent({
          type: 'filterModified',
          column: t,
          filterInstance: e,
        })
      }
    }
    filterChangedCallbackFactory(e, t) {
      return (i) => {
        const s = (i == null ? void 0 : i.source) ?? 'columnFilter',
          n = {
            filter: e,
            additionalEventAttributes: i,
            columns: [t],
            source: s,
          }
        this.callOnFilterChangedOutsideRenderCycle(n)
      }
    }
    checkDestroyFilter(e) {
      const t = this.allColumnFilters.get(e)
      if (!t) return
      const i = t.column,
        { compDetails: s } = i.isFilterAllowed()
          ? this.createFilterInstance(i)
          : { compDetails: null }
      if (this.areFilterCompsDifferent(t.compDetails, s)) {
        this.destroyFilter(i, 'paramsUpdated')
        return
      }
      const n = i.getColDef().filterParams
      if (!t.filterPromise) {
        this.destroyFilter(i, 'paramsUpdated')
        return
      }
      t.filterPromise.then((r) => {
        ;(r != null && r.refresh
          ? r.refresh({
              ...this.createFilterParams(i, i.getColDef()),
              filterModifiedCallback: this.filterModifiedCallbackFactory(r, i),
              filterChangedCallback: this.filterChangedCallbackFactory(r, i),
              doesRowPassOtherFilter: (a) =>
                this.filterManager
                  ? this.filterManager.doesRowPassOtherFilters(r, a)
                  : !0,
              ...n,
            })
          : !0) === !1 && this.destroyFilter(i, 'paramsUpdated')
      })
    }
    setColumnFilterWrapper(e, t) {
      const i = e.getColId()
      this.allColumnFilters.set(i, t),
        this.allColumnListeners.set(
          i,
          this.addManagedListeners(e, {
            colDefChanged: () => this.checkDestroyFilter(i),
          })[0],
        )
    }
    areFilterCompsDifferent(e, t) {
      if (!t || !e) return !0
      const { componentClass: i } = e,
        { componentClass: s } = t
      return !(
        i === s ||
        ((i == null ? void 0 : i.render) &&
          (s == null ? void 0 : s.render) &&
          i.render === s.render)
      )
    }
    hasFloatingFilters() {
      return this.columnModel
        .getCols()
        .some((t) => t.getColDef().floatingFilter)
    }
    getFilterInstance(e, t) {
      t &&
        this.getFilterInstanceImpl(e).then((i) => {
          const s = ao(i)
          t(s)
        })
    }
    getColumnFilterInstance(e) {
      return new Promise((t) => {
        this.getFilterInstanceImpl(e).then((i) => {
          t(ao(i))
        })
      })
    }
    getFilterInstanceImpl(e) {
      var s
      const t = this.columnModel.getColDefCol(e)
      return t
        ? (((s = this.getOrCreateFilterWrapper(t)) == null
            ? void 0
            : s.filterPromise) ?? Nt.resolve(null))
        : Nt.resolve(void 0)
    }
    processFilterModelUpdateQueue() {
      this.filterModelUpdateQueue.forEach(({ model: e, source: t }) =>
        this.setFilterModel(e, t),
      ),
        (this.filterModelUpdateQueue = []),
        this.columnFilterModelUpdateQueue.forEach(
          ({ key: e, model: t, resolve: i }) => {
            this.setColumnFilterModel(e, t).then(() => i())
          },
        ),
        (this.columnFilterModelUpdateQueue = [])
    }
    getColumnFilterModel(e) {
      const t = this.getFilterWrapper(e)
      return t ? this.getModelFromFilterWrapper(t) : null
    }
    setColumnFilterModel(e, t) {
      var r
      if ((r = this.dataTypeService) != null && r.isPendingInference()) {
        let o = () => {}
        const a = new Promise((l) => {
          o = l
        })
        return (
          this.columnFilterModelUpdateQueue.push({
            key: e,
            model: t,
            resolve: o,
          }),
          a
        )
      }
      const i = this.columnModel.getColDefCol(e),
        s = i ? this.getOrCreateFilterWrapper(i) : null
      return s
        ? ((o) =>
            new Promise((a) => {
              o.then((l) => a(l))
            }))(this.setModelOnFilterWrapper(s.filterPromise, t))
        : Promise.resolve()
    }
    getFilterWrapper(e) {
      const t = this.columnModel.getColDefCol(e)
      return t ? (this.cachedFilter(t) ?? null) : null
    }
    setColDefPropertiesForDataType(e, t, i) {
      const s = oc(this.gos),
        n = this.localeService.getLocaleTextFunc(),
        r = (o) => {
          const { filterParams: a } = e
          e.filterParams = typeof a == 'object' ? { ...a, ...o } : o
        }
      switch (t.baseDataType) {
        case 'number': {
          s &&
            r({
              comparator: (o, a) => {
                const l = o == null ? 0 : parseInt(o),
                  c = a == null ? 0 : parseInt(a)
                return l === c ? 0 : l > c ? 1 : -1
              },
            })
          break
        }
        case 'boolean': {
          r(
            s
              ? {
                  valueFormatter: (o) =>
                    ue(o.value)
                      ? n(String(o.value), o.value ? 'True' : 'False')
                      : n('blanks', '(Blanks)'),
                }
              : {
                  maxNumConditions: 1,
                  debounceMs: 0,
                  filterOptions: [
                    'empty',
                    {
                      displayKey: 'true',
                      displayName: 'True',
                      predicate: (o, a) => a,
                      numberOfInputs: 0,
                    },
                    {
                      displayKey: 'false',
                      displayName: 'False',
                      predicate: (o, a) => a === !1,
                      numberOfInputs: 0,
                    },
                  ],
                },
          )
          break
        }
        case 'date': {
          s &&
            r({
              valueFormatter: (o) => {
                const a = i(o)
                return ue(a) ? a : n('blanks', '(Blanks)')
              },
              treeList: !0,
              treeListFormatter: (o, a) => {
                if (a === 1 && o != null) {
                  const l = Eg[Number(o) - 1]
                  return n(l, Fg[l])
                }
                return o ?? n('blanks', '(Blanks)')
              },
            })
          break
        }
        case 'dateString': {
          const o = t.dateParser
          r(
            s
              ? {
                  valueFormatter: (a) => {
                    const l = i(a)
                    return ue(l) ? l : n('blanks', '(Blanks)')
                  },
                  treeList: !0,
                  treeListPathGetter: (a) => {
                    const l = o(a ?? void 0)
                    return l
                      ? [
                          String(l.getFullYear()),
                          String(l.getMonth() + 1),
                          String(l.getDate()),
                        ]
                      : null
                  },
                  treeListFormatter: (a, l) => {
                    if (l === 1 && a != null) {
                      const c = Eg[Number(a) - 1]
                      return n(c, Fg[c])
                    }
                    return a ?? n('blanks', '(Blanks)')
                  },
                }
              : {
                  comparator: (a, l) => {
                    const c = o(l)
                    return l == null || c < a ? -1 : c > a ? 1 : 0
                  },
                },
          )
          break
        }
        case 'object': {
          s
            ? r({
                valueFormatter: (o) => {
                  const a = i(o)
                  return ue(a) ? a : n('blanks', '(Blanks)')
                },
              })
            : (e.filterValueGetter = (o) =>
                i({
                  column: o.column,
                  node: o.node,
                  value: this.valueService.getValue(o.column, o.node),
                }))
          break
        }
      }
    }
    destroy() {
      super.destroy(),
        this.allColumnFilters.forEach((e) =>
          this.disposeFilterWrapper(e, 'gridDestroyed'),
        ),
        this.allColumnListeners.clear()
    }
  }
function lI(e) {
  var t
  return !!((t = e.filterManager) != null && t.isAnyFilterPresent())
}
function cI(e, t = 'api') {
  var i
  ;(i = e.filterManager) == null || i.onFilterChanged({ source: t })
}
var uI = class extends yt {
    constructor() {
      super(
        `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eFloatingFilterText"></ag-input-text-field>
            </div>`,
        [Cl],
      ),
        (this.eFloatingFilterText = Le)
    }
    wireBeans(e) {
      this.columnNameService = e.columnNameService
    }
    destroy() {
      super.destroy()
    }
    init(e) {
      this.params = e
      const t = this.columnNameService.getDisplayNameForColumn(
          e.column,
          'header',
          !0,
        ),
        i = this.localeService.getLocaleTextFunc()
      this.eFloatingFilterText
        .setDisabled(!0)
        .setInputAriaLabel(`${t} ${i('ariaFilterInput', 'Filter Input')}`)
    }
    onParentModelChanged(e) {
      if (e == null) {
        this.eFloatingFilterText.setValue('')
        return
      }
      this.params.parentFilterInstance((t) => {
        if (t.getModelAsString) {
          const i = t.getModelAsString(e)
          this.eFloatingFilterText.setValue(i)
        }
      })
    }
    onParamsUpdated(e) {
      this.refresh(e)
    }
    refresh(e) {
      this.init(e)
    }
  },
  Dv = class extends yt {
    wireBeans(e) {
      this.columnNameService = e.columnNameService
    }
    getDefaultDebounceMs() {
      return 0
    }
    destroy() {
      super.destroy()
    }
    isEventFromFloatingFilter(e) {
      return e && e.afterFloatingFilter
    }
    isEventFromDataChange(e) {
      return e == null ? void 0 : e.afterDataChange
    }
    getLastType() {
      return this.lastType
    }
    isReadOnly() {
      return this.readOnly
    }
    setLastTypeFromModel(e) {
      if (!e) {
        this.lastType = this.optionsFactory.getDefaultOption()
        return
      }
      const t = e.operator
      let i
      t ? (i = e.conditions[0]) : (i = e), (this.lastType = i.type)
    }
    canWeEditAfterModelFromParentFilter(e) {
      if (!e) return this.isTypeEditable(this.lastType)
      if (e.operator) return !1
      const i = e
      return this.isTypeEditable(i.type)
    }
    init(e) {
      this.setSimpleParams(e, !1)
    }
    setSimpleParams(e, t = !0) {
      ;(this.optionsFactory = new dv()),
        this.optionsFactory.init(
          e.filterParams,
          this.getDefaultFilterOptions(),
        ),
        t || (this.lastType = this.optionsFactory.getDefaultOption()),
        (this.readOnly = !!e.filterParams.readOnly)
      const i = this.isTypeEditable(this.optionsFactory.getDefaultOption())
      this.setEditable(i)
    }
    onParamsUpdated(e) {
      this.refresh(e)
    }
    refresh(e) {
      this.setSimpleParams(e)
    }
    doesFilterHaveSingleInput(e) {
      const t = this.optionsFactory.getCustomOption(e),
        { numberOfInputs: i } = t || {}
      return i == null || i == 1
    }
    isTypeEditable(e) {
      const t = ['inRange', 'empty', 'blank', 'notBlank']
      return (
        !!e &&
        !this.isReadOnly() &&
        this.doesFilterHaveSingleInput(e) &&
        t.indexOf(e) < 0
      )
    }
    getAriaLabel(e) {
      const t = this.columnNameService.getDisplayNameForColumn(
          e.column,
          'header',
          !0,
        ),
        i = this.localeService.getLocaleTextFunc()
      return `${t} ${i('ariaFilterInput', 'Filter Input')}`
    }
  },
  dI = class extends Dv {
    constructor() {
      super(
        `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eReadOnlyText"></ag-input-text-field>
                <div data-ref="eDateWrapper" style="display: flex;"></div>
            </div>`,
        [Cl],
      ),
        (this.eReadOnlyText = Le),
        (this.eDateWrapper = Le)
    }
    wireBeans(e) {
      super.wireBeans(e),
        (this.context = e.context),
        (this.userComponentFactory = e.userComponentFactory)
    }
    getDefaultFilterOptions() {
      return bv
    }
    init(e) {
      super.init(e),
        (this.params = e),
        (this.filterParams = e.filterParams),
        this.createDateComponent(),
        (this.filterModelFormatter = new Rv(
          this.filterParams,
          this.localeService,
          this.optionsFactory,
        ))
      const t = this.localeService.getLocaleTextFunc()
      this.eReadOnlyText
        .setDisabled(!0)
        .setInputAriaLabel(t('ariaDateFilterInput', 'Date Filter Input'))
    }
    onParamsUpdated(e) {
      this.refresh(e)
    }
    refresh(e) {
      super.refresh(e),
        (this.params = e),
        (this.filterParams = e.filterParams),
        this.updateDateComponent(),
        this.filterModelFormatter.updateParams({
          optionsFactory: this.optionsFactory,
          dateFilterParams: this.filterParams,
        }),
        this.updateCompOnModelChange(e.currentParentModel())
    }
    updateCompOnModelChange(e) {
      const t =
        !this.isReadOnly() && this.canWeEditAfterModelFromParentFilter(e)
      if ((this.setEditable(t), t)) {
        if (e) {
          const i = e
          this.dateComp.setDate(Mi(i.dateFrom))
        } else this.dateComp.setDate(null)
        this.eReadOnlyText.setValue('')
      } else
        this.eReadOnlyText.setValue(
          this.filterModelFormatter.getModelAsString(e),
        ),
          this.dateComp.setDate(null)
    }
    setEditable(e) {
      Ot(this.eDateWrapper, e), Ot(this.eReadOnlyText.getGui(), !e)
    }
    onParentModelChanged(e, t) {
      this.isEventFromFloatingFilter(t) ||
        this.isEventFromDataChange(t) ||
        (super.setLastTypeFromModel(e), this.updateCompOnModelChange(e))
    }
    onDateChanged() {
      const e = this.dateComp.getDate(),
        t = zi(e)
      this.params.parentFilterInstance((i) => {
        if (i) {
          const s = Mi(t)
          i.onFloatingFilterChanged(this.getLastType() || null, s)
        }
      })
    }
    getDateComponentParams() {
      const e = md(this.params.filterParams, this.getDefaultDebounceMs())
      return {
        onDateChanged: bi(this.onDateChanged.bind(this), e),
        filterParams: this.params.column.getColDef().filterParams,
      }
    }
    createDateComponent() {
      ;(this.dateComp = new yv(
        this.context,
        this.userComponentFactory,
        this.getDateComponentParams(),
        this.eDateWrapper,
        (e) => {
          e.setInputAriaLabel(this.getAriaLabel(this.params))
        },
      )),
        this.addDestroyFunc(() => this.dateComp.destroy())
    }
    updateDateComponent() {
      const e = this.gos.addGridCommonParams(this.getDateComponentParams())
      this.dateComp.updateParams(e)
    }
    getFilterModelFormatter() {
      return this.filterModelFormatter
    }
  },
  hI = class extends yt {
    constructor() {
      super(
        `
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" data-ref="eDateInput"></ag-input-text-field>
            </div>`,
        [Cl],
      ),
        (this.eDateInput = Le)
    }
    destroy() {
      super.destroy()
    }
    init(e) {
      ;(this.params = e), this.setParams(e)
      const t = this.eDateInput.getInputElement()
      this.addManagedListeners(t, {
        mouseDown: () => {
          this.eDateInput.isDisabled() ||
            this.usingSafariDatePicker ||
            t.focus()
        },
        input: (i) => {
          i.target === Lt(this.gos) &&
            (this.eDateInput.isDisabled() || this.params.onDateChanged())
        },
      })
    }
    setParams(e) {
      const t = this.eDateInput.getInputElement(),
        i = this.shouldUseBrowserDatePicker(e)
      ;(this.usingSafariDatePicker = i && gs()), (t.type = i ? 'date' : 'text')
      const {
        minValidYear: s,
        maxValidYear: n,
        minValidDate: r,
        maxValidDate: o,
      } = e.filterParams || {}
      if (
        (r &&
          s &&
          te(
            'DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored.',
          ),
        o &&
          n &&
          te(
            'DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored.',
          ),
        r && o)
      ) {
        const [a, l] = [r, o].map((c) => (c instanceof Date ? c : Mi(c)))
        a &&
          l &&
          a.getTime() > l.getTime() &&
          te(
            'DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate.',
          )
      }
      r
        ? r instanceof Date
          ? (t.min = co(r))
          : (t.min = r)
        : s && (t.min = `${s}-01-01`),
        o
          ? o instanceof Date
            ? (t.max = co(o))
            : (t.max = o)
          : n && (t.max = `${n}-12-31`)
    }
    onParamsUpdated(e) {
      this.refresh(e)
    }
    refresh(e) {
      ;(this.params = e), this.setParams(e)
    }
    getDate() {
      return Mi(this.eDateInput.getValue())
    }
    setDate(e) {
      this.eDateInput.setValue(zi(e, !1))
    }
    setInputPlaceholder(e) {
      this.eDateInput.setInputPlaceholder(e)
    }
    setInputAriaLabel(e) {
      this.eDateInput.setAriaLabel(e)
    }
    setDisabled(e) {
      this.eDateInput.setDisabled(e)
    }
    afterGuiAttached(e) {
      ;(!e || !e.suppressFocus) && this.eDateInput.getInputElement().focus()
    }
    shouldUseBrowserDatePicker(e) {
      return e.filterParams && e.filterParams.browserDatePicker != null
        ? e.filterParams.browserDatePicker
        : od() || ad() || (gs() && _m() >= 14.1)
    }
  },
  Mv = class extends X {
    constructor(e) {
      super(),
        (this.params = e),
        (this.eFloatingFilterTextInput = Le),
        (this.valueChangedListener = () => {})
    }
    setupGui(e) {
      var s
      this.eFloatingFilterTextInput = this.createManagedBean(
        new Yn((s = this.params) == null ? void 0 : s.config),
      )
      const t = this.eFloatingFilterTextInput.getGui()
      e.appendChild(t)
      const i = (n) => this.valueChangedListener(n)
      this.addManagedListeners(t, { input: i, keydown: i })
    }
    setEditable(e) {
      this.eFloatingFilterTextInput.setDisabled(!e)
    }
    setAutoComplete(e) {
      this.eFloatingFilterTextInput.setAutoComplete(e)
    }
    getValue() {
      return this.eFloatingFilterTextInput.getValue()
    }
    setValue(e, t) {
      this.eFloatingFilterTextInput.setValue(e, t)
    }
    setValueChangedListener(e) {
      this.valueChangedListener = e
    }
    setParams(e) {
      this.setAriaLabel(e.ariaLabel),
        e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete)
    }
    setAriaLabel(e) {
      this.eFloatingFilterTextInput.setInputAriaLabel(e)
    }
  },
  Iv = class extends Dv {
    constructor() {
      super(...arguments), (this.eFloatingFilterInputContainer = Le)
    }
    postConstruct() {
      this.setTemplate(`
            <div class="ag-floating-filter-input" role="presentation" data-ref="eFloatingFilterInputContainer"></div>
        `)
    }
    getDefaultDebounceMs() {
      return 500
    }
    onParentModelChanged(e, t) {
      this.isEventFromFloatingFilter(t) ||
        this.isEventFromDataChange(t) ||
        (this.setLastTypeFromModel(e),
        this.setEditable(this.canWeEditAfterModelFromParentFilter(e)),
        this.floatingFilterInputService.setValue(
          this.getFilterModelFormatter().getModelAsString(e),
        ))
    }
    init(e) {
      this.setupFloatingFilterInputService(e),
        super.init(e),
        this.setTextInputParams(e)
    }
    setupFloatingFilterInputService(e) {
      ;(this.floatingFilterInputService =
        this.createFloatingFilterInputService(e)),
        this.floatingFilterInputService.setupGui(
          this.eFloatingFilterInputContainer,
        )
    }
    setTextInputParams(e) {
      this.params = e
      const t = e.browserAutoComplete ?? !1
      if (
        (this.floatingFilterInputService.setParams({
          ariaLabel: this.getAriaLabel(e),
          autoComplete: t,
        }),
        (this.applyActive = Wa(this.params.filterParams)),
        !this.isReadOnly())
      ) {
        const i = md(this.params.filterParams, this.getDefaultDebounceMs()),
          s = bi(this.syncUpWithParentFilter.bind(this), i)
        this.floatingFilterInputService.setValueChangedListener(s)
      }
    }
    onParamsUpdated(e) {
      this.refresh(e)
    }
    refresh(e) {
      super.refresh(e), this.setTextInputParams(e)
    }
    recreateFloatingFilterInputService(e) {
      const t = this.floatingFilterInputService.getValue()
      Ni(this.eFloatingFilterInputContainer),
        this.destroyBean(this.floatingFilterInputService),
        this.setupFloatingFilterInputService(e),
        this.floatingFilterInputService.setValue(t, !0)
    }
    syncUpWithParentFilter(e) {
      const t = e.key === Y.ENTER
      if (this.applyActive && !t) return
      let i = this.floatingFilterInputService.getValue()
      this.params.filterParams.trimInput &&
        ((i = Sv(i)), this.floatingFilterInputService.setValue(i, !0)),
        this.params.parentFilterInstance((s) => {
          s && s.onFloatingFilterChanged(this.getLastType() || null, i || null)
        })
    }
    setEditable(e) {
      this.floatingFilterInputService.setEditable(e)
    }
  },
  gI = class extends X {
    constructor() {
      super(...arguments),
        (this.valueChangedListener = () => {}),
        (this.numberInputActive = !0)
    }
    setupGui(e) {
      ;(this.eFloatingFilterNumberInput = this.createManagedBean(new Cd())),
        (this.eFloatingFilterTextInput = this.createManagedBean(new Yn())),
        this.eFloatingFilterTextInput.setDisabled(!0)
      const t = this.eFloatingFilterNumberInput.getGui(),
        i = this.eFloatingFilterTextInput.getGui()
      e.appendChild(t),
        e.appendChild(i),
        this.setupListeners(t, (s) => this.valueChangedListener(s)),
        this.setupListeners(i, (s) => this.valueChangedListener(s))
    }
    setEditable(e) {
      ;(this.numberInputActive = e),
        this.eFloatingFilterNumberInput.setDisplayed(this.numberInputActive),
        this.eFloatingFilterTextInput.setDisplayed(!this.numberInputActive)
    }
    setAutoComplete(e) {
      this.eFloatingFilterNumberInput.setAutoComplete(e),
        this.eFloatingFilterTextInput.setAutoComplete(e)
    }
    getValue() {
      return this.getActiveInputElement().getValue()
    }
    setValue(e, t) {
      this.getActiveInputElement().setValue(e, t)
    }
    getActiveInputElement() {
      return this.numberInputActive
        ? this.eFloatingFilterNumberInput
        : this.eFloatingFilterTextInput
    }
    setValueChangedListener(e) {
      this.valueChangedListener = e
    }
    setupListeners(e, t) {
      this.addManagedListeners(e, { input: t, keydown: t })
    }
    setParams(e) {
      this.setAriaLabel(e.ariaLabel),
        e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete)
    }
    setAriaLabel(e) {
      this.eFloatingFilterNumberInput.setInputAriaLabel(e),
        this.eFloatingFilterTextInput.setInputAriaLabel(e)
    }
  },
  fI = class extends Iv {
    init(e) {
      var t
      super.init(e),
        (this.filterModelFormatter = new mv(
          this.localeService,
          this.optionsFactory,
          (t = e.filterParams) == null ? void 0 : t.numberFormatter,
        ))
    }
    onParamsUpdated(e) {
      this.refresh(e)
    }
    refresh(e) {
      su(e.filterParams) !== this.allowedCharPattern &&
        this.recreateFloatingFilterInputService(e),
        super.refresh(e),
        this.filterModelFormatter.updateParams({
          optionsFactory: this.optionsFactory,
        })
    }
    getDefaultFilterOptions() {
      return pv
    }
    getFilterModelFormatter() {
      return this.filterModelFormatter
    }
    createFloatingFilterInputService(e) {
      return (
        (this.allowedCharPattern = su(e.filterParams)),
        this.allowedCharPattern
          ? this.createManagedBean(
              new Mv({
                config: { allowedCharPattern: this.allowedCharPattern },
              }),
            )
          : this.createManagedBean(new gI())
      )
    }
  },
  pI = class extends Iv {
    init(e) {
      super.init(e),
        (this.filterModelFormatter = new Cv(
          this.localeService,
          this.optionsFactory,
        ))
    }
    onParamsUpdated(e) {
      this.refresh(e)
    }
    refresh(e) {
      super.refresh(e),
        this.filterModelFormatter.updateParams({
          optionsFactory: this.optionsFactory,
        })
    }
    getDefaultFilterOptions() {
      return vv
    }
    getFilterModelFormatter() {
      return this.filterModelFormatter
    }
    createFloatingFilterInputService() {
      return this.createManagedBean(new Mv())
    }
  }
function mI(e) {
  var t
  return !!((t = e.filterManager) != null && t.isQuickFilterPresent())
}
function vI(e) {
  return e.gos.get('quickFilterText')
}
function CI(e) {
  var t
  ;(t = e.filterManager) == null || t.resetQuickFilterCache()
}
var SI = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'quickFilterService'),
        (this.quickFilter = null),
        (this.quickFilterParts = null)
    }
    wireBeans(e) {
      ;(this.valueService = e.valueService),
        (this.columnModel = e.columnModel),
        (this.rowModel = e.rowModel),
        (this.pivotResultColsService = e.pivotResultColsService)
    }
    postConstruct() {
      const e = this.resetQuickFilterCache.bind(this)
      this.addManagedEventListeners({
        columnPivotModeChanged: e,
        newColumnsLoaded: e,
        columnRowGroupChanged: e,
        columnVisible: () => {
          this.gos.get('includeHiddenColumnsInQuickFilter') ||
            this.resetQuickFilterCache()
        },
      }),
        this.addManagedPropertyListener('quickFilterText', (t) =>
          this.setQuickFilter(t.currentValue),
        ),
        this.addManagedPropertyListeners(
          [
            'includeHiddenColumnsInQuickFilter',
            'applyQuickFilterBeforePivotOrAgg',
          ],
          () => this.onQuickFilterColumnConfigChanged(),
        ),
        (this.quickFilter = this.parseQuickFilter(
          this.gos.get('quickFilterText'),
        )),
        (this.parser = this.gos.get('quickFilterParser')),
        (this.matcher = this.gos.get('quickFilterMatcher')),
        this.setQuickFilterParts(),
        this.addManagedPropertyListeners(
          ['quickFilterMatcher', 'quickFilterParser'],
          () => this.setQuickFilterParserAndMatcher(),
        )
    }
    refreshQuickFilterCols() {
      var n
      const e = this.columnModel.isPivotMode(),
        t = this.columnModel.getAutoCols(),
        i = this.columnModel.getColDefCols()
      let s =
        (e && !this.gos.get('applyQuickFilterBeforePivotOrAgg')
          ? (n = this.pivotResultColsService.getPivotResultCols()) == null
            ? void 0
            : n.list
          : i) ?? []
      t && (s = s.concat(t)),
        (this.colsForQuickFilter = this.gos.get(
          'includeHiddenColumnsInQuickFilter',
        )
          ? s
          : s.filter((r) => r.isVisible() || r.isRowGroupActive()))
    }
    isQuickFilterPresent() {
      return this.quickFilter !== null
    }
    doesRowPassQuickFilter(e) {
      const t = this.gos.get('cacheQuickFilter')
      return this.matcher
        ? this.doesRowPassQuickFilterMatcher(t, e)
        : this.quickFilterParts.every((i) =>
            t
              ? this.doesRowPassQuickFilterCache(e, i)
              : this.doesRowPassQuickFilterNoCache(e, i),
          )
    }
    resetQuickFilterCache() {
      this.rowModel.forEachNode((e) => (e.quickFilterAggregateText = null))
    }
    setQuickFilterParts() {
      const { quickFilter: e, parser: t } = this
      e
        ? (this.quickFilterParts = t ? t(e) : e.split(' '))
        : (this.quickFilterParts = null)
    }
    parseQuickFilter(e) {
      return ue(e)
        ? Pt(this.gos)
          ? e.toUpperCase()
          : (te('Quick filtering only works with the Client-Side Row Model'),
            null)
        : null
    }
    setQuickFilter(e) {
      if (e != null && typeof e != 'string') {
        te(
          `Grid option quickFilterText only supports string inputs, received: ${typeof e}`,
        )
        return
      }
      const t = this.parseQuickFilter(e)
      this.quickFilter !== t &&
        ((this.quickFilter = t),
        this.setQuickFilterParts(),
        this.dispatchLocalEvent({ type: 'quickFilterChanged' }))
    }
    setQuickFilterParserAndMatcher() {
      const e = this.gos.get('quickFilterParser'),
        t = this.gos.get('quickFilterMatcher'),
        i = e !== this.parser || t !== this.matcher
      ;(this.parser = e),
        (this.matcher = t),
        i &&
          (this.setQuickFilterParts(),
          this.dispatchLocalEvent({ type: 'quickFilterChanged' }))
    }
    onQuickFilterColumnConfigChanged() {
      this.refreshQuickFilterCols(),
        this.resetQuickFilterCache(),
        this.isQuickFilterPresent() &&
          this.dispatchLocalEvent({ type: 'quickFilterChanged' })
    }
    doesRowPassQuickFilterNoCache(e, t) {
      return this.colsForQuickFilter.some((i) => {
        const s = this.getQuickFilterTextForColumn(i, e)
        return ue(s) && s.indexOf(t) >= 0
      })
    }
    doesRowPassQuickFilterCache(e, t) {
      return (
        this.checkGenerateQuickFilterAggregateText(e),
        e.quickFilterAggregateText.indexOf(t) >= 0
      )
    }
    doesRowPassQuickFilterMatcher(e, t) {
      let i
      e
        ? (this.checkGenerateQuickFilterAggregateText(t),
          (i = t.quickFilterAggregateText))
        : (i = this.getQuickFilterAggregateText(t))
      const { quickFilterParts: s, matcher: n } = this
      return n(s, i)
    }
    checkGenerateQuickFilterAggregateText(e) {
      e.quickFilterAggregateText ||
        (e.quickFilterAggregateText = this.getQuickFilterAggregateText(e))
    }
    getQuickFilterTextForColumn(e, t) {
      let i = this.valueService.getValue(e, t, !0)
      const s = e.getColDef()
      if (s.getQuickFilterText) {
        const n = this.gos.addGridCommonParams({
          value: i,
          node: t,
          data: t.data,
          column: e,
          colDef: s,
        })
        i = s.getQuickFilterText(n)
      }
      return ue(i) ? i.toString().toUpperCase() : null
    }
    getQuickFilterAggregateText(e) {
      const t = []
      return (
        this.colsForQuickFilter.forEach((i) => {
          const s = this.getQuickFilterTextForColumn(i, e)
          ue(s) && t.push(s)
        }),
        t.join(`
`)
      )
    }
  },
  bd = {
    version: je,
    moduleName: '@ag-grid-community/filter-core',
    beans: [yM],
  },
  wI = {
    version: je,
    moduleName: '@ag-grid-community/filter-api',
    apiFunctions: { isAnyFilterPresent: lI, onFilterChanged: cI },
    dependantModules: [bd],
  },
  Rd = {
    version: je,
    moduleName: '@ag-grid-community/column-filter',
    beans: [aI],
    dependantModules: [bd],
  },
  yI = {
    version: je,
    moduleName: '@ag-grid-community/column-filter-api',
    apiFunctions: {
      isColumnFilterPresent: XM,
      getFilterInstance: JM,
      getColumnFilterInstance: ZM,
      destroyFilter: eI,
      setFilterModel: tI,
      getFilterModel: iI,
      getColumnFilterModel: sI,
      setColumnFilterModel: nI,
      showColumnFilter: rI,
    },
    dependantModules: [Rd, wI],
  },
  Tv = {
    version: je,
    moduleName: '@ag-grid-community/floating-filter-core',
    controllers: [{ name: 'headerFilterCell', classImp: QM }],
    dependantModules: [Rd],
  },
  bI = {
    version: je,
    moduleName: '@ag-grid-community/read-only-floating-filter',
    userComponents: [{ name: 'agReadOnlyFloatingFilter', classImp: uI }],
    dependantModules: [Tv],
  },
  RI = {
    version: je,
    moduleName: '@ag-grid-community/simple-filter',
    dependantModules: [Rd],
    userComponents: [
      { name: 'agTextColumnFilter', classImp: _M },
      { name: 'agNumberColumnFilter', classImp: VM },
      { name: 'agDateColumnFilter', classImp: zM },
      { name: 'agDateInput', classImp: hI },
    ],
  },
  FI = {
    version: je,
    moduleName: '@ag-grid-community/simple-floating-filter',
    dependantModules: [RI, Tv],
    userComponents: [
      { name: 'agTextColumnFloatingFilter', classImp: pI },
      { name: 'agNumberColumnFloatingFilter', classImp: fI },
      { name: 'agDateColumnFloatingFilter', classImp: dI },
    ],
  },
  Av = {
    version: je,
    moduleName: '@ag-grid-community/quick-filter-core',
    beans: [SI],
    dependantModules: [bd],
  },
  EI = {
    version: je,
    moduleName: '@ag-grid-community/quick-filter-api',
    apiFunctions: {
      isQuickFilterPresent: mI,
      getQuickFilter: vI,
      resetQuickFilter: CI,
    },
    dependantModules: [Av],
  },
  PI = {
    version: je,
    moduleName: '@ag-grid-community/quick-filter',
    dependantModules: [Av, EI],
  },
  xI = {
    version: je,
    moduleName: '@ag-grid-community/filter',
    dependantModules: [FI, bI, PI, yI],
  },
  nu = ((e) => (
    (e.COLUMN_GROUP = 'group'),
    (e.COLUMN = 'column'),
    (e.FLOATING_FILTER = 'filter'),
    e
  ))(nu || {}),
  DI = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'headerNavigationService'),
        (this.currentHeaderRowWithoutSpan = -1)
    }
    wireBeans(e) {
      ;(this.focusService = e.focusService),
        (this.headerPositionUtils = e.headerPositionUtils),
        (this.ctrlsService = e.ctrlsService),
        (this.columnModel = e.columnModel),
        (this.visibleColService = e.visibleColsService)
    }
    postConstruct() {
      this.ctrlsService.whenReady(this, (t) => {
        this.gridBodyCon = t.gridBodyCtrl
      })
      const e = Gt(this.gos)
      this.addManagedElementListeners(e, {
        mousedown: () => this.setCurrentHeaderRowWithoutSpan(-1),
      })
    }
    getHeaderRowCount() {
      var e
      return (
        ((e = this.ctrlsService.getHeaderRowContainerCtrl()) == null
          ? void 0
          : e.getRowCount()) ?? 0
      )
    }
    getHeaderPositionForColumn(e, t) {
      let i
      if (
        (typeof e == 'string'
          ? ((i = this.columnModel.getCol(e)),
            i || (i = this.visibleColService.getColumnGroup(e)))
          : (i = e),
        !i)
      )
        return null
      const s = this.ctrlsService.getHeaderRowContainerCtrl(),
        n = s == null ? void 0 : s.getAllCtrls(),
        r = rt(n || []).getType() === 'filter',
        o = this.getHeaderRowCount() - 1
      let a = -1,
        l = i
      for (; l; ) a++, (l = l.getParent())
      let c = a
      return (
        t && r && c === o - 1 && c++,
        c === -1 ? null : { headerRowIndex: c, column: i }
      )
    }
    navigateVertically(e, t, i) {
      if ((t || (t = this.focusService.getFocusedHeader()), !t)) return !1
      const { headerRowIndex: s } = t,
        n = t.column,
        r = this.getHeaderRowCount(),
        o = e === 0
      let {
          headerRowIndex: a,
          column: l,
          headerRowIndexWithoutSpan: c,
        } = o
          ? this.headerPositionUtils.getColumnVisibleParent(n, s)
          : this.headerPositionUtils.getColumnVisibleChild(n, s),
        u = !1
      return (
        a < 0 && ((a = 0), (l = n), (u = !0)),
        a >= r
          ? ((a = -1), this.setCurrentHeaderRowWithoutSpan(-1))
          : c !== void 0 && (this.currentHeaderRowWithoutSpan = c),
        !u && !l
          ? !1
          : this.focusService.focusHeaderPosition({
              headerPosition: { headerRowIndex: a, column: l },
              allowUserOverride: !0,
              event: i,
            })
      )
    }
    setCurrentHeaderRowWithoutSpan(e) {
      this.currentHeaderRowWithoutSpan = e
    }
    navigateHorizontally(e, t = !1, i) {
      const s = this.focusService.getFocusedHeader(),
        n = e === 2,
        r = this.gos.get('enableRtl')
      let o, a
      if (
        (this.currentHeaderRowWithoutSpan !== -1
          ? (s.headerRowIndex = this.currentHeaderRowWithoutSpan)
          : (this.currentHeaderRowWithoutSpan = s.headerRowIndex),
        n !== r
          ? ((a = 'Before'), (o = this.headerPositionUtils.findHeader(s, a)))
          : ((a = 'After'), (o = this.headerPositionUtils.findHeader(s, a))),
        o || !t)
      )
        return this.focusService.focusHeaderPosition({
          headerPosition: o,
          direction: a,
          fromTab: t,
          allowUserOverride: !0,
          event: i,
        })
      if (t) {
        const l = this.gos.getCallback('tabToNextHeader')
        if (l)
          return this.focusService.focusHeaderPositionFromUserFunc({
            userFunc: l,
            headerPosition: o,
            direction: a,
          })
      }
      return this.focusNextHeaderRow(s, a, i)
    }
    focusNextHeaderRow(e, t, i) {
      const s = e.headerRowIndex
      let n = null,
        r
      if (
        (t === 'Before'
          ? s > 0 &&
            ((r = s - 1),
            (this.currentHeaderRowWithoutSpan -= 1),
            (n = this.headerPositionUtils.findColAtEdgeForHeaderRow(r, 'end')))
          : ((r = s + 1),
            this.currentHeaderRowWithoutSpan < this.getHeaderRowCount()
              ? (this.currentHeaderRowWithoutSpan += 1)
              : this.setCurrentHeaderRowWithoutSpan(-1),
            (n = this.headerPositionUtils.findColAtEdgeForHeaderRow(
              r,
              'start',
            ))),
        !n)
      )
        return !1
      const { column: o, headerRowIndex: a } =
        this.headerPositionUtils.getHeaderIndexToFocus(
          n.column,
          n == null ? void 0 : n.headerRowIndex,
        )
      return this.focusService.focusHeaderPosition({
        headerPosition: { column: o, headerRowIndex: a },
        direction: t,
        fromTab: !0,
        allowUserOverride: !0,
        event: i,
      })
    }
    scrollToColumn(e, t = 'After') {
      if (e.getPinned()) return
      let i
      if (_t(e)) {
        const s = e.getDisplayedLeafColumns()
        i = t === 'Before' ? rt(s) : s[0]
      } else i = e
      this.gridBodyCon.getScrollFeature().ensureColumnVisible(i)
    }
  },
  MI = class extends X {
    wireBeans(e) {
      ;(this.animationFrameService = e.animationFrameService),
        (this.headerNavigationService = e.headerNavigationService),
        (this.focusService = e.focusService),
        (this.columnModel = e.columnModel),
        (this.visibleColsService = e.visibleColsService),
        (this.ctrlsService = e.ctrlsService),
        (this.filterManager = e.filterManager),
        (this.menuService = e.menuService)
    }
    setComp(e, t, i) {
      ;(this.comp = e),
        (this.eGui = t),
        this.createManagedBean(
          new jn(i, {
            onTabKeyDown: this.onTabKeyDown.bind(this),
            handleKeyDown: this.handleKeyDown.bind(this),
            onFocusOut: this.onFocusOut.bind(this),
          }),
        ),
        this.addManagedEventListeners({
          columnPivotModeChanged: this.onPivotModeChanged.bind(this),
          displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
        }),
        this.onPivotModeChanged(),
        this.setupHeaderHeight()
      const s = this.onHeaderContextMenu.bind(this)
      this.addManagedElementListeners(this.eGui, { contextmenu: s }),
        this.mockContextMenuForIPad(s),
        this.ctrlsService.register('gridHeaderCtrl', this)
    }
    setupHeaderHeight() {
      const e = this.setHeaderHeight.bind(this)
      e(),
        this.addManagedPropertyListeners(
          [
            'headerHeight',
            'pivotHeaderHeight',
            'groupHeaderHeight',
            'pivotGroupHeaderHeight',
            'floatingFiltersHeight',
          ],
          e,
        ),
        this.addManagedEventListeners({
          displayedColumnsChanged: e,
          columnHeaderHeightChanged: e,
          columnGroupHeaderHeightChanged: () =>
            this.animationFrameService.requestAnimationFrame(() => e()),
          gridStylesChanged: e,
          advancedFilterEnabledChanged: e,
        })
    }
    getHeaderHeight() {
      return this.headerHeight
    }
    setHeaderHeight() {
      var r
      const { columnModel: e } = this
      let t = 0
      const i = this.columnModel
          .getGroupRowsHeight()
          .reduce((o, a) => o + a, 0),
        s = this.columnModel.getColumnHeaderRowHeight()
      if (
        ((r = this.filterManager) != null &&
          r.hasFloatingFilters() &&
          (t += e.getFloatingFiltersHeight()),
        (t += i),
        (t += s),
        this.headerHeight === t)
      )
        return
      this.headerHeight = t
      const n = `${t + 1}px`
      this.comp.setHeightAndMinHeight(n),
        this.eventService.dispatchEvent({ type: 'headerHeightChanged' })
    }
    onPivotModeChanged() {
      const e = this.columnModel.isPivotMode()
      this.comp.addOrRemoveCssClass('ag-pivot-on', e),
        this.comp.addOrRemoveCssClass('ag-pivot-off', !e)
    }
    onDisplayedColumnsChanged() {
      const t = this.visibleColsService
        .getAllCols()
        .some((i) => i.isSpanHeaderHeight())
      this.comp.addOrRemoveCssClass('ag-header-allow-overflow', t)
    }
    onTabKeyDown(e) {
      const t = this.gos.get('enableRtl'),
        i = e.shiftKey,
        s = i !== t ? 2 : 3
      ;(this.headerNavigationService.navigateHorizontally(s, !0, e) ||
        (!i && this.focusService.focusOverlay(!1)) ||
        this.focusService.focusNextGridCoreContainer(i, !0)) &&
        e.preventDefault()
    }
    handleKeyDown(e) {
      let t = null
      switch (e.key) {
        case Y.LEFT:
          t = 2
        case Y.RIGHT: {
          ue(t) || (t = 3),
            this.headerNavigationService.navigateHorizontally(t, !1, e) &&
              e.preventDefault()
          break
        }
        case Y.UP:
          t = 0
        case Y.DOWN: {
          ue(t) || (t = 1),
            this.headerNavigationService.navigateVertically(t, null, e) &&
              e.preventDefault()
          break
        }
        default:
          return
      }
    }
    onFocusOut(e) {
      const { relatedTarget: t } = e
      ;(!t && this.eGui.contains(Lt(this.gos))) ||
        this.eGui.contains(t) ||
        this.focusService.clearFocusedHeader()
    }
    onHeaderContextMenu(e, t, i) {
      var n
      if ((!e && !i) || !this.menuService.isHeaderContextMenuEnabled()) return
      const { target: s } = e ?? t
      ;(s === this.eGui ||
        s ===
          ((n = this.ctrlsService.getHeaderRowContainerCtrl()) == null
            ? void 0
            : n.getViewportElement())) &&
        this.menuService.showHeaderContextMenu(void 0, e, i)
    }
    mockContextMenuForIPad(e) {
      if (!fn()) return
      const t = new on(this.eGui),
        i = (s) => {
          e(void 0, s.touchStart, s.touchEvent)
        }
      this.addManagedListeners(t, { longTap: i }),
        this.addDestroyFunc(() => t.destroy())
    }
  },
  Fd = class extends X {
    constructor(e, t = !1) {
      super(), (this.callback = e), (this.addSpacer = t)
    }
    wireBeans(e) {
      ;(this.visibleColsService = e.visibleColsService),
        (this.scrollVisibleService = e.scrollVisibleService)
    }
    postConstruct() {
      const e = this.setWidth.bind(this)
      this.addManagedPropertyListener('domLayout', e),
        this.addManagedEventListeners({
          columnContainerWidthChanged: e,
          displayedColumnsChanged: e,
          leftPinnedWidthChanged: e,
        }),
        this.addSpacer &&
          this.addManagedEventListeners({
            rightPinnedWidthChanged: e,
            scrollVisibilityChanged: e,
            scrollbarWidthChanged: e,
          }),
        this.setWidth()
    }
    setWidth() {
      const e = ci(this.gos, 'print'),
        t = this.visibleColsService.getBodyContainerWidth(),
        i = this.visibleColsService.getColsLeftWidth(),
        s = this.visibleColsService.getDisplayedColumnsRightWidth()
      let n
      e
        ? (n = t + i + s)
        : ((n = t),
          this.addSpacer &&
            (this.gos.get('enableRtl') ? i : s) === 0 &&
            this.scrollVisibleService.isVerticalScrollShowing() &&
            (n += this.scrollVisibleService.getScrollbarWidth())),
        this.callback(n)
    }
  },
  II = class extends X {
    constructor(e) {
      super(),
        (this.columnsToAggregate = []),
        (this.columnsToGroup = []),
        (this.columnsToPivot = []),
        (this.pinned = e)
    }
    wireBeans(e) {
      this.funcColsService = e.funcColsService
    }
    onDragEnter(e) {
      if ((this.clearColumnsList(), this.gos.get('functionsReadOnly'))) return
      const t = e.dragItem.columns
      t &&
        t.forEach((i) => {
          i.isPrimary() &&
            (i.isAnyFunctionActive() ||
              (i.isAllowValue()
                ? this.columnsToAggregate.push(i)
                : i.isAllowRowGroup()
                  ? this.columnsToGroup.push(i)
                  : i.isAllowPivot() && this.columnsToPivot.push(i)))
        })
    }
    getIconName() {
      return this.columnsToAggregate.length +
        this.columnsToGroup.length +
        this.columnsToPivot.length >
        0
        ? this.pinned
          ? 'pinned'
          : 'move'
        : null
    }
    onDragLeave(e) {
      this.clearColumnsList()
    }
    clearColumnsList() {
      ;(this.columnsToAggregate.length = 0),
        (this.columnsToGroup.length = 0),
        (this.columnsToPivot.length = 0)
    }
    onDragging(e) {}
    onDragStop(e) {
      this.columnsToAggregate.length > 0 &&
        this.funcColsService.addValueColumns(
          this.columnsToAggregate,
          'toolPanelDragAndDrop',
        ),
        this.columnsToGroup.length > 0 &&
          this.funcColsService.addRowGroupColumns(
            this.columnsToGroup,
            'toolPanelDragAndDrop',
          ),
        this.columnsToPivot.length > 0 &&
          this.funcColsService.addPivotColumns(
            this.columnsToPivot,
            'toolPanelDragAndDrop',
          )
    }
    onDragCancel() {
      this.clearColumnsList()
    }
  }
function Ov(e) {
  const {
    isFromHeader: t,
    fromLeft: i,
    xPosition: s,
    fromEnter: n,
    fakeEvent: r,
    pinned: o,
    gos: a,
    columnModel: l,
    columnMoveService: c,
    visibleColsService: u,
  } = e
  let { allMovingColumns: h } = e
  if (t) {
    const F = []
    h.forEach((R) => {
      var D
      let b = null,
        x = R.getParent()
      for (; x != null && x.getDisplayedLeafColumns().length === 1; )
        (b = x), (x = x.getParent())
      b != null
        ? (!!((D = b.getColGroupDef()) != null && D.marryChildren)
            ? b.getProvidedColumnGroup().getLeafColumns()
            : b.getLeafColumns()
          ).forEach((L) => {
            F.includes(L) || F.push(L)
          })
        : F.includes(R) || F.push(R)
    }),
      (h = F)
  }
  const g = h.slice()
  l.sortColsLikeCols(g)
  const f = LI({
      movingCols: g,
      draggingRight: i,
      xPosition: s,
      pinned: o,
      gos: a,
      columnModel: l,
      visibleColsService: u,
    }),
    p = TI(g, l)
  if (f.length === 0) return
  const v = f[0]
  let m = p !== null && !n
  if ((t && (m = p !== null), m && !r && ((!i && v >= p) || (i && v <= p))))
    return
  const C = u.getAllCols(),
    w = []
  let S = null
  for (let F = 0; F < f.length; F++) {
    const R = f[F],
      b = c.getProposedColumnOrder(g, R)
    if (!c.doesOrderPassRules(b)) continue
    const x = b.filter((O) => C.includes(O))
    if (S === null) S = x
    else if (!gn(x, S)) break
    const D = AI(b)
    w.push({ move: R, fragCount: D })
  }
  if (w.length === 0) return
  w.sort((F, R) => F.fragCount - R.fragCount)
  const y = w[0].move
  if (!(y > l.getCols().length - h.length)) return { columns: h, toIndex: y }
}
function Ed(e) {
  const { columns: t, toIndex: i } = Ov(e) || {},
    { finished: s, columnMoveService: n } = e
  return !t || i == null
    ? null
    : (n.moveColumns(t, i, 'uiColumnMoved', s),
      s ? null : { columns: t, toIndex: i })
}
function TI(e, t) {
  const i = t.getCols(),
    s = yx(e.map((l) => i.indexOf(l))),
    n = s[0]
  return rt(s) - n !== s.length - 1 ? null : n
}
function AI(e) {
  function t(s) {
    const n = []
    let r = s.getOriginalParent()
    for (; r != null; ) n.push(r), (r = r.getOriginalParent())
    return n
  }
  let i = 0
  for (let s = 0; s < e.length - 1; s++) {
    let n = t(e[s]),
      r = t(e[s + 1])
    ;([n, r] = n.length > r.length ? [n, r] : [r, n]),
      n.forEach((o) => {
        r.indexOf(o) === -1 && i++
      })
  }
  return i
}
function OI(e, t) {
  switch (t) {
    case 'left':
      return e.getLeftCols()
    case 'right':
      return e.getRightCols()
    default:
      return e.getCenterCols()
  }
}
function LI(e) {
  const {
    movingCols: t,
    draggingRight: i,
    xPosition: s,
    pinned: n,
    gos: r,
    columnModel: o,
    visibleColsService: a,
  } = e
  if (
    r.get('suppressMovableColumns') ||
    t.some((S) => S.getColDef().suppressMovable)
  )
    return []
  const c = OI(a, n),
    u = o.getCols(),
    h = c.filter((S) => Tn(t, S)),
    g = c.filter((S) => !Tn(t, S)),
    f = u.filter((S) => !Tn(t, S))
  let p = 0,
    v = s
  if (i) {
    let S = 0
    h.forEach((y) => (S += y.getActualWidth())), (v -= S)
  }
  if (v > 0) {
    for (let S = 0; S < g.length; S++) {
      const y = g[S]
      if (((v -= y.getActualWidth()), v < 0)) break
      p++
    }
    i && p++
  }
  let m
  if (p > 0) {
    const S = g[p - 1]
    m = f.indexOf(S) + 1
  } else (m = f.indexOf(g[0])), m === -1 && (m = 0)
  const C = [m],
    w = (S, y) => S - y
  if (i) {
    let S = m + 1
    const y = u.length - 1
    for (; S <= y; ) C.push(S), S++
    C.sort(w)
  } else {
    let S = m
    const y = u.length - 1
    let F = u[S]
    for (; S <= y && c.indexOf(F) < 0; ) S++, C.push(S), (F = u[S])
    S = m - 1
    const R = 0
    for (; S >= R; ) C.push(S), S--
    C.sort(w).reverse()
  }
  return C
}
function $a(e) {
  var c
  const {
    pinned: t,
    fromKeyboard: i,
    gos: s,
    ctrlsService: n,
    useHeaderRow: r,
    skipScrollPadding: o,
  } = e
  let a =
      (c = n.getHeaderRowContainerCtrl(t)) == null
        ? void 0
        : c.getViewportElement(),
    { x: l } = e
  return a
    ? (i && (l -= a.getBoundingClientRect().left),
      s.get('enableRtl') &&
        (r && (a = a.querySelector('.ag-header-row')), (l = a.clientWidth - l)),
      t == null && !o && (l += n.get('center').getCenterViewportScrollLeft()),
      l)
    : 0
}
function lr(e, t) {
  for (const i of e) i.setMoving(t, 'uiColumnMoved')
}
var Pg = 7,
  ru = 100,
  ea = ru / 2,
  kI = 5,
  HI = 100,
  NI = class extends X {
    constructor(e) {
      super(),
        (this.needToMoveLeft = !1),
        (this.needToMoveRight = !1),
        (this.lastMovedInfo = null),
        (this.pinned = e),
        (this.isCenterContainer = !ue(e))
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.visibleColsService = e.visibleColsService),
        (this.columnMoveService = e.columnMoveService),
        (this.dragAndDropService = e.dragAndDropService),
        (this.ctrlsService = e.ctrlsService)
    }
    postConstruct() {
      this.ctrlsService.whenReady(this, (e) => {
        this.gridBodyCon = e.gridBodyCtrl
      })
    }
    getIconName() {
      var t
      const e =
        ((t = this.lastDraggingEvent) == null ? void 0 : t.dragItem.columns) ??
        []
      for (const i of e) {
        const s = i.getPinned()
        if (i.getColDef().lockPinned) {
          if (s == this.pinned) return 'move'
          continue
        }
        if (s === this.pinned || !this.pinned) return 'move'
        if (!s && this.pinned) return 'pinned'
      }
      return 'notAllowed'
    }
    onDragEnter(e) {
      const t = e.dragItem.columns
      if (e.dragSource.type === 0)
        this.setColumnsVisible(t, !0, 'uiColumnDragged')
      else {
        const s = e.dragItem.visibleState,
          n = (t || []).filter((r) => s[r.getId()])
        this.setColumnsVisible(n, !0, 'uiColumnDragged')
      }
      this.gos.get('suppressMoveWhenColumnDragging') ||
        this.attemptToPinColumns(t, this.pinned),
        this.onDragging(e, !0, !0)
    }
    onDragging(e = this.lastDraggingEvent, t = !1, i = !1, s = !1) {
      const n = this.gos.get('suppressMoveWhenColumnDragging')
      if (s && !n) {
        this.finishColumnMoving()
        return
      }
      if (((this.lastDraggingEvent = e), !e || (!s && ot(e.hDirection)))) return
      const { pinned: r, gos: o, ctrlsService: a } = this,
        l = $a({ x: e.x, pinned: r, gos: o, ctrlsService: a })
      t || this.checkCenterForScrolling(l),
        n
          ? this.handleColumnDragWhileSuppressingMovement(e, t, i, l, s)
          : this.handleColumnDragWhileAllowingMovement(e, t, i, l, s)
    }
    onDragLeave() {
      this.ensureIntervalCleared(),
        this.clearHighlighted(),
        (this.lastMovedInfo = null)
    }
    onDragStop() {
      this.onDragging(this.lastDraggingEvent, !1, !0, !0),
        this.ensureIntervalCleared(),
        (this.lastMovedInfo = null)
    }
    onDragCancel() {
      this.clearHighlighted(),
        this.ensureIntervalCleared(),
        (this.lastMovedInfo = null)
    }
    setColumnsVisible(e, t, i) {
      if (!e) return
      const s = e.filter((n) => !n.getColDef().lockVisible)
      this.columnModel.setColsVisible(s, t, i)
    }
    finishColumnMoving() {
      if ((this.clearHighlighted(), !this.lastMovedInfo)) return
      const { columns: e, toIndex: t } = this.lastMovedInfo
      this.columnMoveService.moveColumns(e, t, 'uiColumnMoved', !0)
    }
    handleColumnDragWhileSuppressingMovement(e, t, i, s, n) {
      const r = this.getAllMovingColumns(e, !0)
      if (n) {
        const o = this.isAttemptingToPin(r)
        o && this.attemptToPinColumns(r, void 0, !0)
        const { fromLeft: a, xPosition: l } =
          this.getNormalisedXPositionInfo(r, o) || {}
        if (a == null || l == null) {
          this.finishColumnMoving()
          return
        }
        this.moveColumnsAfterHighlight({
          allMovingColumns: r,
          xPosition: l,
          fromEnter: t,
          fakeEvent: i,
          fromLeft: a,
        })
      } else {
        if (!this.dragAndDropService.isDropZoneWithinThisGrid(e)) return
        this.highlightHoveredColumn(r, s)
      }
    }
    handleColumnDragWhileAllowingMovement(e, t, i, s, n) {
      const r = this.getAllMovingColumns(e),
        o = this.normaliseDirection(e.hDirection) === 1,
        a = e.dragSource.type === 1,
        l = this.getMoveColumnParams({
          allMovingColumns: r,
          isFromHeader: a,
          xPosition: s,
          fromLeft: o,
          fromEnter: t,
          fakeEvent: i,
        }),
        c = Ed({ ...l, finished: n })
      c && (this.lastMovedInfo = c)
    }
    getAllMovingColumns(e, t = !1) {
      const i = e.dragSource.getDragItem()
      let s = null
      t ? ((s = i.columnsInSplit), s || (s = i.columns)) : (s = i.columns)
      const n = (r) =>
        r.getColDef().lockPinned ? r.getPinned() == this.pinned : !0
      return s ? s.filter(n) : []
    }
    getMoveColumnParams(e) {
      const {
          allMovingColumns: t,
          isFromHeader: i,
          xPosition: s,
          fromLeft: n,
          fromEnter: r,
          fakeEvent: o,
        } = e,
        {
          pinned: a,
          gos: l,
          columnModel: c,
          columnMoveService: u,
          visibleColsService: h,
        } = this
      return {
        allMovingColumns: t,
        isFromHeader: i,
        fromLeft: n,
        xPosition: s,
        pinned: a,
        fromEnter: r,
        fakeEvent: o,
        gos: l,
        columnModel: c,
        columnMoveService: u,
        visibleColsService: h,
      }
    }
    findFirstAndLastMovingColumns(e) {
      const t = e.length
      let i, s
      for (let n = 0; n <= t; n++) {
        if (!i) {
          const r = e[n]
          r.getLeft() != null && (i = r)
        }
        if (!s) {
          const r = e[t - 1 - n]
          r.getLeft() != null && (s = r)
        }
        if (i && s) break
      }
      return { firstMovingCol: i, lastMovingCol: s }
    }
    highlightHoveredColumn(e, t) {
      var u
      const { gos: i, columnModel: s } = this,
        n = i.get('enableRtl'),
        r = s
          .getCols()
          .filter((h) => h.isVisible() && h.getPinned() === this.pinned)
      let o = null,
        a = null,
        l = null
      for (const h of r) {
        if (
          ((a = h.getActualWidth()),
          (o = this.getNormalisedColumnLeft(h, 0, n)),
          o != null)
        ) {
          const g = o + a
          if (o <= t && g >= t) {
            l = h
            break
          }
        }
        ;(o = null), (a = null)
      }
      if (l) e.indexOf(l) !== -1 && (l = null)
      else {
        for (let h = r.length - 1; h >= 0; h--) {
          const g = r[h],
            f = r[h].getParent()
          if (!f) {
            l = g
            break
          }
          const p = f == null ? void 0 : f.getDisplayedLeafColumns()
          if (p.length) {
            l = rt(p)
            break
          }
        }
        if (!l) return
        ;(o = this.getNormalisedColumnLeft(l, 0, n)), (a = l.getActualWidth())
      }
      if (
        (((u = this.lastHighlightedColumn) == null ? void 0 : u.column) !== l &&
          this.clearHighlighted(),
        l == null || o == null || a == null)
      )
        return
      let c
      t - o < a / 2 !== n ? (c = 0) : (c = 1),
        l.setHighlighted(c),
        (this.lastHighlightedColumn = { column: l, position: c })
    }
    getNormalisedXPositionInfo(e, t) {
      const { gos: i, visibleColsService: s } = this,
        n = i.get('enableRtl'),
        {
          firstMovingCol: r,
          column: o,
          position: a,
        } = this.getColumnMoveAndTargetInfo(e, t, n)
      if (!r || !o || a == null) return
      const l = s.getAllCols(),
        c = l.indexOf(r),
        u = l.indexOf(o),
        h = (a === 0) !== n,
        g = c < u || (c === u && !h)
      let f = 0
      if ((h ? g && (f -= 1) : g || (f += 1), u + f === c)) return
      const p = l[u + f]
      if (!p) return
      const v = this.getNormalisedColumnLeft(p, 20, n)
      return { fromLeft: g, xPosition: v }
    }
    getColumnMoveAndTargetInfo(e, t, i) {
      const s = this.lastHighlightedColumn || {},
        { firstMovingCol: n, lastMovingCol: r } =
          this.findFirstAndLastMovingColumns(e)
      if (!n || !r || s.column || !t) return { firstMovingCol: n, ...s }
      const a = this.getPinDirection() === 'left'
      return { firstMovingCol: n, position: a ? 1 : 0, column: a !== i ? n : r }
    }
    normaliseDirection(e) {
      if (this.gos.get('enableRtl'))
        switch (e) {
          case 0:
            return 1
          case 1:
            return 0
        }
      return e
    }
    getNormalisedColumnLeft(e, t, i) {
      const { gos: s, ctrlsService: n } = this,
        r = e.getLeft()
      if (r == null) return null
      const o = e.getActualWidth()
      return $a({
        x: i ? r + o - t : r + t,
        pinned: e.getPinned(),
        useHeaderRow: i,
        skipScrollPadding: !0,
        gos: s,
        ctrlsService: n,
      })
    }
    isAttemptingToPin(e) {
      const t = this.needToMoveLeft || this.needToMoveRight,
        i = this.failedMoveAttempts > Pg
      return (t && i) || e.some((s) => s.getPinned() !== this.pinned)
    }
    moveColumnsAfterHighlight(e) {
      const {
          allMovingColumns: t,
          xPosition: i,
          fromEnter: s,
          fakeEvent: n,
          fromLeft: r,
        } = e,
        o = this.getMoveColumnParams({
          allMovingColumns: t,
          isFromHeader: !0,
          xPosition: i,
          fromLeft: r,
          fromEnter: s,
          fakeEvent: n,
        }),
        { columns: a, toIndex: l } = Ov(o) || {}
      a && l != null && (this.lastMovedInfo = { columns: a, toIndex: l }),
        this.finishColumnMoving()
    }
    clearHighlighted() {
      this.lastHighlightedColumn &&
        (this.lastHighlightedColumn.column.setHighlighted(null),
        (this.lastHighlightedColumn = null))
    }
    checkCenterForScrolling(e) {
      if (!this.isCenterContainer) return
      const t = this.ctrlsService.get('center'),
        i = t.getCenterViewportScrollLeft(),
        s = i + t.getCenterWidth()
      this.gos.get('enableRtl')
        ? ((this.needToMoveRight = e < i + ea),
          (this.needToMoveLeft = e > s - ea))
        : ((this.needToMoveLeft = e < i + ea),
          (this.needToMoveRight = e > s - ea)),
        this.needToMoveLeft || this.needToMoveRight
          ? this.ensureIntervalStarted()
          : this.ensureIntervalCleared()
    }
    ensureIntervalStarted() {
      var e
      this.movingIntervalId ||
        ((this.intervalCount = 0),
        (this.failedMoveAttempts = 0),
        (this.movingIntervalId = window.setInterval(
          this.moveInterval.bind(this),
          HI,
        )),
        (e = this.dragAndDropService.getDragAndDropImageComponent()) == null ||
          e.setIcon(this.needToMoveLeft ? 'left' : 'right', !0))
    }
    ensureIntervalCleared() {
      var e
      this.movingIntervalId &&
        (window.clearInterval(this.movingIntervalId),
        (this.movingIntervalId = null),
        (this.failedMoveAttempts = 0),
        (e = this.dragAndDropService.getDragAndDropImageComponent()) == null ||
          e.setIcon(this.getIconName()))
    }
    moveInterval() {
      var s, n
      let e
      this.intervalCount++,
        (e = 10 + this.intervalCount * kI),
        e > ru && (e = ru)
      let t = null
      const i = this.gridBodyCon.getScrollFeature()
      if (
        (this.needToMoveLeft
          ? (t = i.scrollHorizontally(-e))
          : this.needToMoveRight && (t = i.scrollHorizontally(e)),
        t !== 0)
      )
        this.onDragging(this.lastDraggingEvent), (this.failedMoveAttempts = 0)
      else {
        if ((this.failedMoveAttempts++, this.failedMoveAttempts <= Pg + 1))
          return
        if (
          ((s = this.dragAndDropService.getDragAndDropImageComponent()) ==
            null || s.setIcon('pinned'),
          !this.gos.get('suppressMoveWhenColumnDragging'))
        ) {
          const r =
            (n = this.lastDraggingEvent) == null ? void 0 : n.dragItem.columns
          this.attemptToPinColumns(r, void 0, !0)
        }
      }
    }
    getPinDirection() {
      if (this.needToMoveLeft || this.pinned === 'left') return 'left'
      if (this.needToMoveRight || this.pinned === 'right') return 'right'
    }
    attemptToPinColumns(e, t, i = !1) {
      const s = (e || []).filter((n) => !n.getColDef().lockPinned)
      return s.length
        ? (i && (t = this.getPinDirection()),
          this.columnModel.setColsPinned(s, t, 'uiColumnDragged'),
          i && this.dragAndDropService.nudge(),
          s.length)
        : 0
    }
    destroy() {
      super.destroy(),
        (this.lastDraggingEvent = null),
        this.clearHighlighted(),
        (this.lastMovedInfo = null)
    }
  },
  GI = class extends X {
    wireBeans(e) {
      ;(this.dragAndDropService = e.dragAndDropService),
        (this.columnModel = e.columnModel),
        (this.ctrlsService = e.ctrlsService)
    }
    constructor(e, t) {
      super(), (this.pinned = e), (this.eContainer = t)
    }
    postConstruct() {
      this.ctrlsService.whenReady(this, (e) => {
        switch (this.pinned) {
          case 'left':
            this.eSecondaryContainers = [
              [
                e.gridBodyCtrl.getBodyViewportElement(),
                e.left.getContainerElement(),
              ],
              [e.bottomLeft.getContainerElement()],
              [e.topLeft.getContainerElement()],
            ]
            break
          case 'right':
            this.eSecondaryContainers = [
              [
                e.gridBodyCtrl.getBodyViewportElement(),
                e.right.getContainerElement(),
              ],
              [e.bottomRight.getContainerElement()],
              [e.topRight.getContainerElement()],
            ]
            break
          default:
            this.eSecondaryContainers = [
              [
                e.gridBodyCtrl.getBodyViewportElement(),
                e.center.getViewportElement(),
              ],
              [e.bottomCenter.getViewportElement()],
              [e.topCenter.getViewportElement()],
            ]
            break
        }
      }),
        (this.moveColumnFeature = this.createManagedBean(new NI(this.pinned))),
        (this.bodyDropPivotTarget = this.createManagedBean(
          new II(this.pinned),
        )),
        this.dragAndDropService.addDropTarget(this),
        this.addDestroyFunc(() =>
          this.dragAndDropService.removeDropTarget(this),
        )
    }
    isInterestedIn(e) {
      return (
        e === 1 || (e === 0 && this.gos.get('allowDragFromColumnsToolPanel'))
      )
    }
    getSecondaryContainers() {
      return this.eSecondaryContainers
    }
    getContainer() {
      return this.eContainer
    }
    getIconName() {
      return this.currentDropListener.getIconName()
    }
    isDropColumnInPivotMode(e) {
      return this.columnModel.isPivotMode() && e.dragSource.type === 0
    }
    onDragEnter(e) {
      ;(this.currentDropListener = this.isDropColumnInPivotMode(e)
        ? this.bodyDropPivotTarget
        : this.moveColumnFeature),
        this.currentDropListener.onDragEnter(e)
    }
    onDragLeave(e) {
      this.currentDropListener.onDragLeave(e)
    }
    onDragging(e) {
      this.currentDropListener.onDragging(e)
    }
    onDragStop(e) {
      this.currentDropListener.onDragStop(e)
    }
    onDragCancel() {
      this.currentDropListener.onDragCancel()
    }
  },
  BI = class extends X {
    wireBeans(e) {
      ;(this.horizontalResizeService = e.horizontalResizeService),
        (this.pinnedWidthService = e.pinnedWidthService),
        (this.ctrlsService = e.ctrlsService),
        (this.columnSizeService = e.columnSizeService),
        (this.columnAutosizeService = e.columnAutosizeService)
    }
    constructor(e, t, i, s, n) {
      super(),
        (this.pinned = e),
        (this.column = t),
        (this.eResize = i),
        (this.comp = s),
        (this.ctrl = n)
    }
    postConstruct() {
      const e = []
      let t, i
      const s = () => {
          if ((Ot(this.eResize, t), !t)) return
          const o = this.horizontalResizeService.addResizeBar({
            eResizeBar: this.eResize,
            onResizeStart: this.onResizeStart.bind(this),
            onResizing: this.onResizing.bind(this, !1),
            onResizeEnd: this.onResizing.bind(this, !0),
          })
          if ((e.push(o), i)) {
            const a = this.gos.get('skipHeaderOnAutoSize'),
              l = () => {
                this.columnAutosizeService.autoSizeColumn(
                  this.column,
                  'uiColumnResized',
                  a,
                )
              }
            this.eResize.addEventListener('dblclick', l)
            const c = new on(this.eResize)
            c.addEventListener('doubleTap', l),
              e.push(() => {
                this.eResize.removeEventListener('dblclick', l),
                  c.removeEventListener('doubleTap', l),
                  c.destroy()
              })
          }
        },
        n = () => {
          e.forEach((o) => o()), (e.length = 0)
        },
        r = () => {
          const o = this.column.isResizable(),
            a =
              !this.gos.get('suppressAutoSize') &&
              !this.column.getColDef().suppressAutoSize
          ;(o !== t || a !== i) && ((t = o), (i = a), n(), s())
        }
      r(), this.addDestroyFunc(n), this.ctrl.setRefreshFunction('resize', r)
    }
    onResizing(e, t) {
      const { column: i, lastResizeAmount: s, resizeStartWidth: n } = this,
        r = this.normaliseResizeAmount(t),
        o = n + r,
        a = [{ key: i, newWidth: o }]
      if (this.column.getPinned()) {
        const l = this.pinnedWidthService.getPinnedLeftWidth(),
          c = this.pinnedWidthService.getPinnedRightWidth(),
          u =
            No(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) -
            50
        if (l + c + (r - s) > u) return
      }
      ;(this.lastResizeAmount = r),
        this.columnSizeService.setColumnWidths(
          a,
          this.resizeWithShiftKey,
          e,
          'uiColumnResized',
        ),
        e && this.toggleColumnResizing(!1)
    }
    onResizeStart(e) {
      ;(this.resizeStartWidth = this.column.getActualWidth()),
        (this.lastResizeAmount = 0),
        (this.resizeWithShiftKey = e),
        this.toggleColumnResizing(!0)
    }
    toggleColumnResizing(e) {
      this.comp.addOrRemoveCssClass('ag-column-resizing', e)
    }
    normaliseResizeAmount(e) {
      let t = e
      const i = this.pinned !== 'left',
        s = this.pinned === 'right'
      return this.gos.get('enableRtl') ? i && (t *= -1) : s && (t *= -1), t
    }
  },
  VI = class extends X {
    constructor(e) {
      super(),
        (this.cbSelectAllVisible = !1),
        (this.processingEventFromCheckbox = !1),
        (this.column = e)
    }
    wireBeans(e) {
      ;(this.rowModel = e.rowModel),
        (this.selectionService = e.selectionService)
    }
    onSpaceKeyDown(e) {
      const t = this.cbSelectAll
      t.isDisplayed() &&
        !t.getGui().contains(Lt(this.gos)) &&
        (e.preventDefault(), t.setValue(!t.getValue()))
    }
    getCheckboxGui() {
      return this.cbSelectAll.getGui()
    }
    setComp(e) {
      ;(this.headerCellCtrl = e),
        (this.cbSelectAll = this.createManagedBean(new gd())),
        this.cbSelectAll.addCssClass('ag-header-select-all'),
        es(this.cbSelectAll.getGui(), 'presentation'),
        this.showOrHideSelectAll(),
        this.addManagedEventListeners({
          newColumnsLoaded: this.onNewColumnsLoaded.bind(this),
          displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
          selectionChanged: this.onSelectionChanged.bind(this),
          paginationChanged: this.onSelectionChanged.bind(this),
          modelUpdated: this.onModelChanged.bind(this),
        }),
        this.addManagedListeners(this.cbSelectAll, {
          fieldValueChanged: this.onCbSelectAll.bind(this),
        }),
        this.cbSelectAll.getInputElement().setAttribute('tabindex', '-1'),
        this.refreshSelectAllLabel()
    }
    onNewColumnsLoaded() {
      this.showOrHideSelectAll()
    }
    onDisplayedColumnsChanged() {
      this.isAlive() && this.showOrHideSelectAll()
    }
    showOrHideSelectAll() {
      ;(this.cbSelectAllVisible = this.isCheckboxSelection()),
        this.cbSelectAll.setDisplayed(this.cbSelectAllVisible),
        this.cbSelectAllVisible &&
          (this.checkRightRowModelType('selectAllCheckbox'),
          this.checkSelectionType('selectAllCheckbox'),
          this.updateStateOfCheckbox()),
        this.refreshSelectAllLabel()
    }
    onModelChanged() {
      this.cbSelectAllVisible && this.updateStateOfCheckbox()
    }
    onSelectionChanged() {
      this.cbSelectAllVisible && this.updateStateOfCheckbox()
    }
    updateStateOfCheckbox() {
      if (this.processingEventFromCheckbox) return
      this.processingEventFromCheckbox = !0
      const e = this.selectionService.getSelectAllState(
        this.isFilteredOnly(),
        this.isCurrentPageOnly(),
      )
      this.cbSelectAll.setValue(e)
      const t = this.selectionService.hasNodesToSelect(
        this.isFilteredOnly(),
        this.isCurrentPageOnly(),
      )
      this.cbSelectAll.setDisabled(!t),
        this.refreshSelectAllLabel(),
        (this.processingEventFromCheckbox = !1)
    }
    refreshSelectAllLabel() {
      const e = this.localeService.getLocaleTextFunc(),
        i = this.cbSelectAll.getValue()
          ? e('ariaChecked', 'checked')
          : e('ariaUnchecked', 'unchecked'),
        s = e('ariaRowSelectAll', 'Press Space to toggle all rows selection')
      this.cbSelectAllVisible
        ? this.headerCellCtrl.setAriaDescriptionProperty(
            'selectAll',
            `${s} (${i})`,
          )
        : this.headerCellCtrl.setAriaDescriptionProperty('selectAll', null),
        this.cbSelectAll.setInputAriaLabel(
          e('ariaHeaderSelection', 'Column with Header Selection'),
        ),
        this.headerCellCtrl.announceAriaDescription()
    }
    checkSelectionType(e) {
      return Fm(this.gos)
        ? !0
        : (te(`${e} is only available if using 'multiRow' selection mode.`), !1)
    }
    checkRightRowModelType(e) {
      return Pt(this.gos) || ms(this.gos)
        ? !0
        : (te(
            `${e} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${this.rowModel.getType()}.`,
          ),
          !1)
    }
    onCbSelectAll() {
      if (this.processingEventFromCheckbox || !this.cbSelectAllVisible) return
      const e = this.cbSelectAll.getValue(),
        t = this.isFilteredOnly(),
        i = this.isCurrentPageOnly()
      let s = 'uiSelectAll'
      i ? (s = 'uiSelectAllCurrentPage') : t && (s = 'uiSelectAllFiltered')
      const n = { source: s, justFiltered: t, justCurrentPage: i }
      e
        ? this.selectionService.selectAllRowNodes(n)
        : this.selectionService.deselectAllRowNodes(n)
    }
    isCheckboxSelection() {
      const e = this.gos.get('rowSelection'),
        t = typeof e == 'object' && Aa(e) && Lo(this.column),
        i = this.column.getColDef().headerCheckboxSelection
      let s = !1
      return (
        t
          ? (s = !0)
          : typeof i == 'function'
            ? (s = i(
                this.gos.addGridCommonParams({
                  column: this.column,
                  colDef: this.column.getColDef(),
                }),
              ))
            : (s = !!i),
        s &&
          this.checkRightRowModelType(
            t ? 'headerCheckbox' : 'headerCheckboxSelection',
          ) &&
          this.checkSelectionType(
            t ? 'headerCheckbox' : 'headerCheckboxSelection',
          )
      )
    }
    isFilteredOnly() {
      const e = this.gos.get('rowSelection')
      return typeof e == 'object'
        ? e.mode === 'multiRow' && e.selectAll === 'filtered'
        : !!this.column.getColDef().headerCheckboxSelectionFilteredOnly
    }
    isCurrentPageOnly() {
      const e = this.gos.get('rowSelection')
      return typeof e == 'object'
        ? e.mode === 'multiRow' && e.selectAll === 'currentPage'
        : !!this.column.getColDef().headerCheckboxSelectionCurrentPageOnly
    }
  },
  _I = class extends Sl {
    constructor(e, t, i) {
      super(e, t, i),
        (this.refreshFunctions = {}),
        (this.userHeaderClasses = new Set()),
        (this.ariaDescriptionProperties = new Map()),
        (this.column = e)
    }
    setComp(e, t, i, s, n) {
      ;(this.comp = e),
        (n = ko(this, this.beans.context, n)),
        this.setGui(t, n),
        this.updateState(),
        this.setupWidth(n),
        this.setupMovingCss(n),
        this.setupMenuClass(n),
        this.setupSortableClass(n),
        this.setupWrapTextClass(),
        this.refreshSpanHeaderHeight(),
        this.setupAutoHeight({
          wrapperElement: s,
          checkMeasuringCallback: (o) =>
            this.setRefreshFunction('measuring', o),
          compBean: n,
        }),
        this.addColumnHoverListener(n),
        this.setupFilterClass(n),
        this.setupClassesFromColDef(),
        this.setupTooltip(n),
        this.addActiveHeaderMouseListeners(n),
        this.setupSelectAll(n),
        this.setupUserComp(n),
        this.refreshAria(),
        (this.resizeFeature = n.createManagedBean(
          new BI(this.getPinned(), this.column, i, e, this),
        )),
        n.createManagedBean(new yd([this.column], t)),
        n.createManagedBean(new wd(this.column, t, this.beans)),
        n.createManagedBean(
          new jn(t, {
            shouldStopEventPropagation: (o) =>
              this.shouldStopEventPropagation(o),
            onTabKeyDown: () => null,
            handleKeyDown: this.handleKeyDown.bind(this),
            onFocusIn: this.onFocusIn.bind(this),
            onFocusOut: this.onFocusOut.bind(this),
          }),
        ),
        this.addResizeAndMoveKeyboardListeners(n),
        n.addManagedPropertyListeners(
          [
            'suppressMovableColumns',
            'suppressMenuHide',
            'suppressAggFuncInHeader',
          ],
          () => this.refresh(n),
        ),
        n.addManagedListeners(this.column, {
          colDefChanged: () => this.refresh(n),
        }),
        n.addManagedListeners(this.column, {
          headerHighlightChanged: this.onHeaderHighlightChanged.bind(this),
        })
      const r = () => this.checkDisplayName(n)
      n.addManagedEventListeners({
        columnValueChanged: r,
        columnRowGroupChanged: r,
        columnPivotChanged: r,
        headerHeightChanged: this.onHeaderHeightChanged.bind(this),
      }),
        n.addDestroyFunc(() => {
          ;(this.refreshFunctions = {}),
            (this.selectAllFeature = null),
            (this.dragSourceElement = void 0),
            (this.userCompDetails = null),
            this.userHeaderClasses.clear(),
            this.ariaDescriptionProperties.clear(),
            this.clearComponent()
        })
    }
    resizeHeader(e, t) {
      if (!this.column.isResizable()) return
      const i = this.column.getActualWidth(),
        s = this.column.getMinWidth(),
        n = this.column.getMaxWidth(),
        r = Math.min(Math.max(i + e, s), n)
      this.beans.columnSizeService.setColumnWidths(
        [{ key: this.column, newWidth: r }],
        t,
        !0,
        'uiColumnResized',
      )
    }
    moveHeader(e) {
      const { eGui: t, beans: i, column: s, ctrlsService: n } = this,
        {
          gos: r,
          columnModel: o,
          columnMoveService: a,
          visibleColsService: l,
        } = i,
        c = this.getPinned(),
        u = t.getBoundingClientRect().left,
        h = s.getActualWidth(),
        g = r.get('enableRtl'),
        p = $a({
          x: (e === 0) !== g ? u - 20 : u + h + 20,
          pinned: c,
          fromKeyboard: !0,
          gos: r,
          ctrlsService: n,
        }),
        v = this.focusService.getFocusedHeader()
      Ed({
        allMovingColumns: [s],
        isFromHeader: !0,
        fromLeft: e === 1,
        xPosition: p,
        pinned: c,
        fromEnter: !1,
        fakeEvent: !1,
        gos: r,
        columnModel: o,
        columnMoveService: a,
        visibleColsService: l,
        finished: !0,
      }),
        n.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(s, 'auto'),
        (!this.isAlive() || this.beans.gos.get('ensureDomOrder')) &&
          v &&
          this.restoreFocus(v)
    }
    restoreFocus(e) {
      this.focusService.focusHeaderPosition({
        headerPosition: { ...e, column: this.column },
      })
    }
    setupUserComp(e) {
      const t = this.lookupUserCompDetails(e)
      this.setCompDetails(t)
    }
    setCompDetails(e) {
      ;(this.userCompDetails = e), this.comp.setUserCompDetails(e)
    }
    lookupUserCompDetails(e) {
      const t = this.createParams(e),
        i = this.column.getColDef()
      return this.userComponentFactory.getHeaderCompDetails(i, t)
    }
    createParams(e) {
      return this.gos.addGridCommonParams({
        column: this.column,
        displayName: this.displayName,
        enableSorting: this.column.isSortable(),
        enableMenu: this.menuEnabled,
        enableFilterButton:
          this.openFilterEnabled &&
          this.menuService.isHeaderFilterButtonEnabled(this.column),
        enableFilterIcon:
          !this.openFilterEnabled || this.menuService.isLegacyMenuEnabled(),
        showColumnMenu: (i) => {
          this.menuService.showColumnMenu({
            column: this.column,
            buttonElement: i,
            positionBy: 'button',
          })
        },
        showColumnMenuAfterMouseClick: (i) => {
          this.menuService.showColumnMenu({
            column: this.column,
            mouseEvent: i,
            positionBy: 'mouse',
          })
        },
        showFilter: (i) => {
          this.menuService.showFilterMenu({
            column: this.column,
            buttonElement: i,
            containerType: 'columnFilter',
            positionBy: 'button',
          })
        },
        progressSort: (i) => {
          this.beans.sortController.progressSort(
            this.column,
            !!i,
            'uiColumnSorted',
          )
        },
        setSort: (i, s) => {
          this.beans.sortController.setSortForColumn(
            this.column,
            i,
            !!s,
            'uiColumnSorted',
          )
        },
        eGridHeader: this.getGui(),
        setTooltip: (i, s) => {
          this.setupTooltip(e, i, s)
        },
      })
    }
    setupSelectAll(e) {
      ;(this.selectAllFeature = e.createManagedBean(new VI(this.column))),
        this.selectAllFeature.setComp(this)
    }
    getSelectAllGui() {
      return this.selectAllFeature.getCheckboxGui()
    }
    handleKeyDown(e) {
      super.handleKeyDown(e),
        e.key === Y.SPACE && this.selectAllFeature.onSpaceKeyDown(e),
        e.key === Y.ENTER && this.onEnterKeyDown(e),
        e.key === Y.DOWN && e.altKey && this.showMenuOnKeyPress(e, !1)
    }
    onEnterKeyDown(e) {
      if (e.ctrlKey || e.metaKey) this.showMenuOnKeyPress(e, !0)
      else if (this.sortable) {
        const t = e.shiftKey
        this.beans.sortController.progressSort(this.column, t, 'uiColumnSorted')
      }
    }
    showMenuOnKeyPress(e, t) {
      const i = this.comp.getUserCompInstance()
      !i ||
        !(i instanceof eu) ||
        (i.onMenuKeyboardShortcut(t) && e.preventDefault())
    }
    onFocusIn(e) {
      if (!this.getGui().contains(e.relatedTarget)) {
        const t = this.getRowIndex()
        this.focusService.setFocusedHeader(t, this.column),
          this.announceAriaDescription()
      }
      this.focusService.isKeyboardMode() && this.setActiveHeader(!0)
    }
    onFocusOut(e) {
      this.getGui().contains(e.relatedTarget) || this.setActiveHeader(!1)
    }
    setupTooltip(e, t, i) {
      this.tooltipFeature &&
        (this.tooltipFeature = this.destroyBean(this.tooltipFeature))
      const s = this.gos.get('tooltipShowMode') === 'whenTruncated',
        n = this.eGui,
        r = this.column.getColDef()
      !i &&
        s &&
        !r.headerComponent &&
        (i = () => {
          const l = n.querySelector('.ag-header-cell-text')
          return l ? l.scrollWidth > l.clientWidth : !0
        })
      const o = {
          getColumn: () => this.column,
          getColDef: () => this.column.getColDef(),
          getGui: () => n,
          getLocation: () => 'header',
          getTooltipValue: () => t ?? this.column.getColDef().headerTooltip,
          shouldDisplayTooltip: i,
        },
        a = e.createManagedBean(new Tr(o))
      this.setRefreshFunction('tooltip', () => a.refreshToolTip())
    }
    setupClassesFromColDef() {
      const e = () => {
        const t = this.column.getColDef(),
          i = Fv(t, this.gos, this.column, null),
          s = this.userHeaderClasses
        ;(this.userHeaderClasses = new Set(i)),
          i.forEach((n) => {
            s.has(n) ? s.delete(n) : this.comp.addOrRemoveCssClass(n, !0)
          }),
          s.forEach((n) => this.comp.addOrRemoveCssClass(n, !1))
      }
      this.setRefreshFunction('headerClasses', e), e()
    }
    setDragSource(e) {
      if (
        ((this.dragSourceElement = e),
        this.removeDragSource(),
        !e || !this.draggable)
      )
        return
      const {
          column: t,
          beans: i,
          displayName: s,
          dragAndDropService: n,
          gos: r,
        } = this,
        { columnModel: o } = i
      let a = !this.gos.get('suppressDragLeaveHidesColumns')
      const l = (this.dragSource = {
        type: 1,
        eElement: e,
        getDefaultIconName: () => (a ? 'hide' : 'notAllowed'),
        getDragItem: () => this.createDragItem(t),
        dragItemName: s,
        onDragStarted: () => {
          ;(a = !r.get('suppressDragLeaveHidesColumns')), lr([t], !0)
        },
        onDragStopped: () => lr([t], !1),
        onDragCancelled: () => lr([t], !1),
        onGridEnter: (c) => {
          var u
          if (a) {
            const h =
              ((u = c == null ? void 0 : c.columns) == null
                ? void 0
                : u.filter((g) => !g.getColDef().lockVisible)) || []
            o.setColsVisible(h, !0, 'uiColumnMoved')
          }
        },
        onGridExit: (c) => {
          var u
          if (a) {
            const h =
              ((u = c == null ? void 0 : c.columns) == null
                ? void 0
                : u.filter((g) => !g.getColDef().lockVisible)) || []
            o.setColsVisible(h, !1, 'uiColumnMoved')
          }
        },
      })
      n.addDragSource(l, !0)
    }
    createDragItem(e) {
      const t = {}
      return (t[e.getId()] = e.isVisible()), { columns: [e], visibleState: t }
    }
    updateState() {
      ;(this.menuEnabled = this.menuService.isColumnMenuInHeaderEnabled(
        this.column,
      )),
        (this.openFilterEnabled = this.menuService.isFilterMenuInHeaderEnabled(
          this.column,
        )),
        (this.sortable = this.column.isSortable()),
        (this.displayName = this.calculateDisplayName()),
        (this.draggable = this.workOutDraggable())
    }
    setRefreshFunction(e, t) {
      this.refreshFunctions[e] = t
    }
    refresh(e) {
      this.updateState(),
        this.refreshHeaderComp(e),
        this.refreshAria(),
        Object.values(this.refreshFunctions).forEach((t) => t())
    }
    refreshHeaderComp(e) {
      const t = this.lookupUserCompDetails(e)
      ;(
        this.comp.getUserCompInstance() != null &&
        this.userCompDetails.componentClass == t.componentClass
          ? this.attemptHeaderCompRefresh(t.params)
          : !1
      )
        ? this.setDragSource(this.dragSourceElement)
        : this.setCompDetails(t)
    }
    attemptHeaderCompRefresh(e) {
      const t = this.comp.getUserCompInstance()
      return !t || !t.refresh ? !1 : t.refresh(e)
    }
    calculateDisplayName() {
      return this.beans.columnNameService.getDisplayNameForColumn(
        this.column,
        'header',
        !0,
      )
    }
    checkDisplayName(e) {
      this.displayName !== this.calculateDisplayName() && this.refresh(e)
    }
    workOutDraggable() {
      const e = this.column.getColDef()
      return (
        !!(
          !this.gos.get('suppressMovableColumns') &&
          !e.suppressMovable &&
          !e.lockPosition
        ) ||
        !!e.enableRowGroup ||
        !!e.enablePivot
      )
    }
    setupWidth(e) {
      const t = () => {
        const i = this.column.getActualWidth()
        this.comp.setWidth(`${i}px`)
      }
      e.addManagedListeners(this.column, { widthChanged: t }), t()
    }
    setupMovingCss(e) {
      const t = () => {
        this.comp.addOrRemoveCssClass(
          'ag-header-cell-moving',
          this.column.isMoving(),
        )
      }
      e.addManagedListeners(this.column, { movingChanged: t }), t()
    }
    setupMenuClass(e) {
      const t = () => {
        this.comp.addOrRemoveCssClass(
          'ag-column-menu-visible',
          this.column.isMenuVisible(),
        )
      }
      e.addManagedListeners(this.column, { menuVisibleChanged: t }), t()
    }
    setupSortableClass(e) {
      const t = () => {
        this.comp.addOrRemoveCssClass(
          'ag-header-cell-sortable',
          !!this.sortable,
        )
      }
      t(),
        this.setRefreshFunction('updateSortable', t),
        e.addManagedEventListeners({
          sortChanged: this.refreshAriaSort.bind(this),
        })
    }
    setupFilterClass(e) {
      const t = () => {
        const i = this.column.isFilterActive()
        this.comp.addOrRemoveCssClass('ag-header-cell-filtered', i),
          this.refreshAria()
      }
      e.addManagedListeners(this.column, { filterActiveChanged: t }), t()
    }
    setupWrapTextClass() {
      const e = () => {
        const t = !!this.column.getColDef().wrapHeaderText
        this.comp.addOrRemoveCssClass('ag-header-cell-wrap-text', t)
      }
      e(), this.setRefreshFunction('wrapText', e)
    }
    onHeaderHighlightChanged() {
      const e = this.column.getHighlighted(),
        t = e === 0,
        i = e === 1
      this.comp.addOrRemoveCssClass('ag-header-highlight-before', t),
        this.comp.addOrRemoveCssClass('ag-header-highlight-after', i)
    }
    onDisplayedColumnsChanged() {
      super.onDisplayedColumnsChanged(),
        this.isAlive() && this.onHeaderHeightChanged()
    }
    onHeaderHeightChanged() {
      this.refreshSpanHeaderHeight()
    }
    refreshSpanHeaderHeight() {
      const { eGui: e, column: t, comp: i, beans: s } = this,
        n = this.beans.columnModel.getGroupRowsHeight(),
        r = n.reduce((h, g) => (h += g), 0) === 0
      if (
        (i.addOrRemoveCssClass('ag-header-parent-hidden', r),
        !t.isSpanHeaderHeight())
      ) {
        e.style.removeProperty('top'),
          e.style.removeProperty('height'),
          i.addOrRemoveCssClass('ag-header-span-height', !1),
          i.addOrRemoveCssClass('ag-header-span-total', !1)
        return
      }
      const { numberOfParents: o, isSpanningTotal: a } =
        this.column.getColumnGroupPaddingInfo()
      i.addOrRemoveCssClass('ag-header-span-height', o > 0)
      const { columnModel: l } = s,
        c = l.getColumnHeaderRowHeight()
      if (o === 0) {
        i.addOrRemoveCssClass('ag-header-span-total', !1),
          e.style.setProperty('top', '0px'),
          e.style.setProperty('height', `${c}px`)
        return
      }
      i.addOrRemoveCssClass('ag-header-span-total', a)
      let u = 0
      for (let h = 0; h < o; h++) u += n[n.length - 1 - h]
      e.style.setProperty('top', `${-u}px`),
        e.style.setProperty('height', `${c + u}px`)
    }
    refreshAriaSort() {
      if (this.sortable) {
        const e = this.localeService.getLocaleTextFunc(),
          t =
            this.beans.sortController.getDisplaySortForColumn(this.column) ||
            null
        this.comp.setAriaSort(Zx(t)),
          this.setAriaDescriptionProperty(
            'sort',
            e('ariaSortableColumn', 'Press ENTER to sort'),
          )
      } else
        this.comp.setAriaSort(), this.setAriaDescriptionProperty('sort', null)
    }
    refreshAriaMenu() {
      if (this.menuEnabled) {
        const e = this.localeService.getLocaleTextFunc()
        this.setAriaDescriptionProperty(
          'menu',
          e('ariaMenuColumn', 'Press ALT DOWN to open column menu'),
        )
      } else this.setAriaDescriptionProperty('menu', null)
    }
    refreshAriaFilterButton() {
      if (this.openFilterEnabled && !this.menuService.isLegacyMenuEnabled()) {
        const e = this.localeService.getLocaleTextFunc()
        this.setAriaDescriptionProperty(
          'filterButton',
          e('ariaFilterColumn', 'Press CTRL ENTER to open filter'),
        )
      } else this.setAriaDescriptionProperty('filterButton', null)
    }
    refreshAriaFiltered() {
      const e = this.localeService.getLocaleTextFunc()
      this.column.isFilterActive()
        ? this.setAriaDescriptionProperty(
            'filter',
            e('ariaColumnFiltered', 'Column Filtered'),
          )
        : this.setAriaDescriptionProperty('filter', null)
    }
    setAriaDescriptionProperty(e, t) {
      t != null
        ? this.ariaDescriptionProperties.set(e, t)
        : this.ariaDescriptionProperties.delete(e)
    }
    announceAriaDescription() {
      if (!this.eGui.contains(Lt(this.beans.gos))) return
      const e = Array.from(this.ariaDescriptionProperties.keys())
        .sort((t, i) =>
          t === 'filter' ? -1 : i.charCodeAt(0) - t.charCodeAt(0),
        )
        .map((t) => this.ariaDescriptionProperties.get(t))
        .join('. ')
      this.beans.ariaAnnouncementService.announceValue(e, 'columnHeader')
    }
    refreshAria() {
      this.refreshAriaSort(),
        this.refreshAriaMenu(),
        this.refreshAriaFilterButton(),
        this.refreshAriaFiltered()
    }
    addColumnHoverListener(e) {
      const t = () => {
        if (!this.gos.get('columnHoverHighlight')) return
        const i = this.beans.columnHoverService.isHovered(this.column)
        this.comp.addOrRemoveCssClass('ag-column-hover', i)
      }
      e.addManagedEventListeners({ columnHoverChanged: t }), t()
    }
    getColId() {
      return this.column.getColId()
    }
    addActiveHeaderMouseListeners(e) {
      const t = (n) => this.handleMouseOverChange(n.type === 'mouseenter'),
        i = () =>
          this.dispatchColumnMouseEvent('columnHeaderClicked', this.column),
        s = (n) => this.handleContextMenuMouseEvent(n, void 0, this.column)
      e.addManagedListeners(this.getGui(), {
        mouseenter: t,
        mouseleave: t,
        click: i,
        contextmenu: s,
      })
    }
    handleMouseOverChange(e) {
      this.setActiveHeader(e),
        this.eventService.dispatchEvent({
          type: e ? 'columnHeaderMouseOver' : 'columnHeaderMouseLeave',
          column: this.column,
        })
    }
    setActiveHeader(e) {
      this.comp.addOrRemoveCssClass('ag-header-active', e)
    }
    getAnchorElementForMenu(e) {
      const t = this.comp.getUserCompInstance()
      return t instanceof eu ? t.getAnchorElementForMenu(e) : this.getGui()
    }
    destroy() {
      super.destroy()
    }
  },
  WI = class extends X {
    wireBeans(e) {
      ;(this.horizontalResizeService = e.horizontalResizeService),
        (this.autoWidthCalculator = e.autoWidthCalculator),
        (this.visibleColsService = e.visibleColsService),
        (this.columnSizeService = e.columnSizeService),
        (this.columnAutosizeService = e.columnAutosizeService)
    }
    constructor(e, t, i, s) {
      super(),
        (this.eResize = t),
        (this.comp = e),
        (this.pinned = i),
        (this.columnGroup = s)
    }
    postConstruct() {
      if (!this.columnGroup.isResizable()) {
        this.comp.setResizableDisplayed(!1)
        return
      }
      const e = this.horizontalResizeService.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, !1),
        onResizeEnd: this.onResizing.bind(this, !0),
      })
      if ((this.addDestroyFunc(e), !this.gos.get('suppressAutoSize'))) {
        const t = this.gos.get('skipHeaderOnAutoSize')
        this.eResize.addEventListener('dblclick', () => {
          const i = []
          this.columnGroup.getDisplayedLeafColumns().forEach((n) => {
            n.getColDef().suppressAutoSize || i.push(n.getColId())
          }),
            i.length > 0 &&
              this.columnAutosizeService.autoSizeCols({
                colKeys: i,
                skipHeader: t,
                stopAtGroup: this.columnGroup,
                source: 'uiColumnResized',
              }),
            this.resizeLeafColumnsToFit('uiColumnResized')
        })
      }
    }
    onResizeStart(e) {
      const t = this.getInitialValues(e)
      this.storeLocalValues(t), this.toggleColumnResizing(!0)
    }
    onResizing(e, t, i = 'uiColumnResized') {
      const s = this.normaliseDragChange(t),
        n = this.resizeStartWidth + s
      this.resizeColumnsFromLocalValues(n, i, e)
    }
    getInitialValues(e) {
      const t = this.getColumnsToResize(),
        i = this.getInitialSizeOfColumns(t),
        s = this.getSizeRatiosOfColumns(t, i),
        n = { columnsToResize: t, resizeStartWidth: i, resizeRatios: s }
      let r = null
      if (
        (e &&
          (r = this.visibleColsService.getGroupAtDirection(
            this.columnGroup,
            'After',
          )),
        r)
      ) {
        const o = r.getDisplayedLeafColumns(),
          a = (n.groupAfterColumns = o.filter((c) => c.isResizable())),
          l = (n.groupAfterStartWidth = this.getInitialSizeOfColumns(a))
        n.groupAfterRatios = this.getSizeRatiosOfColumns(a, l)
      } else
        (n.groupAfterColumns = void 0),
          (n.groupAfterStartWidth = void 0),
          (n.groupAfterRatios = void 0)
      return n
    }
    storeLocalValues(e) {
      const {
        columnsToResize: t,
        resizeStartWidth: i,
        resizeRatios: s,
        groupAfterColumns: n,
        groupAfterStartWidth: r,
        groupAfterRatios: o,
      } = e
      ;(this.resizeCols = t),
        (this.resizeStartWidth = i),
        (this.resizeRatios = s),
        (this.resizeTakeFromCols = n),
        (this.resizeTakeFromStartWidth = r),
        (this.resizeTakeFromRatios = o)
    }
    clearLocalValues() {
      ;(this.resizeCols = void 0),
        (this.resizeRatios = void 0),
        (this.resizeTakeFromCols = void 0),
        (this.resizeTakeFromRatios = void 0)
    }
    resizeLeafColumnsToFit(e) {
      const t = this.autoWidthCalculator.getPreferredWidthForColumnGroup(
          this.columnGroup,
        ),
        i = this.getInitialValues()
      t > i.resizeStartWidth && this.resizeColumns(i, t, e, !0)
    }
    resizeColumnsFromLocalValues(e, t, i = !0) {
      if (!this.resizeCols || !this.resizeRatios) return
      const s = {
        columnsToResize: this.resizeCols,
        resizeStartWidth: this.resizeStartWidth,
        resizeRatios: this.resizeRatios,
        groupAfterColumns: this.resizeTakeFromCols ?? void 0,
        groupAfterStartWidth: this.resizeTakeFromStartWidth ?? void 0,
        groupAfterRatios: this.resizeTakeFromRatios ?? void 0,
      }
      this.resizeColumns(s, e, t, i)
    }
    resizeColumns(e, t, i, s = !0) {
      const {
          columnsToResize: n,
          resizeStartWidth: r,
          resizeRatios: o,
          groupAfterColumns: a,
          groupAfterStartWidth: l,
          groupAfterRatios: c,
        } = e,
        u = []
      if ((u.push({ columns: n, ratios: o, width: t }), a)) {
        const h = t - r
        u.push({ columns: a, ratios: c, width: l - h })
      }
      this.columnSizeService.resizeColumnSets({
        resizeSets: u,
        finished: s,
        source: i,
      }),
        s && this.toggleColumnResizing(!1)
    }
    toggleColumnResizing(e) {
      this.comp.addOrRemoveCssClass('ag-column-resizing', e)
    }
    getColumnsToResize() {
      return this.columnGroup
        .getDisplayedLeafColumns()
        .filter((t) => t.isResizable())
    }
    getInitialSizeOfColumns(e) {
      return e.reduce((t, i) => t + i.getActualWidth(), 0)
    }
    getSizeRatiosOfColumns(e, t) {
      return e.map((i) => i.getActualWidth() / t)
    }
    normaliseDragChange(e) {
      let t = e
      return (
        this.gos.get('enableRtl')
          ? this.pinned !== 'left' && (t *= -1)
          : this.pinned === 'right' && (t *= -1),
        t
      )
    }
    destroy() {
      super.destroy(), this.clearLocalValues()
    }
  },
  $I = class extends X {
    constructor(e, t) {
      super(),
        (this.removeChildListenersFuncs = []),
        (this.columnGroup = t),
        (this.comp = e)
    }
    postConstruct() {
      this.addListenersToChildrenColumns(),
        this.addManagedListeners(this.columnGroup, {
          displayedChildrenChanged: this.onDisplayedChildrenChanged.bind(this),
        }),
        this.onWidthChanged(),
        this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this))
    }
    addListenersToChildrenColumns() {
      this.removeListenersOnChildrenColumns()
      const e = this.onWidthChanged.bind(this)
      this.columnGroup.getLeafColumns().forEach((t) => {
        t.addEventListener('widthChanged', e),
          t.addEventListener('visibleChanged', e),
          this.removeChildListenersFuncs.push(() => {
            t.removeEventListener('widthChanged', e),
              t.removeEventListener('visibleChanged', e)
          })
      })
    }
    removeListenersOnChildrenColumns() {
      this.removeChildListenersFuncs.forEach((e) => e()),
        (this.removeChildListenersFuncs = [])
    }
    onDisplayedChildrenChanged() {
      this.addListenersToChildrenColumns(), this.onWidthChanged()
    }
    onWidthChanged() {
      const e = this.columnGroup.getActualWidth()
      this.comp.setWidth(`${e}px`),
        this.comp.addOrRemoveCssClass('ag-hidden', e === 0)
    }
  },
  zI = class extends Sl {
    constructor(e, t, i) {
      super(e, t, i),
        (this.onSuppressColMoveChange = () => {
          if (!this.isAlive() || this.isSuppressMoving())
            this.removeDragSource()
          else if (!this.dragSource) {
            const s = this.getGui()
            this.setDragSource(s)
          }
        }),
        (this.column = e)
    }
    setComp(e, t, i, s, n) {
      ;(this.comp = e),
        (n = ko(this, this.beans.context, n)),
        this.setGui(t, n),
        (this.displayName =
          this.beans.columnNameService.getDisplayNameForColumnGroup(
            this.column,
            'header',
          )),
        this.addClasses(),
        this.setupMovingCss(n),
        this.setupExpandable(n),
        this.setupTooltip(n),
        this.setupAutoHeight({ wrapperElement: s, compBean: n }),
        this.setupUserComp(n),
        this.addHeaderMouseListeners(n),
        this.addManagedPropertyListener(
          'groupHeaderHeight',
          this.refreshMaxHeaderHeight.bind(this),
        ),
        this.refreshMaxHeaderHeight()
      const r = this.getParentRowCtrl().getPinned(),
        o = this.column.getProvidedColumnGroup().getLeafColumns()
      n.createManagedBean(new yd(o, t)),
        n.createManagedBean(new wd(this.column, t, this.beans)),
        n.createManagedBean(new $I(e, this.column)),
        (this.resizeFeature = n.createManagedBean(
          new WI(e, i, r, this.column),
        )),
        n.createManagedBean(
          new jn(t, {
            shouldStopEventPropagation:
              this.shouldStopEventPropagation.bind(this),
            onTabKeyDown: () => {},
            handleKeyDown: this.handleKeyDown.bind(this),
            onFocusIn: this.onFocusIn.bind(this),
          }),
        ),
        this.addHighlightListeners(n, o),
        n.addManagedPropertyListener(
          'suppressMovableColumns',
          this.onSuppressColMoveChange,
        ),
        this.addResizeAndMoveKeyboardListeners(n),
        n.addDestroyFunc(() => this.clearComponent())
    }
    refreshMaxHeaderHeight() {
      const { gos: e, comp: t } = this,
        i = e.get('groupHeaderHeight')
      i != null
        ? i === 0
          ? t.setHeaderWrapperHidden(!0)
          : t.setHeaderWrapperMaxHeight(i)
        : (t.setHeaderWrapperHidden(!1), t.setHeaderWrapperMaxHeight(null))
    }
    addHighlightListeners(e, t) {
      if (this.beans.gos.get('suppressMoveWhenColumnDragging'))
        for (const i of t)
          e.addManagedListeners(i, {
            headerHighlightChanged: this.onLeafColumnHighlightChanged.bind(
              this,
              i,
            ),
          })
    }
    onLeafColumnHighlightChanged(e) {
      const t = this.column.getDisplayedLeafColumns(),
        i = t[0] === e,
        s = rt(t) === e
      if (!i && !s) return
      const n = e.getHighlighted(),
        r = !!this.getParentRowCtrl().findHeaderCellCtrl((l) =>
          l.getColumnGroupChild().isMoving(),
        )
      let o = !1,
        a = !1
      if (r) {
        const l = this.beans.gos.get('enableRtl'),
          c = n === 1,
          u = n === 0
        i && (l ? (a = c) : (o = u)), s && (l ? (o = u) : (a = c))
      }
      this.comp.addOrRemoveCssClass('ag-header-highlight-before', o),
        this.comp.addOrRemoveCssClass('ag-header-highlight-after', a)
    }
    getColumn() {
      return this.column
    }
    resizeHeader(e, t) {
      if (!this.resizeFeature) return
      const i = this.resizeFeature.getInitialValues(t)
      this.resizeFeature.resizeColumns(
        i,
        i.resizeStartWidth + e,
        'uiColumnResized',
        !0,
      )
    }
    moveHeader(e) {
      const { beans: t, eGui: i, column: s, ctrlsService: n } = this,
        {
          gos: r,
          columnModel: o,
          columnMoveService: a,
          visibleColsService: l,
        } = t,
        c = r.get('enableRtl'),
        u = e === 0,
        h = this.getPinned(),
        g = i.getBoundingClientRect(),
        f = g.left,
        p = g.width,
        v = $a({
          x: u !== c ? f - 20 : f + p + 20,
          pinned: h,
          fromKeyboard: !0,
          gos: r,
          ctrlsService: n,
        }),
        m = s.getGroupId(),
        C = this.focusService.getFocusedHeader()
      Ed({
        allMovingColumns: this.column.getLeafColumns(),
        isFromHeader: !0,
        fromLeft: e === 1,
        xPosition: v,
        pinned: h,
        fromEnter: !1,
        fakeEvent: !1,
        gos: r,
        columnModel: o,
        columnMoveService: a,
        visibleColsService: l,
        finished: !0,
      })
      const w = s.getDisplayedLeafColumns(),
        S = u ? w[0] : rt(w)
      this.ctrlsService
        .getGridBodyCtrl()
        .getScrollFeature()
        .ensureColumnVisible(S, 'auto'),
        (!this.isAlive() || this.beans.gos.get('ensureDomOrder')) &&
          C &&
          this.restoreFocus(m, s, C)
    }
    restoreFocus(e, t, i) {
      const s = t.getLeafColumns()
      if (!s.length) return
      const n = s[0].getParent()
      if (!n) return
      const r = this.findGroupWidthId(n, e)
      r &&
        this.focusService.focusHeaderPosition({
          headerPosition: { ...i, column: r },
        })
    }
    findGroupWidthId(e, t) {
      for (; e; ) {
        if (e.getGroupId() === t) return e
        e = e.getParent()
      }
      return null
    }
    resizeLeafColumnsToFit(e) {
      this.resizeFeature && this.resizeFeature.resizeLeafColumnsToFit(e)
    }
    setupUserComp(e) {
      const t = this.gos.addGridCommonParams({
          displayName: this.displayName,
          columnGroup: this.column,
          setExpanded: (s) => {
            this.beans.columnModel.setColumnGroupOpened(
              this.column.getProvidedColumnGroup(),
              s,
              'gridInitializing',
            )
          },
          setTooltip: (s, n) => {
            this.setupTooltip(e, s, n)
          },
        }),
        i = this.userComponentFactory.getHeaderGroupCompDetails(t)
      this.comp.setUserCompDetails(i)
    }
    addHeaderMouseListeners(e) {
      const t = (n) => this.handleMouseOverChange(n.type === 'mouseenter'),
        i = () =>
          this.dispatchColumnMouseEvent(
            'columnHeaderClicked',
            this.column.getProvidedColumnGroup(),
          ),
        s = (n) =>
          this.handleContextMenuMouseEvent(
            n,
            void 0,
            this.column.getProvidedColumnGroup(),
          )
      e.addManagedListeners(this.getGui(), {
        mouseenter: t,
        mouseleave: t,
        click: i,
        contextmenu: s,
      })
    }
    handleMouseOverChange(e) {
      this.eventService.dispatchEvent({
        type: e ? 'columnHeaderMouseOver' : 'columnHeaderMouseLeave',
        column: this.column.getProvidedColumnGroup(),
      })
    }
    setupTooltip(e, t, i) {
      this.tooltipFeature &&
        (this.tooltipFeature = this.destroyBean(this.tooltipFeature))
      const s = this.column.getColGroupDef(),
        n = this.gos.get('tooltipShowMode') === 'whenTruncated',
        r = this.eGui
      !i &&
        n &&
        !(s != null && s.headerGroupComponent) &&
        (i = () => {
          const a = r.querySelector('.ag-header-group-text')
          return a ? a.scrollWidth > a.clientWidth : !0
        })
      const o = {
        getColumn: () => this.column,
        getGui: () => r,
        getLocation: () => 'headerGroup',
        getTooltipValue: () => t ?? (s && s.headerTooltip),
        shouldDisplayTooltip: i,
      }
      s && (o.getColDef = () => s), e.createManagedBean(new Tr(o))
    }
    setupExpandable(e) {
      const t = this.column.getProvidedColumnGroup()
      this.refreshExpanded()
      const i = this.refreshExpanded.bind(this)
      e.addManagedListeners(t, { expandedChanged: i, expandableChanged: i })
    }
    refreshExpanded() {
      const { column: e } = this
      this.expandable = e.isExpandable()
      const t = e.isExpanded()
      this.expandable
        ? this.comp.setAriaExpanded(t ? 'true' : 'false')
        : this.comp.setAriaExpanded(void 0)
    }
    getColId() {
      return this.column.getUniqueId()
    }
    addClasses() {
      const e = this.column.getColGroupDef(),
        t = Fv(e, this.gos, null, this.column)
      this.column.isPadding()
        ? (t.push('ag-header-group-cell-no-group'),
          this.column.getLeafColumns().every((s) => s.isSpanHeaderHeight()) &&
            t.push('ag-header-span-height'))
        : (t.push('ag-header-group-cell-with-group'),
          e != null && e.wrapHeaderText && t.push('ag-header-cell-wrap-text')),
        t.forEach((i) => this.comp.addOrRemoveCssClass(i, !0))
    }
    setupMovingCss(e) {
      const i = this.column.getProvidedColumnGroup().getLeafColumns(),
        s = () =>
          this.comp.addOrRemoveCssClass(
            'ag-header-cell-moving',
            this.column.isMoving(),
          )
      i.forEach((n) => {
        e.addManagedListeners(n, { movingChanged: s })
      }),
        s()
    }
    onFocusIn(e) {
      if (!this.eGui.contains(e.relatedTarget)) {
        const t = this.getRowIndex()
        this.beans.focusService.setFocusedHeader(t, this.column)
      }
    }
    handleKeyDown(e) {
      super.handleKeyDown(e)
      const t = this.getWrapperHasFocus()
      if (!(!this.expandable || !t) && e.key === Y.ENTER) {
        const i = this.column,
          s = !i.isExpanded()
        this.beans.columnModel.setColumnGroupOpened(
          i.getProvidedColumnGroup(),
          s,
          'uiColumnExpanded',
        )
      }
    }
    setDragSource(e) {
      if (
        !this.isAlive() ||
        this.isSuppressMoving() ||
        (this.removeDragSource(), !e)
      )
        return
      const {
          beans: t,
          column: i,
          displayName: s,
          gos: n,
          dragAndDropService: r,
        } = this,
        { columnModel: o } = t,
        a = i.getProvidedColumnGroup().getLeafColumns()
      let l = !n.get('suppressDragLeaveHidesColumns')
      const c = (this.dragSource = {
        type: 1,
        eElement: e,
        getDefaultIconName: () => (l ? 'hide' : 'notAllowed'),
        dragItemName: s,
        getDragItem: () => this.getDragItemForGroup(i),
        onDragStarted: () => {
          ;(l = !n.get('suppressDragLeaveHidesColumns')), lr(a, !0)
        },
        onDragStopped: () => lr(a, !1),
        onDragCancelled: () => lr(a, !1),
        onGridEnter: (u) => {
          if (l) {
            const { columns: h = [], visibleState: g } = u ?? {},
              f = h.filter(
                (p) => !p.getColDef().lockVisible && (!g || g[p.getColId()]),
              )
            o.setColsVisible(f, !0, 'uiColumnMoved')
          }
        },
        onGridExit: (u) => {
          var h
          if (l) {
            const g =
              ((h = u == null ? void 0 : u.columns) == null
                ? void 0
                : h.filter((f) => !f.getColDef().lockVisible)) || []
            o.setColsVisible(g, !1, 'uiColumnMoved')
          }
        },
      })
      r.addDragSource(c, !0)
    }
    getDragItemForGroup(e) {
      const t = e.getProvidedColumnGroup().getLeafColumns(),
        i = {}
      t.forEach((o) => (i[o.getId()] = o.isVisible()))
      const s = []
      this.beans.visibleColsService.getAllCols().forEach((o) => {
        t.indexOf(o) >= 0 && (s.push(o), Ri(t, o))
      }),
        t.forEach((o) => s.push(o))
      const n = [],
        r = e.getLeafColumns()
      for (const o of s) r.indexOf(o) !== -1 && n.push(o)
      return { columns: s, columnsInSplit: n, visibleState: i }
    }
    isSuppressMoving() {
      let e = !1
      return (
        this.column.getLeafColumns().forEach((i) => {
          ;(i.getColDef().suppressMovable || i.getColDef().lockPosition) &&
            (e = !0)
        }),
        e || this.gos.get('suppressMovableColumns')
      )
    }
    destroy() {
      super.destroy()
    }
  },
  UI = 0,
  mc = class extends X {
    constructor(e, t, i) {
      super(),
        (this.instanceId = UI++),
        (this.rowIndex = e),
        (this.pinned = t),
        (this.type = i)
      const s =
        i == 'group'
          ? 'ag-header-row-column-group'
          : i == 'filter'
            ? 'ag-header-row-column-filter'
            : 'ag-header-row-column'
      this.headerRowClass = `ag-header-row ${s}`
    }
    wireBeans(e) {
      this.beans = e
    }
    postConstruct() {
      ;(this.isPrintLayout = ci(this.gos, 'print')),
        (this.isEnsureDomOrder = this.gos.get('ensureDomOrder'))
    }
    areCellsRendered() {
      return this.comp
        ? this.getHeaderCellCtrls().every((e) => e.getGui() != null)
        : !1
    }
    setComp(e, t, i = !0) {
      ;(this.comp = e),
        (t = ko(this, this.beans.context, t)),
        i && (this.onRowHeightChanged(), this.onVirtualColumnsChanged()),
        this.setWidth(),
        this.addEventListeners(t)
    }
    getHeaderRowClass() {
      return this.headerRowClass
    }
    getAriaRowIndex() {
      return this.rowIndex + 1
    }
    addEventListeners(e) {
      const t = this.onRowHeightChanged.bind(this)
      e.addManagedEventListeners({
        columnResized: this.onColumnResized.bind(this),
        displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
        virtualColumnsChanged: (i) =>
          this.onVirtualColumnsChanged(i.afterScroll),
        columnGroupHeaderHeightChanged: t,
        columnHeaderHeightChanged: t,
        gridStylesChanged: t,
        advancedFilterEnabledChanged: t,
      }),
        e.addManagedPropertyListener(
          'domLayout',
          this.onDisplayedColumnsChanged.bind(this),
        ),
        e.addManagedPropertyListener(
          'ensureDomOrder',
          (i) => (this.isEnsureDomOrder = i.currentValue),
        ),
        e.addManagedPropertyListeners(
          [
            'headerHeight',
            'pivotHeaderHeight',
            'groupHeaderHeight',
            'pivotGroupHeaderHeight',
            'floatingFiltersHeight',
          ],
          t,
        )
    }
    getHeaderCellCtrl(e) {
      if (this.headerCellCtrls)
        return ua(this.headerCellCtrls).find(
          (t) => t.getColumnGroupChild() === e,
        )
    }
    onDisplayedColumnsChanged() {
      ;(this.isPrintLayout = ci(this.gos, 'print')),
        this.onVirtualColumnsChanged(),
        this.setWidth(),
        this.onRowHeightChanged()
    }
    getType() {
      return this.type
    }
    onColumnResized() {
      this.setWidth()
    }
    setWidth() {
      const e = this.getWidthForRow()
      this.comp.setWidth(`${e}px`)
    }
    getWidthForRow() {
      const { visibleColsService: e } = this.beans
      return this.isPrintLayout
        ? this.pinned != null
          ? 0
          : e.getContainerWidth('right') +
            e.getContainerWidth('left') +
            e.getContainerWidth(null)
        : e.getContainerWidth(this.pinned)
    }
    onRowHeightChanged() {
      const { topOffset: e, rowHeight: t } = this.getTopAndHeight()
      this.comp.setTop(e + 'px'), this.comp.setHeight(t + 'px')
    }
    getTopAndHeight() {
      const { columnModel: e, filterManager: t } = this.beans,
        i = [],
        s = e.getGroupRowsHeight(),
        n = e.getColumnHeaderRowHeight()
      i.push(...s),
        i.push(n),
        t != null &&
          t.hasFloatingFilters() &&
          i.push(e.getFloatingFiltersHeight())
      let r = 0
      for (let a = 0; a < this.rowIndex; a++) r += i[a]
      const o = i[this.rowIndex]
      return { topOffset: r, rowHeight: o }
    }
    getPinned() {
      return this.pinned
    }
    getRowIndex() {
      return this.rowIndex
    }
    onVirtualColumnsChanged(e = !1) {
      const t = this.getHeaderCtrls(),
        i = this.isEnsureDomOrder || this.isPrintLayout
      this.comp.setHeaderCtrls(t, i, e)
    }
    getHeaderCtrls() {
      const e = this.headerCellCtrls
      this.headerCellCtrls = new Map()
      const t = this.getColumnsInViewport()
      for (const s of t) this.recycleAndCreateHeaderCtrls(s, e)
      const i = (s) => {
        const { focusService: n, visibleColsService: r } = this.beans
        return n.isHeaderWrapperFocused(s)
          ? r.isVisible(s.getColumnGroupChild())
          : !1
      }
      if (e)
        for (const [s, n] of e)
          i(n) ? this.headerCellCtrls.set(s, n) : this.destroyBean(n)
      return this.getHeaderCellCtrls()
    }
    getHeaderCellCtrls() {
      var e
      return Array.from(
        ((e = this.headerCellCtrls) == null ? void 0 : e.values()) ?? [],
      )
    }
    recycleAndCreateHeaderCtrls(e, t) {
      if (!this.headerCellCtrls || e.isEmptyGroup()) return
      const i = e.getUniqueId()
      let s
      if (
        (t && ((s = t.get(i)), t.delete(i)),
        s &&
          s.getColumnGroupChild() != e &&
          (this.destroyBean(s), (s = void 0)),
        s == null)
      )
        switch (this.type) {
          case 'filter': {
            s = this.createBean(
              this.beans.ctrlsFactory.getInstance(
                'headerFilterCell',
                e,
                this.beans,
                this,
              ),
            )
            break
          }
          case 'group':
            s = this.createBean(new zI(e, this.beans, this))
            break
          default:
            s = this.createBean(new _I(e, this.beans, this))
            break
        }
      this.headerCellCtrls.set(i, s)
    }
    getColumnsInViewport() {
      return this.isPrintLayout
        ? this.getColumnsInViewportPrintLayout()
        : this.getColumnsInViewportNormalLayout()
    }
    getColumnsInViewportPrintLayout() {
      if (this.pinned != null) return []
      let e = []
      const t = this.getActualDepth(),
        { columnViewportService: i } = this.beans
      return (
        ['left', null, 'right'].forEach((s) => {
          const n = i.getHeadersToRender(s, t)
          e = e.concat(n)
        }),
        e
      )
    }
    getActualDepth() {
      return this.type == 'filter' ? this.rowIndex - 1 : this.rowIndex
    }
    getColumnsInViewportNormalLayout() {
      return this.beans.columnViewportService.getHeadersToRender(
        this.pinned,
        this.getActualDepth(),
      )
    }
    findHeaderCellCtrl(e) {
      if (!this.headerCellCtrls) return
      const t = this.getHeaderCellCtrls()
      let i
      return (
        typeof e == 'function'
          ? (i = t.find(e))
          : (i = t.find((s) => s.getColumnGroupChild() == e)),
        i
      )
    }
    focusHeader(e, t) {
      const i = this.findHeaderCellCtrl(e)
      return i ? i.focus(t) : !1
    }
    destroy() {
      var e
      ;(e = this.headerCellCtrls) == null ||
        e.forEach((t) => {
          this.destroyBean(t)
        }),
        (this.headerCellCtrls = void 0),
        super.destroy()
    }
  },
  jI = class extends X {
    constructor(e) {
      super(),
        (this.hidden = !1),
        (this.includeFloatingFilter = !1),
        (this.groupsRowCtrls = []),
        (this.pinned = e)
    }
    wireBeans(e) {
      ;(this.ctrlsService = e.ctrlsService),
        (this.scrollVisibleService = e.scrollVisibleService),
        (this.pinnedWidthService = e.pinnedWidthService),
        (this.columnModel = e.columnModel),
        (this.focusService = e.focusService),
        (this.filterManager = e.filterManager)
    }
    setComp(e, t) {
      ;(this.comp = e),
        (this.eViewport = t),
        this.setupCenterWidth(),
        this.setupPinnedWidth(),
        this.setupDragAndDrop(this.eViewport)
      const i = this.onDisplayedColumnsChanged.bind(this)
      this.addManagedEventListeners({
        gridColumnsChanged: this.onGridColumnsChanged.bind(this),
        displayedColumnsChanged: i,
        advancedFilterEnabledChanged: i,
      })
      const s = `${typeof this.pinned == 'string' ? this.pinned : 'center'}Header`
      this.ctrlsService.register(s, this),
        this.columnModel.isReady() && this.refresh()
    }
    getAllCtrls() {
      const e = [...this.groupsRowCtrls]
      return (
        this.columnsRowCtrl && e.push(this.columnsRowCtrl),
        this.filtersRowCtrl && e.push(this.filtersRowCtrl),
        e
      )
    }
    refresh(e = !1) {
      const t = new vr(),
        i = this.focusService.getFocusHeaderToUseAfterRefresh(),
        s = () => {
          const a = this.columnModel.getHeaderRowCount() - 1
          this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls)
          for (let l = 0; l < a; l++) {
            const c = this.createBean(new mc(t.next(), this.pinned, 'group'))
            this.groupsRowCtrls.push(c)
          }
        },
        n = () => {
          const a = t.next(),
            l =
              !this.hidden &&
              (this.columnsRowCtrl == null ||
                !e ||
                this.columnsRowCtrl.getRowIndex() !== a)
          ;(l || this.hidden) &&
            (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)),
            l &&
              (this.columnsRowCtrl = this.createBean(
                new mc(a, this.pinned, 'column'),
              ))
        },
        r = () => {
          var c
          this.includeFloatingFilter =
            !!((c = this.filterManager) != null && c.hasFloatingFilters()) &&
            !this.hidden
          const a = () => {
            this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl)
          }
          if (!this.includeFloatingFilter) {
            a()
            return
          }
          const l = t.next()
          if (this.filtersRowCtrl) {
            const u = this.filtersRowCtrl.getRowIndex() !== l
            ;(!e || u) && a()
          }
          this.filtersRowCtrl ||
            (this.filtersRowCtrl = this.createBean(
              new mc(l, this.pinned, 'filter'),
            ))
        }
      s(), n(), r()
      const o = this.getAllCtrls()
      this.comp.setCtrls(o), this.restoreFocusOnHeader(i)
    }
    getHeaderCtrlForColumn(e) {
      var t
      if (cn(e))
        return (t = this.columnsRowCtrl) == null
          ? void 0
          : t.getHeaderCellCtrl(e)
      if (this.groupsRowCtrls.length !== 0)
        for (let i = 0; i < this.groupsRowCtrls.length; i++) {
          const s = this.groupsRowCtrls[i].getHeaderCellCtrl(e)
          if (s) return s
        }
    }
    getHtmlElementForColumnHeader(e) {
      const t = this.getHeaderCtrlForColumn(e)
      return t ? t.getGui() : null
    }
    getRowType(e) {
      const i = this.getAllCtrls()[e]
      return i ? i.getType() : void 0
    }
    focusHeader(e, t, i) {
      const n = this.getAllCtrls()[e]
      return n ? n.focusHeader(t, i) : !1
    }
    getViewportElement() {
      return this.eViewport
    }
    getGroupRowCount() {
      return this.groupsRowCtrls.length
    }
    getGroupRowCtrlAtIndex(e) {
      return this.groupsRowCtrls[e]
    }
    getRowCount() {
      return (
        this.groupsRowCtrls.length +
        (this.columnsRowCtrl ? 1 : 0) +
        (this.filtersRowCtrl ? 1 : 0)
      )
    }
    setHorizontalScroll(e) {
      this.comp.setViewportScrollLeft(e)
    }
    onScrollCallback(e) {
      this.addManagedElementListeners(this.getViewportElement(), { scroll: e })
    }
    destroy() {
      this.filtersRowCtrl &&
        (this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl)),
        this.columnsRowCtrl &&
          (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)),
        this.groupsRowCtrls &&
          this.groupsRowCtrls.length &&
          (this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls)),
        super.destroy()
    }
    setupDragAndDrop(e) {
      const t = new GI(this.pinned, e)
      this.createManagedBean(t)
    }
    restoreFocusOnHeader(e) {
      if (!e) return
      const { column: t } = e
      t.getPinned() == this.pinned &&
        this.focusService.focusHeaderPosition({ headerPosition: e })
    }
    onGridColumnsChanged() {
      this.refresh(!0)
    }
    onDisplayedColumnsChanged() {
      var t
      const e =
        ((t = this.filterManager) == null ? void 0 : t.hasFloatingFilters()) &&
        !this.hidden
      this.includeFloatingFilter !== e && this.refresh(!0)
    }
    setupCenterWidth() {
      this.pinned == null &&
        this.createManagedBean(
          new Fd((e) => this.comp.setCenterWidth(`${e}px`), !0),
        )
    }
    setupPinnedWidth() {
      if (this.pinned == null) return
      const e = this.pinned === 'left',
        t = this.pinned === 'right'
      this.hidden = !0
      const i = () => {
        const s = e
          ? this.pinnedWidthService.getPinnedLeftWidth()
          : this.pinnedWidthService.getPinnedRightWidth()
        if (s == null) return
        const n = s == 0,
          r = this.hidden !== n,
          o = this.gos.get('enableRtl'),
          a = this.scrollVisibleService.getScrollbarWidth(),
          c =
            this.scrollVisibleService.isVerticalScrollShowing() &&
            ((o && e) || (!o && t))
              ? s + a
              : s
        this.comp.setPinnedContainerWidth(`${c}px`),
          this.comp.setDisplayed(!n),
          r && ((this.hidden = n), this.refresh())
      }
      this.addManagedEventListeners({
        leftPinnedWidthChanged: i,
        rightPinnedWidthChanged: i,
        scrollVisibilityChanged: i,
        scrollbarWidthChanged: i,
      })
    }
  },
  Pd = class extends X {
    constructor(e) {
      super(), (this.view = e)
    }
    postConstruct() {
      this.addManagedPropertyListener(
        'domLayout',
        this.updateLayoutClasses.bind(this),
      ),
        this.updateLayoutClasses()
    }
    updateLayoutClasses() {
      const e = this.getDomLayout(),
        t = {
          autoHeight: e === 'autoHeight',
          normal: e === 'normal',
          print: e === 'print',
        },
        i = t.autoHeight
          ? 'ag-layout-auto-height'
          : t.print
            ? 'ag-layout-print'
            : 'ag-layout-normal'
      this.view.updateLayoutClasses(i, t)
    }
    getDomLayout() {
      const e = this.gos.get('domLayout') ?? 'normal'
      return ['normal', 'print', 'autoHeight'].indexOf(e) === -1
        ? (te(
            `${e} is not valid for DOM Layout, valid values are 'normal', 'autoHeight', 'print'.`,
          ),
          'normal')
        : e
    }
  },
  YI = class extends yt {
    constructor() {
      super(`
            <div class="ag-overlay" role="presentation">
                <div class="ag-overlay-panel" role="presentation">
                    <div class="ag-overlay-wrapper" data-ref="eOverlayWrapper" role="presentation"></div>
                </div>
            </div>`),
        (this.eOverlayWrapper = Le),
        (this.activePromise = null),
        (this.activeOverlay = null),
        (this.updateListenerDestroyFunc = null),
        (this.activeOverlayWrapperCssClass = null),
        (this.elToFocusAfter = null)
    }
    wireBeans(e) {
      ;(this.overlayService = e.overlayService),
        (this.focusService = e.focusService),
        (this.visibleColsService = e.visibleColsService)
    }
    handleKeyDown(e) {
      if (
        e.key !== Y.TAB ||
        e.defaultPrevented ||
        Os(e) ||
        this.focusService.findNextFocusableElement(
          this.eOverlayWrapper,
          !1,
          e.shiftKey,
        )
      )
        return
      let i = !1
      e.shiftKey
        ? (i = this.focusService.focusGridView(
            rt(this.visibleColsService.getAllCols()),
            !0,
            !1,
          ))
        : (i = this.focusService.focusNextGridCoreContainer(!1)),
        i && e.preventDefault()
    }
    updateLayoutClasses(e, t) {
      const i = this.eOverlayWrapper.classList
      i.toggle('ag-layout-auto-height', t.autoHeight),
        i.toggle('ag-layout-normal', t.normal),
        i.toggle('ag-layout-print', t.print)
    }
    postConstruct() {
      this.createManagedBean(new Pd(this)),
        this.setDisplayed(!1, { skipAriaHidden: !0 }),
        this.overlayService.setOverlayWrapperComp(this),
        this.addManagedElementListeners(this.getFocusableElement(), {
          keydown: this.handleKeyDown.bind(this),
        })
    }
    setWrapperTypeClass(e) {
      const t = this.eOverlayWrapper.classList
      this.activeOverlayWrapperCssClass &&
        t.toggle(this.activeOverlayWrapperCssClass, !1),
        (this.activeOverlayWrapperCssClass = e),
        t.toggle(e, !0)
    }
    showOverlay(e, t, i, s) {
      if (
        (this.setWrapperTypeClass(t),
        this.destroyActiveOverlay(),
        (this.elToFocusAfter = null),
        (this.activePromise = e),
        !!e)
      ) {
        if (
          (this.setDisplayed(!0, { skipAriaHidden: !0 }),
          i && this.focusService.isGridFocused())
        ) {
          const n = Lt(this.gos)
          n && !Sm(this.gos) && (this.elToFocusAfter = n)
        }
        e.then((n) => {
          if (this.activePromise !== e) {
            this.activeOverlay !== n && (this.destroyBean(n), (n = null))
            return
          }
          if (((this.activePromise = null), !n)) return
          if (
            this.activeOverlay !== n &&
            (this.eOverlayWrapper.appendChild(n.getGui()),
            (this.activeOverlay = n),
            s)
          ) {
            const o = n
            this.updateListenerDestroyFunc = this.addManagedPropertyListener(
              s,
              ({ currentValue: a }) => {
                var l
                ;(l = o.refresh) == null ||
                  l.call(o, this.gos.addGridCommonParams({ ...(a ?? {}) }))
              },
            )
          }
          const r = this.focusService
          i && r.isGridFocused() && r.focusInto(this.eOverlayWrapper)
        })
      }
    }
    updateOverlayWrapperPaddingTop(e) {
      this.eOverlayWrapper.style.setProperty('padding-top', `${e}px`)
    }
    destroyActiveOverlay() {
      var s
      this.activePromise = null
      const e = this.activeOverlay
      if (!e) return
      let t = this.elToFocusAfter
      ;(this.activeOverlay = null),
        (this.elToFocusAfter = null),
        t && !this.focusService.isGridFocused() && (t = null)
      const i = this.updateListenerDestroyFunc
      i && (i(), (this.updateListenerDestroyFunc = null)),
        this.destroyBean(e),
        Ni(this.eOverlayWrapper),
        (s = t == null ? void 0 : t.focus) == null ||
          s.call(t, { preventScroll: !0 })
    }
    hideOverlay() {
      this.destroyActiveOverlay(), this.setDisplayed(!1, { skipAriaHidden: !0 })
    }
    destroy() {
      ;(this.elToFocusAfter = null),
        this.destroyActiveOverlay(),
        this.overlayService.setOverlayWrapperComp(void 0),
        super.destroy()
    }
  },
  Lv = class extends yt {
    constructor(e, t) {
      super(),
        (this.direction = t),
        (this.eViewport = Le),
        (this.eContainer = Le),
        (this.hideTimeout = null),
        this.setTemplate(e)
    }
    wireBeans(e) {
      this.animationFrameService = e.animationFrameService
    }
    postConstruct() {
      this.addManagedEventListeners({
        scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
      }),
        this.onScrollVisibilityChanged(),
        this.addOrRemoveCssClass('ag-apple-scrollbar', Wm() || fn())
    }
    initialiseInvisibleScrollbar() {
      this.invisibleScrollbar === void 0 &&
        ((this.invisibleScrollbar = zm()),
        this.invisibleScrollbar &&
          (this.hideAndShowInvisibleScrollAsNeeded(),
          this.addActiveListenerToggles()))
    }
    addActiveListenerToggles() {
      const e = this.getGui(),
        t = () => this.addOrRemoveCssClass('ag-scrollbar-active', !0),
        i = () => this.addOrRemoveCssClass('ag-scrollbar-active', !1)
      this.addManagedListeners(e, {
        mouseenter: t,
        mousedown: t,
        touchstart: t,
        mouseleave: i,
        touchend: i,
      })
    }
    onScrollVisibilityChanged() {
      this.invisibleScrollbar === void 0 && this.initialiseInvisibleScrollbar(),
        this.animationFrameService.requestAnimationFrame(() =>
          this.setScrollVisible(),
        )
    }
    hideAndShowInvisibleScrollAsNeeded() {
      this.addManagedEventListeners({
        bodyScroll: (e) => {
          e.direction === this.direction &&
            (this.hideTimeout !== null &&
              (window.clearTimeout(this.hideTimeout),
              (this.hideTimeout = null)),
            this.addOrRemoveCssClass('ag-scrollbar-scrolling', !0))
        },
        bodyScrollEnd: () => {
          this.hideTimeout = window.setTimeout(() => {
            this.addOrRemoveCssClass('ag-scrollbar-scrolling', !1),
              (this.hideTimeout = null)
          }, 400)
        },
      })
    }
    attemptSettingScrollPosition(e) {
      const t = this.getViewportElement()
      cx(
        () => fs(t),
        () => this.setScrollPosition(e),
        100,
      )
    }
    getViewportElement() {
      return this.eViewport
    }
    getContainer() {
      return this.eContainer
    }
    onScrollCallback(e) {
      this.addManagedElementListeners(this.getViewportElement(), { scroll: e })
    }
  },
  KI = class extends Lv {
    constructor() {
      super(
        `<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" data-ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" data-ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" data-ref="eRightSpacer"></div>
        </div>`,
        'horizontal',
      ),
        (this.eLeftSpacer = Le),
        (this.eRightSpacer = Le)
    }
    wireBeans(e) {
      super.wireBeans(e),
        (this.visibleColsService = e.visibleColsService),
        (this.pinnedRowModel = e.pinnedRowModel),
        (this.ctrlsService = e.ctrlsService),
        (this.scrollVisibleService = e.scrollVisibleService)
    }
    postConstruct() {
      super.postConstruct()
      const e = this.setFakeHScrollSpacerWidths.bind(this)
      this.addManagedEventListeners({
        displayedColumnsChanged: e,
        displayedColumnsWidthChanged: e,
        pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this),
      }),
        this.addManagedPropertyListener('domLayout', e),
        this.ctrlsService.register('fakeHScrollComp', this),
        this.createManagedBean(
          new Fd((t) => (this.eContainer.style.width = `${t}px`)),
        ),
        this.addManagedPropertyListeners(
          ['suppressHorizontalScroll'],
          this.onScrollVisibilityChanged.bind(this),
        )
    }
    initialiseInvisibleScrollbar() {
      this.invisibleScrollbar === void 0 &&
        ((this.enableRtl = this.gos.get('enableRtl')),
        super.initialiseInvisibleScrollbar(),
        this.invisibleScrollbar && this.refreshCompBottom())
    }
    onPinnedRowDataChanged() {
      this.refreshCompBottom()
    }
    refreshCompBottom() {
      if (!this.invisibleScrollbar) return
      const e = this.pinnedRowModel.getPinnedBottomTotalHeight()
      this.getGui().style.bottom = `${e}px`
    }
    onScrollVisibilityChanged() {
      super.onScrollVisibilityChanged(), this.setFakeHScrollSpacerWidths()
    }
    setFakeHScrollSpacerWidths() {
      const e = this.scrollVisibleService.isVerticalScrollShowing()
      let t = this.visibleColsService.getDisplayedColumnsRightWidth()
      const i = !this.enableRtl && e,
        s = this.scrollVisibleService.getScrollbarWidth()
      i && (t += s),
        Zi(this.eRightSpacer, t),
        this.eRightSpacer.classList.toggle('ag-scroller-corner', t <= s)
      let n = this.visibleColsService.getColsLeftWidth()
      this.enableRtl && e && (n += s),
        Zi(this.eLeftSpacer, n),
        this.eLeftSpacer.classList.toggle('ag-scroller-corner', n <= s)
    }
    setScrollVisible() {
      const e = this.scrollVisibleService.isHorizontalScrollShowing(),
        t = this.invisibleScrollbar,
        i = this.gos.get('suppressHorizontalScroll'),
        s = (e && this.scrollVisibleService.getScrollbarWidth()) || 0,
        r = i ? 0 : s === 0 && t ? 16 : s
      this.addOrRemoveCssClass('ag-scrollbar-invisible', t),
        oo(this.getGui(), r),
        oo(this.eViewport, r),
        oo(this.eContainer, r),
        this.setDisplayed(e, { skipAriaHidden: !0 })
    }
    getScrollPosition() {
      return Ba(this.getViewportElement(), this.enableRtl)
    }
    setScrollPosition(e) {
      fs(this.getViewportElement()) || this.attemptSettingScrollPosition(e),
        Va(this.getViewportElement(), e, this.enableRtl)
    }
  },
  kv = class extends X {
    wireBeans(e) {
      this.maxDivHeightScaler = e.rowContainerHeightService
    }
    constructor(e, t) {
      super(), (this.eContainer = e), (this.eViewport = t)
    }
    postConstruct() {
      this.addManagedEventListeners({
        rowContainerHeightChanged: this.onHeightChanged.bind(this),
      })
    }
    onHeightChanged() {
      const e = this.maxDivHeightScaler.getUiContainerHeight(),
        t = e != null ? `${e}px` : ''
      ;(this.eContainer.style.height = t),
        this.eViewport && (this.eViewport.style.height = t)
    }
  },
  qI = class extends Lv {
    wireBeans(e) {
      super.wireBeans(e),
        (this.ctrlsService = e.ctrlsService),
        (this.scrollVisibleService = e.scrollVisibleService)
    }
    constructor() {
      super(
        `<div class="ag-body-vertical-scroll" aria-hidden="true">
            <div class="ag-body-vertical-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-vertical-scroll-container" data-ref="eContainer"></div>
            </div>
        </div>`,
        'vertical',
      )
    }
    postConstruct() {
      super.postConstruct(),
        this.createManagedBean(new kv(this.eContainer)),
        this.ctrlsService.register('fakeVScrollComp', this),
        this.addManagedEventListeners({
          rowContainerHeightChanged:
            this.onRowContainerHeightChanged.bind(this),
        })
    }
    setScrollVisible() {
      const e = this.scrollVisibleService.isVerticalScrollShowing(),
        t = this.invisibleScrollbar,
        i = (e && this.scrollVisibleService.getScrollbarWidth()) || 0,
        s = i === 0 && t ? 16 : i
      this.addOrRemoveCssClass('ag-scrollbar-invisible', t),
        Zi(this.getGui(), s),
        Zi(this.eViewport, s),
        Zi(this.eContainer, s),
        this.setDisplayed(e, { skipAriaHidden: !0 })
    }
    onRowContainerHeightChanged() {
      const { ctrlsService: e } = this,
        i = e.getGridBodyCtrl().getBodyViewportElement(),
        s = this.getScrollPosition(),
        n = i.scrollTop
      s != n && this.setScrollPosition(n, !0)
    }
    getScrollPosition() {
      return this.getViewportElement().scrollTop
    }
    setScrollPosition(e, t) {
      !t &&
        !fs(this.getViewportElement()) &&
        this.attemptSettingScrollPosition(e),
        (this.getViewportElement().scrollTop = e)
    }
  },
  ou = ((e) => (
    (e.FakeHScrollbar = 'fakeHScrollComp'),
    (e.Header = 'centerHeader'),
    (e.PinnedTop = 'topCenter'),
    (e.PinnedBottom = 'bottomCenter'),
    (e.StickyTop = 'stickyTopCenter'),
    (e.StickyBottom = 'stickyBottomCenter'),
    e
  ))(ou || {}),
  QI = class extends X {
    constructor(e) {
      super(),
        (this.lastScrollSource = [null, null]),
        (this.scrollLeft = -1),
        (this.nextScrollTop = -1),
        (this.scrollTop = -1),
        (this.lastOffsetHeight = -1),
        (this.lastScrollTop = -1),
        (this.eBodyViewport = e),
        (this.resetLastHScrollDebounced = bi(
          () => (this.lastScrollSource[1] = null),
          500,
        )),
        (this.resetLastVScrollDebounced = bi(
          () => (this.lastScrollSource[0] = null),
          500,
        ))
    }
    wireBeans(e) {
      ;(this.ctrlsService = e.ctrlsService),
        (this.animationFrameService = e.animationFrameService),
        (this.paginationService = e.paginationService),
        (this.pageBoundsService = e.pageBoundsService),
        (this.rowModel = e.rowModel),
        (this.heightScaler = e.rowContainerHeightService),
        (this.rowRenderer = e.rowRenderer),
        (this.columnModel = e.columnModel),
        (this.visibleColsService = e.visibleColsService)
    }
    postConstruct() {
      ;(this.enableRtl = this.gos.get('enableRtl')),
        this.addManagedEventListeners({
          displayedColumnsWidthChanged:
            this.onDisplayedColumnsWidthChanged.bind(this),
        }),
        this.ctrlsService.whenReady(this, (e) => {
          ;(this.centerRowsCtrl = e.center),
            this.onDisplayedColumnsWidthChanged(),
            this.addScrollListener()
        })
    }
    addScrollListener() {
      this.addHorizontalScrollListeners(), this.addVerticalScrollListeners()
    }
    addHorizontalScrollListeners() {
      this.addManagedElementListeners(
        this.centerRowsCtrl.getViewportElement(),
        { scroll: this.onHScroll.bind(this, 'Viewport') },
      )
      for (const e of Object.values(ou)) {
        const t = this.ctrlsService.get(e)
        this.registerScrollPartner(t, this.onHScroll.bind(this, e))
      }
    }
    addVerticalScrollListeners() {
      const e = this.ctrlsService.get('fakeVScrollComp'),
        t = this.gos.get('debounceVerticalScrollbar'),
        i = t
          ? bi(this.onVScroll.bind(this, 'Viewport'), 100)
          : this.onVScroll.bind(this, 'Viewport'),
        s = t
          ? bi(this.onVScroll.bind(this, 'fakeVScrollComp'), 100)
          : this.onVScroll.bind(this, 'fakeVScrollComp')
      this.addManagedElementListeners(this.eBodyViewport, { scroll: i }),
        this.registerScrollPartner(e, s)
    }
    registerScrollPartner(e, t) {
      e.onScrollCallback(t)
    }
    onDisplayedColumnsWidthChanged() {
      this.enableRtl && this.horizontallyScrollHeaderCenterAndFloatingCenter()
    }
    horizontallyScrollHeaderCenterAndFloatingCenter(e) {
      this.centerRowsCtrl != null &&
        (e === void 0 &&
          (e = this.centerRowsCtrl.getCenterViewportScrollLeft()),
        this.setScrollLeftForAllContainersExceptCurrent(Math.abs(e)))
    }
    setScrollLeftForAllContainersExceptCurrent(e) {
      for (const t of [...Object.values(ou), 'Viewport']) {
        if (this.lastScrollSource[1] === t) continue
        const i = this.getViewportForSource(t)
        Va(i, e, this.enableRtl)
      }
    }
    getViewportForSource(e) {
      return e === 'Viewport'
        ? this.centerRowsCtrl.getViewportElement()
        : this.ctrlsService.get(e).getViewportElement()
    }
    isControllingScroll(e, t) {
      return this.lastScrollSource[t] == null
        ? (t === 0
            ? (this.lastScrollSource[0] = e)
            : (this.lastScrollSource[1] = e),
          !0)
        : this.lastScrollSource[t] === e
    }
    onHScroll(e) {
      if (!this.isControllingScroll(e, 1)) return
      const t = this.centerRowsCtrl.getViewportElement(),
        { scrollLeft: i } = t
      if (this.shouldBlockScrollUpdate(1, i, !0)) return
      const s = Ba(this.getViewportForSource(e), this.enableRtl)
      this.doHorizontalScroll(s), this.resetLastHScrollDebounced()
    }
    onVScroll(e) {
      if (!this.isControllingScroll(e, 0)) return
      let t
      e === 'Viewport'
        ? (t = this.eBodyViewport.scrollTop)
        : (t = this.ctrlsService.get('fakeVScrollComp').getScrollPosition()),
        !this.shouldBlockScrollUpdate(0, t, !0) &&
          (this.animationFrameService.setScrollTop(t),
          (this.nextScrollTop = t),
          e === 'Viewport'
            ? this.ctrlsService.get('fakeVScrollComp').setScrollPosition(t)
            : (this.eBodyViewport.scrollTop = t),
          this.gos.get('suppressAnimationFrame')
            ? this.scrollGridIfNeeded()
            : this.animationFrameService.schedule(),
          this.resetLastVScrollDebounced())
    }
    doHorizontalScroll(e) {
      const t = this.ctrlsService.get('fakeHScrollComp').getScrollPosition()
      ;(this.scrollLeft === e && e === t) ||
        ((this.scrollLeft = e),
        this.fireScrollEvent(1),
        this.horizontallyScrollHeaderCenterAndFloatingCenter(e),
        this.centerRowsCtrl.onHorizontalViewportChanged(!0))
    }
    fireScrollEvent(e) {
      const t = {
        type: 'bodyScroll',
        direction: e === 1 ? 'horizontal' : 'vertical',
        left: this.scrollLeft,
        top: this.scrollTop,
      }
      this.eventService.dispatchEvent(t),
        window.clearTimeout(this.scrollTimer),
        (this.scrollTimer = void 0),
        (this.scrollTimer = window.setTimeout(() => {
          this.eventService.dispatchEvent({ ...t, type: 'bodyScrollEnd' })
        }, 100))
    }
    shouldBlockScrollUpdate(e, t, i = !1) {
      return i && !fn()
        ? !1
        : e === 0
          ? this.shouldBlockVerticalScroll(t)
          : this.shouldBlockHorizontalScroll(t)
    }
    shouldBlockVerticalScroll(e) {
      const t = cd(this.eBodyViewport),
        { scrollHeight: i } = this.eBodyViewport
      return e < 0 || e + t > i
    }
    shouldBlockHorizontalScroll(e) {
      const t = this.centerRowsCtrl.getCenterWidth(),
        { scrollWidth: i } = this.centerRowsCtrl.getViewportElement()
      if (this.enableRtl && Ga()) {
        if (e > 0) return !0
      } else if (e < 0) return !0
      return Math.abs(e) + t > i
    }
    redrawRowsAfterScroll() {
      this.fireScrollEvent(0)
    }
    checkScrollLeft() {
      this.scrollLeft !== this.centerRowsCtrl.getCenterViewportScrollLeft() &&
        this.onHScroll('Viewport')
    }
    scrollGridIfNeeded() {
      const e = this.scrollTop != this.nextScrollTop
      return (
        e &&
          ((this.scrollTop = this.nextScrollTop), this.redrawRowsAfterScroll()),
        e
      )
    }
    setHorizontalScrollPosition(e, t = !1) {
      const s =
        this.centerRowsCtrl.getViewportElement().scrollWidth -
        this.centerRowsCtrl.getCenterWidth()
      !t &&
        this.shouldBlockScrollUpdate(1, e) &&
        (this.enableRtl && Ga()
          ? (e = e > 0 ? 0 : s)
          : (e = Math.min(Math.max(e, 0), s))),
        Va(
          this.centerRowsCtrl.getViewportElement(),
          Math.abs(e),
          this.enableRtl,
        ),
        this.doHorizontalScroll(e)
    }
    setVerticalScrollPosition(e) {
      this.eBodyViewport.scrollTop = e
    }
    getVScrollPosition() {
      return (
        (this.lastScrollTop = this.eBodyViewport.scrollTop),
        (this.lastOffsetHeight = this.eBodyViewport.offsetHeight),
        {
          top: this.lastScrollTop,
          bottom: this.lastScrollTop + this.lastOffsetHeight,
        }
      )
    }
    getApproximateVScollPosition() {
      return this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0
        ? {
            top: this.scrollTop,
            bottom: this.scrollTop + this.lastOffsetHeight,
          }
        : this.getVScrollPosition()
    }
    getHScrollPosition() {
      return this.centerRowsCtrl.getHScrollPosition()
    }
    isHorizontalScrollShowing() {
      return this.centerRowsCtrl.isHorizontalScrollShowing()
    }
    scrollHorizontally(e) {
      const t = this.centerRowsCtrl.getViewportElement().scrollLeft
      return (
        this.setHorizontalScrollPosition(t + e),
        this.centerRowsCtrl.getViewportElement().scrollLeft - t
      )
    }
    scrollToTop() {
      this.eBodyViewport.scrollTop = 0
    }
    ensureNodeVisible(e, t = null) {
      const i = this.rowModel.getRowCount()
      let s = -1
      for (let n = 0; n < i; n++) {
        const r = this.rowModel.getRow(n)
        if (typeof e == 'function') {
          if (r && e(r)) {
            s = n
            break
          }
        } else if (e === r || e === r.data) {
          s = n
          break
        }
      }
      s >= 0 && this.ensureIndexVisible(s, t)
    }
    ensureIndexVisible(e, t) {
      if (ci(this.gos, 'print')) return
      const i = this.rowModel.getRowCount()
      if (typeof e != 'number' || e < 0 || e >= i) {
        te('Invalid row index for ensureIndexVisible: ' + e)
        return
      }
      const n =
        this.gos.get('pagination') && !this.gos.get('suppressPaginationPanel')
      this.getFrameworkOverrides().wrapIncoming(() => {
        var u
        n || (u = this.paginationService) == null || u.goToPageWithIndex(e)
        const r = this.ctrlsService.getGridBodyCtrl(),
          o = r.getStickyTopHeight(),
          a = r.getStickyBottomHeight(),
          l = this.rowModel.getRow(e)
        let c
        do {
          const h = l.rowTop,
            g = l.rowHeight,
            f = this.pageBoundsService.getPixelOffset(),
            p = l.rowTop - f,
            v = p + l.rowHeight,
            m = this.getVScrollPosition(),
            C = this.heightScaler.getDivStretchOffset(),
            w = m.top + C,
            S = m.bottom + C,
            y = S - w,
            F = this.heightScaler.getScrollPositionForPixel(p),
            R = this.heightScaler.getScrollPositionForPixel(v - y),
            b = Math.min((F + R) / 2, p),
            x = w + o > p,
            D = S - a < v
          let O = null
          t === 'top'
            ? (O = F)
            : t === 'bottom'
              ? (O = R)
              : t === 'middle'
                ? (O = b)
                : x
                  ? (O = F - o)
                  : D && (O = R + a),
            O !== null &&
              (this.setVerticalScrollPosition(O),
              this.rowRenderer.redraw({ afterScroll: !0 })),
            (c = h !== l.rowTop || g !== l.rowHeight)
        } while (c)
        this.animationFrameService.flushAllFrames()
      })
    }
    ensureColumnVisible(e, t = 'auto') {
      const i = this.columnModel.getCol(e)
      if (!i || i.isPinned() || !this.visibleColsService.isColDisplayed(i))
        return
      const s = this.getPositionedHorizontalScroll(i, t)
      this.getFrameworkOverrides().wrapIncoming(() => {
        s !== null && this.centerRowsCtrl.setCenterViewportScrollLeft(s),
          this.centerRowsCtrl.onHorizontalViewportChanged(),
          this.animationFrameService.flushAllFrames()
      })
    }
    setScrollPosition(e, t) {
      this.getFrameworkOverrides().wrapIncoming(() => {
        this.centerRowsCtrl.setCenterViewportScrollLeft(t),
          this.setVerticalScrollPosition(e),
          this.rowRenderer.redraw({ afterScroll: !0 }),
          this.animationFrameService.flushAllFrames()
      })
    }
    getPositionedHorizontalScroll(e, t) {
      const { columnBeforeStart: i, columnAfterEnd: s } =
          this.isColumnOutsideViewport(e),
        n = this.centerRowsCtrl.getCenterWidth() < e.getActualWidth(),
        r = this.centerRowsCtrl.getCenterWidth(),
        o = this.enableRtl
      let a = (o ? i : s) || n,
        l = o ? s : i
      t !== 'auto' && ((a = t === 'start'), (l = t === 'end'))
      const c = t === 'middle'
      if (a || l || c) {
        const {
          colLeft: u,
          colMiddle: h,
          colRight: g,
        } = this.getColumnBounds(e)
        return c ? h - r / 2 : a ? (o ? g : u) : o ? u - r : g - r
      }
      return null
    }
    isColumnOutsideViewport(e) {
      const { start: t, end: i } = this.getViewportBounds(),
        { colLeft: s, colRight: n } = this.getColumnBounds(e),
        r = this.enableRtl,
        o = r ? t > n : i < n,
        a = r ? i < s : t > s
      return { columnBeforeStart: o, columnAfterEnd: a }
    }
    getColumnBounds(e) {
      const t = this.enableRtl,
        i = this.visibleColsService.getBodyContainerWidth(),
        s = e.getActualWidth(),
        n = e.getLeft(),
        r = t ? -1 : 1,
        o = t ? i - n : n,
        a = o + s * r,
        l = o + (s / 2) * r
      return { colLeft: o, colMiddle: l, colRight: a }
    }
    getViewportBounds() {
      const e = this.centerRowsCtrl.getCenterWidth(),
        t = this.centerRowsCtrl.getCenterViewportScrollLeft(),
        i = t,
        s = e + t
      return { start: i, end: s, width: e }
    }
  },
  XI = class extends X {
    wireBeans(e) {
      ;(this.animationFrameService = e.animationFrameService),
        (this.ctrlsService = e.ctrlsService),
        (this.pinnedWidthService = e.pinnedWidthService),
        (this.columnModel = e.columnModel),
        (this.visibleColsService = e.visibleColsService),
        (this.columnSizeService = e.columnSizeService),
        (this.scrollVisibleService = e.scrollVisibleService),
        (this.columnViewportService = e.columnViewportService)
    }
    constructor(e) {
      super(), (this.centerContainerCtrl = e)
    }
    postConstruct() {
      this.ctrlsService.whenReady(this, (e) => {
        ;(this.gridBodyCtrl = e.gridBodyCtrl), this.listenForResize()
      }),
        this.addManagedEventListeners({
          scrollbarWidthChanged: this.onScrollbarWidthChanged.bind(this),
        }),
        this.addManagedPropertyListeners(
          ['alwaysShowHorizontalScroll', 'alwaysShowVerticalScroll'],
          () => {
            this.checkViewportAndScrolls()
          },
        )
    }
    listenForResize() {
      const e = () => {
        this.animationFrameService.requestAnimationFrame(() => {
          this.onCenterViewportResized()
        })
      }
      this.centerContainerCtrl.registerViewportResizeListener(e),
        this.gridBodyCtrl.registerBodyViewportResizeListener(e)
    }
    onScrollbarWidthChanged() {
      this.checkViewportAndScrolls()
    }
    onCenterViewportResized() {
      if (
        (this.scrollVisibleService.onCentreViewportResized(),
        this.centerContainerCtrl.isViewportInTheDOMTree())
      ) {
        this.keepPinnedColumnsNarrowerThanViewport(),
          this.checkViewportAndScrolls()
        const e = this.centerContainerCtrl.getCenterWidth()
        e !== this.centerWidth &&
          ((this.centerWidth = e),
          this.columnSizeService.refreshFlexedColumns({
            viewportWidth: this.centerWidth,
            updateBodyWidths: !0,
            fireResizedEvent: !0,
          }))
      } else this.bodyHeight = 0
    }
    keepPinnedColumnsNarrowerThanViewport() {
      const e = this.gridBodyCtrl.getBodyViewportElement(),
        t = No(e)
      if (t <= 50) return
      let i = this.getPinnedColumnsOverflowingViewport(t - 50)
      const s = this.gos.getCallback('processUnpinnedColumns')
      i.length &&
        (s && (i = s({ columns: i, viewportWidth: t })),
        this.columnModel.setColsPinned(i, null, 'viewportSizeFeature'))
    }
    getPinnedColumnsOverflowingViewport(e) {
      const t = this.pinnedWidthService.getPinnedRightWidth(),
        i = this.pinnedWidthService.getPinnedLeftWidth(),
        s = t + i
      if (s < e) return []
      const n = [...this.visibleColsService.getLeftCols()],
        r = [...this.visibleColsService.getRightCols()]
      let o = 0,
        a = 0
      const l = 0,
        c = []
      let u = s - l - e
      for (; (a < n.length || o < r.length) && u > 0; ) {
        if (o < r.length) {
          const h = r[o++]
          ;(u -= h.getActualWidth()), c.push(h)
        }
        if (a < n.length && u > 0) {
          const h = n[a++]
          ;(u -= h.getActualWidth()), c.push(h)
        }
      }
      return c
    }
    checkViewportAndScrolls() {
      this.updateScrollVisibleService(),
        this.checkBodyHeight(),
        this.onHorizontalViewportChanged(),
        this.gridBodyCtrl.getScrollFeature().checkScrollLeft()
    }
    getBodyHeight() {
      return this.bodyHeight
    }
    checkBodyHeight() {
      const e = this.gridBodyCtrl.getBodyViewportElement(),
        t = cd(e)
      this.bodyHeight !== t &&
        ((this.bodyHeight = t),
        this.eventService.dispatchEvent({ type: 'bodyHeightChanged' }))
    }
    updateScrollVisibleService() {
      this.updateScrollVisibleServiceImpl(),
        setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500)
    }
    updateScrollVisibleServiceImpl() {
      const e = {
        horizontalScrollShowing: this.isHorizontalScrollShowing(),
        verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing(),
      }
      this.scrollVisibleService.setScrollsVisible(e)
    }
    isHorizontalScrollShowing() {
      return this.centerContainerCtrl.isHorizontalScrollShowing()
    }
    onHorizontalViewportChanged() {
      const e = this.centerContainerCtrl.getCenterWidth(),
        t = this.centerContainerCtrl.getViewportScrollLeft()
      this.columnViewportService.setScrollPosition(e, t)
    }
  },
  JI = class extends X {
    wireBeans(e) {
      ;(this.dragService = e.dragService), (this.rangeService = e.rangeService)
    }
    constructor(e) {
      super(), (this.eContainer = e)
    }
    postConstruct() {
      if (!this.rangeService) return
      ;(this.params = {
        eElement: this.eContainer,
        onDragStart: this.rangeService.onDragStart.bind(this.rangeService),
        onDragStop: this.rangeService.onDragStop.bind(this.rangeService),
        onDragging: this.rangeService.onDragging.bind(this.rangeService),
      }),
        this.addManagedPropertyListeners(
          ['enableRangeSelection', 'cellSelection'],
          () => {
            Vs(this.gos) ? this.enableFeature() : this.disableFeature()
          },
        ),
        this.addDestroyFunc(() => this.disableFeature()),
        Vs(this.gos) && this.enableFeature()
    }
    enableFeature() {
      this.dragService.addDragSource(this.params)
    }
    disableFeature() {
      this.dragService.removeDragSource(this.params)
    }
  },
  ZI = class extends yt {
    constructor() {
      super(
        `
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
        [fd],
      ),
        (this.eCheckbox = Le)
    }
    postConstruct() {
      this.eCheckbox.setPassive(!0)
    }
    getCheckboxId() {
      return this.eCheckbox.getInputElement().id
    }
    onDataChanged() {
      this.onSelectionChanged()
    }
    onSelectableChanged() {
      this.showOrHideSelect()
    }
    onSelectionChanged() {
      const e = this.localeService.getLocaleTextFunc(),
        t = this.rowNode.isSelected(),
        i = rd(e, t),
        [s, n] = this.rowNode.selectable
          ? ['ariaRowToggleSelection', 'Press Space to toggle row selection']
          : [
              'ariaRowSelectionDisabled',
              'Row Selection is disabled for this row',
            ],
        r = e(s, n)
      this.eCheckbox.setValue(t, !0),
        this.eCheckbox.setInputAriaLabel(`${r} (${i})`)
    }
    onClicked(e, t, i) {
      return this.rowNode.setSelectedParams({
        newValue: e,
        rangeSelect: i.shiftKey,
        groupSelectsFiltered: t,
        event: i,
        source: 'checkboxSelected',
      })
    }
    init(e) {
      if (
        ((this.rowNode = e.rowNode),
        (this.column = e.column),
        (this.overrides = e.overrides),
        this.onSelectionChanged(),
        this.addManagedListeners(this.eCheckbox.getInputElement(), {
          dblclick: (s) => pr(s),
          click: (s) => {
            pr(s)
            const n = ed(this.gos) === 'filteredDescendants',
              r = this.eCheckbox.getValue()
            this.shouldHandleIndeterminateState(r, n)
              ? this.onClicked(!0, n, s || {}) === 0 && this.onClicked(!1, n, s)
              : r
                ? this.onClicked(!1, n, s)
                : this.onClicked(!0, n, s || {})
          },
        }),
        this.addManagedListeners(this.rowNode, {
          rowSelected: this.onSelectionChanged.bind(this),
          dataChanged: this.onDataChanged.bind(this),
          selectableChanged: this.onSelectableChanged.bind(this),
        }),
        Zu(this.gos) || typeof this.getIsVisible() == 'function')
      ) {
        const s = this.showOrHideSelect.bind(this)
        this.addManagedEventListeners({ displayedColumnsChanged: s }),
          this.addManagedListeners(this.rowNode, {
            dataChanged: s,
            cellChanged: s,
          }),
          this.showOrHideSelect()
      }
      this.eCheckbox.getInputElement().setAttribute('tabindex', '-1')
    }
    shouldHandleIndeterminateState(e, t) {
      return (
        t &&
        (this.eCheckbox.getPreviousValue() === void 0 || e === void 0) &&
        Pt(this.gos)
      )
    }
    showOrHideSelect() {
      var n, r, o
      let e = this.rowNode.selectable
      const t = this.getIsVisible()
      if (e)
        if (typeof t == 'function') {
          const a = (n = this.overrides) == null ? void 0 : n.callbackParams
          if (!this.column)
            e = t({ ...a, node: this.rowNode, data: this.rowNode.data })
          else {
            const l = this.column.createColumnFunctionCallbackParams(
              this.rowNode,
            )
            e = t({ ...a, ...l })
          }
        } else e = t ?? !1
      const i = this.gos.get('rowSelection')
      if (
        i && typeof i != 'string'
          ? !fx(i)
          : (r = this.column) == null
            ? void 0
            : r.getColDef().showDisabledCheckboxes
      ) {
        this.eCheckbox.setDisabled(!e),
          this.setVisible(!0),
          this.setDisplayed(!0)
        return
      }
      if ((o = this.overrides) != null && o.removeHidden) {
        this.setDisplayed(e)
        return
      }
      this.setVisible(e)
    }
    getIsVisible() {
      var t, i
      if (this.overrides) return this.overrides.isVisible
      const e = this.gos.get('rowSelection')
      return e && typeof e != 'string'
        ? fr(e)
        : (i = (t = this.column) == null ? void 0 : t.getColDef()) == null
          ? void 0
          : i.checkboxSelection
    }
  },
  eT = class extends yt {
    constructor(e, t, i) {
      super('<div class="ag-drag-handle ag-row-drag" draggable="true"></div>'),
        (this.rowNode = e),
        (this.column = t),
        (this.eCell = i)
    }
    postConstruct() {
      this.getGui().appendChild(Li('rowDrag', this.gos, null)),
        this.addGuiEventListener('mousedown', (t) => {
          t.stopPropagation()
        }),
        this.addDragSource(),
        this.checkVisibility()
    }
    addDragSource() {
      this.addGuiEventListener('dragstart', this.onDragStart.bind(this))
    }
    onDragStart(e) {
      const t = this.column.getColDef().dndSourceOnRowDrag
      e.dataTransfer.setDragImage(this.eCell, 0, 0)
      const i = () => {
        try {
          const s = JSON.stringify(this.rowNode.data)
          e.dataTransfer.setData('application/json', s),
            e.dataTransfer.setData('text/plain', s)
        } catch {}
      }
      if (t) {
        const s = this.gos.addGridCommonParams({
          rowNode: this.rowNode,
          dragEvent: e,
        })
        t(s)
      } else i()
    }
    checkVisibility() {
      const e = this.column.isDndSource(this.rowNode)
      this.setDisplayed(e)
    }
  },
  tT = class extends X {
    constructor(e, t) {
      super(),
        (this.staticClasses = []),
        (this.cellCtrl = e),
        (this.beans = t),
        (this.column = e.getColumn()),
        (this.rowNode = e.getRowNode())
    }
    setComp(e) {
      ;(this.cellComp = e),
        this.applyUserStyles(),
        this.applyCellClassRules(),
        this.applyClassesFromColDef()
    }
    applyCellClassRules() {
      const e = this.column.getColDef(),
        { cellClassRules: t } = e,
        i = this.beans.gos.addGridCommonParams({
          value: this.cellCtrl.getValue(),
          data: this.rowNode.data,
          node: this.rowNode,
          colDef: e,
          column: this.column,
          rowIndex: this.rowNode.rowIndex,
        })
      this.beans.stylingService.processClassRules(
        t === this.cellClassRules ? void 0 : this.cellClassRules,
        t,
        i,
        (s) => this.cellComp.addOrRemoveCssClass(s, !0),
        (s) => this.cellComp.addOrRemoveCssClass(s, !1),
      ),
        (this.cellClassRules = t)
    }
    applyUserStyles() {
      const e = this.column.getColDef()
      if (!e.cellStyle) return
      let t
      if (typeof e.cellStyle == 'function') {
        const i = this.beans.gos.addGridCommonParams({
            column: this.column,
            value: this.cellCtrl.getValue(),
            colDef: e,
            data: this.rowNode.data,
            node: this.rowNode,
            rowIndex: this.rowNode.rowIndex,
          }),
          s = e.cellStyle
        t = s(i)
      } else t = e.cellStyle
      t && this.cellComp.setUserStyles(t)
    }
    applyClassesFromColDef() {
      const e = this.column.getColDef(),
        t = this.beans.gos.addGridCommonParams({
          value: this.cellCtrl.getValue(),
          data: this.rowNode.data,
          node: this.rowNode,
          column: this.column,
          colDef: e,
          rowIndex: this.rowNode.rowIndex,
        })
      this.staticClasses.length &&
        this.staticClasses.forEach((i) =>
          this.cellComp.addOrRemoveCssClass(i, !1),
        ),
        (this.staticClasses = this.beans.stylingService.getStaticCellClasses(
          e,
          t,
        )),
        this.staticClasses.length &&
          this.staticClasses.forEach((i) =>
            this.cellComp.addOrRemoveCssClass(i, !0),
          )
    }
    destroy() {
      super.destroy()
    }
  },
  iT = class extends X {
    constructor(e, t, i, s, n) {
      super(),
        (this.cellCtrl = e),
        (this.beans = t),
        (this.rowNode = s),
        (this.rowCtrl = n)
    }
    setComp(e) {
      this.eGui = e
    }
    onKeyDown(e) {
      const t = e.key
      switch (t) {
        case Y.ENTER:
          this.onEnterKeyDown(e)
          break
        case Y.F2:
          this.onF2KeyDown(e)
          break
        case Y.ESCAPE:
          this.onEscapeKeyDown(e)
          break
        case Y.TAB:
          this.onTabKeyDown(e)
          break
        case Y.BACKSPACE:
        case Y.DELETE:
          this.onBackspaceOrDeleteKeyDown(t, e)
          break
        case Y.DOWN:
        case Y.UP:
        case Y.RIGHT:
        case Y.LEFT:
          this.onNavigationKeyDown(e, t)
          break
      }
    }
    onNavigationKeyDown(e, t) {
      this.cellCtrl.isEditing() ||
        (e.shiftKey && this.cellCtrl.isRangeSelectionEnabled()
          ? this.onShiftRangeSelect(e)
          : this.beans.navigationService.navigateToNextCell(
              e,
              t,
              this.cellCtrl.getCellPosition(),
              !0,
            ),
        e.preventDefault())
    }
    onShiftRangeSelect(e) {
      if (!this.beans.rangeService) return
      const t = this.beans.rangeService.extendLatestRangeInDirection(e)
      t && this.beans.navigationService.ensureCellVisible(t)
    }
    onTabKeyDown(e) {
      this.beans.navigationService.onTabKeyDown(this.cellCtrl, e)
    }
    onBackspaceOrDeleteKeyDown(e, t) {
      const { cellCtrl: i, beans: s, rowNode: n } = this,
        { gos: r, rangeService: o, eventService: a } = s
      if (!i.isEditing()) {
        if (
          (a.dispatchEvent({ type: 'keyShortcutChangedCellStart' }),
          GM(e, r.get('enableCellEditingOnBackspace')))
        ) {
          if (o && Vs(r))
            o.clearCellRangeCellValues({
              dispatchWrapperEvents: !0,
              wrapperEventSource: 'deleteKey',
            })
          else if (i.isCellEditable()) {
            const l = i.getColumn(),
              c = this.beans.valueService.getDeleteValue(l, n)
            n.setDataValue(l, c, 'cellClear')
          }
        } else i.startRowOrCellEdit(e, t)
        a.dispatchEvent({ type: 'keyShortcutChangedCellEnd' })
      }
    }
    onEnterKeyDown(e) {
      if (this.cellCtrl.isEditing() || this.rowCtrl.isEditing())
        this.cellCtrl.stopEditingAndFocus(!1, e.shiftKey)
      else if (this.beans.gos.get('enterNavigatesVertically')) {
        const t = e.shiftKey ? Y.UP : Y.DOWN
        this.beans.navigationService.navigateToNextCell(
          null,
          t,
          this.cellCtrl.getCellPosition(),
          !1,
        )
      } else
        this.cellCtrl.startRowOrCellEdit(Y.ENTER, e),
          this.cellCtrl.isEditing() && e.preventDefault()
    }
    onF2KeyDown(e) {
      this.cellCtrl.isEditing() || this.cellCtrl.startRowOrCellEdit(Y.F2, e)
    }
    onEscapeKeyDown(e) {
      this.cellCtrl.isEditing() &&
        (this.cellCtrl.stopRowOrCellEdit(!0), this.cellCtrl.focusCell(!0))
    }
    processCharacter(e) {
      if (e.target !== this.eGui || this.cellCtrl.isEditing()) return
      const s = e.key
      s === ' '
        ? this.onSpaceKeyDown(e)
        : this.cellCtrl.startRowOrCellEdit(s, e) && e.preventDefault()
    }
    onSpaceKeyDown(e) {
      const { gos: t } = this.beans
      if (!this.cellCtrl.isEditing() && Ia(t)) {
        const i = this.rowNode.isSelected(),
          s = !i,
          n = ed(t) === 'filteredDescendants',
          r = this.rowNode.setSelectedParams({
            newValue: s,
            rangeSelect: e.shiftKey,
            groupSelectsFiltered: n,
            event: e,
            source: 'spaceKey',
          })
        i === void 0 &&
          r === 0 &&
          this.rowNode.setSelectedParams({
            newValue: !1,
            rangeSelect: e.shiftKey,
            groupSelectsFiltered: n,
            event: e,
            source: 'spaceKey',
          })
      }
      e.preventDefault()
    }
    destroy() {
      super.destroy()
    }
  },
  sT = class extends X {
    constructor(e, t, i) {
      super(), (this.cellCtrl = e), (this.beans = t), (this.column = i)
    }
    onMouseEvent(e, t) {
      if (!Os(t))
        switch (e) {
          case 'click':
            this.onCellClicked(t)
            break
          case 'mousedown':
          case 'touchstart':
            this.onMouseDown(t)
            break
          case 'dblclick':
            this.onCellDoubleClicked(t)
            break
          case 'mouseout':
            this.onMouseOut(t)
            break
          case 'mouseover':
            this.onMouseOver(t)
            break
        }
    }
    onCellClicked(e) {
      if (this.isDoubleClickOnIPad()) {
        this.onCellDoubleClicked(e), e.preventDefault()
        return
      }
      const { eventService: t, rangeService: i, gos: s } = this.beans,
        n = e.ctrlKey || e.metaKey
      i &&
        n &&
        i.getCellRangeCount(this.cellCtrl.getCellPosition()) > 1 &&
        i.intersectLastRange(!0)
      const r = this.cellCtrl.createEvent(e, 'cellClicked')
      t.dispatchEvent(r)
      const o = this.column.getColDef()
      o.onCellClicked &&
        window.setTimeout(() => {
          this.beans.frameworkOverrides.wrapOutgoing(() => {
            o.onCellClicked(r)
          })
        }, 0),
        (s.get('singleClickEdit') || o.singleClickEdit) &&
          !s.get('suppressClickEdit') &&
          !(
            e.shiftKey && (i == null ? void 0 : i.getCellRanges().length) != 0
          ) &&
          this.cellCtrl.startRowOrCellEdit()
    }
    isDoubleClickOnIPad() {
      if (!fn() || Dm('dblclick')) return !1
      const e = new Date().getTime(),
        t = e - this.lastIPadMouseClickEvent < 200
      return (this.lastIPadMouseClickEvent = e), t
    }
    onCellDoubleClicked(e) {
      const { column: t, beans: i, cellCtrl: s } = this,
        { eventService: n, frameworkOverrides: r, gos: o } = i,
        a = t.getColDef(),
        l = s.createEvent(e, 'cellDoubleClicked')
      n.dispatchEvent(l),
        typeof a.onCellDoubleClicked == 'function' &&
          window.setTimeout(() => {
            r.wrapOutgoing(() => {
              a.onCellDoubleClicked(l)
            })
          }, 0),
        !o.get('singleClickEdit') &&
          !o.get('suppressClickEdit') &&
          s.startRowOrCellEdit(null, e)
    }
    onMouseDown(e) {
      const { ctrlKey: t, metaKey: i, shiftKey: s } = e,
        n = e.target,
        { cellCtrl: r, beans: o } = this,
        { eventService: a, rangeService: l, focusService: c, gos: u } = o
      if (this.isRightClickInExistingRange(e)) return
      const h = l && l.getCellRanges().length != 0
      if (!s || !h) {
        const f = u.get('enableCellTextSelection') && e.defaultPrevented,
          p = (gs() || f) && !r.isEditing() && !ld(n)
        r.focusCell(p)
      }
      if (s && h && !c.isCellFocused(r.getCellPosition())) {
        e.preventDefault()
        const g = c.getFocusedCell()
        if (g) {
          const { column: f, rowIndex: p, rowPinned: v } = g,
            m = o.rowRenderer.getRowByPosition({ rowIndex: p, rowPinned: v }),
            C = m == null ? void 0 : m.getCellCtrl(f)
          C != null && C.isEditing() && C.stopEditing(),
            c.setFocusedCell({
              column: f,
              rowIndex: p,
              rowPinned: v,
              forceBrowserFocus: !0,
              preventScrollOnBrowserFocus: !0,
            })
        }
      }
      if (!this.containsWidget(n)) {
        if (l) {
          const g = this.cellCtrl.getCellPosition()
          if (s) l.extendLatestRangeToCell(g)
          else {
            const f = t || i
            l.setRangeToCell(g, f)
          }
        }
        a.dispatchEvent(this.cellCtrl.createEvent(e, 'cellMouseDown'))
      }
    }
    isRightClickInExistingRange(e) {
      const { rangeService: t } = this.beans
      if (t) {
        const i = t.isCellInAnyRange(this.cellCtrl.getCellPosition()),
          s =
            e.button === 2 ||
            (e.ctrlKey && this.beans.gos.get('allowContextMenuWithControlKey'))
        if (i && s) return !0
      }
      return !1
    }
    containsWidget(e) {
      return ar(e, 'ag-selection-checkbox', 3)
    }
    onMouseOut(e) {
      this.mouseStayingInsideCell(e) ||
        (this.beans.eventService.dispatchEvent(
          this.cellCtrl.createEvent(e, 'cellMouseOut'),
        ),
        this.beans.columnHoverService.clearMouseOver())
    }
    onMouseOver(e) {
      this.mouseStayingInsideCell(e) ||
        (this.beans.eventService.dispatchEvent(
          this.cellCtrl.createEvent(e, 'cellMouseOver'),
        ),
        this.beans.columnHoverService.setMouseOver([this.column]))
    }
    mouseStayingInsideCell(e) {
      if (!e.target || !e.relatedTarget) return !1
      const t = this.cellCtrl.getGui(),
        i = t.contains(e.target),
        s = t.contains(e.relatedTarget)
      return i && s
    }
    destroy() {
      super.destroy()
    }
  },
  nT = class extends X {
    constructor(e, t) {
      super(),
        (this.cellCtrl = e),
        (this.beans = t),
        (this.column = e.getColumn()),
        (this.rowNode = e.getRowNode())
    }
    setupRowSpan() {
      ;(this.rowSpan = this.column.getRowSpan(this.rowNode)),
        this.addManagedListeners(this.beans.eventService, {
          newColumnsLoaded: () => this.onNewColumnsLoaded(),
        })
    }
    setComp(e) {
      ;(this.eGui = e),
        this.setupColSpan(),
        this.setupRowSpan(),
        this.onLeftChanged(),
        this.onWidthChanged(),
        this.applyRowSpan()
    }
    onNewColumnsLoaded() {
      const e = this.column.getRowSpan(this.rowNode)
      this.rowSpan !== e && ((this.rowSpan = e), this.applyRowSpan(!0))
    }
    onDisplayColumnsChanged() {
      const e = this.getColSpanningList()
      gn(this.colsSpanning, e) ||
        ((this.colsSpanning = e), this.onWidthChanged(), this.onLeftChanged())
    }
    setupColSpan() {
      this.column.getColDef().colSpan != null &&
        ((this.colsSpanning = this.getColSpanningList()),
        this.addManagedListeners(this.beans.eventService, {
          displayedColumnsChanged: this.onDisplayColumnsChanged.bind(this),
          displayedColumnsWidthChanged: this.onWidthChanged.bind(this),
        }))
    }
    onWidthChanged() {
      if (!this.eGui) return
      const e = this.getCellWidth()
      this.eGui.style.width = `${e}px`
    }
    getCellWidth() {
      return this.colsSpanning
        ? this.colsSpanning.reduce((e, t) => e + t.getActualWidth(), 0)
        : this.column.getActualWidth()
    }
    getColSpanningList() {
      const e = this.column.getColSpan(this.rowNode),
        t = []
      if (e === 1) t.push(this.column)
      else {
        let i = this.column
        const s = this.column.getPinned()
        for (
          let n = 0;
          i &&
          n < e &&
          (t.push(i),
          (i = this.beans.visibleColsService.getColAfter(i)),
          !(!i || ot(i) || s !== i.getPinned()));
          n++
        );
      }
      return t
    }
    onLeftChanged() {
      if (!this.eGui) return
      const e = this.modifyLeftForPrintLayout(this.getCellLeft())
      this.eGui.style.left = e + 'px'
    }
    getCellLeft() {
      let e
      return (
        this.beans.gos.get('enableRtl') && this.colsSpanning
          ? (e = rt(this.colsSpanning))
          : (e = this.column),
        e.getLeft()
      )
    }
    modifyLeftForPrintLayout(e) {
      if (!this.cellCtrl.isPrintLayout() || this.column.getPinned() === 'left')
        return e
      const t = this.beans.visibleColsService.getColsLeftWidth()
      if (this.column.getPinned() === 'right') {
        const i = this.beans.visibleColsService.getBodyContainerWidth()
        return t + i + (e || 0)
      }
      return t + (e || 0)
    }
    applyRowSpan(e) {
      if (this.rowSpan === 1 && !e) return
      const i = In(this.beans.gos) * this.rowSpan
      ;(this.eGui.style.height = `${i}px`), (this.eGui.style.zIndex = '1')
    }
    destroy() {
      super.destroy()
    }
  },
  Kr = 'ag-cell-range-selected',
  rT = 'ag-cell-range-chart',
  oT = 'ag-cell-range-single-cell',
  aT = 'ag-cell-range-chart-category',
  lT = 'ag-cell-range-handle',
  cT = 'ag-cell-range-top',
  uT = 'ag-cell-range-right',
  dT = 'ag-cell-range-bottom',
  hT = 'ag-cell-range-left',
  gT = class {
    constructor(e, t) {
      ;(this.beans = e),
        (this.rangeService = e.rangeService),
        (this.selectionHandleFactory = e.selectionHandleFactory),
        (this.cellCtrl = t)
    }
    setComp(e, t) {
      ;(this.cellComp = e), (this.eGui = t), this.onCellSelectionChanged()
    }
    onCellSelectionChanged() {
      this.cellComp &&
        ((this.rangeCount = this.rangeService.getCellRangeCount(
          this.cellCtrl.getCellPosition(),
        )),
        (this.hasChartRange = this.getHasChartRange()),
        this.cellComp.addOrRemoveCssClass(Kr, this.rangeCount !== 0),
        this.cellComp.addOrRemoveCssClass(`${Kr}-1`, this.rangeCount === 1),
        this.cellComp.addOrRemoveCssClass(`${Kr}-2`, this.rangeCount === 2),
        this.cellComp.addOrRemoveCssClass(`${Kr}-3`, this.rangeCount === 3),
        this.cellComp.addOrRemoveCssClass(`${Kr}-4`, this.rangeCount >= 4),
        this.cellComp.addOrRemoveCssClass(rT, this.hasChartRange),
        Ha(this.eGui, this.rangeCount > 0 ? !0 : void 0),
        this.cellComp.addOrRemoveCssClass(oT, this.isSingleCell()),
        this.updateRangeBorders(),
        this.refreshHandle())
    }
    updateRangeBorders() {
      const e = this.getRangeBorders(),
        t = this.isSingleCell(),
        i = !t && e.top,
        s = !t && e.right,
        n = !t && e.bottom,
        r = !t && e.left
      this.cellComp.addOrRemoveCssClass(cT, i),
        this.cellComp.addOrRemoveCssClass(uT, s),
        this.cellComp.addOrRemoveCssClass(dT, n),
        this.cellComp.addOrRemoveCssClass(hT, r)
    }
    isSingleCell() {
      const { rangeService: e } = this.beans
      return this.rangeCount === 1 && !!e && !e.isMoreThanOneCell()
    }
    getHasChartRange() {
      const { rangeService: e } = this.beans
      if (!this.rangeCount || !e) return !1
      const t = e.getCellRanges()
      return t.length > 0 && t.every((i) => Tn([1, 0], i.type))
    }
    updateRangeBordersIfRangeCount() {
      this.rangeCount > 0 && (this.updateRangeBorders(), this.refreshHandle())
    }
    getRangeBorders() {
      const e = this.beans.gos.get('enableRtl')
      let t = !1,
        i = !1,
        s = !1,
        n = !1
      const r = this.cellCtrl.getCellPosition().column,
        o = this.beans.visibleColsService
      let a, l
      e
        ? ((a = o.getColAfter(r)), (l = o.getColBefore(r)))
        : ((a = o.getColBefore(r)), (l = o.getColAfter(r)))
      const c = this.rangeService
        .getCellRanges()
        .filter((u) =>
          this.rangeService.isCellInSpecificRange(
            this.cellCtrl.getCellPosition(),
            u,
          ),
        )
      a || (n = !0), l || (i = !0)
      for (let u = 0; u < c.length && !(t && i && s && n); u++) {
        const h = c[u],
          g = this.rangeService.getRangeStartRow(h),
          f = this.rangeService.getRangeEndRow(h)
        !t &&
          this.beans.rowPositionUtils.sameRow(
            g,
            this.cellCtrl.getCellPosition(),
          ) &&
          (t = !0),
          !s &&
            this.beans.rowPositionUtils.sameRow(
              f,
              this.cellCtrl.getCellPosition(),
            ) &&
            (s = !0),
          !n && a && h.columns.indexOf(a) < 0 && (n = !0),
          !i && l && h.columns.indexOf(l) < 0 && (i = !0)
      }
      return { top: t, right: i, bottom: s, left: n }
    }
    refreshHandle() {
      if (this.beans.context.isDestroyed()) return
      const e = this.shouldHaveSelectionHandle()
      this.selectionHandle &&
        !e &&
        (this.selectionHandle = this.beans.context.destroyBean(
          this.selectionHandle,
        )),
        e && this.addSelectionHandle(),
        this.cellComp.addOrRemoveCssClass(lT, !!this.selectionHandle)
    }
    shouldHaveSelectionHandle() {
      const e = this.beans.gos,
        t = this.rangeService.getCellRanges(),
        i = t.length
      if (this.rangeCount < 1 || i < 1) return !1
      const s = rt(t),
        n = this.cellCtrl.getCellPosition(),
        r = dg(e) && !this.cellCtrl.isSuppressFillHandle(),
        o = Cx(e)
      let a = i === 1 && !this.cellCtrl.isEditing() && (r || o)
      if (this.hasChartRange) {
        const c =
          t[0].type === 1 && this.rangeService.isCellInSpecificRange(n, t[0])
        this.cellComp.addOrRemoveCssClass(aT, c), (a = s.type === 0)
      }
      return (
        a &&
        s.endRow != null &&
        this.rangeService.isContiguousRange(s) &&
        this.rangeService.isBottomRightCell(s, n)
      )
    }
    addSelectionHandle() {
      const e = rt(this.rangeService.getCellRanges()).type,
        i = dg(this.beans.gos) && ot(e) ? 0 : 1
      this.selectionHandle &&
        this.selectionHandle.getType() !== i &&
        (this.selectionHandle = this.beans.context.destroyBean(
          this.selectionHandle,
        )),
        this.selectionHandle ||
          (this.selectionHandle =
            this.selectionHandleFactory.createSelectionHandle(i)),
        this.selectionHandle.refresh(this.cellCtrl)
    }
    destroy() {
      this.beans.context.destroyBean(this.selectionHandle)
    }
  },
  fT = 'ag-cell',
  pT = 'ag-cell-auto-height',
  mT = 'ag-cell-normal-height',
  vT = 'ag-cell-focus',
  CT = 'ag-cell-first-right-pinned',
  ST = 'ag-cell-last-left-pinned',
  wT = 'ag-cell-not-inline-editing',
  yT = 'ag-column-hover',
  bT = 'ag-cell-wrap-text',
  RT = 0,
  Hv = class au extends X {
    constructor(t, i, s, n) {
      super(),
        (this.column = t),
        (this.rowNode = i),
        (this.beans = s),
        (this.rowCtrl = n),
        (this.cellRangeFeature = void 0),
        (this.cellPositionFeature = void 0),
        (this.cellCustomStyleFeature = void 0),
        (this.tooltipFeature = void 0),
        (this.cellMouseListenerFeature = void 0),
        (this.cellKeyboardListenerFeature = void 0),
        (this.suppressRefreshCell = !1),
        (this.onCellCompAttachedFuncs = []),
        (this.onCellEditorAttachedFuncs = []),
        (this.instanceId = t.getId() + '-' + RT++),
        (this.colIdSanitised = hs(this.column.getId())),
        this.createCellPosition(),
        this.updateAndFormatValue(!1)
    }
    shouldRestoreFocus() {
      return this.beans.focusService.shouldRestoreFocus(this.cellPosition)
    }
    onFocusOut() {
      this.beans.focusService.clearRestoreFocus()
    }
    addFeatures() {
      ;(this.cellPositionFeature = new nT(this, this.beans)),
        (this.cellCustomStyleFeature = new tT(this, this.beans)),
        (this.cellMouseListenerFeature = new sT(this, this.beans, this.column)),
        (this.cellKeyboardListenerFeature = new iT(
          this,
          this.beans,
          this.column,
          this.rowNode,
          this.rowCtrl,
        )),
        this.column.isTooltipEnabled() && this.enableTooltipFeature(),
        this.beans.rangeService &&
          Vs(this.beans.gos) &&
          (this.cellRangeFeature = new gT(this.beans, this))
    }
    removeFeatures() {
      const t = this.beans.context
      ;(this.cellPositionFeature = t.destroyBean(this.cellPositionFeature)),
        (this.cellCustomStyleFeature = t.destroyBean(
          this.cellCustomStyleFeature,
        )),
        (this.cellMouseListenerFeature = t.destroyBean(
          this.cellMouseListenerFeature,
        )),
        (this.cellKeyboardListenerFeature = t.destroyBean(
          this.cellKeyboardListenerFeature,
        )),
        (this.cellRangeFeature = t.destroyBean(this.cellRangeFeature)),
        this.disableTooltipFeature()
    }
    enableTooltipFeature(t, i) {
      const s = () => {
          const o = this.column.getColDef(),
            a = this.rowNode.data
          if (o.tooltipField && ue(a))
            return ro(
              a,
              o.tooltipField,
              this.column.isTooltipFieldContainsDots(),
            )
          const l = o.tooltipValueGetter
          return l
            ? l(
                this.beans.gos.addGridCommonParams({
                  location: 'cell',
                  colDef: this.column.getColDef(),
                  column: this.column,
                  rowIndex: this.cellPosition.rowIndex,
                  node: this.rowNode,
                  data: this.rowNode.data,
                  value: this.value,
                  valueFormatted: this.valueFormatted,
                }),
              )
            : null
        },
        n = this.beans.gos.get('tooltipShowMode') === 'whenTruncated'
      !i &&
        n &&
        !this.isCellRenderer() &&
        (i = () => {
          const o = this.getGui(),
            a = o.children.length === 0 ? o : o.querySelector('.ag-cell-value')
          return a ? a.scrollWidth > a.clientWidth : !0
        })
      const r = {
        getColumn: () => this.column,
        getColDef: () => this.column.getColDef(),
        getRowIndex: () => this.cellPosition.rowIndex,
        getRowNode: () => this.rowNode,
        getGui: () => this.getGui(),
        getLocation: () => 'cell',
        getTooltipValue: t != null ? () => t : s,
        getValueFormatted: () => this.valueFormatted,
        shouldDisplayTooltip: i,
      }
      this.tooltipFeature = new Tr(r, this.beans)
    }
    disableTooltipFeature() {
      this.tooltipFeature = this.beans.context.destroyBean(this.tooltipFeature)
    }
    setComp(t, i, s, n, r, o) {
      var a, l, c, u
      ;(this.cellComp = t),
        (this.eGui = i),
        (this.printLayout = n),
        o ?? (o = this),
        this.addDomData(o),
        this.addFeatures(),
        o.addDestroyFunc(() => this.removeFeatures()),
        this.onSuppressCellFocusChanged(
          this.beans.gos.get('suppressCellFocus'),
        ),
        this.onCellFocused(this.focusEventToRestore),
        this.applyStaticCssClasses(),
        this.setWrapText(),
        this.onFirstRightPinnedChanged(),
        this.onLastLeftPinnedChanged(),
        this.onColumnHover(),
        this.setupControlComps(),
        this.setupAutoHeight(s, o),
        this.refreshFirstAndLastStyles(),
        this.refreshAriaColIndex(),
        (a = this.cellPositionFeature) == null || a.setComp(i),
        (l = this.cellCustomStyleFeature) == null || l.setComp(t),
        (c = this.tooltipFeature) == null || c.refreshToolTip(),
        (u = this.cellKeyboardListenerFeature) == null || u.setComp(this.eGui),
        this.cellRangeFeature && this.cellRangeFeature.setComp(t, i),
        r && this.isCellEditable() ? this.startEditing() : this.showValue(),
        this.onCellCompAttachedFuncs.length &&
          (this.onCellCompAttachedFuncs.forEach((h) => h()),
          (this.onCellCompAttachedFuncs = []))
    }
    setupAutoHeight(t, i) {
      if (
        ((this.isAutoHeight = this.column.isAutoHeight()),
        !this.isAutoHeight || !t)
      )
        return
      const s = t.parentElement,
        n = ln(this.beans.gos, this.rowNode).height,
        r = (l) => {
          if (this.editing || !this.isAlive() || !i.isAlive()) return
          const {
              paddingTop: c,
              paddingBottom: u,
              borderBottomWidth: h,
              borderTopWidth: g,
            } = Un(s),
            f = c + u + h + g,
            v = t.offsetHeight + f
          if (l < 5) {
            const C = Gt(this.beans.gos),
              w = !C || !C.contains(t),
              S = v == 0
            if (w || S) {
              window.setTimeout(() => r(l + 1), 0)
              return
            }
          }
          const m = Math.max(v, n)
          this.rowNode.setRowAutoHeight(m, this.column)
        },
        o = () => r(0)
      o()
      const a = this.beans.resizeObserverService.observeResize(t, o)
      i.addDestroyFunc(() => {
        a(), this.rowNode.setRowAutoHeight(void 0, this.column)
      })
    }
    getCellAriaRole() {
      return this.column.getColDef().cellAriaRole ?? 'gridcell'
    }
    isCellRenderer() {
      const t = this.column.getColDef()
      return t.cellRenderer != null || t.cellRendererSelector != null
    }
    getValueToDisplay() {
      return this.valueFormatted ?? this.value
    }
    showValue(t = !1) {
      var g
      const {
          beans: i,
          column: s,
          rowNode: n,
          cellRangeFeature: r,
          cellComp: o,
        } = this,
        { userComponentFactory: a, animationFrameService: l } = i,
        c = this.getValueToDisplay()
      let u
      if (
        n.stub &&
        ((g = n.groupData) == null ? void 0 : g[this.column.getId()]) == null
      ) {
        const f = this.createCellRendererParams()
        u = a.getLoadingCellRendererDetails(s.getColDef(), f)
      } else if (this.isCellRenderer()) {
        const f = this.createCellRendererParams()
        u = a.getCellRendererDetails(s.getColDef(), f)
      }
      o.setRenderDetails(u, c, t),
        l.requestAnimationFrame(() => (r == null ? void 0 : r.refreshHandle()))
    }
    setupControlComps() {
      const t = this.column.getColDef()
      ;(this.includeSelection = this.isIncludeControl(
        this.isCheckboxSelection(t),
      )),
        (this.includeRowDrag = this.isIncludeControl(t.rowDrag)),
        (this.includeDndSource = this.isIncludeControl(t.dndSource)),
        this.cellComp.setIncludeSelection(this.includeSelection),
        this.cellComp.setIncludeDndSource(this.includeDndSource),
        this.cellComp.setIncludeRowDrag(this.includeRowDrag)
    }
    isForceWrapper() {
      return (
        this.beans.gos.get('enableCellTextSelection') ||
        this.column.isAutoHeight()
      )
    }
    isIncludeControl(t) {
      return this.rowNode.rowPinned != null
        ? !1
        : typeof t == 'function' || t === !0
    }
    isCheckboxSelection(t) {
      const { rowSelection: i } = this.beans.gridOptions
      return (
        t.checkboxSelection ||
        (Lo(this.column) && i && typeof i != 'string' && fr(i))
      )
    }
    refreshShouldDestroy() {
      const t = this.column.getColDef(),
        i =
          this.includeSelection !=
          this.isIncludeControl(this.isCheckboxSelection(t)),
        s = this.includeRowDrag != this.isIncludeControl(t.rowDrag),
        n = this.includeDndSource != this.isIncludeControl(t.dndSource),
        r = this.isAutoHeight != this.column.isAutoHeight()
      return i || s || n || r
    }
    startEditing(t = null, i = !1, s = null) {
      const { editService: n } = this.beans
      return !this.isCellEditable() || this.editing || !n
        ? !0
        : this.cellComp
          ? n.startEditing(this, t, i, s)
          : (this.onCellCompAttachedFuncs.push(() => {
              this.startEditing(t, i, s)
            }),
            !0)
    }
    setEditing(t, i) {
      ;(this.editCompDetails = i), this.editing !== t && (this.editing = t)
    }
    stopRowOrCellEdit(t = !1) {
      this.beans.gos.get('editType') === 'fullRow'
        ? this.rowCtrl.stopEditing(t)
        : this.stopEditing(t)
    }
    onPopupEditorClosed() {
      this.editing && this.stopEditingAndFocus()
    }
    stopEditing(t = !1) {
      this.onCellEditorAttachedFuncs = []
      const { editService: i } = this.beans
      return !this.editing || !i ? !1 : i.stopEditing(this, t)
    }
    createCellRendererParams() {
      return this.beans.gos.addGridCommonParams({
        value: this.value,
        valueFormatted: this.valueFormatted,
        getValue: () =>
          this.beans.valueService.getValueForDisplay(this.column, this.rowNode),
        setValue: (i) =>
          this.beans.valueService.setValue(this.rowNode, this.column, i),
        formatValue: this.formatValue.bind(this),
        data: this.rowNode.data,
        node: this.rowNode,
        pinned: this.column.getPinned(),
        colDef: this.column.getColDef(),
        column: this.column,
        refreshCell: this.refreshCell.bind(this),
        eGridCell: this.getGui(),
        eParentOfValue: this.cellComp.getParentOfValue(),
        registerRowDragger: (i, s, n, r) => this.registerRowDragger(i, s, r),
        setTooltip: (i, s) => {
          var n
          this.tooltipFeature && this.disableTooltipFeature(),
            this.enableTooltipFeature(i, s),
            (n = this.tooltipFeature) == null || n.refreshToolTip()
        },
      })
    }
    setFocusOutOnEditor() {
      var t
      this.editing &&
        ((t = this.beans.editService) == null || t.setFocusOutOnEditor(this))
    }
    setFocusInOnEditor() {
      var t
      this.editing &&
        ((t = this.beans.editService) == null || t.setFocusInOnEditor(this))
    }
    onCellChanged(t) {
      t.column === this.column && this.refreshCell({})
    }
    refreshOrDestroyCell(t) {
      var i
      this.refreshShouldDestroy()
        ? (i = this.rowCtrl) == null || i.recreateCell(this)
        : this.refreshCell(t)
    }
    refreshCell(t) {
      var u, h, g, f, p
      if (this.suppressRefreshCell || this.editing) return
      const i = this.column.getColDef(),
        s = t != null && !!t.newData,
        n = (t != null && !!t.suppressFlash) || !!i.suppressCellFlash,
        r = i.field == null && i.valueGetter == null && i.showRowGroup == null,
        o = (t && t.forceRefresh) || r || s,
        a = !!this.cellComp,
        l = this.updateAndFormatValue(a),
        c = o || l
      if (a) {
        if (c) {
          this.showValue(s)
          const v =
            (u = this.beans.filterManager) == null
              ? void 0
              : u.isSuppressFlashingCellsBecauseFiltering()
          !n &&
            !v &&
            (this.beans.gos.get('enableCellChangeFlash') ||
              i.enableCellChangeFlash) &&
            this.flashCell(),
            (h = this.cellCustomStyleFeature) == null || h.applyUserStyles(),
            (g = this.cellCustomStyleFeature) == null ||
              g.applyClassesFromColDef()
        }
        ;(f = this.tooltipFeature) == null || f.refreshToolTip(),
          (p = this.cellCustomStyleFeature) == null || p.applyCellClassRules()
      }
    }
    stopEditingAndFocus(t = !1, i = !1) {
      var s
      ;(s = this.beans.editService) == null || s.stopEditingAndFocus(this, t, i)
    }
    flashCell(t) {
      const i =
          (t == null ? void 0 : t.flashDuration) ??
          (t == null ? void 0 : t.flashDelay),
        s =
          (t == null ? void 0 : t.fadeDuration) ??
          (t == null ? void 0 : t.fadeDelay)
      this.animateCell('data-changed', i, s)
    }
    animateCell(t, i, s) {
      if (!this.cellComp) return
      const { gos: n } = this.beans
      if ((i || (i = n.get('cellFlashDuration')), i === 0)) return
      ue(s) || (s = n.get('cellFadeDuration'))
      const r = `ag-cell-${t}`,
        o = `ag-cell-${t}-animation`
      this.cellComp.addOrRemoveCssClass(r, !0),
        this.cellComp.addOrRemoveCssClass(o, !1),
        this.beans.frameworkOverrides.wrapIncoming(() => {
          window.setTimeout(() => {
            this.isAlive() &&
              (this.cellComp.addOrRemoveCssClass(r, !1),
              this.cellComp.addOrRemoveCssClass(o, !0),
              (this.eGui.style.transition = `background-color ${s}ms`),
              window.setTimeout(() => {
                this.isAlive() &&
                  (this.cellComp.addOrRemoveCssClass(o, !1),
                  (this.eGui.style.transition = ''))
              }, s))
          }, i)
        })
    }
    onFlashCells(t) {
      if (!this.cellComp) return
      const i = this.beans.cellPositionUtils.createId(this.getCellPosition())
      t.cells[i] && this.animateCell('highlight')
    }
    isCellEditable() {
      return this.column.isCellEditable(this.rowNode)
    }
    isSuppressFillHandle() {
      return this.column.isSuppressFillHandle()
    }
    formatValue(t) {
      return this.callValueFormatter(t) ?? t
    }
    callValueFormatter(t) {
      return this.beans.valueService.formatValue(this.column, this.rowNode, t)
    }
    updateAndFormatValue(t) {
      const i = this.value,
        s = this.valueFormatted
      return (
        (this.value = this.beans.valueService.getValueForDisplay(
          this.column,
          this.rowNode,
        )),
        (this.valueFormatted = this.callValueFormatter(this.value)),
        t ? !this.valuesAreEqual(i, this.value) || this.valueFormatted != s : !0
      )
    }
    valuesAreEqual(t, i) {
      const s = this.column.getColDef()
      return s.equals ? s.equals(t, i) : t === i
    }
    getComp() {
      return this.cellComp
    }
    getValue() {
      return this.value
    }
    addDomData(t) {
      const i = this.getGui()
      Nn(this.beans.gos, i, au.DOM_DATA_KEY_CELL_CTRL, this),
        t.addDestroyFunc(() =>
          Nn(this.beans.gos, i, au.DOM_DATA_KEY_CELL_CTRL, null),
        )
    }
    createEvent(t, i) {
      return this.beans.gos.addGridCommonParams({
        type: i,
        node: this.rowNode,
        data: this.rowNode.data,
        value: this.value,
        column: this.column,
        colDef: this.column.getColDef(),
        rowPinned: this.rowNode.rowPinned,
        event: t,
        rowIndex: this.rowNode.rowIndex,
      })
    }
    processCharacter(t) {
      var i
      ;(i = this.cellKeyboardListenerFeature) == null || i.processCharacter(t)
    }
    onKeyDown(t) {
      var i
      ;(i = this.cellKeyboardListenerFeature) == null || i.onKeyDown(t)
    }
    onMouseEvent(t, i) {
      var s
      ;(s = this.cellMouseListenerFeature) == null || s.onMouseEvent(t, i)
    }
    getGui() {
      return this.eGui
    }
    getColSpanningList() {
      return this.cellPositionFeature.getColSpanningList()
    }
    onLeftChanged() {
      var t
      this.cellComp &&
        ((t = this.cellPositionFeature) == null || t.onLeftChanged())
    }
    onDisplayedColumnsChanged() {
      this.eGui &&
        (this.refreshAriaColIndex(), this.refreshFirstAndLastStyles())
    }
    refreshFirstAndLastStyles() {
      const { cellComp: t, column: i, beans: s } = this
      Ev(t, i, s.visibleColsService)
    }
    refreshAriaColIndex() {
      const t = this.beans.visibleColsService.getAriaColIndex(this.column)
      Vm(this.getGui(), t)
    }
    isSuppressNavigable() {
      return this.column.isSuppressNavigable(this.rowNode)
    }
    onWidthChanged() {
      var t
      return (t = this.cellPositionFeature) == null
        ? void 0
        : t.onWidthChanged()
    }
    getColumn() {
      return this.column
    }
    getRowNode() {
      return this.rowNode
    }
    isPrintLayout() {
      return this.printLayout
    }
    getCellPosition() {
      return this.cellPosition
    }
    isEditing() {
      return this.editing
    }
    startRowOrCellEdit(t, i = null) {
      return this.cellComp
        ? this.beans.gos.get('editType') === 'fullRow'
          ? this.rowCtrl.startRowEditing(t, this)
          : this.startEditing(t, !0, i)
        : (this.onCellCompAttachedFuncs.push(() => {
            this.startRowOrCellEdit(t, i)
          }),
          !0)
    }
    getRowCtrl() {
      return this.rowCtrl
    }
    getRowPosition() {
      return {
        rowIndex: this.cellPosition.rowIndex,
        rowPinned: this.cellPosition.rowPinned,
      }
    }
    updateRangeBordersIfRangeCount() {
      this.cellComp &&
        this.cellRangeFeature &&
        this.cellRangeFeature.updateRangeBordersIfRangeCount()
    }
    onCellSelectionChanged() {
      this.cellComp &&
        this.cellRangeFeature &&
        this.cellRangeFeature.onCellSelectionChanged()
    }
    isRangeSelectionEnabled() {
      return this.cellRangeFeature != null
    }
    focusCell(t = !1) {
      this.beans.focusService.setFocusedCell({
        rowIndex: this.getCellPosition().rowIndex,
        column: this.column,
        rowPinned: this.rowNode.rowPinned,
        forceBrowserFocus: t,
      })
    }
    onRowIndexChanged() {
      this.createCellPosition(),
        this.onCellFocused(),
        this.cellRangeFeature && this.cellRangeFeature.onCellSelectionChanged()
    }
    onSuppressCellFocusChanged(t) {
      this.eGui && $i(this.eGui, 'tabindex', t ? void 0 : -1)
    }
    onFirstRightPinnedChanged() {
      if (!this.cellComp) return
      const t = this.column.isFirstRightPinned()
      this.cellComp.addOrRemoveCssClass(CT, t)
    }
    onLastLeftPinnedChanged() {
      if (!this.cellComp) return
      const t = this.column.isLastLeftPinned()
      this.cellComp.addOrRemoveCssClass(ST, t)
    }
    onCellFocused(t) {
      if (this.beans.focusService.isCellFocusSuppressed()) return
      const i = this.beans.focusService.isCellFocused(this.cellPosition)
      if (!this.cellComp) {
        i && t != null && t.forceBrowserFocus && (this.focusEventToRestore = t)
        return
      }
      if (
        ((this.focusEventToRestore = void 0),
        this.cellComp.addOrRemoveCssClass(vT, i),
        i && t && t.forceBrowserFocus)
      ) {
        let n = this.cellComp.getFocusableElement()
        if (this.editing) {
          const r = this.beans.focusService.findFocusableElements(n, null, !0)
          r.length && (n = r[0])
        }
        n.focus({ preventScroll: !!t.preventScrollOnBrowserFocus })
      }
      const s = this.beans.gos.get('editType') === 'fullRow'
      !i && !s && this.editing && this.stopRowOrCellEdit(),
        i && this.rowCtrl.announceDescription()
    }
    createCellPosition() {
      this.cellPosition = {
        rowIndex: this.rowNode.rowIndex,
        rowPinned: As(this.rowNode.rowPinned),
        column: this.column,
      }
    }
    applyStaticCssClasses() {
      this.cellComp.addOrRemoveCssClass(fT, !0),
        this.cellComp.addOrRemoveCssClass(wT, !0)
      const t = this.column.isAutoHeight() == !0
      this.cellComp.addOrRemoveCssClass(pT, t),
        this.cellComp.addOrRemoveCssClass(mT, !t)
    }
    onColumnHover() {
      if (!this.cellComp || !this.beans.gos.get('columnHoverHighlight')) return
      const t = this.beans.columnHoverService.isHovered(this.column)
      this.cellComp.addOrRemoveCssClass(yT, t)
    }
    onColDefChanged() {
      var i
      if (!this.cellComp) return
      this.column.isTooltipEnabled()
        ? (this.disableTooltipFeature(), this.enableTooltipFeature())
        : this.disableTooltipFeature(),
        this.setWrapText(),
        this.editing
          ? (i = this.beans.editService) == null || i.handleColDefChanged(this)
          : this.refreshOrDestroyCell({ forceRefresh: !0, suppressFlash: !0 })
    }
    setWrapText() {
      const t = this.column.getColDef().wrapText == !0
      this.cellComp.addOrRemoveCssClass(bT, t)
    }
    dispatchCellContextMenuEvent(t) {
      const i = this.column.getColDef(),
        s = this.createEvent(t, 'cellContextMenu')
      this.beans.eventService.dispatchEvent(s),
        i.onCellContextMenu &&
          window.setTimeout(() => {
            this.beans.frameworkOverrides.wrapOutgoing(() => {
              i.onCellContextMenu(s)
            })
          }, 0)
    }
    getCellRenderer() {
      return this.cellComp ? this.cellComp.getCellRenderer() : null
    }
    getCellEditor() {
      return this.cellComp ? this.cellComp.getCellEditor() : null
    }
    destroy() {
      ;(this.onCellCompAttachedFuncs = []),
        (this.onCellEditorAttachedFuncs = []),
        super.destroy()
    }
    createSelectionCheckbox() {
      const t = new ZI()
      return (
        this.beans.context.createBean(t),
        t.init({ rowNode: this.rowNode, column: this.column }),
        t
      )
    }
    createDndSource() {
      const t = new eT(this.rowNode, this.column, this.eGui)
      return this.beans.context.createBean(t), t
    }
    registerRowDragger(t, i, s) {
      if (this.customRowDragComp) {
        this.customRowDragComp.setDragElement(t, i)
        return
      }
      const n = this.createRowDragComp(t, i, s)
      n &&
        ((this.customRowDragComp = n),
        this.addDestroyFunc(() => {
          this.beans.context.destroyBean(n), (this.customRowDragComp = null)
        }))
    }
    createRowDragComp(t, i, s) {
      const n = this.beans.gos.get('pagination'),
        r = this.beans.gos.get('rowDragManaged'),
        o = Pt(this.beans.gos)
      if (r) {
        if (!o) {
          te(
            'managed row dragging is only allowed in the Client Side Row Model',
          )
          return
        }
        if (n) {
          te('managed row dragging is not possible when doing pagination')
          return
        }
      }
      const a = new tu(() => this.value, this.rowNode, this.column, t, i, s)
      return this.beans.context.createBean(a), a
    }
    setSuppressRefreshCell(t) {
      this.suppressRefreshCell = t
    }
    getEditCompDetails() {
      return this.editCompDetails
    }
    onCellEditorAttached(t) {
      this.onCellEditorAttachedFuncs.push(t)
    }
    cellEditorAttached() {
      this.onCellEditorAttachedFuncs.forEach((t) => t()),
        (this.onCellEditorAttachedFuncs = [])
    }
  }
Hv.DOM_DATA_KEY_CELL_CTRL = 'cellCtrl'
var An = Hv,
  FT = 0,
  Nv = class lu extends X {
    constructor(t, i, s, n, r) {
      var o
      super(),
        (this.allRowGuis = []),
        (this.active = !0),
        (this.centerCellCtrls = { list: [], map: {} }),
        (this.leftCellCtrls = { list: [], map: {} }),
        (this.rightCellCtrls = { list: [], map: {} }),
        (this.slideInAnimation = {
          left: !1,
          center: !1,
          right: !1,
          fullWidth: !1,
        }),
        (this.fadeInAnimation = {
          left: !1,
          center: !1,
          right: !1,
          fullWidth: !1,
        }),
        (this.rowDragComps = []),
        (this.lastMouseDownOnDragger = !1),
        (this.emptyStyle = {}),
        (this.updateColumnListsPending = !1),
        (this.rowId = null),
        (this.businessKeySanitised = null),
        (this.beans = i),
        (this.gos = i.gos),
        (this.rowNode = t),
        (this.paginationPage =
          ((o = i.paginationService) == null ? void 0 : o.getCurrentPage()) ??
          0),
        (this.useAnimationFrameForCreate = n),
        (this.printLayout = r),
        (this.suppressRowTransform = this.gos.get('suppressRowTransform')),
        (this.instanceId = t.id + '-' + FT++),
        (this.rowId = hs(t.id)),
        this.initRowBusinessKey(),
        (this.rowFocused = i.focusService.isRowFocused(
          this.rowNode.rowIndex,
          this.rowNode.rowPinned,
        )),
        (this.rowLevel = i.rowCssClassCalculator.calculateRowLevel(
          this.rowNode,
        )),
        this.setRowType(),
        this.setAnimateFlags(s),
        (this.rowStyles = this.processStylesFromGridOptions()),
        this.addListeners()
    }
    initRowBusinessKey() {
      ;(this.businessKeyForNodeFunc = this.gos.get('getBusinessKeyForNode')),
        this.updateRowBusinessKey()
    }
    updateRowBusinessKey() {
      if (typeof this.businessKeyForNodeFunc != 'function') return
      const t = this.businessKeyForNodeFunc(this.rowNode)
      this.businessKeySanitised = hs(t)
    }
    getRowId() {
      return this.rowId
    }
    getRowStyles() {
      return this.rowStyles
    }
    isSticky() {
      return this.rowNode.sticky
    }
    updateGui(t, i) {
      t === 'left'
        ? (this.leftGui = i)
        : t === 'right'
          ? (this.rightGui = i)
          : t === 'fullWidth'
            ? (this.fullWidthGui = i)
            : (this.centerGui = i)
    }
    setComp(t, i, s, n) {
      n = ko(this, this.beans.context, n)
      const r = { rowComp: t, element: i, containerType: s, compBean: n }
      this.allRowGuis.push(r),
        this.updateGui(s, r),
        this.initialiseRowComp(r),
        this.rowType !== 'FullWidthLoading' &&
          !this.rowNode.rowPinned &&
          this.beans.rowRenderer.dispatchFirstDataRenderedEvent()
    }
    unsetComp(t) {
      ;(this.allRowGuis = this.allRowGuis.filter((i) => i.containerType !== t)),
        this.updateGui(t, void 0)
    }
    isCacheable() {
      return (
        this.rowType === 'FullWidthDetail' && this.gos.get('keepDetailRows')
      )
    }
    setCached(t) {
      const i = t ? 'none' : ''
      this.allRowGuis.forEach((s) => (s.element.style.display = i))
    }
    initialiseRowComp(t) {
      const i = this.gos
      this.onSuppressCellFocusChanged(this.beans.gos.get('suppressCellFocus')),
        this.listenOnDomOrder(t),
        this.beans.columnModel.wasAutoRowHeightEverActive() &&
          this.rowNode.checkAutoHeights(),
        this.onRowHeightChanged(t),
        this.updateRowIndexes(t),
        this.setFocusedClasses(t),
        this.setStylesFromGridOptions(!1, t),
        Ia(i) && this.rowNode.selectable && this.onRowSelected(t),
        this.updateColumnLists(!this.useAnimationFrameForCreate)
      const s = t.rowComp
      this.getInitialRowClasses(t.containerType).forEach((r) =>
        s.addOrRemoveCssClass(r, !0),
      ),
        this.executeSlideAndFadeAnimations(t),
        this.rowNode.group && ka(t.element, this.rowNode.expanded == !0),
        this.setRowCompRowId(s),
        this.setRowCompRowBusinessKey(s),
        Nn(i, t.element, lu.DOM_DATA_KEY_ROW_CTRL, this),
        t.compBean.addDestroyFunc(() =>
          Nn(i, t.element, lu.DOM_DATA_KEY_ROW_CTRL, null),
        ),
        this.useAnimationFrameForCreate
          ? this.beans.animationFrameService.createTask(
              this.addHoverFunctionality.bind(this, t),
              this.rowNode.rowIndex,
              'createTasksP2',
            )
          : this.addHoverFunctionality(t),
        this.isFullWidth() && this.setupFullWidth(t),
        i.get('rowDragEntireRow') && this.addRowDraggerToRow(t),
        this.useAnimationFrameForCreate &&
          this.beans.animationFrameService.addDestroyTask(() => {
            this.isAlive() &&
              t.rowComp.addOrRemoveCssClass('ag-after-created', !0)
          }),
        this.executeProcessRowPostCreateFunc()
    }
    setRowCompRowBusinessKey(t) {
      this.businessKeySanitised != null &&
        t.setRowBusinessKey(this.businessKeySanitised)
    }
    getBusinessKey() {
      return this.businessKeySanitised
    }
    setRowCompRowId(t) {
      ;(this.rowId = hs(this.rowNode.id)),
        this.rowId != null && t.setRowId(this.rowId)
    }
    executeSlideAndFadeAnimations(t) {
      const { containerType: i } = t
      this.slideInAnimation[i] &&
        (cg(() => {
          this.onTopChanged()
        }),
        (this.slideInAnimation[i] = !1)),
        this.fadeInAnimation[i] &&
          (cg(() => {
            t.rowComp.addOrRemoveCssClass('ag-opacity-zero', !1)
          }),
          (this.fadeInAnimation[i] = !1))
    }
    addRowDraggerToRow(t) {
      if (Vs(this.gos)) {
        te(
          "Setting `rowDragEntireRow: true` in the gridOptions doesn't work with `cellSelection: true`",
        )
        return
      }
      const i = this.beans.localeService.getLocaleTextFunc(),
        s = new tu(
          () => `1 ${i('rowDragRow', 'row')}`,
          this.rowNode,
          void 0,
          t.element,
          void 0,
          !0,
        ),
        n = this.createBean(s, this.beans.context)
      this.rowDragComps.push(n),
        t.compBean.addDestroyFunc(() => {
          ;(this.rowDragComps = this.rowDragComps.filter((r) => r !== n)),
            this.destroyBean(n, this.beans.context)
        })
    }
    setupFullWidth(t) {
      const i = this.getPinnedForContainer(t.containerType)
      if (
        this.rowType == 'FullWidthDetail' &&
        !this.gos.assertModuleRegistered(
          '@ag-grid-enterprise/master-detail',
          "cell renderer 'agDetailCellRenderer' (for master detail)",
        )
      )
        return
      const s = this.createFullWidthCompDetails(t.element, i)
      t.rowComp.showFullWidth(s)
    }
    isPrintLayout() {
      return this.printLayout
    }
    getFullWidthCellRenderers() {
      var t, i
      return this.gos.get('embedFullWidthRows')
        ? this.allRowGuis.map((s) => {
            var n
            return (n = s == null ? void 0 : s.rowComp) == null
              ? void 0
              : n.getFullWidthCellRenderer()
          })
        : [
            (i = (t = this.fullWidthGui) == null ? void 0 : t.rowComp) == null
              ? void 0
              : i.getFullWidthCellRenderer(),
          ]
    }
    getCellElement(t) {
      const i = this.getCellCtrl(t)
      return i ? i.getGui() : null
    }
    executeProcessRowPostCreateFunc() {
      const t = this.gos.getCallback('processRowPostCreate')
      if (!t || !this.areAllContainersReady()) return
      const i = {
        eRow: this.centerGui.element,
        ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
        ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex,
        addRenderedRowListener: this.addEventListener.bind(this),
      }
      t(i)
    }
    areAllContainersReady() {
      const t =
          !!this.leftGui || !this.beans.visibleColsService.isPinningLeft(),
        i = !!this.centerGui,
        s = !!this.rightGui || !this.beans.visibleColsService.isPinningRight()
      return t && i && s
    }
    isNodeFullWidthCell() {
      if (this.rowNode.detail) return !0
      const t = this.beans.gos.getCallback('isFullWidthRow')
      return t ? t({ rowNode: this.rowNode }) : !1
    }
    setRowType() {
      const t =
          this.rowNode.stub &&
          !this.gos.get('suppressServerSideFullWidthLoadingRow') &&
          !this.gos.get('groupHideOpenParents'),
        i = this.isNodeFullWidthCell(),
        s = this.gos.get('masterDetail') && this.rowNode.detail,
        n = this.beans.columnModel.isPivotMode(),
        o = !!this.rowNode.group && !this.rowNode.footer && pl(this.gos, n)
      t
        ? (this.rowType = 'FullWidthLoading')
        : s
          ? (this.rowType = 'FullWidthDetail')
          : i
            ? (this.rowType = 'FullWidth')
            : o
              ? (this.rowType = 'FullWidthGroup')
              : (this.rowType = 'Normal')
    }
    updateColumnLists(t = !1, i = !1) {
      if (this.isFullWidth()) return
      if (t || this.gos.get('suppressAnimationFrame') || this.printLayout) {
        this.updateColumnListsImpl(i)
        return
      }
      this.updateColumnListsPending ||
        (this.beans.animationFrameService.createTask(
          () => {
            this.active && this.updateColumnListsImpl(!0)
          },
          this.rowNode.rowIndex,
          'createTasksP1',
        ),
        (this.updateColumnListsPending = !0))
    }
    createCellCtrls(t, i, s = null) {
      const n = { list: [], map: {} },
        r = (o, a) => {
          n.list.push(a), (n.map[o] = a)
        }
      return (
        i.forEach((o) => {
          const a = o.getInstanceId()
          let l = t.map[a]
          l || (l = new An(o, this.rowNode, this.beans, this)), r(a, l)
        }),
        t.list.forEach((o) => {
          const a = o.getColumn().getInstanceId()
          if (n.map[a] != null) return
          if (!this.isCellEligibleToBeRemoved(o, s)) {
            r(a, o)
            return
          }
          o.destroy()
        }),
        n
      )
    }
    updateColumnListsImpl(t) {
      ;(this.updateColumnListsPending = !1),
        this.createAllCellCtrls(),
        this.setCellCtrls(t)
    }
    setCellCtrls(t) {
      this.allRowGuis.forEach((i) => {
        const s = this.getCellCtrlsForContainer(i.containerType)
        i.rowComp.setCellCtrls(s, t)
      })
    }
    getCellCtrlsForContainer(t) {
      switch (t) {
        case 'left':
          return this.leftCellCtrls.list
        case 'right':
          return this.rightCellCtrls.list
        case 'fullWidth':
          return []
        case 'center':
          return this.centerCellCtrls.list
      }
    }
    createAllCellCtrls() {
      const t = this.beans.columnViewportService,
        i = this.beans.visibleColsService
      if (this.printLayout)
        (this.centerCellCtrls = this.createCellCtrls(
          this.centerCellCtrls,
          i.getAllCols(),
        )),
          (this.leftCellCtrls = { list: [], map: {} }),
          (this.rightCellCtrls = { list: [], map: {} })
      else {
        const s = t.getColsWithinViewport(this.rowNode)
        this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, s)
        const n = i.getLeftColsForRow(this.rowNode)
        this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, n, 'left')
        const r = i.getRightColsForRow(this.rowNode)
        this.rightCellCtrls = this.createCellCtrls(
          this.rightCellCtrls,
          r,
          'right',
        )
      }
    }
    isCellEligibleToBeRemoved(t, i) {
      if (t.getColumn().getPinned() != i) return !0
      const o = t.isEditing(),
        a = this.beans.focusService.isCellFocused(t.getCellPosition())
      if (o || a) {
        const c = t.getColumn()
        return !(this.beans.visibleColsService.getAllCols().indexOf(c) >= 0)
      }
      return !0
    }
    getDomOrder() {
      return this.gos.get('ensureDomOrder') || ci(this.gos, 'print')
    }
    listenOnDomOrder(t) {
      const i = () => {
        t.rowComp.setDomOrder(this.getDomOrder())
      }
      t.compBean.addManagedPropertyListeners(['domLayout', 'ensureDomOrder'], i)
    }
    setAnimateFlags(t) {
      if (this.isSticky() || !t) return
      const i = ue(this.rowNode.oldRowTop),
        s = this.beans.visibleColsService.isPinningLeft(),
        n = this.beans.visibleColsService.isPinningRight()
      if (i) {
        if (this.isFullWidth() && !this.gos.get('embedFullWidthRows')) {
          this.slideInAnimation.fullWidth = !0
          return
        }
        ;(this.slideInAnimation.center = !0),
          (this.slideInAnimation.left = s),
          (this.slideInAnimation.right = n)
      } else {
        if (this.isFullWidth() && !this.gos.get('embedFullWidthRows')) {
          this.fadeInAnimation.fullWidth = !0
          return
        }
        ;(this.fadeInAnimation.center = !0),
          (this.fadeInAnimation.left = s),
          (this.fadeInAnimation.right = n)
      }
    }
    isEditing() {
      return this.editingRow
    }
    isFullWidth() {
      return this.rowType !== 'Normal'
    }
    refreshFullWidth() {
      const t = (a, l) =>
          a
            ? a.rowComp.refreshFullWidth(
                () => this.createFullWidthCompDetails(a.element, l).params,
              )
            : !0,
        i = t(this.fullWidthGui, null),
        s = t(this.centerGui, null),
        n = t(this.leftGui, 'left'),
        r = t(this.rightGui, 'right')
      return i && s && n && r
    }
    addListeners() {
      this.addManagedListeners(this.rowNode, {
        heightChanged: () => this.onRowHeightChanged(),
        rowSelected: () => this.onRowSelected(),
        rowIndexChanged: this.onRowIndexChanged.bind(this),
        topChanged: this.onTopChanged.bind(this),
        expandedChanged: this.updateExpandedCss.bind(this),
        hasChildrenChanged: this.updateExpandedCss.bind(this),
      }),
        this.rowNode.detail &&
          this.addManagedListeners(this.rowNode.parent, {
            dataChanged: this.onRowNodeDataChanged.bind(this),
          }),
        this.addManagedListeners(this.rowNode, {
          dataChanged: this.onRowNodeDataChanged.bind(this),
          cellChanged: this.postProcessCss.bind(this),
          rowHighlightChanged: this.onRowNodeHighlightChanged.bind(this),
          draggingChanged: this.postProcessRowDragging.bind(this),
          uiLevelChanged: this.onUiLevelChanged.bind(this),
        }),
        this.addManagedListeners(this.beans.eventService, {
          paginationPixelOffsetChanged:
            this.onPaginationPixelOffsetChanged.bind(this),
          heightScaleChanged: this.onTopChanged.bind(this),
          displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
          virtualColumnsChanged: this.onVirtualColumnsChanged.bind(this),
          cellFocused: this.onCellFocusChanged.bind(this),
          cellFocusCleared: this.onCellFocusChanged.bind(this),
          paginationChanged: this.onPaginationChanged.bind(this),
          modelUpdated: this.refreshFirstAndLastRowStyles.bind(this),
          columnMoved: () => this.updateColumnLists(),
        }),
        this.addDestroyFunc(() => {
          ;(this.rowDragComps = this.destroyBeans(
            this.rowDragComps,
            this.beans.context,
          )),
            this.tooltipFeature &&
              (this.tooltipFeature = this.destroyBean(
                this.tooltipFeature,
                this.beans.context,
              ))
        }),
        this.addManagedPropertyListeners(
          [
            'rowStyle',
            'getRowStyle',
            'rowClass',
            'getRowClass',
            'rowClassRules',
          ],
          this.postProcessCss.bind(this),
        ),
        this.addManagedPropertyListener('rowDragEntireRow', () => {
          if (this.gos.get('rowDragEntireRow')) {
            this.allRowGuis.forEach((i) => {
              this.addRowDraggerToRow(i)
            })
            return
          }
          this.rowDragComps = this.destroyBeans(
            this.rowDragComps,
            this.beans.context,
          )
        }),
        this.addListenersForCellComps()
    }
    addListenersForCellComps() {
      this.addManagedListeners(this.rowNode, {
        rowIndexChanged: () => {
          this.getAllCellCtrls().forEach((t) => t.onRowIndexChanged())
        },
        cellChanged: (t) => {
          this.getAllCellCtrls().forEach((i) => i.onCellChanged(t))
        },
      })
    }
    onRowNodeDataChanged(t) {
      if (this.isFullWidth() !== !!this.isNodeFullWidthCell()) {
        this.beans.rowRenderer.redrawRow(this.rowNode)
        return
      }
      if (this.isFullWidth()) {
        this.refreshFullWidth() ||
          this.beans.rowRenderer.redrawRow(this.rowNode)
        return
      }
      this.getAllCellCtrls().forEach((s) =>
        s.refreshCell({ suppressFlash: !t.update, newData: !t.update }),
      ),
        this.allRowGuis.forEach((s) => {
          this.setRowCompRowId(s.rowComp),
            this.updateRowBusinessKey(),
            this.setRowCompRowBusinessKey(s.rowComp)
        }),
        this.onRowSelected(),
        this.postProcessCss()
    }
    postProcessCss() {
      this.setStylesFromGridOptions(!0),
        this.postProcessClassesFromGridOptions(),
        this.postProcessRowClassRules(),
        this.postProcessRowDragging()
    }
    onRowNodeHighlightChanged() {
      const t = this.rowNode.highlighted
      this.allRowGuis.forEach((i) => {
        const s = t === 0,
          n = t === 1
        i.rowComp.addOrRemoveCssClass('ag-row-highlight-above', s),
          i.rowComp.addOrRemoveCssClass('ag-row-highlight-below', n)
      })
    }
    postProcessRowDragging() {
      const t = this.rowNode.dragging
      this.allRowGuis.forEach((i) =>
        i.rowComp.addOrRemoveCssClass('ag-row-dragging', t),
      )
    }
    updateExpandedCss() {
      const t = this.rowNode.isExpandable(),
        i = this.rowNode.expanded == !0
      this.allRowGuis.forEach((s) => {
        s.rowComp.addOrRemoveCssClass('ag-row-group', t),
          s.rowComp.addOrRemoveCssClass('ag-row-group-expanded', t && i),
          s.rowComp.addOrRemoveCssClass('ag-row-group-contracted', t && !i),
          ka(s.element, t && i)
      })
    }
    onDisplayedColumnsChanged() {
      this.updateColumnLists(!0),
        this.beans.columnModel.wasAutoRowHeightEverActive() &&
          this.rowNode.checkAutoHeights()
    }
    onVirtualColumnsChanged() {
      this.updateColumnLists(!1, !0)
    }
    getRowPosition() {
      return {
        rowPinned: As(this.rowNode.rowPinned),
        rowIndex: this.rowNode.rowIndex,
      }
    }
    findFullWidthRowGui(t) {
      return this.allRowGuis.find((i) => i.element.contains(t))
    }
    onKeyboardNavigate(t) {
      const i = this.findFullWidthRowGui(t.target)
      if (!((i ? i.element : null) === t.target)) return
      const r = this.rowNode,
        o = this.beans.focusService.getFocusedCell(),
        a = {
          rowIndex: r.rowIndex,
          rowPinned: r.rowPinned,
          column:
            (o == null ? void 0 : o.column) ?? this.getColumnForFullWidth(i),
        }
      this.beans.navigationService.navigateToNextCell(t, t.key, a, !0),
        t.preventDefault()
    }
    onTabKeyDown(t) {
      if (t.defaultPrevented || Os(t)) return
      const i = this.allRowGuis.find((l) => l.element.contains(t.target)),
        s = i ? i.element : null,
        n = s === t.target,
        r = Lt(this.gos)
      let o = !1
      s && r && (o = s.contains(r) && r.classList.contains('ag-cell'))
      let a = null
      !n &&
        !o &&
        (a = this.beans.focusService.findNextFocusableElement(
          s,
          !1,
          t.shiftKey,
        )),
        ((this.isFullWidth() && n) || !a) &&
          this.beans.navigationService.onTabKeyDown(this, t)
    }
    getFullWidthElement() {
      return this.fullWidthGui ? this.fullWidthGui.element : null
    }
    getRowYPosition() {
      var i
      const t =
        (i = this.allRowGuis.find((s) => fs(s.element))) == null
          ? void 0
          : i.element
      return t ? t.getBoundingClientRect().top : 0
    }
    onSuppressCellFocusChanged(t) {
      const i = this.isFullWidth() && t ? void 0 : -1
      this.allRowGuis.forEach((s) => {
        $i(s.element, 'tabindex', i)
      })
    }
    onFullWidthRowFocused(t) {
      var r
      const i = this.rowNode,
        s = t
          ? this.isFullWidth() &&
            t.rowIndex === i.rowIndex &&
            t.rowPinned == i.rowPinned
          : !1,
        n = this.fullWidthGui
          ? this.fullWidthGui.element
          : (r = this.centerGui) == null
            ? void 0
            : r.element
      n &&
        (n.classList.toggle('ag-full-width-focus', s),
        s && t != null && t.forceBrowserFocus && n.focus({ preventScroll: !0 }))
    }
    recreateCell(t) {
      ;(this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, t)),
        (this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, t)),
        (this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, t)),
        t.destroy(),
        this.updateColumnLists()
    }
    removeCellCtrl(t, i) {
      const s = { list: [], map: {} }
      return (
        t.list.forEach((n) => {
          n !== i &&
            (s.list.push(n), (s.map[n.getColumn().getInstanceId()] = n))
        }),
        s
      )
    }
    onMouseEvent(t, i) {
      switch (t) {
        case 'dblclick':
          this.onRowDblClick(i)
          break
        case 'click':
          this.onRowClick(i)
          break
        case 'touchstart':
        case 'mousedown':
          this.onRowMouseDown(i)
          break
      }
    }
    createRowEvent(t, i) {
      return this.gos.addGridCommonParams({
        type: t,
        node: this.rowNode,
        data: this.rowNode.data,
        rowIndex: this.rowNode.rowIndex,
        rowPinned: this.rowNode.rowPinned,
        event: i,
      })
    }
    createRowEventWithSource(t, i) {
      const s = this.createRowEvent(t, i)
      return (s.source = this), s
    }
    onRowDblClick(t) {
      Os(t) ||
        this.beans.eventService.dispatchEvent(
          this.createRowEventWithSource('rowDoubleClicked', t),
        )
    }
    getColumnForFullWidth(t) {
      const { visibleColsService: i } = this.beans
      switch (t == null ? void 0 : t.containerType) {
        case 'center':
          return i.getCenterCols()[0]
        case 'left':
          return i.getLeftCols()[0]
        case 'right':
          return i.getRightCols()[0]
        default:
          return i.getAllCols()[0]
      }
    }
    onRowMouseDown(t) {
      if (
        ((this.lastMouseDownOnDragger = ar(t.target, 'ag-row-drag', 3)),
        !this.isFullWidth())
      )
        return
      const i = this.rowNode
      this.beans.rangeService && this.beans.rangeService.removeAllCellRanges()
      const s = this.findFullWidthRowGui(t.target),
        n = s == null ? void 0 : s.element,
        r = t.target
      let o = !0
      n && n.contains(r) && ld(r) && (o = !1),
        this.beans.focusService.setFocusedCell({
          rowIndex: i.rowIndex,
          column: this.getColumnForFullWidth(s),
          rowPinned: i.rowPinned,
          forceBrowserFocus: o,
        })
    }
    onRowClick(t) {
      if (Os(t) || this.lastMouseDownOnDragger) return
      const { gos: s } = this
      this.beans.eventService.dispatchEvent(
        this.createRowEventWithSource('rowClicked', t),
      )
      const n = t.ctrlKey || t.metaKey,
        r = t.shiftKey,
        o = this.rowNode.isSelected(),
        a = Gn(s),
        l = hg(s),
        c = Sx(s)
      if (
        (a && this.rowNode.group) ||
        this.isRowSelectionBlocked() ||
        (!c && !o) ||
        (!l && o)
      )
        return
      const u = wx(s),
        h = 'rowClicked'
      if (o)
        u
          ? this.rowNode.setSelectedParams({
              newValue: !1,
              event: t,
              source: h,
            })
          : n
            ? l &&
              this.rowNode.setSelectedParams({
                newValue: !1,
                event: t,
                source: h,
              })
            : c &&
              this.rowNode.setSelectedParams({
                newValue: !0,
                clearSelection: !r,
                rangeSelect: r,
                event: t,
                source: h,
              })
      else {
        const g = u ? !1 : !n
        this.rowNode.setSelectedParams({
          newValue: !0,
          clearSelection: g,
          rangeSelect: r,
          event: t,
          source: h,
        })
      }
    }
    isRowSelectionBlocked() {
      return (
        !this.rowNode.selectable || !!this.rowNode.rowPinned || !Ia(this.gos)
      )
    }
    setupDetailRowAutoHeight(t) {
      if (
        this.rowType !== 'FullWidthDetail' ||
        !this.gos.get('detailRowAutoHeight')
      )
        return
      const i = () => {
          const n = t.clientHeight
          if (n != null && n > 0) {
            const r = () => {
              this.rowNode.setRowHeight(n),
                (Pt(this.gos) || ms(this.gos)) &&
                  this.beans.rowModel.onRowHeightChanged()
            }
            window.setTimeout(r, 0)
          }
        },
        s = this.beans.resizeObserverService.observeResize(t, i)
      this.addDestroyFunc(s), i()
    }
    createFullWidthCompDetails(t, i) {
      const { gos: s, rowNode: n } = this,
        r = s.addGridCommonParams({
          fullWidth: !0,
          data: n.data,
          node: n,
          value: n.key,
          valueFormatted: n.key,
          eGridCell: t,
          eParentOfValue: t,
          pinned: i,
          addRenderedRowListener: this.addEventListener.bind(this),
          registerRowDragger: (a, l, c, u) =>
            this.addFullWidthRowDragging(a, l, c, u),
          setTooltip: (a, l) => this.refreshRowTooltip(a, l),
        }),
        o = this.beans.userComponentFactory
      switch (this.rowType) {
        case 'FullWidthDetail':
          return o.getFullWidthDetailCellRendererDetails(r)
        case 'FullWidthGroup':
          return o.getFullWidthGroupCellRendererDetails(r)
        case 'FullWidthLoading':
          return o.getFullWidthLoadingCellRendererDetails(r)
        default:
          return o.getFullWidthCellRendererDetails(r)
      }
    }
    refreshRowTooltip(t, i) {
      if (!this.fullWidthGui) return
      const s = {
        getGui: () => this.fullWidthGui.element,
        getTooltipValue: () => t,
        getLocation: () => 'fullWidthRow',
        shouldDisplayTooltip: i,
      }
      this.tooltipFeature &&
        this.destroyBean(this.tooltipFeature, this.beans.context),
        (this.tooltipFeature = this.createBean(new Tr(s, this.beans)))
    }
    addFullWidthRowDragging(t, i, s = '', n) {
      if (!this.isFullWidth()) return
      const r = new tu(() => s, this.rowNode, void 0, t, i, n)
      this.createBean(r, this.beans.context),
        this.addDestroyFunc(() => {
          this.destroyBean(r, this.beans.context)
        })
    }
    onUiLevelChanged() {
      const t = this.beans.rowCssClassCalculator.calculateRowLevel(this.rowNode)
      if (this.rowLevel != t) {
        const i = 'ag-row-level-' + t,
          s = 'ag-row-level-' + this.rowLevel
        this.allRowGuis.forEach((n) => {
          n.rowComp.addOrRemoveCssClass(i, !0),
            n.rowComp.addOrRemoveCssClass(s, !1)
        })
      }
      this.rowLevel = t
    }
    isFirstRowOnPage() {
      return (
        this.rowNode.rowIndex === this.beans.pageBoundsService.getFirstRow()
      )
    }
    isLastRowOnPage() {
      return this.rowNode.rowIndex === this.beans.pageBoundsService.getLastRow()
    }
    refreshFirstAndLastRowStyles() {
      const t = this.isFirstRowOnPage(),
        i = this.isLastRowOnPage()
      this.firstRowOnPage !== t &&
        ((this.firstRowOnPage = t),
        this.allRowGuis.forEach((s) =>
          s.rowComp.addOrRemoveCssClass('ag-row-first', t),
        )),
        this.lastRowOnPage !== i &&
          ((this.lastRowOnPage = i),
          this.allRowGuis.forEach((s) =>
            s.rowComp.addOrRemoveCssClass('ag-row-last', i),
          ))
    }
    stopEditing(t = !1) {
      var i
      this.stoppingRowEdit ||
        (i = this.beans.rowEditService) == null ||
        i.stopEditing(this, t)
    }
    setInlineEditingCss() {
      const t =
        this.editingRow || this.getAllCellCtrls().some((i) => i.isEditing())
      this.allRowGuis.forEach((i) => {
        i.rowComp.addOrRemoveCssClass('ag-row-inline-editing', t),
          i.rowComp.addOrRemoveCssClass('ag-row-not-inline-editing', !t)
      })
    }
    setEditingRow(t) {
      this.editingRow = t
    }
    startRowEditing(t = null, i = null, s = null) {
      var n
      return this.editingRow
        ? !0
        : (((n = this.beans.rowEditService) == null
            ? void 0
            : n.startEditing(this, t, i, s)) ?? !0)
    }
    getAllCellCtrls() {
      return this.leftCellCtrls.list.length === 0 &&
        this.rightCellCtrls.list.length === 0
        ? this.centerCellCtrls.list
        : [
            ...this.centerCellCtrls.list,
            ...this.leftCellCtrls.list,
            ...this.rightCellCtrls.list,
          ]
    }
    postProcessClassesFromGridOptions() {
      const t = this.beans.rowCssClassCalculator.processClassesFromGridOptions(
        this.rowNode,
      )
      !t ||
        !t.length ||
        t.forEach((i) => {
          this.allRowGuis.forEach((s) => s.rowComp.addOrRemoveCssClass(i, !0))
        })
    }
    postProcessRowClassRules() {
      this.beans.rowCssClassCalculator.processRowClassRules(
        this.rowNode,
        (t) => {
          this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass(t, !0))
        },
        (t) => {
          this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass(t, !1))
        },
      )
    }
    setStylesFromGridOptions(t, i) {
      t && (this.rowStyles = this.processStylesFromGridOptions()),
        this.forEachGui(i, (s) => s.rowComp.setUserStyles(this.rowStyles))
    }
    getPinnedForContainer(t) {
      return t === 'left' || t === 'right' ? t : null
    }
    getInitialRowClasses(t) {
      const i = this.getPinnedForContainer(t),
        s = {
          rowNode: this.rowNode,
          rowFocused: this.rowFocused,
          fadeRowIn: this.fadeInAnimation[t],
          rowIsEven: this.rowNode.rowIndex % 2 === 0,
          rowLevel: this.rowLevel,
          fullWidthRow: this.isFullWidth(),
          firstRowOnPage: this.isFirstRowOnPage(),
          lastRowOnPage: this.isLastRowOnPage(),
          printLayout: this.printLayout,
          expandable: this.rowNode.isExpandable(),
          pinned: i,
        }
      return this.beans.rowCssClassCalculator.getInitialRowClasses(s)
    }
    processStylesFromGridOptions() {
      const t = this.gos.get('rowStyle')
      if (t && typeof t == 'function') {
        te(
          'rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead',
        )
        return
      }
      const i = this.gos.getCallback('getRowStyle')
      let s
      if (i) {
        const n = {
          data: this.rowNode.data,
          node: this.rowNode,
          rowIndex: this.rowNode.rowIndex,
        }
        s = i(n)
      }
      return s || t ? Object.assign({}, t, s) : this.emptyStyle
    }
    onRowSelected(t) {
      const i = !!this.rowNode.isSelected()
      this.forEachGui(t, (s) => {
        s.rowComp.addOrRemoveCssClass('ag-row-selected', i),
          Ha(s.element, i),
          s.element.contains(Lt(this.gos)) &&
            (s === this.centerGui || s === this.fullWidthGui) &&
            this.announceDescription()
      })
    }
    announceDescription() {
      if (this.isRowSelectionBlocked()) return
      const t = this.rowNode.isSelected()
      if (t && !hg(this.gos)) return
      const s = this.beans.localeService.getLocaleTextFunc()(
        t ? 'ariaRowDeselect' : 'ariaRowSelect',
        `Press SPACE to ${t ? 'deselect' : 'select'} this row.`,
      )
      this.beans.ariaAnnouncementService.announceValue(s, 'rowSelection')
    }
    addHoverFunctionality(t) {
      if (!this.active) return
      const { element: i, compBean: s } = t,
        { rowNode: n, beans: r, gos: o } = this
      s.addManagedListeners(i, {
        mouseenter: () => n.onMouseEnter(),
        mouseleave: () => n.onMouseLeave(),
      }),
        s.addManagedListeners(n, {
          mouseEnter: () => {
            !r.dragService.isDragging() &&
              !o.get('suppressRowHoverHighlight') &&
              (i.classList.add('ag-row-hover'), n.setHovered(!0))
          },
          mouseLeave: () => {
            i.classList.remove('ag-row-hover'), n.setHovered(!1)
          },
        })
    }
    roundRowTopToBounds(t) {
      const i = this.beans.ctrlsService
          .getGridBodyCtrl()
          .getScrollFeature()
          .getApproximateVScollPosition(),
        s = this.applyPaginationOffset(i.top, !0) - 100,
        n = this.applyPaginationOffset(i.bottom, !0) + 100
      return Math.min(Math.max(s, t), n)
    }
    getFrameworkOverrides() {
      return this.beans.frameworkOverrides
    }
    forEachGui(t, i) {
      t ? i(t) : this.allRowGuis.forEach(i)
    }
    onRowHeightChanged(t) {
      if (this.rowNode.rowHeight == null) return
      const i = this.rowNode.rowHeight,
        s = this.beans.environment.getDefaultRowHeight(),
        r = vm(this.gos) ? ln(this.gos, this.rowNode).height : void 0,
        o = r ? `${Math.min(s, r) - 2}px` : void 0
      this.forEachGui(t, (a) => {
        ;(a.element.style.height = `${i}px`),
          o && a.element.style.setProperty('--ag-line-height', o)
      })
    }
    addEventListener(t, i) {
      super.addEventListener(t, i)
    }
    removeEventListener(t, i) {
      super.removeEventListener(t, i)
    }
    destroyFirstPass(t = !1) {
      if (((this.active = !1), !t && or(this.gos) && !this.isSticky()))
        if (this.rowNode.rowTop != null) {
          const n = this.roundRowTopToBounds(this.rowNode.rowTop)
          this.setRowTop(n)
        } else
          this.allRowGuis.forEach((n) =>
            n.rowComp.addOrRemoveCssClass('ag-opacity-zero', !0),
          )
      this.rowNode.setHovered(!1)
      const i = this.createRowEvent('virtualRowRemoved')
      this.dispatchLocalEvent(i),
        this.beans.eventService.dispatchEvent(i),
        super.destroy()
    }
    destroySecondPass() {
      ;(this.allRowGuis.length = 0), this.stopEditing()
      const t = (i) => (
        i.list.forEach((s) => s.destroy()), { list: [], map: {} }
      )
      ;(this.centerCellCtrls = t(this.centerCellCtrls)),
        (this.leftCellCtrls = t(this.leftCellCtrls)),
        (this.rightCellCtrls = t(this.rightCellCtrls))
    }
    setFocusedClasses(t) {
      this.forEachGui(t, (i) => {
        i.rowComp.addOrRemoveCssClass('ag-row-focus', this.rowFocused),
          i.rowComp.addOrRemoveCssClass('ag-row-no-focus', !this.rowFocused)
      })
    }
    onCellFocusChanged() {
      const t = this.beans.focusService.isRowFocused(
        this.rowNode.rowIndex,
        this.rowNode.rowPinned,
      )
      t !== this.rowFocused &&
        ((this.rowFocused = t), this.setFocusedClasses()),
        !t && this.editingRow && this.stopEditing(!1)
    }
    onPaginationChanged() {
      var i
      const t =
        ((i = this.beans.paginationService) == null
          ? void 0
          : i.getCurrentPage()) ?? 0
      this.paginationPage !== t &&
        ((this.paginationPage = t), this.onTopChanged()),
        this.refreshFirstAndLastRowStyles()
    }
    onTopChanged() {
      this.setRowTop(this.rowNode.rowTop)
    }
    onPaginationPixelOffsetChanged() {
      this.onTopChanged()
    }
    applyPaginationOffset(t, i = !1) {
      if (this.rowNode.isRowPinned() || this.rowNode.sticky) return t
      const s = this.beans.pageBoundsService.getPixelOffset()
      return t + s * (i ? 1 : -1)
    }
    setRowTop(t) {
      if (!this.printLayout && ue(t)) {
        const i = this.applyPaginationOffset(t),
          r = `${this.rowNode.isRowPinned() || this.rowNode.sticky ? i : this.beans.rowContainerHeightService.getRealPixelPosition(i)}px`
        this.setRowTopStyle(r)
      }
    }
    getInitialRowTop(t) {
      return this.suppressRowTransform ? this.getInitialRowTopShared(t) : void 0
    }
    getInitialTransform(t) {
      return this.suppressRowTransform
        ? void 0
        : `translateY(${this.getInitialRowTopShared(t)})`
    }
    getInitialRowTopShared(t) {
      if (this.printLayout) return ''
      const i = this.rowNode
      let s
      if (this.isSticky()) s = i.stickyRowTop
      else {
        const n = this.slideInAnimation[t]
            ? this.roundRowTopToBounds(i.oldRowTop)
            : i.rowTop,
          r = this.applyPaginationOffset(n)
        s = i.isRowPinned()
          ? r
          : this.beans.rowContainerHeightService.getRealPixelPosition(r)
      }
      return s + 'px'
    }
    setRowTopStyle(t) {
      this.allRowGuis.forEach((i) =>
        this.suppressRowTransform
          ? i.rowComp.setTop(t)
          : i.rowComp.setTransform(`translateY(${t})`),
      )
    }
    getRowNode() {
      return this.rowNode
    }
    getCellCtrl(t) {
      let i = null
      return (
        this.getAllCellCtrls().forEach((s) => {
          s.getColumn() == t && (i = s)
        }),
        i != null ||
          this.getAllCellCtrls().forEach((s) => {
            s.getColSpanningList().indexOf(t) >= 0 && (i = s)
          }),
        i
      )
    }
    onRowIndexChanged() {
      this.rowNode.rowIndex != null &&
        (this.onCellFocusChanged(),
        this.updateRowIndexes(),
        this.postProcessCss())
    }
    getRowIndex() {
      return this.rowNode.getRowIndexString()
    }
    updateRowIndexes(t) {
      var o
      const i = this.rowNode.getRowIndexString()
      if (i === null) return
      const s =
          this.beans.headerNavigationService.getHeaderRowCount() +
          (((o = this.beans.filterManager) == null
            ? void 0
            : o.getHeaderRowCount()) ?? 0),
        n = this.rowNode.rowIndex % 2 === 0,
        r = s + this.rowNode.rowIndex + 1
      this.forEachGui(t, (a) => {
        a.rowComp.setRowIndex(i),
          a.rowComp.addOrRemoveCssClass('ag-row-even', n),
          a.rowComp.addOrRemoveCssClass('ag-row-odd', !n),
          aD(a.element, r)
      })
    }
    setStoppingRowEdit(t) {
      this.stoppingRowEdit = t
    }
  }
Nv.DOM_DATA_KEY_ROW_CTRL = 'renderedRow'
var On = Nv,
  ET = class extends X {
    wireBeans(e) {
      ;(this.mouseEventService = e.mouseEventService),
        (this.valueService = e.valueService),
        (this.menuService = e.menuService),
        (this.ctrlsService = e.ctrlsService),
        (this.navigationService = e.navigationService),
        (this.focusService = e.focusService),
        (this.undoRedoService = e.undoRedoService),
        (this.visibleColsService = e.visibleColsService),
        (this.rowModel = e.rowModel),
        (this.pinnedRowModel = e.pinnedRowModel),
        (this.rangeService = e.rangeService),
        (this.clipboardService = e.clipboardService)
    }
    constructor(e) {
      super(), (this.element = e)
    }
    postConstruct() {
      this.addKeyboardListeners(),
        this.addMouseListeners(),
        this.mockContextMenuForIPad()
    }
    addKeyboardListeners() {
      const e = 'keydown',
        t = this.processKeyboardEvent.bind(this, e)
      this.addManagedElementListeners(this.element, { [e]: t })
    }
    addMouseListeners() {
      ;[
        'dblclick',
        'contextmenu',
        'mouseover',
        'mouseout',
        'click',
        Dm('touchstart') ? 'touchstart' : 'mousedown',
      ].forEach((i) => {
        const s = this.processMouseEvent.bind(this, i)
        this.addManagedElementListeners(this.element, { [i]: s })
      })
    }
    processMouseEvent(e, t) {
      if (!this.mouseEventService.isEventFromThisGrid(t) || Os(t)) return
      const i = this.getRowForEvent(t),
        s = this.mouseEventService.getRenderedCellForEvent(t)
      e === 'contextmenu'
        ? this.handleContextMenuMouseEvent(t, void 0, i, s)
        : (s && s.onMouseEvent(e, t), i && i.onMouseEvent(e, t))
    }
    mockContextMenuForIPad() {
      if (!fn()) return
      const e = new on(this.element),
        t = (i) => {
          const s = this.getRowForEvent(i.touchEvent),
            n = this.mouseEventService.getRenderedCellForEvent(i.touchEvent)
          this.handleContextMenuMouseEvent(void 0, i.touchEvent, s, n)
        }
      this.addManagedListeners(e, { longTap: t }),
        this.addDestroyFunc(() => e.destroy())
    }
    getRowForEvent(e) {
      let t = e.target
      for (; t; ) {
        const i = mo(this.gos, t, On.DOM_DATA_KEY_ROW_CTRL)
        if (i) return i
        t = t.parentElement
      }
      return null
    }
    handleContextMenuMouseEvent(e, t, i, s) {
      const n = i ? i.getRowNode() : null,
        r = s ? s.getColumn() : null
      let o = null
      if (r) {
        const c = e || t
        s.dispatchCellContextMenuEvent(c ?? null),
          (o = this.valueService.getValue(r, n))
      }
      const a = this.ctrlsService.getGridBodyCtrl(),
        l = s ? s.getGui() : a.getGridBodyElement()
      this.menuService.showContextMenu({
        mouseEvent: e,
        touchEvent: t,
        rowNode: n,
        column: r,
        value: o,
        anchorToElement: l,
      })
    }
    getControlsForEventTarget(e) {
      return {
        cellCtrl: jc(this.gos, e, An.DOM_DATA_KEY_CELL_CTRL),
        rowCtrl: jc(this.gos, e, On.DOM_DATA_KEY_ROW_CTRL),
      }
    }
    processKeyboardEvent(e, t) {
      const { cellCtrl: i, rowCtrl: s } = this.getControlsForEventTarget(
        t.target,
      )
      t.defaultPrevented ||
        (i
          ? this.processCellKeyboardEvent(i, e, t)
          : s &&
            s.isFullWidth() &&
            this.processFullWidthRowKeyboardEvent(s, e, t))
    }
    processCellKeyboardEvent(e, t, i) {
      const s = e.getRowNode(),
        n = e.getColumn(),
        r = e.isEditing()
      !iu(this.gos, i, s, n, r) &&
        t === 'keydown' &&
        ((!r && this.navigationService.handlePageScrollingKey(i)) ||
          e.onKeyDown(i),
        this.doGridOperations(i, e.isEditing()),
        fv(i) && e.processCharacter(i)),
        t === 'keydown' &&
          this.eventService.dispatchEvent(e.createEvent(i, 'cellKeyDown'))
    }
    processFullWidthRowKeyboardEvent(e, t, i) {
      const s = e.getRowNode(),
        n = this.focusService.getFocusedCell(),
        r = n && n.column
      if (!iu(this.gos, i, s, r, !1)) {
        const a = i.key
        if (t === 'keydown')
          switch (a) {
            case Y.PAGE_HOME:
            case Y.PAGE_END:
            case Y.PAGE_UP:
            case Y.PAGE_DOWN:
              this.navigationService.handlePageScrollingKey(i, !0)
              break
            case Y.UP:
            case Y.DOWN:
              e.onKeyboardNavigate(i)
              break
            case Y.TAB:
              e.onTabKeyDown(i)
              break
          }
      }
      t === 'keydown' &&
        this.eventService.dispatchEvent(e.createRowEvent('cellKeyDown', i))
    }
    doGridOperations(e, t) {
      if (
        (!e.ctrlKey && !e.metaKey) ||
        t ||
        !this.mouseEventService.isEventFromThisGrid(e)
      )
        return
      const i = NM(e)
      if (i === Y.A) return this.onCtrlAndA(e)
      if (i === Y.C) return this.onCtrlAndC(e)
      if (i === Y.D) return this.onCtrlAndD(e)
      if (i === Y.V) return this.onCtrlAndV(e)
      if (i === Y.X) return this.onCtrlAndX(e)
      if (i === Y.Y) return this.onCtrlAndY()
      if (i === Y.Z) return this.onCtrlAndZ(e)
    }
    onCtrlAndA(e) {
      const { pinnedRowModel: t, rowModel: i, rangeService: s } = this
      if (s && i.isRowsToRender()) {
        const [n, r] = [t.isEmpty('top'), t.isEmpty('bottom')],
          o = n ? null : 'top'
        let a, l
        r
          ? ((a = null), (l = i.getRowCount() - 1))
          : ((a = 'bottom'), (l = t.getPinnedBottomRowCount() - 1))
        const c = this.visibleColsService.getAllCols()
        if (Hi(c)) return
        s.setCellRange({
          rowStartIndex: 0,
          rowStartPinned: o,
          rowEndIndex: l,
          rowEndPinned: a,
          columnStart: c[0],
          columnEnd: rt(c),
        })
      }
      e.preventDefault()
    }
    onCtrlAndC(e) {
      if (!this.clipboardService || this.gos.get('enableCellTextSelection'))
        return
      const { cellCtrl: t, rowCtrl: i } = this.getControlsForEventTarget(
        e.target,
      )
      ;(t != null && t.isEditing()) ||
        (i != null && i.isEditing()) ||
        (e.preventDefault(), this.clipboardService.copyToClipboard())
    }
    onCtrlAndX(e) {
      if (
        !this.clipboardService ||
        this.gos.get('enableCellTextSelection') ||
        this.gos.get('suppressCutToClipboard')
      )
        return
      const { cellCtrl: t, rowCtrl: i } = this.getControlsForEventTarget(
        e.target,
      )
      ;(t != null && t.isEditing()) ||
        (i != null && i.isEditing()) ||
        (e.preventDefault(), this.clipboardService.cutToClipboard(void 0, 'ui'))
    }
    onCtrlAndV(e) {
      const { cellCtrl: t, rowCtrl: i } = this.getControlsForEventTarget(
        e.target,
      )
      ;(t != null && t.isEditing()) ||
        (i != null && i.isEditing()) ||
        (this.clipboardService &&
          !this.gos.get('suppressClipboardPaste') &&
          this.clipboardService.pasteFromClipboard())
    }
    onCtrlAndD(e) {
      this.clipboardService &&
        !this.gos.get('suppressClipboardPaste') &&
        this.clipboardService.copyRangeDown(),
        e.preventDefault()
    }
    onCtrlAndZ(e) {
      !this.gos.get('undoRedoCellEditing') ||
        !this.undoRedoService ||
        (e.preventDefault(),
        e.shiftKey
          ? this.undoRedoService.redo('ui')
          : this.undoRedoService.undo('ui'))
    }
    onCtrlAndY() {
      var e
      ;(e = this.undoRedoService) == null || e.redo('ui')
    }
  },
  PT = class extends X {
    wireBeans(e) {
      this.pinnedWidthService = e.pinnedWidthService
    }
    constructor(e) {
      super(), (this.element = e)
    }
    postConstruct() {
      this.addManagedEventListeners({
        leftPinnedWidthChanged: this.onPinnedLeftWidthChanged.bind(this),
      })
    }
    onPinnedLeftWidthChanged() {
      const e = this.pinnedWidthService.getPinnedLeftWidth(),
        t = e > 0
      Ot(this.element, t), Zi(this.element, e)
    }
    getWidth() {
      return this.pinnedWidthService.getPinnedLeftWidth()
    }
  },
  xT = class extends X {
    wireBeans(e) {
      this.pinnedWidthService = e.pinnedWidthService
    }
    constructor(e) {
      super(), (this.element = e)
    }
    postConstruct() {
      this.addManagedEventListeners({
        rightPinnedWidthChanged: this.onPinnedRightWidthChanged.bind(this),
      })
    }
    onPinnedRightWidthChanged() {
      const e = this.pinnedWidthService.getPinnedRightWidth(),
        t = e > 0
      Ot(this.element, t), Zi(this.element, e)
    }
    getWidth() {
      return this.pinnedWidthService.getPinnedRightWidth()
    }
  },
  ta = (e) => e.getTopRowCtrls(),
  ia = (e) => e.getStickyTopRowCtrls(),
  sa = (e) => e.getStickyBottomRowCtrls(),
  na = (e) => e.getBottomRowCtrls(),
  ra = (e) => e.getCentreRowCtrls(),
  DT = {
    center: {
      type: 'center',
      container: 'ag-center-cols-container',
      viewport: 'ag-center-cols-viewport',
      getRowCtrls: ra,
    },
    left: {
      type: 'left',
      container: 'ag-pinned-left-cols-container',
      pinnedType: 'left',
      getRowCtrls: ra,
    },
    right: {
      type: 'right',
      container: 'ag-pinned-right-cols-container',
      pinnedType: 'right',
      getRowCtrls: ra,
    },
    fullWidth: {
      type: 'fullWidth',
      container: 'ag-full-width-container',
      fullWidth: !0,
      getRowCtrls: ra,
    },
    topCenter: {
      type: 'center',
      container: 'ag-floating-top-container',
      viewport: 'ag-floating-top-viewport',
      getRowCtrls: ta,
    },
    topLeft: {
      type: 'left',
      container: 'ag-pinned-left-floating-top',
      pinnedType: 'left',
      getRowCtrls: ta,
    },
    topRight: {
      type: 'right',
      container: 'ag-pinned-right-floating-top',
      pinnedType: 'right',
      getRowCtrls: ta,
    },
    topFullWidth: {
      type: 'fullWidth',
      container: 'ag-floating-top-full-width-container',
      fullWidth: !0,
      getRowCtrls: ta,
    },
    stickyTopCenter: {
      type: 'center',
      container: 'ag-sticky-top-container',
      viewport: 'ag-sticky-top-viewport',
      getRowCtrls: ia,
    },
    stickyTopLeft: {
      type: 'left',
      container: 'ag-pinned-left-sticky-top',
      pinnedType: 'left',
      getRowCtrls: ia,
    },
    stickyTopRight: {
      type: 'right',
      container: 'ag-pinned-right-sticky-top',
      pinnedType: 'right',
      getRowCtrls: ia,
    },
    stickyTopFullWidth: {
      type: 'fullWidth',
      container: 'ag-sticky-top-full-width-container',
      fullWidth: !0,
      getRowCtrls: ia,
    },
    stickyBottomCenter: {
      type: 'center',
      container: 'ag-sticky-bottom-container',
      viewport: 'ag-sticky-bottom-viewport',
      getRowCtrls: sa,
    },
    stickyBottomLeft: {
      type: 'left',
      container: 'ag-pinned-left-sticky-bottom',
      pinnedType: 'left',
      getRowCtrls: sa,
    },
    stickyBottomRight: {
      type: 'right',
      container: 'ag-pinned-right-sticky-bottom',
      pinnedType: 'right',
      getRowCtrls: sa,
    },
    stickyBottomFullWidth: {
      type: 'fullWidth',
      container: 'ag-sticky-bottom-full-width-container',
      fullWidth: !0,
      getRowCtrls: sa,
    },
    bottomCenter: {
      type: 'center',
      container: 'ag-floating-bottom-container',
      viewport: 'ag-floating-bottom-viewport',
      getRowCtrls: na,
    },
    bottomLeft: {
      type: 'left',
      container: 'ag-pinned-left-floating-bottom',
      pinnedType: 'left',
      getRowCtrls: na,
    },
    bottomRight: {
      type: 'right',
      container: 'ag-pinned-right-floating-bottom',
      pinnedType: 'right',
      getRowCtrls: na,
    },
    bottomFullWidth: {
      type: 'fullWidth',
      container: 'ag-floating-bottom-full-width-container',
      fullWidth: !0,
      getRowCtrls: na,
    },
  }
function nr(e) {
  return DT[e]
}
var MT = ['topCenter', 'topLeft', 'topRight'],
  IT = ['bottomCenter', 'bottomLeft', 'bottomRight'],
  TT = ['center', 'left', 'right'],
  AT = ['center', 'left', 'right', 'fullWidth'],
  OT = [
    'stickyTopCenter',
    'stickyBottomCenter',
    'center',
    'topCenter',
    'bottomCenter',
  ],
  LT = ['left', 'bottomLeft', 'topLeft', 'stickyTopLeft', 'stickyBottomLeft'],
  kT = [
    'right',
    'bottomRight',
    'topRight',
    'stickyTopRight',
    'stickyBottomRight',
  ],
  Gv = ['stickyTopCenter', 'stickyTopLeft', 'stickyTopRight'],
  Bv = ['stickyBottomCenter', 'stickyBottomLeft', 'stickyBottomRight'],
  HT = [...Gv, 'stickyTopFullWidth', ...Bv, 'stickyBottomFullWidth'],
  NT = [...MT, ...IT, ...TT, ...Gv, ...Bv],
  GT = class extends X {
    constructor(e) {
      super(),
        (this.visible = !0),
        (this.EMPTY_CTRLS = []),
        (this.name = e),
        (this.options = nr(e))
    }
    wireBeans(e) {
      ;(this.dragService = e.dragService),
        (this.ctrlsService = e.ctrlsService),
        (this.columnViewportService = e.columnViewportService),
        (this.resizeObserverService = e.resizeObserverService),
        (this.rowRenderer = e.rowRenderer)
    }
    postConstruct() {
      ;(this.enableRtl = this.gos.get('enableRtl')),
        this.forContainers(['center'], () => {
          ;(this.viewportSizeFeature = this.createManagedBean(new XI(this))),
            this.addManagedEventListeners({
              stickyTopOffsetChanged: this.onStickyTopOffsetChanged.bind(this),
            })
        })
    }
    onStickyTopOffsetChanged(e) {
      this.comp.setOffsetTop(`${e.offset}px`)
    }
    registerWithCtrlsService() {
      this.options.fullWidth || this.ctrlsService.register(this.name, this)
    }
    forContainers(e, t) {
      e.indexOf(this.name) >= 0 && t()
    }
    getContainerElement() {
      return this.eContainer
    }
    getViewportSizeFeature() {
      return this.viewportSizeFeature
    }
    setComp(e, t, i) {
      ;(this.comp = e),
        (this.eContainer = t),
        (this.eViewport = i),
        this.createManagedBean(new ET(this.eContainer)),
        this.addPreventScrollWhileDragging(),
        this.listenOnDomOrder()
      const s = () => this.onPinnedWidthChanged()
      this.forContainers(LT, () => {
        ;(this.pinnedWidthFeature = this.createManagedBean(
          new PT(this.eContainer),
        )),
          this.addManagedEventListeners({ leftPinnedWidthChanged: s })
      }),
        this.forContainers(kT, () => {
          ;(this.pinnedWidthFeature = this.createManagedBean(
            new xT(this.eContainer),
          )),
            this.addManagedEventListeners({ rightPinnedWidthChanged: s })
        }),
        this.forContainers(AT, () =>
          this.createManagedBean(
            new kv(this.eContainer, this.name === 'center' ? i : void 0),
          ),
        ),
        this.forContainers(NT, () =>
          this.createManagedBean(new JI(this.eContainer)),
        ),
        this.forContainers(OT, () =>
          this.createManagedBean(
            new Fd((n) => this.comp.setContainerWidth(`${n}px`)),
          ),
        ),
        (this.visible = this.isContainerVisible()),
        this.addListeners(),
        this.registerWithCtrlsService()
    }
    onScrollCallback(e) {
      this.addManagedElementListeners(this.getViewportElement(), { scroll: e })
    }
    addListeners() {
      this.addManagedEventListeners({
        displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
        displayedColumnsWidthChanged:
          this.onDisplayedColumnsWidthChanged.bind(this),
        displayedRowsChanged: (e) => this.onDisplayedRowsChanged(e.afterScroll),
      }),
        this.onDisplayedColumnsChanged(),
        this.onDisplayedColumnsWidthChanged(),
        this.onDisplayedRowsChanged()
    }
    listenOnDomOrder() {
      if (HT.indexOf(this.name) >= 0) {
        this.comp.setDomOrder(!0)
        return
      }
      const t = () => {
        const i = this.gos.get('ensureDomOrder'),
          s = ci(this.gos, 'print')
        this.comp.setDomOrder(i || s)
      }
      this.addManagedPropertyListener('domLayout', t), t()
    }
    onDisplayedColumnsChanged() {
      this.forContainers(['center'], () => this.onHorizontalViewportChanged())
    }
    onDisplayedColumnsWidthChanged() {
      this.forContainers(['center'], () => this.onHorizontalViewportChanged())
    }
    addPreventScrollWhileDragging() {
      const e = (t) => {
        this.dragService.isDragging() && t.cancelable && t.preventDefault()
      }
      this.eContainer.addEventListener('touchmove', e, { passive: !1 }),
        this.addDestroyFunc(() =>
          this.eContainer.removeEventListener('touchmove', e),
        )
    }
    onHorizontalViewportChanged(e = !1) {
      const t = this.getCenterWidth(),
        i = this.getCenterViewportScrollLeft()
      this.columnViewportService.setScrollPosition(t, i, e)
    }
    hasHorizontalScrollGap() {
      return this.eContainer.clientWidth - this.eViewport.clientWidth < 0
    }
    hasVerticalScrollGap() {
      return this.eContainer.clientHeight - this.eViewport.clientHeight < 0
    }
    getCenterWidth() {
      return No(this.eViewport)
    }
    getCenterViewportScrollLeft() {
      return Ba(this.eViewport, this.enableRtl)
    }
    registerViewportResizeListener(e) {
      const t = this.resizeObserverService.observeResize(this.eViewport, e)
      this.addDestroyFunc(() => t())
    }
    isViewportInTheDOMTree() {
      return Km(this.eViewport)
    }
    getViewportScrollLeft() {
      return Ba(this.eViewport, this.enableRtl)
    }
    isHorizontalScrollShowing() {
      return this.gos.get('alwaysShowHorizontalScroll') || SD(this.eViewport)
    }
    getViewportElement() {
      return this.eViewport
    }
    setHorizontalScroll(e) {
      this.comp.setHorizontalScroll(e)
    }
    getHScrollPosition() {
      return {
        left: this.eViewport.scrollLeft,
        right: this.eViewport.scrollLeft + this.eViewport.offsetWidth,
      }
    }
    setCenterViewportScrollLeft(e) {
      Va(this.eViewport, e, this.enableRtl)
    }
    isContainerVisible() {
      return (
        !(this.options.pinnedType != null) ||
        (!!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0)
      )
    }
    onPinnedWidthChanged() {
      const e = this.isContainerVisible()
      this.visible != e && ((this.visible = e), this.onDisplayedRowsChanged())
    }
    onDisplayedRowsChanged(e = !1) {
      const t = this.options.getRowCtrls(this.rowRenderer)
      if (!this.visible || t.length === 0) {
        this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS })
        return
      }
      const i = ci(this.gos, 'print'),
        n = this.gos.get('embedFullWidthRows') || i,
        r = t.filter((o) => {
          const a = o.isFullWidth()
          return this.options.fullWidth ? !n && a : n || !a
        })
      this.comp.setRowCtrls({ rowCtrls: r, useFlushSync: e })
    }
  },
  BT = 'ag-force-vertical-scroll',
  VT = 'ag-selectable',
  _T = 'ag-column-moving',
  WT = class extends X {
    constructor() {
      super(...arguments),
        (this.stickyTopHeight = 0),
        (this.stickyBottomHeight = 0)
    }
    wireBeans(e) {
      ;(this.animationFrameService = e.animationFrameService),
        (this.rowContainerHeightService = e.rowContainerHeightService),
        (this.ctrlsService = e.ctrlsService),
        (this.columnModel = e.columnModel),
        (this.columnSizeService = e.columnSizeService),
        (this.scrollVisibleService = e.scrollVisibleService),
        (this.menuService = e.menuService),
        (this.headerNavigationService = e.headerNavigationService),
        (this.dragAndDropService = e.dragAndDropService),
        (this.pinnedRowModel = e.pinnedRowModel),
        (this.rowRenderer = e.rowRenderer),
        (this.popupService = e.popupService),
        (this.mouseEventService = e.mouseEventService),
        (this.rowModel = e.rowModel),
        (this.filterManager = e.filterManager),
        (this.environment = e.environment)
    }
    getScrollFeature() {
      return this.bodyScrollFeature
    }
    getBodyViewportElement() {
      return this.eBodyViewport
    }
    setComp(e, t, i, s, n, r, o) {
      var a
      ;(this.comp = e),
        (this.eGridBody = t),
        (this.eBodyViewport = i),
        (this.eTop = s),
        (this.eBottom = n),
        (this.eStickyTop = r),
        (this.eStickyBottom = o),
        (this.eCenterColsViewport = i.querySelector(
          `.${nr('center').viewport}`,
        )),
        (this.eFullWidthContainer = i.querySelector(
          `.${nr('fullWidth').container}`,
        )),
        (this.eStickyTopFullWidthContainer = r.querySelector(
          `.${nr('stickyTopFullWidth').container}`,
        )),
        (this.eStickyBottomFullWidthContainer = o.querySelector(
          `.${nr('stickyBottomFullWidth').container}`,
        )),
        this.setCellTextSelection(this.gos.get('enableCellTextSelection')),
        this.addManagedPropertyListener('enableCellTextSelection', (l) =>
          this.setCellTextSelection(l.currentValue),
        ),
        this.createManagedBean(new Pd(this.comp)),
        (this.bodyScrollFeature = this.createManagedBean(
          new QI(this.eBodyViewport),
        )),
        this.addRowDragListener(),
        this.setupRowAnimationCssClass(),
        this.addEventListeners(),
        this.addFocusListeners([s, i, n, r, o]),
        this.onGridColumnsChanged(),
        this.addBodyViewportListener(),
        this.setFloatingHeights(),
        this.disableBrowserDragging(),
        this.addStopEditingWhenGridLosesFocus(),
        this.updateScrollingClasses(),
        (a = this.filterManager) == null || a.setupAdvancedFilterHeaderComp(s),
        this.ctrlsService.register('gridBodyCtrl', this)
    }
    getComp() {
      return this.comp
    }
    addEventListeners() {
      const e = this.setFloatingHeights.bind(this)
      this.addManagedEventListeners({
        gridColumnsChanged: this.onGridColumnsChanged.bind(this),
        scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
        scrollGapChanged: this.onScrollGapChanged.bind(this),
        pinnedRowDataChanged: e,
        pinnedHeightChanged: e,
        headerHeightChanged: this.onHeaderHeightChanged.bind(this),
      })
    }
    addFocusListeners(e) {
      e.forEach((t) => {
        this.addManagedElementListeners(t, {
          focusin: (i) => {
            const { target: s } = i,
              n = ar(s, 'ag-root', t)
            t.classList.toggle('ag-has-focus', !n)
          },
          focusout: (i) => {
            const { target: s, relatedTarget: n } = i,
              r = t.contains(n),
              o = ar(n, 'ag-root', t)
            ar(s, 'ag-root', t) ||
              ((!r || o) && t.classList.remove('ag-has-focus'))
          },
        })
      })
    }
    setColumnMovingCss(e) {
      this.comp.setColumnMovingCss(_T, e)
    }
    setCellTextSelection(e = !1) {
      this.comp.setCellSelectableCss(VT, e)
    }
    onScrollVisibilityChanged() {
      const e = this.scrollVisibleService.isVerticalScrollShowing()
      this.setVerticalScrollPaddingVisible(e),
        this.setStickyWidth(e),
        this.setStickyBottomOffsetBottom()
      const t = (e && this.scrollVisibleService.getScrollbarWidth()) || 0,
        i = zm() ? 16 : 0,
        s = `calc(100% + ${t + i}px)`
      this.animationFrameService.requestAnimationFrame(() =>
        this.comp.setBodyViewportWidth(s),
      ),
        this.updateScrollingClasses()
    }
    onScrollGapChanged() {
      this.updateScrollingClasses()
    }
    updateScrollingClasses() {
      this.eGridBody.classList.toggle(
        'ag-body-vertical-content-no-gap',
        !this.scrollVisibleService.hasVerticalScrollGap(),
      ),
        this.eGridBody.classList.toggle(
          'ag-body-horizontal-content-no-gap',
          !this.scrollVisibleService.hasHorizontalScrollGap(),
        )
    }
    onGridColumnsChanged() {
      const e = this.columnModel.getCols()
      this.comp.setColumnCount(e.length)
    }
    disableBrowserDragging() {
      this.addManagedElementListeners(this.eGridBody, {
        dragstart: (e) => {
          if (e.target instanceof HTMLImageElement)
            return e.preventDefault(), !1
        },
      })
    }
    addStopEditingWhenGridLosesFocus() {
      if (!this.gos.get('stopEditingWhenCellsLoseFocus')) return
      const e = (i) => {
          const s = i.relatedTarget
          if (Zc(s) === null) {
            this.rowRenderer.stopEditing()
            return
          }
          let n =
            t.some((r) => r.contains(s)) &&
            this.mouseEventService.isElementInThisGrid(s)
          if (!n) {
            const r = this.popupService
            n =
              r.getActivePopups().some((o) => o.contains(s)) ||
              r.isElementWithinCustomPopup(s)
          }
          n || this.rowRenderer.stopEditing()
        },
        t = [
          this.eBodyViewport,
          this.eBottom,
          this.eTop,
          this.eStickyTop,
          this.eStickyBottom,
        ]
      t.forEach((i) => this.addManagedElementListeners(i, { focusout: e }))
    }
    updateRowCount() {
      var s
      const e =
          this.headerNavigationService.getHeaderRowCount() +
          (((s = this.filterManager) == null
            ? void 0
            : s.getHeaderRowCount()) ?? 0),
        t = this.rowModel.isLastRowIndexKnown()
          ? this.rowModel.getRowCount()
          : -1,
        i = t === -1 ? -1 : e + t
      this.comp.setRowCount(i)
    }
    registerBodyViewportResizeListener(e) {
      this.comp.registerBodyViewportResizeListener(e)
    }
    setVerticalScrollPaddingVisible(e) {
      const t = e ? 'scroll' : 'hidden'
      this.comp.setPinnedTopBottomOverflowY(t)
    }
    isVerticalScrollShowing() {
      const e = this.gos.get('alwaysShowVerticalScroll'),
        t = e ? BT : null,
        i = ci(this.gos, 'normal')
      return (
        this.comp.setAlwaysVerticalScrollClass(t, e),
        e || (i && wD(this.eBodyViewport))
      )
    }
    setupRowAnimationCssClass() {
      let e = this.environment.hasMeasuredSizes()
      const t = () => {
        const i =
            e && or(this.gos) && !this.rowContainerHeightService.isStretching(),
          s = i ? 'ag-row-animation' : 'ag-row-no-animation'
        this.comp.setRowAnimationCssOnBodyViewport(s, i)
      }
      t(),
        this.addManagedEventListeners({ heightScaleChanged: t }),
        this.addManagedPropertyListener('animateRows', t),
        this.addManagedEventListeners({
          gridStylesChanged: () => {
            !e && this.environment.hasMeasuredSizes() && ((e = !0), t())
          },
        })
    }
    getGridBodyElement() {
      return this.eGridBody
    }
    addBodyViewportListener() {
      const e = this.onBodyViewportContextMenu.bind(this)
      this.addManagedElementListeners(this.eBodyViewport, { contextmenu: e }),
        this.mockContextMenuForIPad(e),
        this.addManagedElementListeners(this.eBodyViewport, {
          wheel: this.onBodyViewportWheel.bind(this),
        }),
        this.addManagedElementListeners(this.eStickyTop, {
          wheel: this.onStickyWheel.bind(this),
        }),
        this.addManagedElementListeners(this.eStickyBottom, {
          wheel: this.onStickyWheel.bind(this),
        }),
        this.addFullWidthContainerWheelListener()
    }
    addFullWidthContainerWheelListener() {
      this.addManagedElementListeners(this.eFullWidthContainer, {
        wheel: (e) => this.onFullWidthContainerWheel(e),
      })
    }
    onFullWidthContainerWheel(e) {
      const { deltaX: t, deltaY: i, shiftKey: s } = e
      ;(s || Math.abs(t) > Math.abs(i)) &&
        this.mouseEventService.isEventFromThisGrid(e) &&
        this.scrollGridBodyToMatchEvent(e)
    }
    onStickyWheel(e) {
      const { deltaX: t, deltaY: i, shiftKey: s } = e,
        n = s || Math.abs(t) > Math.abs(i),
        r = e.target
      n
        ? (this.eStickyTopFullWidthContainer.contains(r) ||
            this.eStickyBottomFullWidthContainer.contains(r)) &&
          this.scrollGridBodyToMatchEvent(e)
        : (e.preventDefault(), this.scrollVertically(i))
    }
    scrollGridBodyToMatchEvent(e) {
      const { deltaX: t, deltaY: i } = e
      e.preventDefault(), this.eCenterColsViewport.scrollBy({ left: t || i })
    }
    onBodyViewportContextMenu(e, t, i) {
      if (!e && !i) return
      this.gos.get('preventDefaultOnContextMenu') && (e || i).preventDefault()
      const { target: s } = e || t
      ;(s === this.eBodyViewport ||
        s === this.ctrlsService.get('center').getViewportElement()) &&
        this.menuService.showContextMenu({
          mouseEvent: e,
          touchEvent: i,
          value: null,
          anchorToElement: this.eGridBody,
        })
    }
    mockContextMenuForIPad(e) {
      if (!fn()) return
      const t = new on(this.eBodyViewport),
        i = (s) => {
          e(void 0, s.touchStart, s.touchEvent)
        }
      this.addManagedListeners(t, { longTap: i }),
        this.addDestroyFunc(() => t.destroy())
    }
    onBodyViewportWheel(e) {
      this.gos.get('suppressScrollWhenPopupsAreOpen') &&
        this.popupService.hasAnchoredPopup() &&
        e.preventDefault()
    }
    getGui() {
      return this.eGridBody
    }
    scrollVertically(e) {
      const t = this.eBodyViewport.scrollTop
      return (
        this.bodyScrollFeature.setVerticalScrollPosition(t + e),
        this.eBodyViewport.scrollTop - t
      )
    }
    addRowDragListener() {
      ;(this.rowDragFeature = this.createManagedBean(
        new mM(this.eBodyViewport),
      )),
        this.dragAndDropService.addDropTarget(this.rowDragFeature),
        this.addDestroyFunc(() =>
          this.dragAndDropService.removeDropTarget(this.rowDragFeature),
        )
    }
    getRowDragFeature() {
      return this.rowDragFeature
    }
    setFloatingHeights() {
      const { pinnedRowModel: e } = this,
        t = e.getPinnedTopTotalHeight(),
        i = e.getPinnedBottomTotalHeight()
      this.comp.setTopHeight(t),
        this.comp.setBottomHeight(i),
        this.comp.setTopDisplay(t ? 'inherit' : 'none'),
        this.comp.setBottomDisplay(i ? 'inherit' : 'none'),
        this.setStickyTopOffsetTop(),
        this.setStickyBottomOffsetBottom()
    }
    setStickyTopHeight(e = 0) {
      this.comp.setStickyTopHeight(`${e}px`), (this.stickyTopHeight = e)
    }
    getStickyTopHeight() {
      return this.stickyTopHeight
    }
    setStickyBottomHeight(e = 0) {
      this.comp.setStickyBottomHeight(`${e}px`), (this.stickyBottomHeight = e)
    }
    getStickyBottomHeight() {
      return this.stickyBottomHeight
    }
    setStickyWidth(e) {
      if (!e)
        this.comp.setStickyTopWidth('100%'),
          this.comp.setStickyBottomWidth('100%')
      else {
        const t = this.scrollVisibleService.getScrollbarWidth()
        this.comp.setStickyTopWidth(`calc(100% - ${t}px)`),
          this.comp.setStickyBottomWidth(`calc(100% - ${t}px)`)
      }
    }
    onHeaderHeightChanged() {
      this.setStickyTopOffsetTop()
    }
    setStickyTopOffsetTop() {
      var n
      const t =
          this.ctrlsService.get('gridHeaderCtrl').getHeaderHeight() +
          (((n = this.filterManager) == null ? void 0 : n.getHeaderHeight()) ??
            0),
        i = this.pinnedRowModel.getPinnedTopTotalHeight()
      let s = 0
      t > 0 && (s += t),
        i > 0 && (s += i),
        s > 0 && (s += 1),
        this.comp.setStickyTopTop(`${s}px`)
    }
    setStickyBottomOffsetBottom() {
      const e = this.pinnedRowModel.getPinnedBottomTotalHeight(),
        i =
          (this.scrollVisibleService.isHorizontalScrollShowing() &&
            this.scrollVisibleService.getScrollbarWidth()) ||
          0,
        s = e + i
      this.comp.setStickyBottomBottom(`${s}px`)
    }
    sizeColumnsToFit(e, t) {
      const s = this.isVerticalScrollShowing()
          ? this.scrollVisibleService.getScrollbarWidth()
          : 0,
        r = No(this.eGridBody) - s
      if (r > 0) {
        this.columnSizeService.sizeColumnsToFit(r, 'sizeColumnsToFit', !1, e)
        return
      }
      t === void 0
        ? window.setTimeout(() => {
            this.sizeColumnsToFit(e, 100)
          }, 0)
        : t === 100
          ? window.setTimeout(() => {
              this.sizeColumnsToFit(e, 500)
            }, 100)
          : t === 500
            ? window.setTimeout(() => {
                this.sizeColumnsToFit(e, -1)
              }, 500)
            : te(
                'tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?',
              )
    }
    addScrollEventListener(e) {
      this.eBodyViewport.addEventListener('scroll', e, { passive: !0 })
    }
    removeScrollEventListener(e) {
      this.eBodyViewport.removeEventListener('scroll', e)
    }
  }
function qr(e) {
  return e
    .map((t) => `<ag-row-container name="${t}"></ag-row-container>`)
    .join('')
}
;`${qr(['topLeft', 'topCenter', 'topRight', 'topFullWidth'])}${qr(['left', 'center', 'right', 'fullWidth'])}${qr(['stickyTopLeft', 'stickyTopCenter', 'stickyTopRight', 'stickyTopFullWidth'])}${qr(['stickyBottomLeft', 'stickyBottomCenter', 'stickyBottomRight', 'stickyBottomFullWidth'])}${qr(['bottomLeft', 'bottomCenter', 'bottomRight', 'bottomFullWidth'])}`
var $T = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'scrollVisibleService')
    }
    wireBeans(e) {
      ;(this.ctrlsService = e.ctrlsService),
        (this.columnAnimationService = e.columnAnimationService)
    }
    postConstruct() {
      this.getScrollbarWidth(),
        this.addManagedEventListeners({
          displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
          displayedColumnsWidthChanged:
            this.onDisplayedColumnsWidthChanged.bind(this),
        })
    }
    onDisplayedColumnsChanged() {
      this.updateScrollVisible()
    }
    onDisplayedColumnsWidthChanged() {
      this.updateScrollVisible()
    }
    onCentreViewportResized() {
      this.updateScrollGap()
    }
    updateScrollVisible() {
      this.columnAnimationService.isActive()
        ? this.columnAnimationService.executeLaterVMTurn(() => {
            this.columnAnimationService.executeLaterVMTurn(() =>
              this.updateScrollVisibleImpl(),
            )
          })
        : this.updateScrollVisibleImpl()
    }
    updateScrollVisibleImpl() {
      const e = this.ctrlsService.get('center')
      if (!e || this.columnAnimationService.isActive()) return
      const t = {
        horizontalScrollShowing: e.isHorizontalScrollShowing(),
        verticalScrollShowing: this.isVerticalScrollShowing(),
      }
      this.setScrollsVisible(t), this.updateScrollGap()
    }
    updateScrollGap() {
      const e = this.ctrlsService.get('center'),
        t = e.hasHorizontalScrollGap(),
        i = e.hasVerticalScrollGap()
      ;(this.horizontalScrollGap !== t || this.verticalScrollGap !== i) &&
        ((this.horizontalScrollGap = t),
        (this.verticalScrollGap = i),
        this.eventService.dispatchEvent({ type: 'scrollGapChanged' }))
    }
    setScrollsVisible(e) {
      ;(this.horizontalScrollShowing !== e.horizontalScrollShowing ||
        this.verticalScrollShowing !== e.verticalScrollShowing) &&
        ((this.horizontalScrollShowing = e.horizontalScrollShowing),
        (this.verticalScrollShowing = e.verticalScrollShowing),
        this.eventService.dispatchEvent({ type: 'scrollVisibilityChanged' }))
    }
    isHorizontalScrollShowing() {
      return this.horizontalScrollShowing
    }
    isVerticalScrollShowing() {
      return this.verticalScrollShowing
    }
    hasHorizontalScrollGap() {
      return this.horizontalScrollGap
    }
    hasVerticalScrollGap() {
      return this.verticalScrollGap
    }
    getScrollbarWidth() {
      if (this.scrollbarWidth == null) {
        const e = this.gos.get('scrollbarWidth'),
          i = typeof e == 'number' && e >= 0 ? e : mD()
        i != null &&
          ((this.scrollbarWidth = i),
          this.eventService.dispatchEvent({ type: 'scrollbarWidthChanged' }))
      }
      return this.scrollbarWidth
    }
  },
  xg = '__ag_grid_instance',
  Vv = class _v extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'mouseEventService'),
        (this.gridInstanceId = _v.gridInstanceSequence.next())
    }
    wireBeans(t) {
      this.ctrlsService = t.ctrlsService
    }
    stampTopLevelGridCompWithGridInstance(t) {
      t[xg] = this.gridInstanceId
    }
    getRenderedCellForEvent(t) {
      return jc(this.gos, t.target, An.DOM_DATA_KEY_CELL_CTRL)
    }
    isEventFromThisGrid(t) {
      return this.isElementInThisGrid(t.target)
    }
    isElementInThisGrid(t) {
      let i = t
      for (; i; ) {
        const s = i[xg]
        if (ue(s)) return s === this.gridInstanceId
        i = i.parentElement
      }
      return !1
    }
    getCellPositionForEvent(t) {
      const i = this.getRenderedCellForEvent(t)
      return i ? i.getCellPosition() : null
    }
    getNormalisedPosition(t) {
      const i = ci(this.gos, 'normal'),
        s = t
      let n, r
      if (
        (s.clientX != null || s.clientY != null
          ? ((n = s.clientX), (r = s.clientY))
          : ((n = s.x), (r = s.y)),
        i)
      ) {
        const o = this.ctrlsService.getGridBodyCtrl(),
          a = o.getScrollFeature().getVScrollPosition(),
          l = o.getScrollFeature().getHScrollPosition()
        ;(n += l.left), (r += a.top)
      }
      return { x: n, y: r }
    }
  }
Vv.gridInstanceSequence = new vr()
var zT = Vv,
  UT = class extends X {
    constructor() {
      super(),
        (this.beanName = 'navigationService'),
        (this.onPageDown = ug(this.onPageDown, 100)),
        (this.onPageUp = ug(this.onPageUp, 100))
    }
    wireBeans(e) {
      ;(this.mouseEventService = e.mouseEventService),
        (this.pageBoundsService = e.pageBoundsService),
        (this.focusService = e.focusService),
        (this.columnModel = e.columnModel),
        (this.visibleColsService = e.visibleColsService),
        (this.rowModel = e.rowModel),
        (this.ctrlsService = e.ctrlsService),
        (this.rowRenderer = e.rowRenderer),
        (this.headerNavigationService = e.headerNavigationService),
        (this.rowPositionUtils = e.rowPositionUtils),
        (this.cellNavigationService = e.cellNavigationService),
        (this.pinnedRowModel = e.pinnedRowModel),
        (this.scrollVisibleService = e.scrollVisibleService),
        (this.rangeService = e.rangeService)
    }
    postConstruct() {
      this.ctrlsService.whenReady(this, (e) => {
        this.gridBodyCon = e.gridBodyCtrl
      })
    }
    handlePageScrollingKey(e, t = !1) {
      const i = e.key,
        s = e.altKey,
        n = e.ctrlKey || e.metaKey,
        r = !!this.rangeService && e.shiftKey,
        o = this.mouseEventService.getCellPositionForEvent(e)
      let a = !1
      switch (i) {
        case Y.PAGE_HOME:
        case Y.PAGE_END:
          !n && !s && (this.onHomeOrEndKey(i), (a = !0))
          break
        case Y.LEFT:
        case Y.RIGHT:
        case Y.UP:
        case Y.DOWN:
          if (!o) return !1
          n && !s && !r && (this.onCtrlUpDownLeftRight(i, o), (a = !0))
          break
        case Y.PAGE_DOWN:
        case Y.PAGE_UP:
          !n && !s && (a = this.handlePageUpDown(i, o, t))
          break
      }
      return a && e.preventDefault(), a
    }
    handlePageUpDown(e, t, i) {
      return (
        i && (t = this.focusService.getFocusedCell()),
        t ? (e === Y.PAGE_UP ? this.onPageUp(t) : this.onPageDown(t), !0) : !1
      )
    }
    navigateTo(e) {
      var o
      const {
        scrollIndex: t,
        scrollType: i,
        scrollColumn: s,
        focusIndex: n,
        focusColumn: r,
      } = e
      ue(s) &&
        !s.isPinned() &&
        this.gridBodyCon.getScrollFeature().ensureColumnVisible(s),
        ue(t) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(t, i),
        e.isAsync || this.gridBodyCon.getScrollFeature().ensureIndexVisible(n),
        this.focusService.setFocusedCell({
          rowIndex: n,
          column: r,
          rowPinned: null,
          forceBrowserFocus: !0,
        }),
        (o = this.rangeService) == null ||
          o.setRangeToCell({ rowIndex: n, rowPinned: null, column: r })
    }
    onPageDown(e) {
      const i = this.ctrlsService
          .getGridBodyCtrl()
          .getScrollFeature()
          .getVScrollPosition(),
        s = this.getViewportHeight(),
        n = this.pageBoundsService.getPixelOffset(),
        r = i.top + s,
        o = this.rowModel.getRowIndexAtPixel(r + n)
      this.columnModel.isAutoRowHeightActive()
        ? this.navigateToNextPageWithAutoHeight(e, o)
        : this.navigateToNextPage(e, o)
    }
    onPageUp(e) {
      const i = this.ctrlsService
          .getGridBodyCtrl()
          .getScrollFeature()
          .getVScrollPosition(),
        s = this.pageBoundsService.getPixelOffset(),
        n = i.top,
        r = this.rowModel.getRowIndexAtPixel(n + s)
      this.columnModel.isAutoRowHeightActive()
        ? this.navigateToNextPageWithAutoHeight(e, r, !0)
        : this.navigateToNextPage(e, r, !0)
    }
    navigateToNextPage(e, t, i = !1) {
      const s = this.getViewportHeight(),
        n = this.pageBoundsService.getFirstRow(),
        r = this.pageBoundsService.getLastRow(),
        o = this.pageBoundsService.getPixelOffset(),
        a = this.rowModel.getRow(e.rowIndex),
        l = i ? (a == null ? void 0 : a.rowHeight) - s - o : s - o,
        c = (a == null ? void 0 : a.rowTop) + l
      let u = this.rowModel.getRowIndexAtPixel(c + o)
      if (u === e.rowIndex) {
        const g = i ? -1 : 1
        t = u = e.rowIndex + g
      }
      let h
      i
        ? ((h = 'bottom'), u < n && (u = n), t < n && (t = n))
        : ((h = 'top'), u > r && (u = r), t > r && (t = r)),
        this.isRowTallerThanView(u) && ((t = u), (h = 'top')),
        this.navigateTo({
          scrollIndex: t,
          scrollType: h,
          scrollColumn: null,
          focusIndex: u,
          focusColumn: e.column,
        })
    }
    navigateToNextPageWithAutoHeight(e, t, i = !1) {
      this.navigateTo({
        scrollIndex: t,
        scrollType: i ? 'bottom' : 'top',
        scrollColumn: null,
        focusIndex: t,
        focusColumn: e.column,
      }),
        setTimeout(() => {
          const s = this.getNextFocusIndexForAutoHeight(e, i)
          this.navigateTo({
            scrollIndex: t,
            scrollType: i ? 'bottom' : 'top',
            scrollColumn: null,
            focusIndex: s,
            focusColumn: e.column,
            isAsync: !0,
          })
        }, 50)
    }
    getNextFocusIndexForAutoHeight(e, t = !1) {
      const i = t ? -1 : 1,
        s = this.getViewportHeight(),
        n = this.pageBoundsService.getLastRow()
      let r = 0,
        o = e.rowIndex
      for (; o >= 0 && o <= n; ) {
        const a = this.rowModel.getRow(o)
        if (a) {
          const l = a.rowHeight ?? 0
          if (r + l > s) break
          r += l
        }
        o += i
      }
      return Math.max(0, Math.min(o, n))
    }
    getViewportHeight() {
      const e = this.ctrlsService
          .getGridBodyCtrl()
          .getScrollFeature()
          .getVScrollPosition(),
        t = this.scrollVisibleService.getScrollbarWidth()
      let i = e.bottom - e.top
      return (
        this.ctrlsService.get('center').isHorizontalScrollShowing() && (i -= t),
        i
      )
    }
    isRowTallerThanView(e) {
      const t = this.rowModel.getRow(e)
      if (!t) return !1
      const i = t.rowHeight
      return typeof i != 'number' ? !1 : i > this.getViewportHeight()
    }
    onCtrlUpDownLeftRight(e, t) {
      const i = this.cellNavigationService.getNextCellToFocus(e, t, !0),
        { rowIndex: s } = i,
        n = i.column
      this.navigateTo({
        scrollIndex: s,
        scrollType: null,
        scrollColumn: n,
        focusIndex: s,
        focusColumn: n,
      })
    }
    onHomeOrEndKey(e) {
      const t = e === Y.PAGE_HOME,
        i = this.visibleColsService.getAllCols(),
        s = t ? i[0] : rt(i),
        n = t
          ? this.pageBoundsService.getFirstRow()
          : this.pageBoundsService.getLastRow()
      this.navigateTo({
        scrollIndex: n,
        scrollType: null,
        scrollColumn: s,
        focusIndex: n,
        focusColumn: s,
      })
    }
    onTabKeyDown(e, t) {
      const i = t.shiftKey,
        s = this.tabToNextCellCommon(e, i, t)
      if (s !== !1) {
        s
          ? t.preventDefault()
          : s === null &&
            this.focusService.allowFocusForNextGridCoreContainer(i)
        return
      }
      if (i) {
        const { rowIndex: n, rowPinned: r } = e.getRowPosition()
        ;(r ? n === 0 : n === this.pageBoundsService.getFirstRow()) &&
          (this.gos.get('headerHeight') === 0 ||
          this.focusService.isHeaderFocusSuppressed()
            ? this.focusService.focusNextGridCoreContainer(!0, !0)
            : (t.preventDefault(),
              this.focusService.focusPreviousFromFirstCell(t)))
      } else
        e instanceof An && e.focusCell(!0),
          ((!i && this.focusService.focusOverlay(!1)) ||
            this.focusService.focusNextGridCoreContainer(i)) &&
            t.preventDefault()
    }
    tabToNextCell(e, t) {
      const i = this.focusService.getFocusedCell()
      if (!i) return !1
      let s = this.getCellByPosition(i)
      return !s &&
        ((s = this.rowRenderer.getRowByPosition(i)), !s || !s.isFullWidth())
        ? !1
        : !!this.tabToNextCellCommon(s, e, t)
    }
    tabToNextCellCommon(e, t, i) {
      let s = e.isEditing()
      if (!s && e instanceof An) {
        const o = e.getRowCtrl()
        o && (s = o.isEditing())
      }
      let n
      return (
        s
          ? this.gos.get('editType') === 'fullRow'
            ? (n = this.moveToNextEditingRow(e, t, i))
            : (n = this.moveToNextEditingCell(e, t, i))
          : (n = this.moveToNextCellNotEditing(e, t)),
        n === null ? n : n || !!this.focusService.getFocusedHeader()
      )
    }
    moveToNextEditingCell(e, t, i = null) {
      const s = e.getCellPosition()
      e.getGui().focus(), e.stopEditing()
      const n = this.findNextCellToFocusOn(s, t, !0)
      return n === !1
        ? null
        : n == null
          ? !1
          : (n.startEditing(null, !0, i), n.focusCell(!1), !0)
    }
    moveToNextEditingRow(e, t, i = null) {
      const s = e.getCellPosition(),
        n = this.findNextCellToFocusOn(s, t, !0)
      if (n === !1) return null
      if (n == null) return !1
      const r = n.getCellPosition(),
        o = this.isCellEditable(s),
        a = this.isCellEditable(r),
        l = r && s.rowIndex === r.rowIndex && s.rowPinned === r.rowPinned
      return (
        o && e.setFocusOutOnEditor(),
        l ||
          (e.getRowCtrl().stopEditing(),
          n.getRowCtrl().startRowEditing(void 0, void 0, i)),
        a ? (n.setFocusInOnEditor(), n.focusCell()) : n.focusCell(!0),
        !0
      )
    }
    moveToNextCellNotEditing(e, t) {
      const i = this.visibleColsService.getAllCols()
      let s
      e instanceof On
        ? (s = { ...e.getRowPosition(), column: t ? i[0] : rt(i) })
        : (s = e.getCellPosition())
      const n = this.findNextCellToFocusOn(s, t, !1)
      if (n === !1) return null
      if (n instanceof An) n.focusCell(!0)
      else if (n) return this.tryToFocusFullWidthRow(n.getRowPosition(), t)
      return ue(n)
    }
    findNextCellToFocusOn(e, t, i) {
      var n
      let s = e
      for (;;) {
        e !== s && (e = s),
          t || (s = this.getLastCellOfColSpan(s)),
          (s = this.cellNavigationService.getNextTabbedCell(s, t))
        const r = this.gos.getCallback('tabToNextCell')
        if (ue(r)) {
          const c = r({
            backwards: t,
            editing: i,
            previousCellPosition: e,
            nextCellPosition: s || null,
          })
          if (c === !0 || c === null)
            c === null &&
              te(
                'Returning `null` from tabToNextCell is deprecated. Return `true` to stay on the current cell, or `false` to let the browser handle the tab behaviour.',
              ),
              (s = e)
          else {
            if (c === !1) return !1
            s = {
              rowIndex: c.rowIndex,
              column: c.column,
              rowPinned: c.rowPinned,
            }
          }
        }
        if (!s) return null
        if (s.rowIndex < 0) {
          const l = this.headerNavigationService.getHeaderRowCount()
          return (
            this.focusService.focusHeaderPosition({
              headerPosition: {
                headerRowIndex: l + s.rowIndex,
                column: s.column,
              },
              fromCell: !0,
            }),
            null
          )
        }
        const o = this.gos.get('editType') === 'fullRow'
        if (i && !o && !this.isCellEditable(s)) continue
        this.ensureCellVisible(s)
        const a = this.getCellByPosition(s)
        if (!a) {
          const l = this.rowRenderer.getRowByPosition(s)
          if (!l || !l.isFullWidth() || i) continue
          return l
        }
        if (!a.isSuppressNavigable())
          return (n = this.rangeService) == null || n.setRangeToCell(s), a
      }
    }
    isCellEditable(e) {
      const t = this.lookupRowNodeForCell(e)
      return t ? e.column.isCellEditable(t) : !1
    }
    getCellByPosition(e) {
      const t = this.rowRenderer.getRowByPosition(e)
      return t ? t.getCellCtrl(e.column) : null
    }
    lookupRowNodeForCell(e) {
      return e.rowPinned === 'top'
        ? this.pinnedRowModel.getPinnedTopRow(e.rowIndex)
        : e.rowPinned === 'bottom'
          ? this.pinnedRowModel.getPinnedBottomRow(e.rowIndex)
          : this.rowModel.getRow(e.rowIndex)
    }
    navigateToNextCell(e, t, i, s) {
      let n = i,
        r = !1
      for (; n && (n === i || !this.isValidNavigateCell(n)); )
        this.gos.get('enableRtl')
          ? t === Y.LEFT && (n = this.getLastCellOfColSpan(n))
          : t === Y.RIGHT && (n = this.getLastCellOfColSpan(n)),
          (n = this.cellNavigationService.getNextCellToFocus(t, n)),
          (r = ot(n))
      if (
        (r &&
          e &&
          e.key === Y.UP &&
          (n = { rowIndex: -1, rowPinned: null, column: i.column }),
        s)
      ) {
        const a = this.gos.getCallback('navigateToNextCell')
        if (ue(a)) {
          const c = a({
            key: t,
            previousCellPosition: i,
            nextCellPosition: n || null,
            event: e,
          })
          ue(c)
            ? (n = {
                rowPinned: c.rowPinned,
                rowIndex: c.rowIndex,
                column: c.column,
              })
            : (n = null)
        }
      }
      if (!n) return
      if (n.rowIndex < 0) {
        const a = this.headerNavigationService.getHeaderRowCount()
        this.focusService.focusHeaderPosition({
          headerPosition: { headerRowIndex: a + n.rowIndex, column: i.column },
          event: e || void 0,
          fromCell: !0,
        })
        return
      }
      const o = this.getNormalisedPosition(n)
      o ? this.focusPosition(o) : this.tryToFocusFullWidthRow(n)
    }
    getNormalisedPosition(e) {
      this.ensureCellVisible(e)
      const t = this.getCellByPosition(e)
      return t
        ? ((e = t.getCellPosition()), this.ensureCellVisible(e), e)
        : null
    }
    tryToFocusFullWidthRow(e, t) {
      const i = this.visibleColsService.getAllCols(),
        s = this.rowRenderer.getRowByPosition(e)
      if (!s || !s.isFullWidth()) return !1
      const n = this.focusService.getFocusedCell(),
        r = {
          rowIndex: e.rowIndex,
          rowPinned: e.rowPinned,
          column: e.column || (t ? rt(i) : i[0]),
        }
      this.focusPosition(r)
      const o = t ?? (n != null && this.rowPositionUtils.before(r, n))
      return (
        this.eventService.dispatchEvent({
          type: 'fullWidthRowFocused',
          rowIndex: r.rowIndex,
          rowPinned: r.rowPinned,
          column: r.column,
          isFullWidthCell: !0,
          fromBelow: o,
        }),
        !0
      )
    }
    focusPosition(e) {
      var t
      this.focusService.setFocusedCell({
        rowIndex: e.rowIndex,
        column: e.column,
        rowPinned: e.rowPinned,
        forceBrowserFocus: !0,
      }),
        (t = this.rangeService) == null || t.setRangeToCell(e)
    }
    isValidNavigateCell(e) {
      return !!this.rowPositionUtils.getRowNode(e)
    }
    getLastCellOfColSpan(e) {
      const t = this.getCellByPosition(e)
      if (!t) return e
      const i = t.getColSpanningList()
      return i.length === 1
        ? e
        : { rowIndex: e.rowIndex, column: rt(i), rowPinned: e.rowPinned }
    }
    ensureCellVisible(e) {
      const t = fl(this.gos),
        i = this.rowModel.getRow(e.rowIndex)
      !(t && (i == null ? void 0 : i.sticky)) &&
        ot(e.rowPinned) &&
        this.gridBodyCon.getScrollFeature().ensureIndexVisible(e.rowIndex),
        e.column.isPinned() ||
          this.gridBodyCon.getScrollFeature().ensureColumnVisible(e.column)
    }
  },
  jT = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'horizontalResizeService')
    }
    wireBeans(e) {
      ;(this.dragService = e.dragService), (this.ctrlsService = e.ctrlsService)
    }
    addResizeBar(e) {
      const t = {
        dragStartPixels: e.dragStartPixels || 0,
        eElement: e.eResizeBar,
        onDragStart: this.onDragStart.bind(this, e),
        onDragStop: this.onDragStop.bind(this, e),
        onDragging: this.onDragging.bind(this, e),
        onDragCancel: this.onDragStop.bind(this, e),
        includeTouch: !0,
        stopPropagationForTouch: !0,
      }
      return (
        this.dragService.addDragSource(t),
        () => this.dragService.removeDragSource(t)
      )
    }
    onDragStart(e, t) {
      ;(this.dragStartX = t.clientX), this.setResizeIcons()
      const i = t instanceof MouseEvent && t.shiftKey === !0
      e.onResizeStart(i)
    }
    setResizeIcons() {
      const e = this.ctrlsService.get('gridCtrl')
      e.setResizeCursor(!0), e.disableUserSelect(!0)
    }
    onDragStop(e) {
      e.onResizeEnd(this.resizeAmount), this.resetIcons()
    }
    resetIcons() {
      const e = this.ctrlsService.get('gridCtrl')
      e.setResizeCursor(!1), e.disableUserSelect(!1)
    }
    onDragging(e, t) {
      ;(this.resizeAmount = t.clientX - this.dragStartX),
        e.onResizing(this.resizeAmount)
    }
  },
  YT = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'filterMenuFactory')
    }
    wireBeans(e) {
      ;(this.popupService = e.popupService),
        (this.focusService = e.focusService),
        (this.ctrlsService = e.ctrlsService),
        (this.menuService = e.menuService)
    }
    hideActiveMenu() {
      this.hidePopup && this.hidePopup()
    }
    showMenuAfterMouseEvent(e, t, i) {
      this.showPopup(
        e,
        (s) => {
          this.popupService.positionPopupUnderMouseEvent({
            column: e,
            type: i,
            mouseEvent: t,
            ePopup: s,
          })
        },
        i,
        t.target,
        this.menuService.isLegacyMenuEnabled(),
      )
    }
    showMenuAfterButtonClick(e, t, i) {
      let s = -1,
        n = 'left'
      const r = this.menuService.isLegacyMenuEnabled()
      !r && this.gos.get('enableRtl') && ((s = 1), (n = 'right'))
      const o = r ? void 0 : 4 * s,
        a = r ? void 0 : 4
      this.showPopup(
        e,
        (l) => {
          this.popupService.positionPopupByComponent({
            type: i,
            eventSource: t,
            ePopup: l,
            nudgeX: o,
            nudgeY: a,
            alignSide: n,
            keepWithinBounds: !0,
            position: 'under',
            column: e,
          })
        },
        i,
        t,
        r,
      )
    }
    showPopup(e, t, i, s, n) {
      const r = e ? this.createBean(new bM(e, 'COLUMN_MENU')) : void 0
      if (((this.activeMenu = r), !(r != null && r.hasFilter()) || !e))
        throw new Error(
          'AG Grid - unable to show popup filter, filter instantiation failed',
        )
      const o = document.createElement('div')
      es(o, 'presentation'),
        o.classList.add('ag-menu'),
        n || o.classList.add('ag-filter-menu'),
        ([this.tabListener] = this.addManagedElementListeners(o, {
          keydown: (p) => this.trapFocusWithin(p, o),
        })),
        o.appendChild(r == null ? void 0 : r.getGui())
      let a
      const l = () => (r == null ? void 0 : r.afterGuiDetached()),
        c = this.menuService.isColumnMenuAnchoringEnabled()
          ? (s ?? this.ctrlsService.getGridBodyCtrl().getGui())
          : void 0,
        u = (p) => {
          e.setMenuVisible(!1, 'contextMenu')
          const v = p instanceof KeyboardEvent
          if (
            (this.tabListener && (this.tabListener = this.tabListener()),
            v && s && fs(s))
          ) {
            const m = this.focusService.findTabbableParent(s)
            m && m.focus()
          }
          l(),
            this.destroyBean(this.activeMenu),
            this.dispatchVisibleChangedEvent(!1, i, e)
        },
        h = this.localeService.getLocaleTextFunc(),
        g =
          n && i !== 'columnFilter'
            ? h('ariaLabelColumnMenu', 'Column Menu')
            : h('ariaLabelColumnFilter', 'Column Filter'),
        f = this.popupService.addPopup({
          modal: !0,
          eChild: o,
          closeOnEsc: !0,
          closedCallback: u,
          positionCallback: () => t(o),
          anchorToElement: c,
          ariaLabel: g,
        })
      f && (this.hidePopup = a = f.hideFunc),
        r.afterInit().then(() => {
          t(o), r.afterGuiAttached({ container: i, hidePopup: a })
        }),
        e.setMenuVisible(!0, 'contextMenu'),
        this.dispatchVisibleChangedEvent(!0, i, e)
    }
    trapFocusWithin(e, t) {
      e.key !== Y.TAB ||
        e.defaultPrevented ||
        this.focusService.findNextFocusableElement(t, !1, e.shiftKey) ||
        (e.preventDefault(), this.focusService.focusInto(t, e.shiftKey))
    }
    dispatchVisibleChangedEvent(e, t, i) {
      this.eventService.dispatchEvent({
        type: 'columnMenuVisibleChanged',
        visible: e,
        switchingTab: !1,
        key: t,
        column: i ?? null,
        columnGroup: null,
      })
    }
    isMenuEnabled(e) {
      return (
        e.isFilterAllowed() &&
        (e.getColDef().menuTabs ?? ['filterMenuTab']).includes('filterMenuTab')
      )
    }
    showMenuAfterContextMenuEvent() {}
    destroy() {
      this.destroyBean(this.activeMenu), super.destroy()
    }
  },
  KT = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'resizeObserverService')
    }
    observeResize(e, t) {
      const s = Cm(this.gos).ResizeObserver,
        n = s ? new s(t) : null
      return (
        n == null || n.observe(e), () => (n == null ? void 0 : n.disconnect())
      )
    }
  },
  qT = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'animationFrameService'),
        (this.createTasksP1 = { list: [], sorted: !1 }),
        (this.createTasksP2 = { list: [], sorted: !1 }),
        (this.destroyTasks = []),
        (this.ticking = !1),
        (this.scrollGoingDown = !0),
        (this.lastPage = 0),
        (this.lastScrollTop = 0),
        (this.taskCount = 0),
        (this.cancelledTasks = new Set())
    }
    wireBeans(e) {
      ;(this.ctrlsService = e.ctrlsService),
        (this.paginationService = e.paginationService)
    }
    setScrollTop(e) {
      var i
      const t = this.gos.get('pagination')
      if (((this.scrollGoingDown = e >= this.lastScrollTop), t && e === 0)) {
        const s =
          ((i = this.paginationService) == null
            ? void 0
            : i.getCurrentPage()) ?? 0
        s !== this.lastPage &&
          ((this.lastPage = s), (this.scrollGoingDown = !0))
      }
      this.lastScrollTop = e
    }
    postConstruct() {
      this.useAnimationFrame = !this.gos.get('suppressAnimationFrame')
    }
    isOn() {
      return this.useAnimationFrame
    }
    verifyAnimationFrameOn(e) {
      this.useAnimationFrame === !1 &&
        te(`AnimationFrameService.${e} called but animation frames are off`)
    }
    createTask(e, t, i) {
      this.verifyAnimationFrameOn(i)
      const s = { task: e, index: t, createOrder: ++this.taskCount }
      this.addTaskToList(this[i], s), this.schedule()
    }
    cancelTask(e) {
      this.cancelledTasks.add(e)
    }
    addTaskToList(e, t) {
      e.list.push(t), (e.sorted = !1)
    }
    sortTaskList(e) {
      if (e.sorted) return
      const t = this.scrollGoingDown ? 1 : -1
      e.list.sort((i, s) =>
        i.index !== s.index
          ? t * (s.index - i.index)
          : s.createOrder - i.createOrder,
      ),
        (e.sorted = !0)
    }
    addDestroyTask(e) {
      this.verifyAnimationFrameOn('createTasksP3'),
        this.destroyTasks.push(e),
        this.schedule()
    }
    executeFrame(e) {
      this.verifyAnimationFrameOn('executeFrame')
      const t = this.createTasksP1,
        i = t.list,
        s = this.createTasksP2,
        n = s.list,
        r = this.destroyTasks,
        o = new Date().getTime()
      let a = new Date().getTime() - o
      const l = e <= 0,
        c = this.ctrlsService.getGridBodyCtrl()
      for (; l || a < e; ) {
        if (!c.getScrollFeature().scrollGridIfNeeded()) {
          let h
          if (i.length) this.sortTaskList(t), (h = i.pop().task)
          else if (n.length) this.sortTaskList(s), (h = n.pop().task)
          else if (r.length) h = r.pop()
          else {
            this.cancelledTasks.clear()
            break
          }
          this.cancelledTasks.has(h) || h()
        }
        a = new Date().getTime() - o
      }
      i.length || n.length || r.length
        ? this.requestFrame()
        : this.stopTicking()
    }
    stopTicking() {
      this.ticking = !1
    }
    flushAllFrames() {
      this.useAnimationFrame && this.executeFrame(-1)
    }
    schedule() {
      this.useAnimationFrame &&
        (this.ticking || ((this.ticking = !0), this.requestFrame()))
    }
    requestFrame() {
      const e = this.executeFrame.bind(this, 60)
      this.requestAnimationFrame(e)
    }
    requestAnimationFrame(e) {
      const t = Cm(this.gos)
      t.requestAnimationFrame
        ? t.requestAnimationFrame(e)
        : t.webkitRequestAnimationFrame
          ? t.webkitRequestAnimationFrame(e)
          : t.setTimeout(e, 0)
    }
    isQueueEmpty() {
      return !this.ticking
    }
    debounce(e) {
      let t = !1
      return () => {
        if (!this.isOn()) {
          window.setTimeout(e, 0)
          return
        }
        t ||
          ((t = !0),
          this.addDestroyTask(() => {
            ;(t = !1), e()
          }))
      }
    }
  },
  QT = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'expansionService')
    }
    wireBeans(e) {
      this.rowModel = e.rowModel
    }
    postConstruct() {
      this.isClientSideRowModel = Pt(this.gos)
    }
    expandRows(e) {
      if (!this.isClientSideRowModel) return
      const t = new Set(e)
      this.rowModel.forEachNode((i) => {
        i.id && t.has(i.id) && (i.expanded = !0)
      }),
        this.onGroupExpandedOrCollapsed()
    }
    getExpandedRows() {
      const e = []
      return (
        this.rowModel.forEachNode(({ expanded: t, id: i }) => {
          t && i && e.push(i)
        }),
        e
      )
    }
    expandAll(e) {
      this.isClientSideRowModel && this.rowModel.expandOrCollapseAll(e)
    }
    setRowNodeExpanded(e, t, i, s) {
      e &&
        (i &&
          e.parent &&
          e.parent.level !== -1 &&
          this.setRowNodeExpanded(e.parent, t, i, s),
        e.setExpanded(t, void 0, s))
    }
    onGroupExpandedOrCollapsed() {
      this.isClientSideRowModel && this.rowModel.refreshModel({ step: 'map' })
    }
  },
  XT = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'menuService')
    }
    wireBeans(e) {
      ;(this.valueService = e.valueService),
        (this.filterMenuFactory = e.filterMenuFactory),
        (this.ctrlsService = e.ctrlsService),
        (this.animationFrameService = e.animationFrameService),
        (this.filterManager = e.filterManager),
        (this.rowRenderer = e.rowRenderer),
        (this.columnChooserFactory = e.columnChooserFactory),
        (this.contextMenuFactory = e.contextMenuFactory),
        (this.enterpriseMenuFactory = e.enterpriseMenuFactory)
    }
    postConstruct() {
      this.activeMenuFactory =
        this.enterpriseMenuFactory ?? this.filterMenuFactory
    }
    showColumnMenu(e) {
      this.showColumnMenuCommon(this.activeMenuFactory, e, 'columnMenu')
    }
    showFilterMenu(e) {
      const t =
        this.enterpriseMenuFactory && this.isLegacyMenuEnabled()
          ? this.enterpriseMenuFactory
          : this.filterMenuFactory
      this.showColumnMenuCommon(t, e, e.containerType, !0)
    }
    showHeaderContextMenu(e, t, i) {
      this.activeMenuFactory.showMenuAfterContextMenuEvent(e, t, i)
    }
    getContextMenuPosition(e, t) {
      const i = this.getRowCtrl(e),
        s = this.getCellGui(i, t)
      if (!s) return i ? { x: 0, y: i.getRowYPosition() } : { x: 0, y: 0 }
      const n = s.getBoundingClientRect()
      return { x: n.x + n.width / 2, y: n.y + n.height / 2 }
    }
    showContextMenu(e) {
      var r
      const t = e.rowNode,
        i = e.column
      let { anchorToElement: s, value: n } = e
      t && i && n == null && (n = this.valueService.getValueForDisplay(i, t)),
        s == null && (s = this.getContextMenuAnchorElement(t, i)),
        (r = this.contextMenuFactory) == null ||
          r.onContextMenu(
            e.mouseEvent ?? null,
            e.touchEvent ?? null,
            t ?? null,
            i ?? null,
            n,
            s,
          )
    }
    showColumnChooser(e) {
      var t
      ;(t = this.columnChooserFactory) == null || t.showColumnChooser(e)
    }
    hidePopupMenu() {
      var e
      ;(e = this.contextMenuFactory) == null || e.hideActiveMenu(),
        this.activeMenuFactory.hideActiveMenu()
    }
    hideColumnChooser() {
      var e
      ;(e = this.columnChooserFactory) == null || e.hideActiveColumnChooser()
    }
    isColumnMenuInHeaderEnabled(e) {
      const { suppressMenu: t, suppressHeaderMenuButton: i } = e.getColDef()
      return (
        !(i ?? t) &&
        this.activeMenuFactory.isMenuEnabled(e) &&
        (this.isLegacyMenuEnabled() || !!this.enterpriseMenuFactory)
      )
    }
    isFilterMenuInHeaderEnabled(e) {
      var t
      return (
        !e.getColDef().suppressHeaderFilterButton &&
        !!((t = this.filterManager) != null && t.isFilterAllowed(e))
      )
    }
    isHeaderContextMenuEnabled(e) {
      const t =
        e && cn(e) ? e.getColDef() : e == null ? void 0 : e.getColGroupDef()
      return (
        !(t != null && t.suppressHeaderContextMenu) &&
        this.getColumnMenuType() === 'new'
      )
    }
    isHeaderMenuButtonAlwaysShowEnabled() {
      return this.isSuppressMenuHide()
    }
    isHeaderMenuButtonEnabled() {
      const e = !this.isSuppressMenuHide()
      return !(fn() && e)
    }
    isHeaderFilterButtonEnabled(e) {
      return (
        this.isFilterMenuInHeaderEnabled(e) &&
        !this.isLegacyMenuEnabled() &&
        !this.isFloatingFilterButtonDisplayed(e)
      )
    }
    isFilterMenuItemEnabled(e) {
      var t
      return (
        !!((t = this.filterManager) != null && t.isFilterAllowed(e)) &&
        !this.isLegacyMenuEnabled() &&
        !this.isFilterMenuInHeaderEnabled(e) &&
        !this.isFloatingFilterButtonDisplayed(e)
      )
    }
    isColumnMenuAnchoringEnabled() {
      return !this.isLegacyMenuEnabled()
    }
    areAdditionalColumnMenuItemsEnabled() {
      return this.getColumnMenuType() === 'new'
    }
    isLegacyMenuEnabled() {
      return this.getColumnMenuType() === 'legacy'
    }
    isFloatingFilterButtonEnabled(e) {
      var s
      const t = e.getColDef(),
        i =
          (s = t.floatingFilterComponentParams) == null
            ? void 0
            : s.suppressFilterButton
      return (
        i != null &&
          te(
            "As of v31.1, 'colDef.floatingFilterComponentParams.suppressFilterButton' is deprecated. Use 'colDef.suppressFloatingFilterButton' instead.",
          ),
        t.suppressFloatingFilterButton == null
          ? !i
          : !t.suppressFloatingFilterButton
      )
    }
    getColumnMenuType() {
      return this.gos.get('columnMenu')
    }
    isFloatingFilterButtonDisplayed(e) {
      return (
        !!e.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(e)
      )
    }
    isSuppressMenuHide() {
      const e = this.gos.get('suppressMenuHide')
      return this.isLegacyMenuEnabled()
        ? this.gos.exists('suppressMenuHide')
          ? e
          : !1
        : e
    }
    showColumnMenuCommon(e, t, i, s) {
      const { positionBy: n } = t,
        r = t.column
      if (n === 'button') {
        const { buttonElement: o } = t
        e.showMenuAfterButtonClick(r, o, i, s)
      } else if (n === 'mouse') {
        const { mouseEvent: o } = t
        e.showMenuAfterMouseEvent(r, o, i, s)
      } else
        r &&
          (this.ctrlsService
            .getGridBodyCtrl()
            .getScrollFeature()
            .ensureColumnVisible(r, 'auto'),
          this.animationFrameService.requestAnimationFrame(() => {
            var a
            const o =
              (a = this.ctrlsService.getHeaderRowContainerCtrl(
                r.getPinned(),
              )) == null
                ? void 0
                : a.getHeaderCtrlForColumn(r)
            o &&
              e.showMenuAfterButtonClick(r, o.getAnchorElementForMenu(s), i, !0)
          }))
    }
    getRowCtrl(e) {
      const { rowIndex: t, rowPinned: i } = e || {}
      if (t != null)
        return (
          this.rowRenderer.getRowByPosition({ rowIndex: t, rowPinned: i }) ||
          void 0
        )
    }
    getCellGui(e, t) {
      if (!e || !t) return
      const i = e.getCellCtrl(t)
      return (i == null ? void 0 : i.getGui()) || void 0
    }
    getContextMenuAnchorElement(e, t) {
      const i = this.ctrlsService.getGridBodyCtrl().getGridBodyElement(),
        s = this.getRowCtrl(e)
      if (!s) return i
      const n = this.getCellGui(s, t)
      return n || (s.isFullWidth() ? s.getFullWidthElement() : i)
    }
  },
  JT = class extends Pn {
    constructor(e) {
      super(e, 'ag-text-area', null, 'textarea')
    }
    setValue(e, t) {
      const i = super.setValue(e, t)
      return (this.eInput.value = e), i
    }
    setCols(e) {
      return (this.eInput.cols = e), this
    }
    setRows(e) {
      return (this.eInput.rows = e), this
    }
  },
  ZT = { selector: 'AG-INPUT-TEXT-AREA', component: JT },
  eA = class extends Ar {
    constructor() {
      super(
        `<div class="ag-large-text">
        <ag-input-text-area data-ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`,
        [ZT],
      ),
        (this.eTextArea = Le)
    }
    init(e) {
      ;(this.params = e),
        (this.focusAfterAttached = e.cellStartedEdit),
        this.eTextArea
          .setMaxLength(e.maxLength || 200)
          .setCols(e.cols || 60)
          .setRows(e.rows || 10),
        ue(e.value, !0) && this.eTextArea.setValue(e.value.toString(), !0),
        this.addGuiEventListener('keydown', this.onKeyDown.bind(this)),
        this.activateTabIndex()
    }
    onKeyDown(e) {
      const t = e.key
      ;(t === Y.LEFT ||
        t === Y.UP ||
        t === Y.RIGHT ||
        t === Y.DOWN ||
        (e.shiftKey && t === Y.ENTER)) &&
        e.stopPropagation()
    }
    afterGuiAttached() {
      const e = this.localeService.getLocaleTextFunc()
      this.eTextArea.setInputAriaLabel(e('ariaInputEditor', 'Input Editor')),
        this.focusAfterAttached && this.eTextArea.getFocusableElement().focus()
    }
    getValue() {
      const e = this.eTextArea.getValue()
      return !ue(e) && !ue(this.params.value)
        ? this.params.value
        : this.params.parseValue(e)
    }
  },
  tA = class extends Ar {
    constructor(e) {
      super('<div class="ag-popup-editor" tabindex="-1"/>'), (this.params = e)
    }
    postConstruct() {
      Nn(this.gos, this.getGui(), 'popupEditorWrapper', !0),
        this.addKeyDownListener()
    }
    addKeyDownListener() {
      const e = this.getGui(),
        t = this.params,
        i = (s) => {
          iu(this.gos, s, t.node, t.column, !0) || t.onKeyDown(s)
        }
      this.addManagedElementListeners(e, { keydown: i })
    }
  },
  iA = class extends Ar {
    constructor() {
      super(
        `<div class="ag-cell-edit-wrapper">
                <ag-select class="ag-cell-editor" data-ref="eSelect"></ag-select>
            </div>`,
        [MM],
      ),
        (this.eSelect = Le),
        (this.startedByEnter = !1)
    }
    wireBeans(e) {
      this.valueService = e.valueService
    }
    init(e) {
      this.focusAfterAttached = e.cellStartedEdit
      const { eSelect: t, valueService: i, gos: s } = this,
        { values: n, value: r, eventKey: o } = e
      if (ot(n)) {
        te('no values found for select cellEditor')
        return
      }
      this.startedByEnter = o != null ? o === Y.ENTER : !1
      let a = !1
      n.forEach((h) => {
        const g = { value: h },
          f = i.formatValue(e.column, null, h),
          p = f != null
        ;(g.text = p ? f : h), t.addOption(g), (a = a || r === h)
      }),
        a
          ? t.setValue(e.value, !0)
          : e.values.length && t.setValue(e.values[0], !0)
      const { valueListGap: l, valueListMaxWidth: c, valueListMaxHeight: u } = e
      l != null && t.setPickerGap(l),
        u != null && t.setPickerMaxHeight(u),
        c != null && t.setPickerMaxWidth(c),
        s.get('editType') !== 'fullRow' &&
          this.addManagedListeners(this.eSelect, {
            selectedItem: () => e.stopEditing(),
          })
    }
    afterGuiAttached() {
      this.focusAfterAttached && this.eSelect.getFocusableElement().focus(),
        this.startedByEnter &&
          setTimeout(() => {
            this.isAlive() && this.eSelect.showPicker()
          })
    }
    focusIn() {
      this.eSelect.getFocusableElement().focus()
    }
    getValue() {
      return this.eSelect.getValue()
    }
    isPopup() {
      return !1
    }
  },
  wl = class extends Ar {
    constructor(e) {
      super(
        `
            <div class="ag-cell-edit-wrapper">
                ${e.getTemplate()}
            </div>`,
        e.getAgComponents(),
      ),
        (this.cellEditorInput = e),
        (this.eInput = Le)
    }
    init(e) {
      this.params = e
      const { cellStartedEdit: t, eventKey: i, suppressPreventDefault: s } = e,
        n = this.eInput
      this.cellEditorInput.init(n, e)
      let r,
        o = !0
      t
        ? ((this.focusAfterAttached = !0),
          i === Y.BACKSPACE || i === Y.DELETE
            ? (r = '')
            : i && i.length === 1
              ? s
                ? (o = !1)
                : (r = i)
              : ((r = this.cellEditorInput.getStartValue()),
                i !== Y.F2 && (this.highlightAllOnFocus = !0)))
        : ((this.focusAfterAttached = !1),
          (r = this.cellEditorInput.getStartValue())),
        o && r != null && n.setStartValue(r),
        this.addManagedElementListeners(n.getGui(), {
          keydown: (a) => {
            const { key: l } = a
            ;(l === Y.PAGE_UP || l === Y.PAGE_DOWN) && a.preventDefault()
          },
        })
    }
    afterGuiAttached() {
      var s, n
      const e = this.localeService.getLocaleTextFunc(),
        t = this.eInput
      if (
        (t.setInputAriaLabel(e('ariaInputEditor', 'Input Editor')),
        !this.focusAfterAttached)
      )
        return
      gs() || t.getFocusableElement().focus()
      const i = t.getInputElement()
      this.highlightAllOnFocus
        ? i.select()
        : (n = (s = this.cellEditorInput).setCaret) == null || n.call(s)
    }
    focusIn() {
      const e = this.eInput,
        t = e.getFocusableElement(),
        i = e.getInputElement()
      t.focus(), i.select()
    }
    getValue() {
      return this.cellEditorInput.getValue()
    }
    isPopup() {
      return !1
    }
  },
  sA = class {
    getTemplate() {
      return '<ag-input-text-field class="ag-cell-editor" data-ref="eInput"></ag-input-text-field>'
    }
    getAgComponents() {
      return [Cl]
    }
    init(e, t) {
      ;(this.eInput = e),
        (this.params = t),
        t.maxLength != null && e.setMaxLength(t.maxLength)
    }
    getValue() {
      const e = this.eInput.getValue()
      return !ue(e) && !ue(this.params.value)
        ? this.params.value
        : this.params.parseValue(e)
    }
    getStartValue() {
      return this.params.useFormatter || this.params.column.getColDef().refData
        ? this.params.formatValue(this.params.value)
        : this.params.value
    }
    setCaret() {
      const e = this.eInput.getValue(),
        t = (ue(e) && e.length) || 0
      t && this.eInput.getInputElement().setSelectionRange(t, t)
    }
  },
  Wv = class extends wl {
    constructor() {
      super(new sA())
    }
  },
  nA = class {
    getTemplate() {
      return '<ag-input-number-field class="ag-cell-editor" data-ref="eInput"></ag-input-number-field>'
    }
    getAgComponents() {
      return [BM]
    }
    init(e, t) {
      ;(this.eInput = e),
        (this.params = t),
        t.max != null && e.setMax(t.max),
        t.min != null && e.setMin(t.min),
        t.precision != null && e.setPrecision(t.precision),
        t.step != null && e.setStep(t.step)
      const i = e.getInputElement()
      t.preventStepping
        ? e.addManagedElementListeners(i, { keydown: this.preventStepping })
        : t.showStepperButtons &&
          i.classList.add('ag-number-field-input-stepper')
    }
    preventStepping(e) {
      ;(e.key === Y.UP || e.key === Y.DOWN) && e.preventDefault()
    }
    getValue() {
      const e = this.eInput.getValue()
      if (!ue(e) && !ue(this.params.value)) return this.params.value
      let t = this.params.parseValue(e)
      if (t == null) return t
      if (typeof t == 'string') {
        if (t === '') return null
        t = Number(t)
      }
      return isNaN(t) ? null : t
    }
    getStartValue() {
      return this.params.value
    }
    setCaret() {
      gs() && this.eInput.getInputElement().focus({ preventScroll: !0 })
    }
  },
  rA = class extends wl {
    constructor() {
      super(new nA())
    }
  },
  oA = class extends Yn {
    constructor(e) {
      super(e, 'ag-date-field', 'date')
    }
    postConstruct() {
      super.postConstruct()
      const e = gs()
      this.addManagedListeners(this.eInput, {
        wheel: this.onWheel.bind(this),
        mousedown: () => {
          this.isDisabled() || e || this.eInput.focus()
        },
      }),
        (this.eInput.step = 'any')
    }
    onWheel(e) {
      Lt(this.gos) === this.eInput && e.preventDefault()
    }
    setMin(e) {
      const t = e instanceof Date ? (zi(e ?? null, !1) ?? void 0) : e
      return this.min === t
        ? this
        : ((this.min = t), $i(this.eInput, 'min', t), this)
    }
    setMax(e) {
      const t = e instanceof Date ? (zi(e ?? null, !1) ?? void 0) : e
      return this.max === t
        ? this
        : ((this.max = t), $i(this.eInput, 'max', t), this)
    }
    setStep(e) {
      return this.step === e
        ? this
        : ((this.step = e), $i(this.eInput, 'step', e), this)
    }
    getDate() {
      if (this.eInput.validity.valid) return Mi(this.getValue()) ?? void 0
    }
    setDate(e, t) {
      this.setValue(zi(e ?? null, !1), t)
    }
  },
  $v = { selector: 'AG-INPUT-DATE-FIELD', component: oA },
  aA = class {
    getTemplate() {
      return '<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>'
    }
    getAgComponents() {
      return [$v]
    }
    init(e, t) {
      ;(this.eInput = e),
        (this.params = t),
        t.min != null && e.setMin(t.min),
        t.max != null && e.setMax(t.max),
        t.step != null && e.setStep(t.step)
    }
    getValue() {
      const e = this.eInput.getDate()
      return !ue(e) && !ue(this.params.value) ? this.params.value : (e ?? null)
    }
    getStartValue() {
      const { value: e } = this.params
      if (e instanceof Date) return zi(e, !1)
    }
  },
  lA = class extends wl {
    constructor() {
      super(new aA())
    }
  },
  cA = class {
    constructor(e) {
      this.getDataTypeService = e
    }
    getTemplate() {
      return '<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>'
    }
    getAgComponents() {
      return [$v]
    }
    init(e, t) {
      ;(this.eInput = e),
        (this.params = t),
        t.min != null && e.setMin(t.min),
        t.max != null && e.setMax(t.max),
        t.step != null && e.setStep(t.step)
    }
    getValue() {
      const e = this.formatDate(this.eInput.getDate())
      return !ue(e) && !ue(this.params.value)
        ? this.params.value
        : this.params.parseValue(e ?? '')
    }
    getStartValue() {
      return zi(this.parseDate(this.params.value ?? void 0) ?? null, !1)
    }
    parseDate(e) {
      const t = this.getDataTypeService()
      return t
        ? t.getDateParserFunction(this.params.column)(e)
        : (Mi(e) ?? void 0)
    }
    formatDate(e) {
      const t = this.getDataTypeService()
      return t
        ? t.getDateFormatterFunction(this.params.column)(e)
        : (zi(e ?? null, !1) ?? void 0)
    }
  },
  uA = class extends wl {
    wireBeans(e) {
      this.dataTypeService = e.dataTypeService
    }
    constructor() {
      super(new cA(() => this.dataTypeService))
    }
  },
  dA = class extends Ar {
    constructor() {
      super(
        `
            <div class="ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
        [fd],
      ),
        (this.eCheckbox = Le)
    }
    init(e) {
      this.params = e
      const t = e.value ?? void 0
      this.eCheckbox.setValue(t),
        this.eCheckbox.getInputElement().setAttribute('tabindex', '-1'),
        this.setAriaLabel(t),
        this.addManagedListeners(this.eCheckbox, {
          fieldValueChanged: (s) => this.setAriaLabel(s.selected),
        })
    }
    getValue() {
      return this.eCheckbox.getValue()
    }
    focusIn() {
      this.eCheckbox.getFocusableElement().focus()
    }
    afterGuiAttached() {
      this.params.cellStartedEdit && this.focusIn()
    }
    isPopup() {
      return !1
    }
    setAriaLabel(e) {
      const t = this.localeService.getLocaleTextFunc(),
        i = rd(t, e),
        s = t('ariaToggleCellValue', 'Press SPACE to toggle cell value')
      this.eCheckbox.setInputAriaLabel(`${s} (${i})`)
    }
  },
  io = class {
    constructor(e) {
      this.cellValueChanges = e
    }
  },
  vc = class extends io {
    constructor(e, t, i, s) {
      super(e),
        (this.initialRange = t),
        (this.finalRange = i),
        (this.ranges = s)
    }
  },
  hA = 10,
  Dg = class {
    constructor(e) {
      ;(this.actionStack = []),
        (this.maxStackSize = e || hA),
        (this.actionStack = new Array(this.maxStackSize))
    }
    pop() {
      return this.actionStack.pop()
    }
    push(e) {
      e.cellValueChanges &&
        e.cellValueChanges.length > 0 &&
        (this.actionStack.length === this.maxStackSize &&
          this.actionStack.shift(),
        this.actionStack.push(e))
    }
    clear() {
      this.actionStack = []
    }
    getCurrentStackSize() {
      return this.actionStack.length
    }
  },
  gA = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'undoRedoService'),
        (this.cellValueChanges = []),
        (this.activeCellEdit = null),
        (this.activeRowEdit = null),
        (this.isPasting = !1),
        (this.isRangeInAction = !1),
        (this.onCellValueChanged = (e) => {
          const t = {
              column: e.column,
              rowIndex: e.rowIndex,
              rowPinned: e.rowPinned,
            },
            i =
              this.activeCellEdit !== null &&
              this.cellPositionUtils.equals(this.activeCellEdit, t),
            s =
              this.activeRowEdit !== null &&
              this.rowPositionUtils.sameRow(this.activeRowEdit, t)
          if (!(i || s || this.isPasting || this.isRangeInAction)) return
          const {
              rowPinned: r,
              rowIndex: o,
              column: a,
              oldValue: l,
              value: c,
            } = e,
            u = {
              rowPinned: r,
              rowIndex: o,
              columnId: a.getColId(),
              newValue: c,
              oldValue: l,
            }
          this.cellValueChanges.push(u)
        }),
        (this.clearStacks = () => {
          this.undoStack.clear(), this.redoStack.clear()
        })
    }
    wireBeans(e) {
      ;(this.focusService = e.focusService),
        (this.ctrlsService = e.ctrlsService),
        (this.cellPositionUtils = e.cellPositionUtils),
        (this.rowPositionUtils = e.rowPositionUtils),
        (this.columnModel = e.columnModel),
        (this.rangeService = e.rangeService)
    }
    postConstruct() {
      if (!this.gos.get('undoRedoCellEditing')) return
      const e = this.gos.get('undoRedoCellEditingLimit')
      if (e <= 0) return
      ;(this.undoStack = new Dg(e)),
        (this.redoStack = new Dg(e)),
        this.addListeners()
      const t = this.clearStacks.bind(this)
      this.addManagedEventListeners({
        cellValueChanged: this.onCellValueChanged.bind(this),
        modelUpdated: (i) => {
          i.keepUndoRedoStack || this.clearStacks()
        },
        columnPivotModeChanged: t,
        newColumnsLoaded: t,
        columnGroupOpened: t,
        columnRowGroupChanged: t,
        columnMoved: t,
        columnPinned: t,
        columnVisible: t,
        rowDragEnd: t,
      }),
        this.ctrlsService.whenReady(this, (i) => {
          this.gridBodyCtrl = i.gridBodyCtrl
        })
    }
    getCurrentUndoStackSize() {
      return this.undoStack ? this.undoStack.getCurrentStackSize() : 0
    }
    getCurrentRedoStackSize() {
      return this.redoStack ? this.redoStack.getCurrentStackSize() : 0
    }
    undo(e) {
      this.eventService.dispatchEvent({ type: 'undoStarted', source: e })
      const t = this.undoRedo(
        this.undoStack,
        this.redoStack,
        'initialRange',
        'oldValue',
        'undo',
      )
      this.eventService.dispatchEvent({
        type: 'undoEnded',
        source: e,
        operationPerformed: t,
      })
    }
    redo(e) {
      this.eventService.dispatchEvent({ type: 'redoStarted', source: e })
      const t = this.undoRedo(
        this.redoStack,
        this.undoStack,
        'finalRange',
        'newValue',
        'redo',
      )
      this.eventService.dispatchEvent({
        type: 'redoEnded',
        source: e,
        operationPerformed: t,
      })
    }
    undoRedo(e, t, i, s, n) {
      if (!e) return !1
      const r = e.pop()
      return !r || !r.cellValueChanges
        ? !1
        : (this.processAction(r, (o) => o[s], n),
          r instanceof vc
            ? this.processRange(this.rangeService, r.ranges || [r[i]])
            : this.processCell(r.cellValueChanges),
          t.push(r),
          !0)
    }
    processAction(e, t, i) {
      e.cellValueChanges.forEach((s) => {
        const { rowIndex: n, rowPinned: r, columnId: o } = s,
          a = { rowIndex: n, rowPinned: r },
          l = this.rowPositionUtils.getRowNode(a)
        l.displayed && l.setDataValue(o, t(s), i)
      })
    }
    processRange(e, t) {
      let i
      e.removeAllCellRanges(!0),
        t.forEach((s, n) => {
          if (!s) return
          const r = s.startRow,
            o = s.endRow
          n === t.length - 1 &&
            ((i = {
              rowPinned: r.rowPinned,
              rowIndex: r.rowIndex,
              columnId: s.startColumn.getColId(),
            }),
            this.setLastFocusedCell(i))
          const a = {
            rowStartIndex: r.rowIndex,
            rowStartPinned: r.rowPinned,
            rowEndIndex: o.rowIndex,
            rowEndPinned: o.rowPinned,
            columnStart: s.startColumn,
            columns: s.columns,
          }
          e.addCellRange(a)
        })
    }
    processCell(e) {
      const t = e[0],
        { rowIndex: i, rowPinned: s } = t,
        n = { rowIndex: i, rowPinned: s },
        r = this.rowPositionUtils.getRowNode(n),
        o = {
          rowPinned: t.rowPinned,
          rowIndex: r.rowIndex,
          columnId: t.columnId,
        }
      this.setLastFocusedCell(o, this.rangeService)
    }
    setLastFocusedCell(e, t) {
      const { rowIndex: i, columnId: s, rowPinned: n } = e,
        r = this.gridBodyCtrl.getScrollFeature(),
        o = this.columnModel.getCol(s)
      if (!o) return
      r.ensureIndexVisible(i), r.ensureColumnVisible(o)
      const a = { rowIndex: i, column: o, rowPinned: n }
      this.focusService.setFocusedCell({ ...a, forceBrowserFocus: !0 }),
        t == null || t.setRangeToCell(a)
    }
    addListeners() {
      this.addManagedEventListeners({
        rowEditingStarted: (e) => {
          this.activeRowEdit = { rowIndex: e.rowIndex, rowPinned: e.rowPinned }
        },
        rowEditingStopped: () => {
          const e = new io(this.cellValueChanges)
          this.pushActionsToUndoStack(e), (this.activeRowEdit = null)
        },
        cellEditingStarted: (e) => {
          this.activeCellEdit = {
            column: e.column,
            rowIndex: e.rowIndex,
            rowPinned: e.rowPinned,
          }
        },
        cellEditingStopped: (e) => {
          if (
            ((this.activeCellEdit = null),
            e.valueChanged &&
              !this.activeRowEdit &&
              !this.isPasting &&
              !this.isRangeInAction)
          ) {
            const i = new io(this.cellValueChanges)
            this.pushActionsToUndoStack(i)
          }
        },
        pasteStart: () => {
          this.isPasting = !0
        },
        pasteEnd: () => {
          const e = new io(this.cellValueChanges)
          this.pushActionsToUndoStack(e), (this.isPasting = !1)
        },
        fillStart: () => {
          this.isRangeInAction = !0
        },
        fillEnd: (e) => {
          const t = new vc(this.cellValueChanges, e.initialRange, e.finalRange)
          this.pushActionsToUndoStack(t), (this.isRangeInAction = !1)
        },
        keyShortcutChangedCellStart: () => {
          this.isRangeInAction = !0
        },
        keyShortcutChangedCellEnd: () => {
          let e
          this.rangeService && Vs(this.gos)
            ? (e = new vc(this.cellValueChanges, void 0, void 0, [
                ...this.rangeService.getCellRanges(),
              ]))
            : (e = new io(this.cellValueChanges)),
            this.pushActionsToUndoStack(e),
            (this.isRangeInAction = !1)
        },
      })
    }
    pushActionsToUndoStack(e) {
      this.undoStack.push(e),
        (this.cellValueChanges = []),
        this.redoStack.clear()
    }
  }
function fA(e) {
  return e.ctrlsService
    .getGridBodyCtrl()
    .getScrollFeature()
    .getVScrollPosition()
}
function pA(e) {
  return e.ctrlsService
    .getGridBodyCtrl()
    .getScrollFeature()
    .getHScrollPosition()
}
function zv(e, t, i = 'auto') {
  e.frameworkOverrides.wrapIncoming(
    () =>
      e.ctrlsService
        .getGridBodyCtrl()
        .getScrollFeature()
        .ensureColumnVisible(t, i),
    'ensureVisible',
  )
}
function Uv(e, t, i) {
  e.frameworkOverrides.wrapIncoming(
    () =>
      e.ctrlsService
        .getGridBodyCtrl()
        .getScrollFeature()
        .ensureIndexVisible(t, i),
    'ensureVisible',
  )
}
function mA(e, t, i = null) {
  e.frameworkOverrides.wrapIncoming(
    () =>
      e.ctrlsService
        .getGridBodyCtrl()
        .getScrollFeature()
        .ensureNodeVisible(t, i),
    'ensureVisible',
  )
}
function vA(e) {
  var t
  ;(t = e.undoRedoService) == null || t.undo('api')
}
function CA(e) {
  var t
  ;(t = e.undoRedoService) == null || t.redo('api')
}
function SA(e, t = {}) {
  return e.rowRenderer.getCellEditorInstances(t).map(ao)
}
function wA(e) {
  return e.rowRenderer.getEditingCells()
}
function yA(e, t = !1) {
  e.rowRenderer.stopEditing(t)
}
function bA(e, t) {
  const i = e.columnModel.getCol(t.colKey)
  if (!i) {
    te(`no column found for ${t.colKey}`)
    return
  }
  const s = { rowIndex: t.rowIndex, rowPinned: t.rowPinned || null, column: i }
  t.rowPinned == null && Uv(e, t.rowIndex), zv(e, t.colKey)
  const r = e.navigationService.getCellByPosition(s)
  if (!r) return
  const { focusService: o, gos: a } = e,
    l = () => {
      const u = Lt(a),
        h = r.getGui()
      return u !== h && !!(h != null && h.contains(u))
    },
    c = a.get('stopEditingWhenCellsLoseFocus') && l()
  ;(c || !o.isCellFocused(s)) &&
    o.setFocusedCell({
      ...s,
      forceBrowserFocus: c,
      preventScrollOnBrowserFocus: !0,
    }),
    r.startRowOrCellEdit(t.key)
}
function RA(e) {
  var t
  return (
    ((t = e.undoRedoService) == null ? void 0 : t.getCurrentUndoStackSize()) ??
    0
  )
}
function FA(e) {
  var t
  return (
    ((t = e.undoRedoService) == null ? void 0 : t.getCurrentRedoStackSize()) ??
    0
  )
}
var EA = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'editService')
    }
    wireBeans(e) {
      ;(this.navigationService = e.navigationService),
        (this.userComponentFactory = e.userComponentFactory),
        (this.valueService = e.valueService)
    }
    startEditing(e, t = null, i = !1, s = null) {
      var c
      const n = this.createCellEditorParams(e, t, i),
        r = e.getColumn().getColDef(),
        o = this.userComponentFactory.getCellEditorDetails(r, n),
        a =
          (o == null ? void 0 : o.popupFromSelector) != null
            ? o.popupFromSelector
            : !!r.cellEditorPopup,
        l =
          (o == null ? void 0 : o.popupPositionFromSelector) != null
            ? o.popupPositionFromSelector
            : r.cellEditorPopupPosition
      return (
        e.setEditing(!0, o),
        e
          .getComp()
          .setEditDetails(o, a, l, this.gos.get('reactiveCustomComponents')),
        this.eventService.dispatchEvent(e.createEvent(s, 'cellEditingStarted')),
        !(
          (c = o == null ? void 0 : o.params) != null &&
          c.suppressPreventDefault
        )
      )
    }
    stopEditing(e, t) {
      const i = e.getComp(),
        { newValue: s, newValueExists: n } = this.takeValueFromCellEditor(t, i),
        r = e.getRowNode(),
        o = e.getColumn(),
        a = this.valueService.getValueForDisplay(o, r)
      let l = !1
      return (
        n && (l = this.saveNewValue(e, a, s, r, o)),
        e.setEditing(!1, void 0),
        i.setEditDetails(),
        e.updateAndFormatValue(!1),
        e.refreshCell({ forceRefresh: !0, suppressFlash: !0 }),
        this.eventService.dispatchEvent({
          ...e.createEvent(null, 'cellEditingStopped'),
          oldValue: a,
          newValue: s,
          valueChanged: l,
        }),
        l
      )
    }
    handleColDefChanged(e) {
      const t = e.getCellEditor()
      if (t != null && t.refresh) {
        const { eventKey: i, cellStartedEdit: s } =
            e.getEditCompDetails().params,
          n = this.createCellEditorParams(e, i, s),
          r = e.getColumn().getColDef(),
          o = this.userComponentFactory.getCellEditorDetails(r, n)
        t.refresh(o.params)
      }
    }
    setFocusOutOnEditor(e) {
      const t = e.getComp().getCellEditor()
      t && t.focusOut && t.focusOut()
    }
    setFocusInOnEditor(e) {
      const t = e.getComp(),
        i = t.getCellEditor()
      i != null && i.focusIn
        ? i.focusIn()
        : (e.focusCell(!0),
          e.onCellEditorAttached(() => {
            var s, n
            return (n = (s = t.getCellEditor()) == null ? void 0 : s.focusIn) ==
              null
              ? void 0
              : n.call(s)
          }))
    }
    stopEditingAndFocus(e, t = !1, i = !1) {
      e.stopRowOrCellEdit(),
        e.focusCell(!0),
        t || this.navigateAfterEdit(i, e.getCellPosition())
    }
    createPopupEditorWrapper(e) {
      return new tA(e)
    }
    takeValueFromCellEditor(e, t) {
      const i = { newValueExists: !1 }
      if (e) return i
      const s = t.getCellEditor()
      return !s || (s.isCancelAfterEnd && s.isCancelAfterEnd())
        ? i
        : { newValue: s.getValue(), newValueExists: !0 }
    }
    saveNewValue(e, t, i, s, n) {
      if (i === t) return !1
      e.setSuppressRefreshCell(!0)
      const r = s.setDataValue(n, i, 'edit')
      return e.setSuppressRefreshCell(!1), r
    }
    createCellEditorParams(e, t, i) {
      const s = e.getColumn(),
        n = e.getRowNode()
      return this.gos.addGridCommonParams({
        value: this.valueService.getValueForDisplay(s, n),
        eventKey: t,
        column: s,
        colDef: s.getColDef(),
        rowIndex: e.getCellPosition().rowIndex,
        node: n,
        data: n.data,
        cellStartedEdit: i,
        onKeyDown: e.onKeyDown.bind(e),
        stopEditing: e.stopEditingAndFocus.bind(e),
        eGridCell: e.getGui(),
        parseValue: (r) => this.valueService.parseValue(s, n, r, e.getValue()),
        formatValue: e.formatValue.bind(e),
      })
    }
    navigateAfterEdit(e, t) {
      if (this.gos.get('enterNavigatesVerticallyAfterEdit')) {
        const s = e ? Y.UP : Y.DOWN
        this.navigationService.navigateToNextCell(null, s, t, !1)
      }
    }
  },
  PA = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'rowEditService')
    }
    startEditing(e, t = null, i = null, s = null) {
      let n = !0
      return (
        e.getAllCellCtrls().reduce((o, a) => {
          const l = a === i
          return (
            l ? (n = a.startEditing(t, l, s)) : a.startEditing(null, l, s),
            o ? !0 : a.isEditing()
          )
        }, !1) && this.setEditing(e, !0),
        n
      )
    }
    stopEditing(e, t = !1) {
      const i = e.getAllCellCtrls(),
        s = e.isEditing()
      e.setStoppingRowEdit(!0)
      let n = !1
      for (const r of i) {
        const o = r.stopEditing(t)
        s && !t && !n && o && (n = !0)
      }
      n && this.eventService.dispatchEvent(e.createRowEvent('rowValueChanged')),
        s && this.setEditing(e, !1),
        e.setStoppingRowEdit(!1)
    }
    setEditing(e, t) {
      e.setEditingRow(t),
        e.forEachGui(void 0, (s) =>
          s.rowComp.addOrRemoveCssClass('ag-row-editing', t),
        )
      const i = t
        ? e.createRowEvent('rowEditingStarted')
        : e.createRowEvent('rowEditingStopped')
      this.eventService.dispatchEvent(i)
    }
  },
  Kn = { version: je, moduleName: '@ag-grid-community/edit-core', beans: [EA] },
  xA = {
    version: je,
    moduleName: '@ag-grid-community/edit-api',
    apiFunctions: {
      undoCellEditing: vA,
      redoCellEditing: CA,
      getCellEditorInstances: SA,
      getEditingCells: wA,
      stopEditing: yA,
      startEditingCell: bA,
      getCurrentUndoSize: RA,
      getCurrentRedoSize: FA,
    },
    dependantModules: [Kn],
  },
  DA = {
    version: je,
    moduleName: '@ag-grid-community/undo-redo-edit',
    beans: [gA],
    dependantModules: [Kn],
  },
  MA = {
    version: je,
    moduleName: '@ag-grid-community/full-row-edit',
    beans: [PA],
    dependantModules: [Kn],
  },
  jv = {
    version: je,
    moduleName: '@ag-grid-community/default-editor',
    userComponents: [{ name: 'agCellEditor', classImp: Wv }],
    dependantModules: [Kn],
  },
  IA = {
    version: je,
    moduleName: '@ag-grid-community/data-type-editors',
    userComponents: [
      { name: 'agTextCellEditor', classImp: Wv },
      {
        name: 'agNumberCellEditor',
        classImp: rA,
        params: { suppressPreventDefault: !0 },
      },
      { name: 'agDateCellEditor', classImp: lA },
      { name: 'agDateStringCellEditor', classImp: uA },
      { name: 'agCheckboxCellEditor', classImp: dA },
    ],
    dependantModules: [jv],
  },
  TA = {
    version: je,
    moduleName: '@ag-grid-community/select-editor',
    userComponents: [{ name: 'agSelectCellEditor', classImp: iA }],
    dependantModules: [Kn],
  },
  AA = {
    version: je,
    moduleName: '@ag-grid-community/large-text-editor',
    userComponents: [{ name: 'agLargeTextCellEditor', classImp: eA }],
    dependantModules: [Kn],
  },
  OA = {
    version: je,
    moduleName: '@ag-grid-community/all-editors',
    dependantModules: [jv, IA, TA, AA],
  },
  LA = {
    version: je,
    moduleName: '@ag-grid-community/editing',
    dependantModules: [Kn, DA, MA, OA, xA],
  },
  kA = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'autoWidthCalculator')
    }
    wireBeans(e) {
      ;(this.rowRenderer = e.rowRenderer), (this.ctrlsService = e.ctrlsService)
    }
    postConstruct() {
      this.ctrlsService.whenReady(this, (e) => {
        this.centerRowContainerCtrl = e.center
      })
    }
    getPreferredWidthForColumn(e, t) {
      const i = this.getHeaderCellForColumn(e)
      if (!i) return -1
      const s = this.rowRenderer.getAllCellsForColumn(e)
      return t || s.push(i), this.addElementsToContainerAndGetWidth(s)
    }
    getPreferredWidthForColumnGroup(e) {
      const t = this.getHeaderCellForColumn(e)
      return t ? this.addElementsToContainerAndGetWidth([t]) : -1
    }
    addElementsToContainerAndGetWidth(e) {
      const t = document.createElement('form')
      t.style.position = 'fixed'
      const i = this.centerRowContainerCtrl.getContainerElement()
      e.forEach((r) => this.cloneItemIntoDummy(r, t)), i.appendChild(t)
      const s = t.offsetWidth
      i.removeChild(t)
      const n = this.getAutoSizePadding()
      return s + n
    }
    getAutoSizePadding() {
      return this.gos.get('autoSizePadding')
    }
    getHeaderCellForColumn(e) {
      let t = null
      return (
        this.ctrlsService.getHeaderRowContainerCtrls().forEach((i) => {
          const s = i.getHtmlElementForColumnHeader(e)
          s != null && (t = s)
        }),
        t
      )
    }
    cloneItemIntoDummy(e, t) {
      const i = e.cloneNode(!0)
      ;(i.style.width = ''), (i.style.position = 'static'), (i.style.left = '')
      const s = document.createElement('div'),
        n = s.classList
      ;['ag-header-cell', 'ag-header-group-cell'].some((a) =>
        i.classList.contains(a),
      )
        ? (n.add('ag-header', 'ag-header-row'), (s.style.position = 'static'))
        : n.add('ag-row')
      let o = e.parentElement
      for (; o; ) {
        if (['ag-header-row', 'ag-row'].some((l) => o.classList.contains(l))) {
          for (let l = 0; l < o.classList.length; l++) {
            const c = o.classList[l]
            c != 'ag-row-position-absolute' && n.add(c)
          }
          break
        }
        o = o.parentElement
      }
      s.appendChild(i), t.appendChild(s)
    }
  },
  HA = class extends X {
    constructor(e, t) {
      super(),
        (this.createRowCon = e),
        (this.destroyRowCtrls = t),
        (this.stickyTopRowCtrls = []),
        (this.stickyBottomRowCtrls = []),
        (this.extraTopHeight = 0),
        (this.extraBottomHeight = 0)
    }
    wireBeans(e) {
      ;(this.rowModel = e.rowModel),
        (this.rowRenderer = e.rowRenderer),
        (this.ctrlsService = e.ctrlsService),
        (this.pageBoundsService = e.pageBoundsService)
    }
    postConstruct() {
      ;(this.isClientSide = Pt(this.gos)),
        this.ctrlsService.whenReady(this, (e) => {
          this.gridBodyCtrl = e.gridBodyCtrl
        }),
        this.resetStickyContainers()
    }
    getStickyTopRowCtrls() {
      return this.stickyTopRowCtrls
    }
    getStickyBottomRowCtrls() {
      return this.stickyBottomRowCtrls
    }
    setOffsetTop(e) {
      this.extraTopHeight !== e &&
        ((this.extraTopHeight = e),
        this.eventService.dispatchEvent({
          type: 'stickyTopOffsetChanged',
          offset: e,
        }))
    }
    setOffsetBottom(e) {
      this.extraBottomHeight !== e && (this.extraBottomHeight = e)
    }
    resetOffsets() {
      this.setOffsetBottom(0), this.setOffsetTop(0)
    }
    getExtraTopHeight() {
      return this.extraTopHeight
    }
    getExtraBottomHeight() {
      return this.extraBottomHeight
    }
    getLastPixelOfGroup(e) {
      return this.isClientSide
        ? this.getClientSideLastPixelOfGroup(e)
        : this.getServerSideLastPixelOfGroup(e)
    }
    getFirstPixelOfGroup(e) {
      return e.footer
        ? e.sibling.rowTop + e.sibling.rowHeight - 1
        : e.hasChildren()
          ? e.rowTop - 1
          : 0
    }
    getServerSideLastPixelOfGroup(e) {
      var t, i
      if (this.isClientSide)
        throw new Error(
          'This func should only be called in server side row model.',
        )
      if (e.isExpandable() || e.footer) {
        if (e.master) return e.detailNode.rowTop + e.detailNode.rowHeight
        if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
          let n = (t = e.childStore) == null ? void 0 : t.getStoreBounds()
          return (
            e.footer &&
              (n =
                (i = e.sibling.childStore) == null
                  ? void 0
                  : i.getStoreBounds()),
            ((n == null ? void 0 : n.heightPx) ?? 0) +
              ((n == null ? void 0 : n.topPx) ?? 0)
          )
        }
        return e.footer
          ? e.rowTop + e.rowHeight
          : e.sibling.rowTop + e.sibling.rowHeight
      }
      return Number.MAX_SAFE_INTEGER
    }
    getClientSideLastPixelOfGroup(e) {
      if (!this.isClientSide)
        throw new Error(
          'This func should only be called in client side row model.',
        )
      if (e.isExpandable() || e.footer) {
        if (e.footer && e.rowIndex === 0) return Number.MAX_SAFE_INTEGER
        if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
          let s = e.footer ? e.sibling : e
          for (; s.isExpandable() && s.expanded; )
            if (s.master) s = s.detailNode
            else if (s.childrenAfterSort) {
              if (s.childrenAfterSort.length === 0) break
              s = rt(s.childrenAfterSort)
            }
          return s.rowTop + s.rowHeight
        }
        return e.footer
          ? e.rowTop + e.rowHeight
          : e.sibling.rowTop + e.sibling.rowHeight
      }
      return Number.MAX_SAFE_INTEGER
    }
    updateStickyRows(e) {
      const t = e === 'top'
      let i = 0
      if (!this.canRowsBeSticky())
        return this.refreshNodesAndContainerHeight(e, new Set(), i)
      const s = t
          ? this.rowRenderer.getFirstVisibleVerticalPixel() -
            this.extraTopHeight
          : this.rowRenderer.getLastVisibleVerticalPixel() -
            this.extraTopHeight,
        n = new Set(),
        r = (c) => {
          if ((n.add(c), t)) {
            const u = this.getLastPixelOfGroup(c),
              h = s + i + c.rowHeight
            u < h ? (c.stickyRowTop = i + (u - h)) : (c.stickyRowTop = i)
          } else {
            const u = this.getFirstPixelOfGroup(c),
              h = s - (i + c.rowHeight)
            u > h ? (c.stickyRowTop = i - (u - h)) : (c.stickyRowTop = i)
          }
          ;(i = 0),
            n.forEach((u) => {
              const h = u.stickyRowTop + u.rowHeight
              i < h && (i = h)
            })
        },
        o = this.areFooterRowsStickySuppressed(),
        a = this.gos.get('suppressGroupRowsSticky'),
        l = (c) => {
          if (!c.displayed) return !1
          if (c.footer) {
            if (
              o === !0 ||
              (o === 'grand' && c.level === -1) ||
              (o === 'group' && c.level > -1)
            )
              return !1
            const u = c.sibling.rowIndex
              ? c.sibling.rowIndex + 1 === c.rowIndex
              : !1
            return e === 'bottom' && u ? !1 : !n.has(c)
          }
          return c.isExpandable()
            ? a === !0 || e === 'bottom'
              ? !1
              : !n.has(c) && c.expanded
            : !1
        }
      for (let c = 0; c < 100; c++) {
        let u = s + i
        t || (u = s - i)
        const h = this.rowModel.getRowIndexAtPixel(u),
          g = this.rowModel.getRow(h)
        if (g == null) break
        const p = this.getStickyAncestors(g).find(
          (m) => (t ? m.rowIndex < h : m.rowIndex > h) && l(m),
        )
        if (p) {
          r(p)
          continue
        }
        if ((t ? g.rowTop < u : g.rowTop + g.rowHeight > u) && l(g)) {
          r(g)
          continue
        }
        break
      }
      return (
        t ||
          n.forEach((c) => {
            c.stickyRowTop = i - (c.stickyRowTop + c.rowHeight)
          }),
        this.refreshNodesAndContainerHeight(e, n, i)
      )
    }
    areFooterRowsStickySuppressed() {
      const e = this.gos.get('suppressStickyTotalRow')
      if (e === !0) return !0
      const t = !!this.gos.get('groupIncludeFooter') || e === 'group',
        i = !!this.gos.get('groupIncludeTotalFooter') || e === 'grand'
      return t && i ? !0 : i ? 'grand' : t ? 'group' : !1
    }
    canRowsBeSticky() {
      const e = fl(this.gos),
        t = this.areFooterRowsStickySuppressed(),
        i = this.gos.get('suppressGroupRowsSticky')
      return e && (!t || !i)
    }
    getStickyAncestors(e) {
      const t = []
      let i = e.footer ? e.sibling : e.parent
      for (; i; ) i.sibling && t.push(i.sibling), t.push(i), (i = i.parent)
      return t.reverse()
    }
    checkStickyRows() {
      const e = this.updateStickyRows('top'),
        t = this.updateStickyRows('bottom')
      return e || t
    }
    destroyStickyCtrls() {
      this.resetStickyContainers()
    }
    resetStickyContainers() {
      this.refreshNodesAndContainerHeight('top', new Set(), 0),
        this.refreshNodesAndContainerHeight('bottom', new Set(), 0)
    }
    refreshStickyNode(e) {
      const t = new Set()
      if (this.stickyTopRowCtrls.some((i) => i.getRowNode() === e)) {
        for (let i = 0; i < this.stickyTopRowCtrls.length; i++) {
          const s = this.stickyTopRowCtrls[i].getRowNode()
          s !== e && t.add(s)
        }
        this.refreshNodesAndContainerHeight(
          'top',
          t,
          this.topContainerHeight,
        ) && this.checkStickyRows()
        return
      }
      for (let i = 0; i < this.stickyBottomRowCtrls.length; i++) {
        const s = this.stickyBottomRowCtrls[i].getRowNode()
        s !== e && t.add(s)
      }
      this.refreshNodesAndContainerHeight(
        'bottom',
        t,
        this.bottomContainerHeight,
      ) && this.checkStickyRows()
    }
    refreshNodesAndContainerHeight(e, t, i) {
      const s = e === 'top',
        n = s ? this.stickyTopRowCtrls : this.stickyBottomRowCtrls,
        r = {},
        o = []
      for (let g = 0; g < n.length; g++) {
        const f = n[g].getRowNode()
        if (!t.has(f)) {
          ;(r[f.id] = n[g]), (f.sticky = !1)
          continue
        }
        o.push(n[g])
      }
      const a = new Set()
      for (let g = 0; g < o.length; g++) a.add(o[g].getRowNode())
      const l = []
      t.forEach((g) => {
        a.has(g) || ((g.sticky = !0), l.push(this.createRowCon(g, !1, !1)))
      })
      let c = !!l.length || o.length !== n.length
      s
        ? this.topContainerHeight !== i &&
          ((this.topContainerHeight = i),
          this.gridBodyCtrl.setStickyTopHeight(i),
          (c = !0))
        : this.bottomContainerHeight !== i &&
          ((this.bottomContainerHeight = i),
          this.gridBodyCtrl.setStickyBottomHeight(i),
          (c = !0)),
        this.destroyRowCtrls(r, !1)
      const u = [...o, ...l]
      u.sort((g, f) => f.getRowNode().rowIndex - g.getRowNode().rowIndex),
        s || u.reverse(),
        u.forEach((g) => g.setRowTop(g.getRowNode().stickyRowTop))
      let h = 0
      return (
        s
          ? (t.forEach((g) => {
              g.rowIndex < this.pageBoundsService.getFirstRow() &&
                (h += g.rowHeight)
            }),
            h > this.topContainerHeight && (h = this.topContainerHeight),
            this.setOffsetTop(h))
          : (t.forEach((g) => {
              g.rowIndex > this.pageBoundsService.getLastRow() &&
                (h += g.rowHeight)
            }),
            h > this.bottomContainerHeight && (h = this.bottomContainerHeight),
            this.setOffsetBottom(h)),
        c
          ? (s ? (this.stickyTopRowCtrls = u) : (this.stickyBottomRowCtrls = u),
            !0)
          : !1
      )
    }
    ensureRowHeightsValid() {
      let e = !1
      const t = (i) => {
        const s = i.getRowNode()
        if (s.rowHeightEstimated) {
          const n = ln(this.gos, s)
          s.setRowHeight(n.height), (e = !0)
        }
      }
      return (
        this.stickyTopRowCtrls.forEach(t),
        this.stickyBottomRowCtrls.forEach(t),
        e
      )
    }
  },
  NA = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'rowRenderer'),
        (this.destroyFuncsForColumnListeners = []),
        (this.rowCtrlsByRowIndex = {}),
        (this.zombieRowCtrls = {}),
        (this.allRowCtrls = []),
        (this.topRowCtrls = []),
        (this.bottomRowCtrls = []),
        (this.refreshInProgress = !1),
        (this.dataFirstRenderedFired = !1),
        (this.setupRangeSelectionListeners = () => {
          const e = () => {
              this.getAllCellCtrls().forEach((r) => r.onCellSelectionChanged())
            },
            t = () => {
              this.getAllCellCtrls().forEach((r) =>
                r.updateRangeBordersIfRangeCount(),
              )
            },
            i = () => {
              this.eventService.addEventListener('cellSelectionChanged', e),
                this.eventService.addEventListener('columnMoved', t),
                this.eventService.addEventListener('columnPinned', t),
                this.eventService.addEventListener('columnVisible', t)
            },
            s = () => {
              this.eventService.removeEventListener('cellSelectionChanged', e),
                this.eventService.removeEventListener('columnMoved', t),
                this.eventService.removeEventListener('columnPinned', t),
                this.eventService.removeEventListener('columnVisible', t)
            }
          this.addDestroyFunc(() => s()),
            this.addManagedPropertyListeners(
              ['enableRangeSelection', 'cellSelection'],
              () => {
                Vs(this.gos) ? i() : s()
              },
            ),
            Vs(this.gos) && i()
        })
    }
    wireBeans(e) {
      ;(this.animationFrameService = e.animationFrameService),
        (this.paginationService = e.paginationService),
        (this.pageBoundsService = e.pageBoundsService),
        (this.columnModel = e.columnModel),
        (this.visibleColsService = e.visibleColsService),
        (this.pinnedRowModel = e.pinnedRowModel),
        (this.rowModel = e.rowModel),
        (this.focusService = e.focusService),
        (this.beans = e),
        (this.rowContainerHeightService = e.rowContainerHeightService),
        (this.ctrlsService = e.ctrlsService),
        (this.environment = e.environment)
    }
    postConstruct() {
      this.ctrlsService.whenReady(this, (e) => {
        ;(this.gridBodyCtrl = e.gridBodyCtrl), this.initialise()
      })
    }
    initialise() {
      this.addManagedEventListeners({
        paginationChanged: this.onPageLoaded.bind(this),
        pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this),
        displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
        bodyScroll: this.onBodyScroll.bind(this),
        bodyHeightChanged: this.redraw.bind(this, {}),
      }),
        this.addManagedPropertyListeners(
          ['domLayout', 'embedFullWidthRows'],
          () => this.onDomLayoutChanged(),
        ),
        this.addManagedPropertyListeners(
          ['suppressMaxRenderedRowRestriction', 'rowBuffer'],
          () => this.redraw(),
        ),
        this.addManagedPropertyListener('suppressCellFocus', (e) =>
          this.onSuppressCellFocusChanged(e.currentValue),
        ),
        this.addManagedPropertyListeners(
          [
            'groupSuppressBlankHeader',
            'getBusinessKeyForNode',
            'fullWidthCellRenderer',
            'fullWidthCellRendererParams',
            'suppressStickyTotalRow',
            'groupRowRenderer',
            'groupRowRendererParams',
            'loadingCellRenderer',
            'loadingCellRendererParams',
            'detailCellRenderer',
            'detailCellRendererParams',
            'enableRangeSelection',
            'enableCellTextSelection',
            'rowSelection',
          ],
          () => this.redrawRows(),
        ),
        fl(this.gos) &&
          (Pt(this.gos) || ms(this.gos)) &&
          (this.stickyRowFeature = this.createManagedBean(
            new HA(
              this.createRowCon.bind(this),
              this.destroyRowCtrls.bind(this),
            ),
          )),
        this.registerCellEventListeners(),
        this.initialiseCache(),
        (this.printLayout = ci(this.gos, 'print')),
        (this.embedFullWidthRows =
          this.printLayout || this.gos.get('embedFullWidthRows')),
        this.redrawAfterModelUpdate()
    }
    initialiseCache() {
      if (this.gos.get('keepDetailRows')) {
        const e = this.getKeepDetailRowsCount(),
          t = e ?? 3
        this.cachedRowCtrls = new GA(t)
      }
    }
    getKeepDetailRowsCount() {
      return this.gos.get('keepDetailRowsCount')
    }
    getStickyTopRowCtrls() {
      return this.stickyRowFeature
        ? this.stickyRowFeature.getStickyTopRowCtrls()
        : []
    }
    getStickyBottomRowCtrls() {
      return this.stickyRowFeature
        ? this.stickyRowFeature.getStickyBottomRowCtrls()
        : []
    }
    updateAllRowCtrls() {
      const e = qc(this.rowCtrlsByRowIndex),
        t = qc(this.zombieRowCtrls),
        i = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : []
      t.length > 0 || i.length > 0
        ? (this.allRowCtrls = [...e, ...t, ...i])
        : (this.allRowCtrls = e)
    }
    onCellFocusChanged(e) {
      this.getAllCellCtrls().forEach((t) => t.onCellFocused(e)),
        this.getFullWidthRowCtrls().forEach((t) => t.onFullWidthRowFocused(e))
    }
    onSuppressCellFocusChanged(e) {
      this.getAllCellCtrls().forEach((t) => t.onSuppressCellFocusChanged(e)),
        this.getFullWidthRowCtrls().forEach((t) =>
          t.onSuppressCellFocusChanged(e),
        )
    }
    registerCellEventListeners() {
      this.addManagedEventListeners({
        cellFocused: (e) => {
          this.onCellFocusChanged(e)
        },
        cellFocusCleared: () => this.onCellFocusChanged(),
        flashCells: (e) => {
          this.getAllCellCtrls().forEach((t) => t.onFlashCells(e))
        },
        columnHoverChanged: () => {
          this.getAllCellCtrls().forEach((e) => e.onColumnHover())
        },
        displayedColumnsChanged: () => {
          this.getAllCellCtrls().forEach((e) => e.onDisplayedColumnsChanged())
        },
        displayedColumnsWidthChanged: () => {
          this.printLayout &&
            this.getAllCellCtrls().forEach((e) => e.onLeftChanged())
        },
      }),
        this.setupRangeSelectionListeners(),
        this.refreshListenersToColumnsForCellComps(),
        this.addManagedEventListeners({
          gridColumnsChanged:
            this.refreshListenersToColumnsForCellComps.bind(this),
        }),
        this.addDestroyFunc(this.removeGridColumnListeners.bind(this))
    }
    removeGridColumnListeners() {
      this.destroyFuncsForColumnListeners.forEach((e) => e()),
        (this.destroyFuncsForColumnListeners.length = 0)
    }
    refreshListenersToColumnsForCellComps() {
      this.removeGridColumnListeners(),
        this.columnModel.getCols().forEach((t) => {
          const i = (l) => {
              this.getAllCellCtrls().forEach((c) => {
                c.getColumn() === t && l(c)
              })
            },
            s = () => {
              i((l) => l.onLeftChanged())
            },
            n = () => {
              i((l) => l.onWidthChanged())
            },
            r = () => {
              i((l) => l.onFirstRightPinnedChanged())
            },
            o = () => {
              i((l) => l.onLastLeftPinnedChanged())
            },
            a = () => {
              i((l) => l.onColDefChanged())
            }
          t.addEventListener('leftChanged', s),
            t.addEventListener('widthChanged', n),
            t.addEventListener('firstRightPinnedChanged', r),
            t.addEventListener('lastLeftPinnedChanged', o),
            t.addEventListener('colDefChanged', a),
            this.destroyFuncsForColumnListeners.push(() => {
              t.removeEventListener('leftChanged', s),
                t.removeEventListener('widthChanged', n),
                t.removeEventListener('firstRightPinnedChanged', r),
                t.removeEventListener('lastLeftPinnedChanged', o),
                t.removeEventListener('colDefChanged', a)
            })
        })
    }
    onDomLayoutChanged() {
      const e = ci(this.gos, 'print'),
        t = e || this.gos.get('embedFullWidthRows'),
        i = t !== this.embedFullWidthRows || this.printLayout !== e
      ;(this.printLayout = e),
        (this.embedFullWidthRows = t),
        i && this.redrawAfterModelUpdate({ domLayoutChanged: !0 })
    }
    datasourceChanged() {
      ;(this.firstRenderedRow = 0), (this.lastRenderedRow = -1)
      const e = Object.keys(this.rowCtrlsByRowIndex)
      this.removeRowCtrls(e)
    }
    onPageLoaded(e) {
      const t = {
        recycleRows: e.keepRenderedRows,
        animate: e.animate,
        newData: e.newData,
        newPage: e.newPage,
        onlyBody: !0,
      }
      this.redrawAfterModelUpdate(t)
    }
    getAllCellsForColumn(e) {
      const t = []
      return (
        this.getAllRowCtrls().forEach((i) => {
          const s = i.getCellElement(e)
          s && t.push(s)
        }),
        t
      )
    }
    refreshFloatingRowComps() {
      this.refreshFloatingRows(this.topRowCtrls, 'top'),
        this.refreshFloatingRows(this.bottomRowCtrls, 'bottom')
    }
    getTopRowCtrls() {
      return this.topRowCtrls
    }
    getCentreRowCtrls() {
      return this.allRowCtrls
    }
    getBottomRowCtrls() {
      return this.bottomRowCtrls
    }
    refreshFloatingRows(e, t) {
      const { pinnedRowModel: i, beans: s, printLayout: n } = this,
        r = Object.fromEntries(e.map((a) => [a.getRowNode().id, a]))
      i.forEachPinnedRow(t, (a, l) => {
        const c = e[l]
        c &&
          i.getPinnedRowById(c.getRowNode().id, t) === void 0 &&
          (c.destroyFirstPass(), c.destroySecondPass()),
          a.id in r
            ? ((e[l] = r[a.id]), delete r[a.id])
            : (e[l] = new On(a, s, !1, !1, n))
      })
      const o =
        t === 'top' ? i.getPinnedTopRowCount() : i.getPinnedBottomRowCount()
      e.length = o
    }
    onPinnedRowDataChanged() {
      const e = { recycleRows: !0 }
      this.redrawAfterModelUpdate(e)
    }
    redrawRow(e, t = !1) {
      var i
      if (e.sticky) this.stickyRowFeature.refreshStickyNode(e)
      else if ((i = this.cachedRowCtrls) != null && i.has(e)) {
        this.cachedRowCtrls.removeRow(e)
        return
      } else {
        const s = (n) => {
          const r = n[e.rowIndex]
          r &&
            r.getRowNode() === e &&
            (r.destroyFirstPass(),
            r.destroySecondPass(),
            (n[e.rowIndex] = this.createRowCon(e, !1, !1)))
        }
        switch (e.rowPinned) {
          case 'top':
            s(this.topRowCtrls)
            break
          case 'bottom':
            s(this.bottomRowCtrls)
            break
          default:
            s(this.rowCtrlsByRowIndex), this.updateAllRowCtrls()
        }
      }
      t || this.dispatchDisplayedRowsChanged(!1)
    }
    redrawRows(e) {
      if (e != null) {
        e == null || e.forEach((i) => this.redrawRow(i, !0)),
          this.dispatchDisplayedRowsChanged(!1)
        return
      }
      this.redrawAfterModelUpdate()
    }
    getCellToRestoreFocusToAfterRefresh(e) {
      const t =
        e != null && e.suppressKeepFocus
          ? null
          : this.focusService.getFocusCellToUseAfterRefresh()
      if (t == null) return null
      const i = Lt(this.gos),
        s = mo(this.gos, i, An.DOM_DATA_KEY_CELL_CTRL),
        n = mo(this.gos, i, On.DOM_DATA_KEY_ROW_CTRL)
      return s || n ? t : null
    }
    redrawAfterModelUpdate(e = {}) {
      this.getLockOnRefresh()
      const t = this.getCellToRestoreFocusToAfterRefresh(e)
      this.updateContainerHeights(), this.scrollToTopIfNewData(e)
      const i = !e.domLayoutChanged && !!e.recycleRows,
        s = e.animate && or(this.gos),
        n = i ? this.getRowsToRecycle() : null
      if (
        (i || this.removeAllRowComps(),
        this.workOutFirstAndLastRowsToRender(),
        this.stickyRowFeature)
      ) {
        this.stickyRowFeature.checkStickyRows()
        const r =
          this.stickyRowFeature.getExtraTopHeight() +
          this.stickyRowFeature.getExtraBottomHeight()
        r && this.updateContainerHeights(r)
      }
      this.recycleRows(n, s),
        this.gridBodyCtrl.updateRowCount(),
        e.onlyBody || this.refreshFloatingRowComps(),
        this.dispatchDisplayedRowsChanged(),
        t != null && this.restoreFocusedCell(t),
        this.releaseLockOnRefresh()
    }
    scrollToTopIfNewData(e) {
      var s
      const t = e.newData || e.newPage,
        i = this.gos.get('suppressScrollOnNewData')
      t &&
        !i &&
        (this.gridBodyCtrl.getScrollFeature().scrollToTop(),
        (s = this.stickyRowFeature) == null || s.resetOffsets())
    }
    updateContainerHeights(e = 0) {
      if (this.printLayout) {
        this.rowContainerHeightService.setModelHeight(null)
        return
      }
      let t = this.pageBoundsService.getCurrentPageHeight()
      t === 0 && (t = 1), this.rowContainerHeightService.setModelHeight(t + e)
    }
    getLockOnRefresh() {
      var e, t
      if (this.refreshInProgress)
        throw new Error(
          'AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. Your code probably called a grid API method while the grid was in the render stage. To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). To see what part of your code that caused the refresh check this stacktrace.',
        )
      ;(this.refreshInProgress = !0),
        (t = (e = this.frameworkOverrides).getLockOnRefresh) == null ||
          t.call(e)
    }
    releaseLockOnRefresh() {
      var e, t
      ;(this.refreshInProgress = !1),
        (t = (e = this.frameworkOverrides).releaseLockOnRefresh) == null ||
          t.call(e)
    }
    isRefreshInProgress() {
      return this.refreshInProgress
    }
    restoreFocusedCell(e) {
      e &&
        this.focusService.restoreFocusedCell(e, () => {
          this.onCellFocusChanged(
            this.gos.addGridCommonParams({
              rowIndex: e.rowIndex,
              column: e.column,
              rowPinned: e.rowPinned,
              forceBrowserFocus: !0,
              preventScrollOnBrowserFocus: !0,
              type: 'cellFocused',
            }),
          )
        })
    }
    stopEditing(e = !1) {
      this.getAllRowCtrls().forEach((t) => {
        t.stopEditing(e)
      })
    }
    getAllCellCtrls() {
      const e = [],
        t = this.getAllRowCtrls(),
        i = t.length
      for (let s = 0; s < i; s++) {
        const n = t[s].getAllCellCtrls(),
          r = n.length
        for (let o = 0; o < r; o++) e.push(n[o])
      }
      return e
    }
    getAllRowCtrls() {
      const e =
          (this.stickyRowFeature &&
            this.stickyRowFeature.getStickyTopRowCtrls()) ||
          [],
        t =
          (this.stickyRowFeature &&
            this.stickyRowFeature.getStickyBottomRowCtrls()) ||
          [],
        i = [...this.topRowCtrls, ...this.bottomRowCtrls, ...e, ...t]
      for (const s in this.rowCtrlsByRowIndex)
        i.push(this.rowCtrlsByRowIndex[s])
      return i
    }
    addRenderedRowListener(e, t, i) {
      const s = this.rowCtrlsByRowIndex[t]
      s && s.addEventListener(e, i)
    }
    flashCells(e = {}) {
      this.getCellCtrls(e.rowNodes, e.columns).forEach((t) => t.flashCell(e))
    }
    refreshCells(e = {}) {
      const t = {
        forceRefresh: e.force,
        newData: !1,
        suppressFlash: e.suppressFlash,
      }
      for (const i of this.getCellCtrls(e.rowNodes, e.columns))
        i.refreshOrDestroyCell(t)
      this.refreshFullWidth(e.rowNodes)
    }
    refreshFullWidth(e) {
      if (!e) return
      let t = null
      this.stickyRowFeature &&
        Cg() &&
        (t = this.getCellToRestoreFocusToAfterRefresh() || null)
      for (const i of this.getRowCtrls(e)) {
        if (!i.isFullWidth()) continue
        i.refreshFullWidth() || this.redrawRow(i.getRowNode(), !0)
      }
      this.dispatchDisplayedRowsChanged(!1), t && this.restoreFocusedCell(t)
    }
    getCellRendererInstances(e) {
      var n
      const t = this.getCellCtrls(e.rowNodes, e.columns)
        .map((r) => r.getCellRenderer())
        .filter((r) => r != null)
      if ((n = e.columns) != null && n.length) return t
      const i = [],
        s = this.mapRowNodes(e.rowNodes)
      return (
        this.getAllRowCtrls().forEach((r) => {
          if ((s && !this.isRowInMap(r.getRowNode(), s)) || !r.isFullWidth())
            return
          const o = r.getFullWidthCellRenderers()
          for (let a = 0; a < o.length; a++) {
            const l = o[a]
            l != null && i.push(l)
          }
        }),
        [...i, ...t]
      )
    }
    getCellEditorInstances(e) {
      const t = []
      return (
        this.getCellCtrls(e.rowNodes, e.columns).forEach((i) => {
          const s = i.getCellEditor()
          s && t.push(s)
        }),
        t
      )
    }
    getEditingCells() {
      const e = []
      return (
        this.getAllCellCtrls().forEach((t) => {
          if (t.isEditing()) {
            const i = t.getCellPosition()
            e.push(i)
          }
        }),
        e
      )
    }
    mapRowNodes(e) {
      if (!e) return
      const t = { top: {}, bottom: {}, normal: {} }
      return (
        e.forEach((i) => {
          const s = i.id
          switch (i.rowPinned) {
            case 'top':
              t.top[s] = i
              break
            case 'bottom':
              t.bottom[s] = i
              break
            default:
              t.normal[s] = i
              break
          }
        }),
        t
      )
    }
    isRowInMap(e, t) {
      const i = e.id
      switch (e.rowPinned) {
        case 'top':
          return t.top[i] != null
        case 'bottom':
          return t.bottom[i] != null
        default:
          return t.normal[i] != null
      }
    }
    getRowCtrls(e) {
      const t = this.mapRowNodes(e),
        i = this.getAllRowCtrls()
      return !e || !t
        ? i
        : i.filter((s) => {
            const n = s.getRowNode()
            return this.isRowInMap(n, t)
          })
    }
    getCellCtrls(e, t) {
      let i
      ue(t) &&
        ((i = {}),
        t.forEach((n) => {
          const r = this.columnModel.getCol(n)
          ue(r) && (i[r.getId()] = !0)
        }))
      const s = []
      return (
        this.getRowCtrls(e).forEach((n) => {
          n.getAllCellCtrls().forEach((r) => {
            const o = r.getColumn().getId()
            ;(i && !i[o]) || s.push(r)
          })
        }),
        s
      )
    }
    destroy() {
      this.removeAllRowComps(!0), super.destroy()
    }
    removeAllRowComps(e = !1) {
      const t = Object.keys(this.rowCtrlsByRowIndex)
      this.removeRowCtrls(t, e),
        this.stickyRowFeature && this.stickyRowFeature.destroyStickyCtrls()
    }
    getRowsToRecycle() {
      const e = []
      Qi(this.rowCtrlsByRowIndex, (i, s) => {
        s.getRowNode().id == null && e.push(i)
      }),
        this.removeRowCtrls(e)
      const t = {}
      return (
        Qi(this.rowCtrlsByRowIndex, (i, s) => {
          const n = s.getRowNode()
          t[n.id] = s
        }),
        (this.rowCtrlsByRowIndex = {}),
        t
      )
    }
    removeRowCtrls(e, t = !1) {
      e.forEach((i) => {
        const s = this.rowCtrlsByRowIndex[i]
        s && (s.destroyFirstPass(t), s.destroySecondPass()),
          delete this.rowCtrlsByRowIndex[i]
      })
    }
    onBodyScroll(e) {
      e.direction === 'vertical' && this.redraw({ afterScroll: !0 })
    }
    redraw(e = {}) {
      const { afterScroll: t } = e
      let i
      this.stickyRowFeature &&
        Cg() &&
        (i = this.getCellToRestoreFocusToAfterRefresh() || void 0)
      const s = this.firstRenderedRow,
        n = this.lastRenderedRow
      this.workOutFirstAndLastRowsToRender()
      let r = !1
      if (this.stickyRowFeature) {
        r = this.stickyRowFeature.checkStickyRows()
        const a =
          this.stickyRowFeature.getExtraTopHeight() +
          this.stickyRowFeature.getExtraBottomHeight()
        a && this.updateContainerHeights(a)
      }
      const o = this.firstRenderedRow !== s || this.lastRenderedRow !== n
      if (
        !(t && !r && !o) &&
        (this.getLockOnRefresh(),
        this.recycleRows(null, !1, t),
        this.releaseLockOnRefresh(),
        this.dispatchDisplayedRowsChanged(t && !r),
        i != null)
      ) {
        const a = this.getCellToRestoreFocusToAfterRefresh()
        i != null &&
          a == null &&
          (this.animationFrameService.flushAllFrames(),
          this.restoreFocusedCell(i))
      }
    }
    removeRowCompsNotToDraw(e, t) {
      const i = {}
      e.forEach((r) => (i[r] = !0))
      const n = Object.keys(this.rowCtrlsByRowIndex).filter((r) => !i[r])
      this.removeRowCtrls(n, t)
    }
    calculateIndexesToDraw(e) {
      const t = WM(this.firstRenderedRow, this.lastRenderedRow),
        i = (n, r) => {
          const o = r.getRowNode().rowIndex
          o != null &&
            (o < this.firstRenderedRow || o > this.lastRenderedRow) &&
            this.doNotUnVirtualiseRow(r) &&
            t.push(o)
        }
      Qi(this.rowCtrlsByRowIndex, i), Qi(e, i), t.sort((n, r) => n - r)
      const s = []
      for (let n = 0; n < t.length; n++) {
        const r = t[n],
          o = this.rowModel.getRow(r)
        o && !o.sticky && s.push(r)
      }
      return s
    }
    recycleRows(e, t = !1, i = !1) {
      const s = this.calculateIndexesToDraw(e)
      ;(this.printLayout || i) && (t = !1),
        this.removeRowCompsNotToDraw(s, !t),
        s.forEach((n) => {
          this.createOrUpdateRowCtrl(n, e, t, i)
        }),
        e &&
          (i && !this.gos.get('suppressAnimationFrame') && !this.printLayout
            ? this.beans.animationFrameService.addDestroyTask(() => {
                this.destroyRowCtrls(e, t),
                  this.updateAllRowCtrls(),
                  this.dispatchDisplayedRowsChanged()
              })
            : this.destroyRowCtrls(e, t)),
        this.updateAllRowCtrls()
    }
    dispatchDisplayedRowsChanged(e = !1) {
      this.eventService.dispatchEvent({
        type: 'displayedRowsChanged',
        afterScroll: e,
      })
    }
    onDisplayedColumnsChanged() {
      const e = this.visibleColsService.isPinningLeft(),
        t = this.visibleColsService.isPinningRight()
      ;(this.pinningLeft !== e || t !== this.pinningRight) &&
        ((this.pinningLeft = e),
        (this.pinningRight = t),
        this.embedFullWidthRows && this.redrawFullWidthEmbeddedRows())
    }
    redrawFullWidthEmbeddedRows() {
      const e = []
      this.getFullWidthRowCtrls().forEach((t) => {
        const i = t.getRowNode().rowIndex
        e.push(i.toString())
      }),
        this.refreshFloatingRowComps(),
        this.removeRowCtrls(e),
        this.redraw({ afterScroll: !0 })
    }
    getFullWidthRowCtrls(e) {
      const t = this.mapRowNodes(e)
      return this.getAllRowCtrls().filter((i) => {
        if (!i.isFullWidth()) return !1
        const s = i.getRowNode()
        return !(t != null && !this.isRowInMap(s, t))
      })
    }
    createOrUpdateRowCtrl(e, t, i, s) {
      let n,
        r = this.rowCtrlsByRowIndex[e]
      if (
        (r ||
          ((n = this.rowModel.getRow(e)),
          ue(n) &&
            ue(t) &&
            t[n.id] &&
            n.alreadyRendered &&
            ((r = t[n.id]), (t[n.id] = null))),
        !r)
      )
        if ((n || (n = this.rowModel.getRow(e)), ue(n)))
          r = this.createRowCon(n, i, s)
        else return
      return n && (n.alreadyRendered = !0), (this.rowCtrlsByRowIndex[e] = r), r
    }
    destroyRowCtrls(e, t) {
      const i = []
      Qi(e, (s, n) => {
        if (n) {
          if (this.cachedRowCtrls && n.isCacheable()) {
            this.cachedRowCtrls.addRow(n)
            return
          }
          if ((n.destroyFirstPass(!t), t)) {
            const r = n.instanceId
            ;(this.zombieRowCtrls[r] = n),
              i.push(() => {
                n.destroySecondPass(), delete this.zombieRowCtrls[r]
              })
          } else n.destroySecondPass()
        }
      }),
        t &&
          (i.push(() => {
            this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged()
          }),
          ax(i))
    }
    getRowBuffer() {
      return this.gos.get('rowBuffer')
    }
    getRowBufferInPixels() {
      const e = this.getRowBuffer(),
        t = In(this.gos)
      return e * t
    }
    workOutFirstAndLastRowsToRender() {
      this.rowContainerHeightService.updateOffset()
      let e, t
      if (!this.rowModel.isRowsToRender()) (e = 0), (t = -1)
      else if (this.printLayout)
        this.environment.refreshRowHeightVariable(),
          (e = this.pageBoundsService.getFirstRow()),
          (t = this.pageBoundsService.getLastRow())
      else {
        const a = this.getRowBufferInPixels(),
          l = this.ctrlsService.getGridBodyCtrl(),
          c = this.gos.get('suppressRowVirtualisation')
        let u = !1,
          h,
          g
        do {
          const C = this.pageBoundsService.getPixelOffset(),
            { pageFirstPixel: w, pageLastPixel: S } =
              this.pageBoundsService.getCurrentPagePixelRange(),
            y = this.rowContainerHeightService.getDivStretchOffset(),
            F = l.getScrollFeature().getVScrollPosition(),
            R = F.top,
            b = F.bottom
          c
            ? ((h = w + y), (g = S + y))
            : ((h = Math.max(R + C - a, w) + y),
              (g = Math.min(b + C + a, S) + y)),
            (this.firstVisibleVPixel = Math.max(R + C, w) + y),
            (this.lastVisibleVPixel = Math.min(b + C, S) + y),
            (u = this.ensureAllRowsInRangeHaveHeightsCalculated(h, g))
        } while (u)
        let f = this.rowModel.getRowIndexAtPixel(h),
          p = this.rowModel.getRowIndexAtPixel(g)
        const v = this.pageBoundsService.getFirstRow(),
          m = this.pageBoundsService.getLastRow()
        f < v && (f = v), p > m && (p = m), (e = f), (t = p)
      }
      const i = ci(this.gos, 'normal'),
        s = this.gos.get('suppressMaxRenderedRowRestriction'),
        n = Math.max(this.getRowBuffer(), 500)
      i && !s && t - e > n && (t = e + n)
      const r = e !== this.firstRenderedRow,
        o = t !== this.lastRenderedRow
      ;(r || o) &&
        ((this.firstRenderedRow = e),
        (this.lastRenderedRow = t),
        this.eventService.dispatchEvent({
          type: 'viewportChanged',
          firstRow: e,
          lastRow: t,
        }))
    }
    dispatchFirstDataRenderedEvent() {
      this.dataFirstRenderedFired ||
        ((this.dataFirstRenderedFired = !0),
        window.requestAnimationFrame(() => {
          this.beans.eventService.dispatchEvent({
            type: 'firstDataRendered',
            firstRow: this.firstRenderedRow,
            lastRow: this.lastRenderedRow,
          })
        }))
    }
    ensureAllRowsInRangeHaveHeightsCalculated(e, t) {
      var r, o
      const i =
          (r = this.pinnedRowModel) == null
            ? void 0
            : r.ensureRowHeightsValid(),
        s =
          (o = this.stickyRowFeature) == null
            ? void 0
            : o.ensureRowHeightsValid(),
        n = this.rowModel.ensureRowHeightsValid(
          e,
          t,
          this.pageBoundsService.getFirstRow(),
          this.pageBoundsService.getLastRow(),
        )
      return (
        (n || s) &&
          this.eventService.dispatchEvent({ type: 'recalculateRowBounds' }),
        s || n || i ? (this.updateContainerHeights(), !0) : !1
      )
    }
    getFirstVisibleVerticalPixel() {
      return this.firstVisibleVPixel
    }
    getLastVisibleVerticalPixel() {
      return this.lastVisibleVPixel
    }
    getFirstVirtualRenderedRow() {
      return this.firstRenderedRow
    }
    getLastVirtualRenderedRow() {
      return this.lastRenderedRow
    }
    doNotUnVirtualiseRow(e) {
      const s = e.getRowNode(),
        n = this.focusService.isRowNodeFocused(s),
        r = e.isEditing(),
        o = s.detail
      return n || r || o ? !!this.isRowPresent(s) : !1
    }
    isRowPresent(e) {
      return this.rowModel.isRowPresent(e)
        ? this.paginationService
          ? this.paginationService.isRowPresent(e)
          : !0
        : !1
    }
    createRowCon(e, t, i) {
      const s = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(e) : null
      if (s) return s
      const n = this.gos.get('suppressAnimationFrame'),
        r = i && !n && !this.printLayout
      return new On(e, this.beans, t, r, this.printLayout)
    }
    getRenderedNodes() {
      const e = this.rowCtrlsByRowIndex
      return Object.values(e).map((t) => t.getRowNode())
    }
    getRowByPosition(e) {
      let t
      const { rowIndex: i } = e
      switch (e.rowPinned) {
        case 'top':
          t = this.topRowCtrls[i]
          break
        case 'bottom':
          t = this.bottomRowCtrls[i]
          break
        default:
          ;(t = this.rowCtrlsByRowIndex[i]),
            t ||
              ((t =
                this.getStickyTopRowCtrls().find(
                  (s) => s.getRowNode().rowIndex === i,
                ) || null),
              t ||
                (t =
                  this.getStickyBottomRowCtrls().find(
                    (s) => s.getRowNode().rowIndex === i,
                  ) || null))
          break
      }
      return t
    }
    isRangeInRenderedViewport(e, t) {
      if (e == null || t == null) return !1
      const s = e > this.lastRenderedRow
      return !(t < this.firstRenderedRow) && !s
    }
  },
  GA = class {
    constructor(e) {
      ;(this.entriesMap = {}), (this.entriesList = []), (this.maxCount = e)
    }
    addRow(e) {
      if (
        ((this.entriesMap[e.getRowNode().id] = e),
        this.entriesList.push(e),
        e.setCached(!0),
        this.entriesList.length > this.maxCount)
      ) {
        const t = this.entriesList[0]
        t.destroyFirstPass(), t.destroySecondPass(), this.removeFromCache(t)
      }
    }
    getRow(e) {
      if (e == null || e.id == null) return null
      const t = this.entriesMap[e.id]
      return t
        ? (this.removeFromCache(t),
          t.setCached(!1),
          t.getRowNode() != e ? null : t)
        : null
    }
    has(e) {
      return this.entriesMap[e.id] != null
    }
    removeRow(e) {
      const t = e.id,
        i = this.entriesMap[t]
      delete this.entriesMap[t], Ri(this.entriesList, i)
    }
    removeFromCache(e) {
      const t = e.getRowNode().id
      delete this.entriesMap[t], Ri(this.entriesList, e)
    }
    getEntries() {
      return this.entriesList
    }
  },
  BA = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'pinnedRowModel'),
        (this.nextId = 0),
        (this.pinnedTopRows = new Mg()),
        (this.pinnedBottomRows = new Mg())
    }
    wireBeans(e) {
      this.beans = e
    }
    postConstruct() {
      this.setPinnedRowData(this.gos.get('pinnedTopRowData'), 'top'),
        this.setPinnedRowData(this.gos.get('pinnedBottomRowData'), 'bottom'),
        this.addManagedPropertyListener('pinnedTopRowData', (e) =>
          this.setPinnedRowData(e.currentValue, 'top'),
        ),
        this.addManagedPropertyListener('pinnedBottomRowData', (e) =>
          this.setPinnedRowData(e.currentValue, 'bottom'),
        ),
        this.addManagedEventListeners({
          gridStylesChanged: this.onGridStylesChanges.bind(this),
        })
    }
    isEmpty(e) {
      return (
        e === 'top' ? this.pinnedTopRows : this.pinnedBottomRows
      ).isEmpty()
    }
    isRowsToRender(e) {
      return !this.isEmpty(e)
    }
    onGridStylesChanges(e) {
      if (e.rowHeightChanged) {
        const t = (i) => {
          i.setRowHeight(i.rowHeight, !0)
        }
        this.pinnedBottomRows.forEach(t), this.pinnedTopRows.forEach(t)
      }
    }
    ensureRowHeightsValid() {
      var s, n
      let e = !1,
        t = 0
      const i = (r) => {
        if (r.rowHeightEstimated) {
          const o = ln(this.gos, r)
          r.setRowTop(t), r.setRowHeight(o.height), (t += o.height), (e = !0)
        }
      }
      return (
        (s = this.pinnedBottomRows) == null || s.forEach(i),
        (t = 0),
        (n = this.pinnedTopRows) == null || n.forEach(i),
        this.eventService.dispatchEvent({ type: 'pinnedHeightChanged' }),
        e
      )
    }
    setPinnedRowData(e, t) {
      this.updateNodesFromRowData(e, t),
        this.eventService.dispatchEvent({ type: 'pinnedRowDataChanged' })
    }
    updateNodesFromRowData(e, t) {
      const i = t === 'top' ? this.pinnedTopRows : this.pinnedBottomRows
      if (e === void 0) {
        i.clear()
        return
      }
      const s = Mr(this.gos),
        n = t === 'top' ? Ls.ID_PREFIX_TOP_PINNED : Ls.ID_PREFIX_BOTTOM_PINNED,
        r = i.getIds(),
        o = [],
        a = new Set()
      let l = 0,
        c = -1
      for (const u of e) {
        const h =
          (s == null ? void 0 : s({ data: u, level: 0, rowPinned: t })) ??
          n + this.nextId++
        if (a.has(h)) {
          te(
            'Duplicate ID',
            h,
            'found for pinned row with data',
            u,
            'When `getRowId` is defined, it must return unique IDs for all pinned rows. Use the `rowPinned` parameter.',
          )
          continue
        }
        c++, a.add(h), o.push(h)
        const g = i.getById(h)
        if (g !== void 0)
          g.data !== u && g.setData(u),
            (l += this.setRowTopAndRowIndex(g, l, c)),
            r.delete(h)
        else {
          const f = new Ls(this.beans)
          ;(f.id = h),
            (f.data = u),
            (f.rowPinned = t),
            (l += this.setRowTopAndRowIndex(f, l, c)),
            i.push(f)
        }
      }
      r.forEach((u) => {
        var h
        ;(h = i.getById(u)) == null || h.clearRowTopAndRowIndex()
      }),
        i.removeAllById(r),
        i.setOrder(o)
    }
    setRowTopAndRowIndex(e, t, i) {
      return (
        e.setRowTop(t),
        e.setRowHeight(ln(this.gos, e).height),
        e.setRowIndex(i),
        e.rowHeight
      )
    }
    getPinnedTopTotalHeight() {
      return this.getTotalHeight(this.pinnedTopRows)
    }
    getPinnedBottomTotalHeight() {
      return this.getTotalHeight(this.pinnedBottomRows)
    }
    getPinnedTopRowCount() {
      return this.pinnedTopRows.getSize()
    }
    getPinnedBottomRowCount() {
      return this.pinnedBottomRows.getSize()
    }
    getPinnedTopRow(e) {
      return this.pinnedTopRows.getByIndex(e)
    }
    getPinnedBottomRow(e) {
      return this.pinnedBottomRows.getByIndex(e)
    }
    getPinnedRowById(e, t) {
      return t === 'top'
        ? this.pinnedTopRows.getById(e)
        : this.pinnedBottomRows.getById(e)
    }
    forEachPinnedRow(e, t) {
      return e === 'top'
        ? this.pinnedTopRows.forEach(t)
        : this.pinnedBottomRows.forEach(t)
    }
    getTotalHeight(e) {
      const t = e.getSize()
      if (t === 0) return 0
      const i = e.getByIndex(t - 1)
      return i === void 0 ? 0 : i.rowTop + i.rowHeight
    }
  },
  Mg = class {
    constructor() {
      ;(this.cache = {}), (this.ordering = [])
    }
    getById(e) {
      return this.cache[e]
    }
    getByIndex(e) {
      const t = this.ordering[e]
      return this.cache[t]
    }
    push(e) {
      ;(this.cache[e.id] = e), this.ordering.push(e.id)
    }
    removeAllById(e) {
      for (const t of e) delete this.cache[t]
      this.ordering = this.ordering.filter((t) => !e.has(t))
    }
    setOrder(e) {
      this.ordering = e
    }
    forEach(e) {
      this.ordering.forEach((t, i) => {
        const s = this.cache[t]
        s && e(s, i)
      })
    }
    clear() {
      ;(this.ordering.length = 0), (this.cache = {})
    }
    isEmpty() {
      return this.ordering.length === 0
    }
    getSize() {
      return this.ordering.length
    }
    getIds() {
      return new Set(this.ordering)
    }
  },
  VA = class extends X {
    constructor(e) {
      super(), (this.state = 'needsLoading'), (this.version = 0), (this.id = e)
    }
    getId() {
      return this.id
    }
    load() {
      ;(this.state = 'loading'), this.loadFromDatasource()
    }
    getVersion() {
      return this.version
    }
    setStateWaitingToLoad() {
      this.version++, (this.state = 'needsLoading')
    }
    getState() {
      return this.state
    }
    pageLoadFailed(e) {
      this.isRequestMostRecentAndLive(e) &&
        ((this.state = 'failed'), this.processServerFail()),
        this.dispatchLoadCompleted(!1)
    }
    success(e, t) {
      this.successCommon(e, t)
    }
    pageLoaded(e, t, i) {
      this.successCommon(e, { rowData: t, rowCount: i })
    }
    isRequestMostRecentAndLive(e) {
      const t = e === this.version,
        i = this.isAlive()
      return t && i
    }
    successCommon(e, t) {
      this.dispatchLoadCompleted(),
        this.isRequestMostRecentAndLive(e) &&
          ((this.state = 'loaded'), this.processServerResult(t))
    }
    dispatchLoadCompleted(e = !0) {
      const t = { type: 'loadComplete', success: e, block: this }
      this.dispatchLocalEvent(t)
    }
  },
  _A = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'rowNodeBlockLoader'),
        (this.activeBlockLoadsCount = 0),
        (this.blocks = []),
        (this.active = !0)
    }
    wireBeans(e) {
      this.rowModel = e.rowModel
    }
    postConstruct() {
      this.maxConcurrentRequests = this.getMaxConcurrentDatasourceRequests()
      const e = this.gos.get('blockLoadDebounceMillis')
      e &&
        e > 0 &&
        (this.checkBlockToLoadDebounce = bi(
          this.performCheckBlocksToLoad.bind(this),
          e,
        ))
    }
    getMaxConcurrentDatasourceRequests() {
      const e = this.gos.get('maxConcurrentDatasourceRequests')
      if (e == null) return 2
      if (!(e <= 0)) return e
    }
    addBlock(e) {
      this.blocks.push(e),
        e.addEventListener('loadComplete', this.loadComplete.bind(this)),
        this.checkBlockToLoad()
    }
    removeBlock(e) {
      Ri(this.blocks, e)
    }
    destroy() {
      super.destroy(), (this.active = !1)
    }
    loadComplete() {
      this.activeBlockLoadsCount--,
        this.checkBlockToLoad(),
        this.dispatchLocalEvent({ type: 'blockLoaded' }),
        this.activeBlockLoadsCount == 0 &&
          this.dispatchLocalEvent({ type: 'blockLoaderFinished' })
    }
    checkBlockToLoad() {
      this.checkBlockToLoadDebounce
        ? this.checkBlockToLoadDebounce()
        : this.performCheckBlocksToLoad()
    }
    performCheckBlocksToLoad() {
      if (!this.active) return
      if (
        (this.printCacheStatus(),
        this.maxConcurrentRequests != null &&
          this.activeBlockLoadsCount >= this.maxConcurrentRequests)
      ) {
        this.gos.get('debug') &&
          Xi('RowNodeBlockLoader - checkBlockToLoad: max loads exceeded')
        return
      }
      const e = this.getAvailableLoadingCount(),
        t = this.blocks
          .filter((i) => i.getState() === 'needsLoading')
          .slice(0, e)
      this.registerLoads(t.length),
        t.forEach((i) => i.load()),
        this.printCacheStatus()
    }
    getBlockState() {
      if (ms(this.gos)) return this.rowModel.getBlockStates()
      const e = {}
      return (
        this.blocks.forEach((t) => {
          const { id: i, state: s } = t.getBlockStateJson()
          e[i] = s
        }),
        e
      )
    }
    printCacheStatus() {
      this.gos.get('debug') &&
        Xi(
          `RowNodeBlockLoader - printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount}, blocks = ${JSON.stringify(this.getBlockState())}`,
        )
    }
    isLoading() {
      return this.activeBlockLoadsCount > 0
    }
    registerLoads(e) {
      this.activeBlockLoadsCount += e
    }
    getAvailableLoadingCount() {
      return this.maxConcurrentRequests !== void 0
        ? this.maxConcurrentRequests - this.activeBlockLoadsCount
        : void 0
    }
  },
  WA = {
    version: je,
    moduleName: '@ag-grid-community/row-node-block',
    beans: [_A],
  },
  $A = class {
    constructor() {
      ;(this.root = null), (this.end = null), (this.cachedRange = [])
    }
    init(e) {
      this.rowModel = e
    }
    reset() {
      ;(this.root = null), (this.end = null), (this.cachedRange.length = 0)
    }
    setRoot(e) {
      ;(this.root = e), (this.end = null), (this.cachedRange.length = 0)
    }
    setEndRange(e) {
      ;(this.end = e), (this.cachedRange.length = 0)
    }
    getRange() {
      if (this.cachedRange.length === 0) {
        const e = this.getRoot(),
          t = this.getEnd()
        if (e == null || t == null) return this.cachedRange
        this.cachedRange = this.rowModel.getNodesInRangeForSelection(e, t)
      }
      return this.cachedRange
    }
    isInRange(e) {
      return this.root === null
        ? !1
        : this.getRange().some((t) => t.id === e.id)
    }
    getRoot() {
      var e
      return (
        this.root &&
          ((e = this.root) == null ? void 0 : e.key) === null &&
          (this.root = this.rowModel.getRowNode(this.root.id) ?? null),
        this.root
      )
    }
    getEnd() {
      var e
      return (
        this.end &&
          ((e = this.end) == null ? void 0 : e.key) === null &&
          (this.end = this.rowModel.getRowNode(this.end.id) ?? null),
        this.end
      )
    }
    truncate(e) {
      const t = this.getRange()
      if (t.length === 0) return { keep: [], discard: [] }
      const i = t[0].id === this.root.id,
        s = t.findIndex((n) => n.id === e.id)
      if (s > -1) {
        const n = t.slice(0, s),
          r = t.slice(s + 1)
        return (
          this.setEndRange(e),
          i ? { keep: n, discard: r } : { keep: r, discard: n }
        )
      } else return { keep: t, discard: [] }
    }
    extend(e, t = !1) {
      const i = this.getRoot()
      if (i == null) {
        const n = this.getRange().slice()
        return (
          t && e.depthFirstSearch((r) => !r.group && n.push(r)),
          n.push(e),
          this.setRoot(e),
          { keep: n, discard: [] }
        )
      }
      if (
        this.rowModel.getNodesInRangeForSelection(i, e).find((n) => {
          var r
          return n.id === ((r = this.end) == null ? void 0 : r.id)
        })
      )
        return this.setEndRange(e), { keep: this.getRange(), discard: [] }
      {
        const n = this.getRange().slice()
        return this.setEndRange(e), { keep: this.getRange(), discard: n }
      }
    }
  },
  zA = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'stylingService')
    }
    wireBeans(e) {
      this.expressionService = e.expressionService
    }
    processAllCellClasses(e, t, i, s) {
      this.processClassRules(void 0, e.cellClassRules, t, i, s),
        this.processStaticCellClasses(e, t, i)
    }
    processClassRules(e, t, i, s, n) {
      if (t == null && e == null) return
      const r = {},
        o = {},
        a = (l, c) => {
          l.split(' ').forEach((u) => {
            u.trim() != '' && c(u)
          })
        }
      if (t) {
        const l = Object.keys(t)
        for (let c = 0; c < l.length; c++) {
          const u = l[c],
            h = t[u]
          let g
          typeof h == 'string'
            ? (g = this.expressionService.evaluate(h, i))
            : typeof h == 'function' && (g = h(i)),
            a(u, (f) => {
              g ? (r[f] = !0) : (o[f] = !0)
            })
        }
      }
      e &&
        n &&
        Object.keys(e).forEach((l) =>
          a(l, (c) => {
            r[c] || (o[c] = !0)
          }),
        ),
        n && Object.keys(o).forEach(n),
        Object.keys(r).forEach(s)
    }
    getStaticCellClasses(e, t) {
      const { cellClass: i } = e
      if (!i) return []
      let s
      return (
        typeof i == 'function' ? (s = i(t)) : (s = i),
        typeof s == 'string' && (s = [s]),
        s || []
      )
    }
    processStaticCellClasses(e, t, i) {
      this.getStaticCellClasses(e, t).forEach((n) => {
        i(n)
      })
    }
  },
  ga = ((e) => (
    (e.TAB_GUARD = 'ag-tab-guard'),
    (e.TAB_GUARD_TOP = 'ag-tab-guard-top'),
    (e.TAB_GUARD_BOTTOM = 'ag-tab-guard-bottom'),
    e
  ))(ga || {}),
  Yv = class extends X {
    constructor(e) {
      super(),
        (this.skipTabGuardFocus = !1),
        (this.forcingFocusOut = !1),
        (this.allowFocus = !1)
      const {
        comp: t,
        eTopGuard: i,
        eBottomGuard: s,
        focusTrapActive: n,
        forceFocusOutWhenTabGuardsAreEmpty: r,
        isFocusableContainer: o,
        focusInnerElement: a,
        onFocusIn: l,
        onFocusOut: c,
        shouldStopEventPropagation: u,
        onTabKeyDown: h,
        handleKeyDown: g,
        eFocusableElement: f,
      } = e
      ;(this.comp = t),
        (this.eTopGuard = i),
        (this.eBottomGuard = s),
        (this.providedFocusInnerElement = a),
        (this.eFocusableElement = f),
        (this.focusTrapActive = !!n),
        (this.forceFocusOutWhenTabGuardsAreEmpty = !!r),
        (this.isFocusableContainer = !!o),
        (this.providedFocusIn = l),
        (this.providedFocusOut = c),
        (this.providedShouldStopEventPropagation = u),
        (this.providedOnTabKeyDown = h),
        (this.providedHandleKeyDown = g)
    }
    wireBeans(e) {
      this.focusService = e.focusService
    }
    postConstruct() {
      this.createManagedBean(
        new jn(this.eFocusableElement, {
          shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
          onTabKeyDown: (e) => this.onTabKeyDown(e),
          handleKeyDown: (e) => this.handleKeyDown(e),
          onFocusIn: (e) => this.onFocusIn(e),
          onFocusOut: (e) => this.onFocusOut(e),
        }),
      ),
        this.activateTabGuards(),
        [this.eTopGuard, this.eBottomGuard].forEach((e) =>
          this.addManagedElementListeners(e, {
            focus: this.onFocus.bind(this),
          }),
        )
    }
    handleKeyDown(e) {
      this.providedHandleKeyDown && this.providedHandleKeyDown(e)
    }
    tabGuardsAreActive() {
      return !!this.eTopGuard && this.eTopGuard.hasAttribute('tabIndex')
    }
    shouldStopEventPropagation() {
      return this.providedShouldStopEventPropagation
        ? this.providedShouldStopEventPropagation()
        : !1
    }
    activateTabGuards() {
      if (this.forcingFocusOut) return
      const e = this.gos.get('tabIndex')
      this.comp.setTabIndex(e.toString())
    }
    deactivateTabGuards() {
      this.comp.setTabIndex()
    }
    onFocus(e) {
      if (
        this.isFocusableContainer &&
        !this.eFocusableElement.contains(e.relatedTarget) &&
        !this.allowFocus
      ) {
        this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard)
        return
      }
      if (this.skipTabGuardFocus) {
        this.skipTabGuardFocus = !1
        return
      }
      if (
        this.forceFocusOutWhenTabGuardsAreEmpty &&
        this.focusService.findFocusableElements(
          this.eFocusableElement,
          '.ag-tab-guard',
        ).length === 0
      ) {
        this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard)
        return
      }
      if (
        this.isFocusableContainer &&
        this.eFocusableElement.contains(e.relatedTarget)
      )
        return
      const t = e.target === this.eBottomGuard
      this.providedFocusInnerElement
        ? this.providedFocusInnerElement(t)
        : this.focusInnerElement(t)
    }
    findNextElementOutsideAndFocus(e) {
      var l
      const t = Gt(this.gos),
        i = this.focusService.findFocusableElements(t.body, null, !0),
        s = i.indexOf(e ? this.eTopGuard : this.eBottomGuard)
      if (s === -1) return
      let n, r
      e ? ((n = 0), (r = s)) : ((n = s + 1), (r = i.length))
      const o = i.slice(n, r),
        a = this.gos.get('tabIndex')
      o.sort((c, u) => {
        const h = parseInt(c.getAttribute('tabindex') || '0'),
          g = parseInt(u.getAttribute('tabindex') || '0')
        return g === a ? 1 : h === a ? -1 : h === 0 ? 1 : g === 0 ? -1 : h - g
      }),
        (l = o[e ? o.length - 1 : 0]) == null || l.focus()
    }
    onFocusIn(e) {
      this.focusTrapActive ||
        this.forcingFocusOut ||
        (this.providedFocusIn && this.providedFocusIn(e),
        this.isFocusableContainer || this.deactivateTabGuards())
    }
    onFocusOut(e) {
      this.focusTrapActive ||
        (this.providedFocusOut && this.providedFocusOut(e),
        this.eFocusableElement.contains(e.relatedTarget) ||
          this.activateTabGuards())
    }
    onTabKeyDown(e) {
      if (this.providedOnTabKeyDown) {
        this.providedOnTabKeyDown(e)
        return
      }
      if (this.focusTrapActive || e.defaultPrevented) return
      const t = this.tabGuardsAreActive()
      t && this.deactivateTabGuards()
      const i = this.getNextFocusableElement(e.shiftKey)
      t && setTimeout(() => this.activateTabGuards(), 0),
        i && (i.focus(), e.preventDefault())
    }
    focusInnerElement(e = !1) {
      const t = this.focusService.findFocusableElements(this.eFocusableElement)
      this.tabGuardsAreActive() && (t.splice(0, 1), t.splice(t.length - 1, 1)),
        t.length && t[e ? t.length - 1 : 0].focus({ preventScroll: !0 })
    }
    getNextFocusableElement(e) {
      return this.focusService.findNextFocusableElement(
        this.eFocusableElement,
        !1,
        e,
      )
    }
    forceFocusOutOfContainer(e = !1) {
      if (this.forcingFocusOut) return
      const t = e ? this.eTopGuard : this.eBottomGuard
      this.activateTabGuards(),
        (this.skipTabGuardFocus = !0),
        (this.forcingFocusOut = !0),
        t.focus(),
        window.setTimeout(() => {
          ;(this.forcingFocusOut = !1), this.activateTabGuards()
        })
    }
    isTabGuard(e, t) {
      return (
        (e === this.eTopGuard && !t) || (e === this.eBottomGuard && (t ?? !0))
      )
    }
    setAllowFocus(e) {
      this.allowFocus = e
    }
  },
  UA = class extends X {
    constructor(e) {
      super(), (this.comp = e)
    }
    initialiseTabGuard(e) {
      ;(this.eTopGuard = this.createTabGuard('top')),
        (this.eBottomGuard = this.createTabGuard('bottom')),
        (this.eFocusableElement = this.comp.getFocusableElement())
      const { eTopGuard: t, eBottomGuard: i, eFocusableElement: s } = this,
        n = [t, i],
        r = {
          setTabIndex: (v) => {
            n.forEach((m) =>
              v != null
                ? m.setAttribute('tabindex', v)
                : m.removeAttribute('tabindex'),
            )
          },
        }
      this.addTabGuards(t, i)
      const {
        focusTrapActive: o = !1,
        onFocusIn: a,
        onFocusOut: l,
        focusInnerElement: c,
        handleKeyDown: u,
        onTabKeyDown: h,
        shouldStopEventPropagation: g,
        forceFocusOutWhenTabGuardsAreEmpty: f,
        isFocusableContainer: p,
      } = e
      this.tabGuardCtrl = this.createManagedBean(
        new Yv({
          comp: r,
          focusTrapActive: o,
          eTopGuard: t,
          eBottomGuard: i,
          eFocusableElement: s,
          onFocusIn: a,
          onFocusOut: l,
          focusInnerElement: c,
          handleKeyDown: u,
          onTabKeyDown: h,
          shouldStopEventPropagation: g,
          forceFocusOutWhenTabGuardsAreEmpty: f,
          isFocusableContainer: p,
        }),
      )
    }
    getTabGuardCtrl() {
      return this.tabGuardCtrl
    }
    createTabGuard(e) {
      const t = Gt(this.gos).createElement('div'),
        i = e === 'top' ? 'ag-tab-guard-top' : 'ag-tab-guard-bottom'
      return t.classList.add('ag-tab-guard', i), es(t, 'presentation'), t
    }
    addTabGuards(e, t) {
      this.eFocusableElement.insertAdjacentElement('afterbegin', e),
        this.eFocusableElement.insertAdjacentElement('beforeend', t)
    }
    removeAllChildrenExceptTabGuards() {
      const e = [this.eTopGuard, this.eBottomGuard]
      Ni(this.comp.getFocusableElement()), this.addTabGuards(...e)
    }
    forceFocusOutOfContainer(e = !1) {
      this.tabGuardCtrl.forceFocusOutOfContainer(e)
    }
    appendChild(e, t, i) {
      dd(t) || (t = t.getGui())
      const { eBottomGuard: s } = this
      s ? s.insertAdjacentElement('beforebegin', t) : e(t, i)
    }
  },
  jA = class extends yt {
    initialiseTabGuard(t) {
      ;(this.tabGuardFeature = this.createManagedBean(new UA(this))),
        this.tabGuardFeature.initialiseTabGuard(t)
    }
    forceFocusOutOfContainer(t = !1) {
      this.tabGuardFeature.forceFocusOutOfContainer(t)
    }
    appendChild(t, i) {
      this.tabGuardFeature.appendChild(super.appendChild.bind(this), t, i)
    }
  },
  YA = 0,
  KA = 200,
  qA = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'popupService'),
        (this.popupList = [])
    }
    wireBeans(e) {
      ;(this.ctrlsService = e.ctrlsService),
        (this.resizeObserverService = e.resizeObserverService),
        (this.environment = e.environment)
    }
    postConstruct() {
      this.ctrlsService.whenReady(this, (e) => {
        this.gridCtrl = e.gridCtrl
      }),
        this.addManagedEventListeners({
          gridStylesChanged: this.handleThemeChange.bind(this),
        })
    }
    getPopupParent() {
      const e = this.gos.get('popupParent')
      return e || this.gridCtrl.getGui()
    }
    positionPopupForMenu(e) {
      const { eventSource: t, ePopup: i } = e,
        s = this.getPopupIndex(i)
      if (s !== -1) {
        const f = this.popupList[s]
        f.alignedToElement = t
      }
      const n = t.getBoundingClientRect(),
        r = this.getParentRect(),
        o = this.keepXYWithinBounds(i, n.top - r.top, 0),
        a = i.clientWidth > 0 ? i.clientWidth : 200
      i.style.minWidth = `${a}px`
      const c = r.right - r.left - a
      let u
      this.gos.get('enableRtl')
        ? ((u = g()),
          u < 0 && ((u = h()), this.setAlignedStyles(i, 'left')),
          u > c && ((u = 0), this.setAlignedStyles(i, 'right')))
        : ((u = h()),
          u > c && ((u = g()), this.setAlignedStyles(i, 'right')),
          u < 0 && ((u = 0), this.setAlignedStyles(i, 'left'))),
        (i.style.left = `${u}px`),
        (i.style.top = `${o}px`)
      function h() {
        return n.right - r.left - 2
      }
      function g() {
        return n.left - r.left - a
      }
    }
    positionPopupUnderMouseEvent(e) {
      const { ePopup: t, nudgeX: i, nudgeY: s, skipObserver: n } = e
      this.positionPopup({
        ePopup: t,
        nudgeX: i,
        nudgeY: s,
        keepWithinBounds: !0,
        skipObserver: n,
        updatePosition: () => this.calculatePointerAlign(e.mouseEvent),
        postProcessCallback: () =>
          this.callPostProcessPopup(
            e.type,
            e.ePopup,
            null,
            e.mouseEvent,
            e.column,
            e.rowNode,
          ),
      })
    }
    calculatePointerAlign(e) {
      const t = this.getParentRect()
      return { x: e.clientX - t.left, y: e.clientY - t.top }
    }
    positionPopupByComponent(e) {
      const {
          ePopup: t,
          nudgeX: i,
          nudgeY: s,
          keepWithinBounds: n,
          eventSource: r,
          alignSide: o = 'left',
          position: a = 'over',
          column: l,
          rowNode: c,
          type: u,
        } = e,
        h = r.getBoundingClientRect(),
        g = this.getParentRect(),
        f = this.getPopupIndex(t)
      if (f !== -1) {
        const v = this.popupList[f]
        v.alignedToElement = r
      }
      const p = () => {
        let v = h.left - g.left
        o === 'right' && (v -= t.offsetWidth - h.width)
        let m
        return (
          a === 'over'
            ? ((m = h.top - g.top), this.setAlignedStyles(t, 'over'))
            : (this.setAlignedStyles(t, 'under'),
              this.shouldRenderUnderOrAbove(t, h, g, e.nudgeY || 0) === 'under'
                ? (m = h.top - g.top + h.height)
                : (m = h.top - t.offsetHeight - (s || 0) * 2 - g.top)),
          { x: v, y: m }
        )
      }
      this.positionPopup({
        ePopup: t,
        nudgeX: i,
        nudgeY: s,
        keepWithinBounds: n,
        updatePosition: p,
        postProcessCallback: () =>
          this.callPostProcessPopup(u, t, r, null, l, c),
      })
    }
    shouldRenderUnderOrAbove(e, t, i, s) {
      const n = i.bottom - t.bottom,
        r = t.top - i.top,
        o = e.offsetHeight + s
      return n > o ? 'under' : r > o || r > n ? 'above' : 'under'
    }
    setAlignedStyles(e, t) {
      const i = this.getPopupIndex(e)
      if (i === -1) return
      const s = this.popupList[i],
        { alignedToElement: n } = s
      !n ||
        (['right', 'left', 'over', 'above', 'under'].forEach((o) => {
          n.classList.remove(`ag-has-popup-positioned-${o}`),
            e.classList.remove(`ag-popup-positioned-${o}`)
        }),
        !t) ||
        (n.classList.add(`ag-has-popup-positioned-${t}`),
        e.classList.add(`ag-popup-positioned-${t}`))
    }
    callPostProcessPopup(e, t, i, s, n, r) {
      const o = this.gos.getCallback('postProcessPopup')
      o &&
        o({
          column: n,
          rowNode: r,
          ePopup: t,
          type: e,
          eventSource: i,
          mouseEvent: s,
        })
    }
    positionPopup(e) {
      const {
          ePopup: t,
          keepWithinBounds: i,
          nudgeX: s,
          nudgeY: n,
          skipObserver: r,
          updatePosition: o,
        } = e,
        a = { width: 0, height: 0 },
        l = (c = !1) => {
          let { x: u, y: h } = o()
          ;(c && t.clientWidth === a.width && t.clientHeight === a.height) ||
            ((a.width = t.clientWidth),
            (a.height = t.clientHeight),
            s && (u += s),
            n && (h += n),
            i &&
              ((u = this.keepXYWithinBounds(t, u, 1)),
              (h = this.keepXYWithinBounds(t, h, 0))),
            (t.style.left = `${u}px`),
            (t.style.top = `${h}px`),
            e.postProcessCallback && e.postProcessCallback())
        }
      if ((l(), !r)) {
        const c = this.resizeObserverService.observeResize(t, () => l(!0))
        setTimeout(() => c(), KA)
      }
    }
    getActivePopups() {
      return this.popupList.map((e) => e.element)
    }
    getPopupList() {
      return this.popupList
    }
    getParentRect() {
      const e = Gt(this.gos)
      let t = this.getPopupParent()
      return (
        t === e.body
          ? (t = e.documentElement)
          : getComputedStyle(t).position === 'static' && (t = t.offsetParent),
        Ym(t)
      )
    }
    keepXYWithinBounds(e, t, i) {
      const s = i === 0,
        n = s ? 'clientHeight' : 'clientWidth',
        r = s ? 'top' : 'left',
        o = s ? 'height' : 'width',
        a = s ? 'scrollTop' : 'scrollLeft',
        l = Gt(this.gos),
        c = l.documentElement,
        u = this.getPopupParent(),
        h = e.getBoundingClientRect(),
        g = u.getBoundingClientRect(),
        f = l.documentElement.getBoundingClientRect(),
        p = u === l.body,
        v = Math.ceil(h[o])
      let C = p ? (s ? jm : Na)(c) + c[a] : u[n]
      p && (C -= Math.abs(f[r] - g[r]))
      const w = C - v
      return Math.min(Math.max(t, 0), Math.abs(w))
    }
    addPopup(e) {
      const t = Gt(this.gos),
        {
          eChild: i,
          ariaLabel: s,
          alwaysOnTop: n,
          positionCallback: r,
          anchorToElement: o,
        } = e
      if (!t)
        return (
          te('could not find the document, document is empty'),
          { hideFunc: () => {} }
        )
      const a = this.getPopupIndex(i)
      if (a !== -1) return { hideFunc: this.popupList[a].hideFunc }
      this.initialisePopupPosition(i)
      const l = this.createPopupWrapper(i, s, !!n),
        c = this.addEventListenersToPopup({ ...e, wrapperEl: l })
      return r && r(), this.addPopupToPopupList(i, l, c, o), { hideFunc: c }
    }
    initialisePopupPosition(e) {
      const i = this.getPopupParent().getBoundingClientRect()
      ue(e.style.top) || (e.style.top = `${i.top * -1}px`),
        ue(e.style.left) || (e.style.left = `${i.left * -1}px`)
    }
    createPopupWrapper(e, t, i) {
      const s = this.getPopupParent(),
        n = document.createElement('div')
      return (
        this.environment.applyThemeClasses(n),
        n.classList.add('ag-popup'),
        e.classList.add(
          this.gos.get('enableRtl') ? 'ag-rtl' : 'ag-ltr',
          'ag-popup-child',
        ),
        e.hasAttribute('role') || es(e, 'dialog'),
        mr(e, t),
        n.appendChild(e),
        s.appendChild(n),
        i ? this.setAlwaysOnTop(e, !0) : this.bringPopupToFront(e),
        n
      )
    }
    handleThemeChange(e) {
      if (e.themeChanged)
        for (const t of this.popupList)
          this.environment.applyThemeClasses(t.wrapper)
    }
    addEventListenersToPopup(e) {
      const t = Gt(this.gos),
        i = this.getPopupParent(),
        {
          wrapperEl: s,
          eChild: n,
          closedCallback: r,
          afterGuiAttached: o,
          closeOnEsc: a,
          modal: l,
        } = e
      let c = !1
      const u = (p) => {
          if (!s.contains(Lt(this.gos))) return
          p.key === Y.ESCAPE && !Os(p) && f({ keyboardEvent: p })
        },
        h = (p) => f({ mouseEvent: p }),
        g = (p) => f({ touchEvent: p }),
        f = (p = {}) => {
          const {
            mouseEvent: v,
            touchEvent: m,
            keyboardEvent: C,
            forceHide: w,
          } = p
          ;(!w &&
            (this.isEventFromCurrentPopup(
              { mouseEvent: v, touchEvent: m },
              n,
            ) ||
              c)) ||
            ((c = !0),
            i.removeChild(s),
            t.removeEventListener('keydown', u),
            t.removeEventListener('mousedown', h),
            t.removeEventListener('touchstart', g),
            t.removeEventListener('contextmenu', h),
            this.eventService.removeEventListener('dragStarted', h),
            r && r(v || m || C),
            this.removePopupFromPopupList(n))
        }
      return (
        o && o({ hidePopup: f }),
        window.setTimeout(() => {
          a && t.addEventListener('keydown', u),
            l &&
              (t.addEventListener('mousedown', h),
              this.eventService.addEventListener('dragStarted', h),
              t.addEventListener('touchstart', g),
              t.addEventListener('contextmenu', h))
        }, 0),
        f
      )
    }
    addPopupToPopupList(e, t, i, s) {
      this.popupList.push({
        element: e,
        wrapper: t,
        hideFunc: i,
        instanceId: YA++,
        isAnchored: !!s,
      }),
        s && this.setPopupPositionRelatedToElement(e, s)
    }
    getPopupIndex(e) {
      return this.popupList.findIndex((t) => t.element === e)
    }
    setPopupPositionRelatedToElement(e, t) {
      const i = this.getPopupIndex(e)
      if (i === -1) return
      const s = this.popupList[i]
      if (
        (s.stopAnchoringPromise && s.stopAnchoringPromise.then((r) => r && r()),
        (s.stopAnchoringPromise = void 0),
        (s.isAnchored = !1),
        !t)
      )
        return
      const n = this.keepPopupPositionedRelativeTo({
        element: t,
        ePopup: e,
        hidePopup: s.hideFunc,
      })
      return (s.stopAnchoringPromise = n), (s.isAnchored = !0), n
    }
    removePopupFromPopupList(e) {
      this.setAlignedStyles(e, null),
        this.setPopupPositionRelatedToElement(e, null),
        (this.popupList = this.popupList.filter((t) => t.element !== e))
    }
    keepPopupPositionedRelativeTo(e) {
      const t = this.getPopupParent(),
        i = t.getBoundingClientRect(),
        { element: s, ePopup: n } = e,
        r = s.getBoundingClientRect(),
        o = (h) => parseInt(h.substring(0, h.length - 1), 10),
        a = (h, g) => {
          const f = i[h] - r[h],
            p = o(n.style[h])
          return {
            initialDiff: f,
            lastDiff: f,
            initial: p,
            last: p,
            direction: g,
          }
        },
        l = a('top', 0),
        c = a('left', 1),
        u = this.getFrameworkOverrides()
      return new Nt((h) => {
        u.wrapIncoming(() => {
          u.setInterval(() => {
            const g = t.getBoundingClientRect(),
              f = s.getBoundingClientRect()
            if (f.top == 0 && f.left == 0 && f.height == 0 && f.width == 0) {
              e.hidePopup()
              return
            }
            const v = (m, C) => {
              const w = o(n.style[C])
              m.last !== w && ((m.initial = w), (m.last = w))
              const S = g[C] - f[C]
              if (S != m.lastDiff) {
                const y = this.keepXYWithinBounds(
                  n,
                  m.initial + m.initialDiff - S,
                  m.direction,
                )
                ;(n.style[C] = `${y}px`), (m.last = y)
              }
              m.lastDiff = S
            }
            v(l, 'top'), v(c, 'left')
          }, 200).then((g) => {
            h(() => {
              g != null && window.clearInterval(g)
            })
          })
        }, 'popupPositioning')
      })
    }
    hasAnchoredPopup() {
      return this.popupList.some((e) => e.isAnchored)
    }
    isEventFromCurrentPopup(e, t) {
      const { mouseEvent: i, touchEvent: s } = e,
        n = i || s
      if (!n) return !1
      const r = this.getPopupIndex(t)
      if (r === -1) return !1
      for (let o = r; o < this.popupList.length; o++) {
        const a = this.popupList[o]
        if (Px(a.element, n)) return !0
      }
      return this.isElementWithinCustomPopup(n.target)
    }
    isElementWithinCustomPopup(e) {
      const t = Gt(this.gos)
      for (; e && e !== t.body; ) {
        if (
          e.classList.contains('ag-custom-component-popup') ||
          e.parentElement === null
        )
          return !0
        e = e.parentElement
      }
      return !1
    }
    getWrapper(e) {
      for (; !e.classList.contains('ag-popup') && e.parentElement; )
        e = e.parentElement
      return e.classList.contains('ag-popup') ? e : null
    }
    setAlwaysOnTop(e, t) {
      const i = this.getWrapper(e)
      i &&
        (i.classList.toggle('ag-always-on-top', !!t),
        t && this.bringPopupToFront(i))
    }
    bringPopupToFront(e) {
      const t = this.getPopupParent(),
        i = Array.prototype.slice.call(t.querySelectorAll('.ag-popup')),
        s = i.length,
        n = this.getWrapper(e)
      if (!n || s <= 1 || !t.contains(e)) return
      const r = [],
        o = []
      for (const g of i)
        g !== n &&
          (g.classList.contains('ag-always-on-top') ? o.push(g) : r.push(g))
      const a = [],
        l = o.length,
        h =
          n.classList.contains('ag-always-on-top') || !l
            ? [...r, ...o, n]
            : [...r, n, ...o]
      for (let g = 0; g <= s; g++) {
        const f = h[g]
        if (i[g] === h[g] || f === n) continue
        f.querySelectorAll('div').forEach((v) => {
          v.scrollTop !== 0 && a.push([v, v.scrollTop])
        }),
          g === 0
            ? t.insertAdjacentElement('afterbegin', f)
            : h[g - 1].insertAdjacentElement('afterend', f)
      }
      for (; a.length; ) {
        const g = a.pop()
        g[0].scrollTop = g[1]
      }
    }
  },
  QA = ['touchstart', 'touchend', 'touchmove', 'touchcancel'],
  Kv = class {
    constructor(e = 'javascript') {
      ;(this.frameworkName = e),
        (this.renderingEngine = 'vanilla'),
        (this.wrapIncoming = (t) => t()),
        (this.wrapOutgoing = (t) => t())
    }
    setInterval(e, t) {
      return new Nt((i) => {
        i(window.setInterval(e, t))
      })
    }
    addEventListener(e, t, i, s) {
      const n = Tn(QA, t)
      e.addEventListener(t, i, { capture: !!s, passive: n })
    }
    get shouldWrapOutgoing() {
      return !1
    }
    frameworkComponent(e) {
      return null
    }
    isFrameworkComponent(e) {
      return !1
    }
    getDocLink(e) {
      return `https://www.ag-grid.com/${this.frameworkName === 'solid' ? 'react' : this.frameworkName}-data-grid${e ? `/${e}` : ''}`
    }
  },
  XA = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'cellNavigationService')
    }
    wireBeans(e) {
      ;(this.visibleColsService = e.visibleColsService),
        (this.rowModel = e.rowModel),
        (this.rowRenderer = e.rowRenderer),
        (this.pinnedRowModel = e.pinnedRowModel),
        (this.paginationService = e.paginationService),
        (this.pageBoundsService = e.pageBoundsService)
    }
    getNextCellToFocus(e, t, i = !1) {
      return i
        ? this.getNextCellToFocusWithCtrlPressed(e, t)
        : this.getNextCellToFocusWithoutCtrlPressed(e, t)
    }
    getNextCellToFocusWithCtrlPressed(e, t) {
      const i = e === Y.UP,
        s = e === Y.DOWN,
        n = e === Y.LEFT
      let r, o
      if (i || s)
        (o = i
          ? this.pageBoundsService.getFirstRow()
          : this.pageBoundsService.getLastRow()),
          (r = t.column)
      else {
        const a = this.visibleColsService.getAllCols(),
          l = this.gos.get('enableRtl')
        ;(o = t.rowIndex), (r = n !== l ? a[0] : rt(a))
      }
      return { rowIndex: o, rowPinned: null, column: r }
    }
    getNextCellToFocusWithoutCtrlPressed(e, t) {
      let i = t,
        s = !1
      for (; !s; ) {
        switch (e) {
          case Y.UP:
            i = this.getCellAbove(i)
            break
          case Y.DOWN:
            i = this.getCellBelow(i)
            break
          case Y.RIGHT:
            this.gos.get('enableRtl')
              ? (i = this.getCellToLeft(i))
              : (i = this.getCellToRight(i))
            break
          case Y.LEFT:
            this.gos.get('enableRtl')
              ? (i = this.getCellToRight(i))
              : (i = this.getCellToLeft(i))
            break
          default:
            ;(i = null), te('unknown key for navigation ', e)
            break
        }
        i ? (s = this.isCellGoodToFocusOn(i)) : (s = !0)
      }
      return i
    }
    isCellGoodToFocusOn(e) {
      const t = e.column
      let i
      switch (e.rowPinned) {
        case 'top':
          i = this.pinnedRowModel.getPinnedTopRow(e.rowIndex)
          break
        case 'bottom':
          i = this.pinnedRowModel.getPinnedBottomRow(e.rowIndex)
          break
        default:
          i = this.rowModel.getRow(e.rowIndex)
          break
      }
      return i ? !t.isSuppressNavigable(i) : !1
    }
    getCellToLeft(e) {
      if (!e) return null
      const t = this.visibleColsService.getColBefore(e.column)
      return t
        ? { rowIndex: e.rowIndex, column: t, rowPinned: e.rowPinned }
        : null
    }
    getCellToRight(e) {
      if (!e) return null
      const t = this.visibleColsService.getColAfter(e.column)
      return t
        ? { rowIndex: e.rowIndex, column: t, rowPinned: e.rowPinned }
        : null
    }
    getRowBelow(e) {
      const t = e.rowIndex,
        i = e.rowPinned
      let s = !1
      if (this.isLastRowInContainer(e))
        switch (i) {
          case 'bottom':
            return null
          case 'top':
            return this.rowModel.isRowsToRender()
              ? {
                  rowIndex: this.pageBoundsService.getFirstRow(),
                  rowPinned: null,
                }
              : this.pinnedRowModel.isRowsToRender('bottom')
                ? { rowIndex: 0, rowPinned: 'bottom' }
                : null
          default:
            return this.pinnedRowModel.isRowsToRender('bottom')
              ? { rowIndex: 0, rowPinned: 'bottom' }
              : null
        }
      else i && (s = !0)
      const n = this.rowModel.getRow(e.rowIndex),
        r = s ? void 0 : this.getNextStickyPosition(n)
      return r || { rowIndex: t + 1, rowPinned: i }
    }
    getNextStickyPosition(e, t) {
      if (!fl(this.gos) || !e || !e.sticky) return
      const i = this.rowRenderer
        .getStickyTopRowCtrls()
        .some((a) => a.getRowNode().rowIndex === e.rowIndex)
      let s = []
      i
        ? (s = [...this.rowRenderer.getStickyTopRowCtrls()].sort(
            (a, l) => a.getRowNode().rowIndex - l.getRowNode().rowIndex,
          ))
        : (s = [...this.rowRenderer.getStickyBottomRowCtrls()].sort(
            (a, l) => l.getRowNode().rowIndex - a.getRowNode().rowIndex,
          ))
      const n = t ? -1 : 1,
        r = s.findIndex((a) => a.getRowNode().rowIndex === e.rowIndex),
        o = s[r + n]
      if (o) return { rowIndex: o.getRowNode().rowIndex, rowPinned: null }
    }
    getCellBelow(e) {
      if (!e) return null
      const t = this.getRowBelow(e)
      return t
        ? { rowIndex: t.rowIndex, column: e.column, rowPinned: t.rowPinned }
        : null
    }
    isLastRowInContainer(e) {
      const t = e.rowPinned,
        i = e.rowIndex
      return t === 'top'
        ? this.pinnedRowModel.getPinnedTopRowCount() - 1 <= i
        : t === 'bottom'
          ? this.pinnedRowModel.getPinnedBottomRowCount() - 1 <= i
          : this.pageBoundsService.getLastRow() <= i
    }
    getRowAbove(e) {
      const t = e.rowIndex,
        i = e.rowPinned,
        s = i ? t === 0 : t === this.pageBoundsService.getFirstRow()
      let n = !1
      if (s)
        return i === 'top'
          ? null
          : i
            ? this.rowModel.isRowsToRender()
              ? this.getLastBodyCell()
              : this.pinnedRowModel.isRowsToRender('top')
                ? this.getLastFloatingTopRow()
                : null
            : this.pinnedRowModel.isRowsToRender('top')
              ? this.getLastFloatingTopRow()
              : null
      i && (n = !0)
      const r = this.rowModel.getRow(e.rowIndex),
        o = n ? void 0 : this.getNextStickyPosition(r, !0)
      return o || { rowIndex: t - 1, rowPinned: i }
    }
    getCellAbove(e) {
      if (!e) return null
      const t = this.getRowAbove({
        rowIndex: e.rowIndex,
        rowPinned: e.rowPinned,
      })
      return t
        ? { rowIndex: t.rowIndex, column: e.column, rowPinned: t.rowPinned }
        : null
    }
    getLastBodyCell() {
      return { rowIndex: this.pageBoundsService.getLastRow(), rowPinned: null }
    }
    getLastFloatingTopRow() {
      return {
        rowIndex: this.pinnedRowModel.getPinnedTopRowCount() - 1,
        rowPinned: 'top',
      }
    }
    getNextTabbedCell(e, t) {
      return t
        ? this.getNextTabbedCellBackwards(e)
        : this.getNextTabbedCellForwards(e)
    }
    getNextTabbedCellForwards(e) {
      var r
      const t = this.visibleColsService.getAllCols()
      let i = e.rowIndex,
        s = e.rowPinned,
        n = this.visibleColsService.getColAfter(e.column)
      if (!n) {
        n = t[0]
        const o = this.getRowBelow(e)
        if (
          ot(o) ||
          (!o.rowPinned &&
            !(
              ((r = this.paginationService) == null
                ? void 0
                : r.isRowInPage(o)) ?? !0
            ))
        )
          return null
        ;(i = o ? o.rowIndex : null), (s = o ? o.rowPinned : null)
      }
      return { rowIndex: i, column: n, rowPinned: s }
    }
    getNextTabbedCellBackwards(e) {
      var r
      const t = this.visibleColsService.getAllCols()
      let i = e.rowIndex,
        s = e.rowPinned,
        n = this.visibleColsService.getColBefore(e.column)
      if (!n) {
        n = rt(t)
        const o = this.getRowAbove({
          rowIndex: e.rowIndex,
          rowPinned: e.rowPinned,
        })
        if (
          ot(o) ||
          (!o.rowPinned &&
            !(
              ((r = this.paginationService) == null
                ? void 0
                : r.isRowInPage(o)) ?? !0
            ))
        )
          return null
        ;(i = o ? o.rowIndex : null), (s = o ? o.rowPinned : null)
      }
      return { rowIndex: i, column: n, rowPinned: s }
    }
  },
  Ci = (e, t) => {
    for (const i in t) t[i] = e
    return t
  },
  Ig = {
    ...Ci('@ag-grid-community/core', {
      dispatchEvent: 0,
      destroy: 0,
      getGridId: 0,
      getGridOption: 0,
      isDestroyed: 0,
      setGridOption: 0,
      updateGridOptions: 0,
      getState: 0,
      setNodesSelected: 0,
      selectAll: 0,
      deselectAll: 0,
      selectAllFiltered: 0,
      deselectAllFiltered: 0,
      selectAllOnCurrentPage: 0,
      deselectAllOnCurrentPage: 0,
      getSelectedNodes: 0,
      getSelectedRows: 0,
      redrawRows: 0,
      setRowNodeExpanded: 0,
      getRowNode: 0,
      addRenderedRowListener: 0,
      getRenderedNodes: 0,
      forEachNode: 0,
      getFirstDisplayedRow: 0,
      getFirstDisplayedRowIndex: 0,
      getLastDisplayedRow: 0,
      getLastDisplayedRowIndex: 0,
      getDisplayedRowAtIndex: 0,
      getDisplayedRowCount: 0,
      getModel: 0,
      getVerticalPixelRange: 0,
      getHorizontalPixelRange: 0,
      ensureColumnVisible: 0,
      ensureIndexVisible: 0,
      ensureNodeVisible: 0,
      getFocusedCell: 0,
      clearFocusedCell: 0,
      setFocusedCell: 0,
      tabToNextCell: 0,
      tabToPreviousCell: 0,
      setFocusedHeader: 0,
      addEventListener: 0,
      addGlobalListener: 0,
      removeEventListener: 0,
      removeGlobalListener: 0,
      expireValueCache: 0,
      getValue: 0,
      getCellValue: 0,
      showColumnMenuAfterButtonClick: 0,
      showColumnMenuAfterMouseClick: 0,
      showColumnMenu: 0,
      hidePopupMenu: 0,
      onSortChanged: 0,
      getPinnedTopRowCount: 0,
      getPinnedBottomRowCount: 0,
      getPinnedTopRow: 0,
      getPinnedBottomRow: 0,
      showLoadingOverlay: 0,
      showNoRowsOverlay: 0,
      hideOverlay: 0,
      setGridAriaProperty: 0,
      refreshCells: 0,
      flashCells: 0,
      refreshHeader: 0,
      isAnimationFrameQueueEmpty: 0,
      flushAllAnimationFrames: 0,
      getSizesForCurrentTheme: 0,
      getCellRendererInstances: 0,
      addRowDropZone: 0,
      removeRowDropZone: 0,
      getRowDropZoneParams: 0,
      getColumnDef: 0,
      getColumnDefs: 0,
      sizeColumnsToFit: 0,
      setColumnGroupOpened: 0,
      getColumnGroup: 0,
      getProvidedColumnGroup: 0,
      getDisplayNameForColumn: 0,
      getDisplayNameForColumnGroup: 0,
      getColumn: 0,
      getColumns: 0,
      applyColumnState: 0,
      getColumnState: 0,
      resetColumnState: 0,
      getColumnGroupState: 0,
      setColumnGroupState: 0,
      resetColumnGroupState: 0,
      isPinning: 0,
      isPinningLeft: 0,
      isPinningRight: 0,
      getDisplayedColAfter: 0,
      getDisplayedColBefore: 0,
      setColumnVisible: 0,
      setColumnsVisible: 0,
      setColumnPinned: 0,
      setColumnsPinned: 0,
      getAllGridColumns: 0,
      getDisplayedLeftColumns: 0,
      getDisplayedCenterColumns: 0,
      getDisplayedRightColumns: 0,
      getAllDisplayedColumns: 0,
      getAllDisplayedVirtualColumns: 0,
      moveColumn: 0,
      moveColumnByIndex: 0,
      moveColumns: 0,
      setColumnWidth: 0,
      setColumnWidths: 0,
      getLeftDisplayedColumnGroups: 0,
      getCenterDisplayedColumnGroups: 0,
      getRightDisplayedColumnGroups: 0,
      getAllDisplayedColumnGroups: 0,
      autoSizeColumn: 0,
      autoSizeColumns: 0,
      autoSizeAllColumns: 0,
      undoCellEditing: 0,
      redoCellEditing: 0,
      getCellEditorInstances: 0,
      getEditingCells: 0,
      stopEditing: 0,
      startEditingCell: 0,
      getCurrentUndoSize: 0,
      getCurrentRedoSize: 0,
      isAnyFilterPresent: 0,
      onFilterChanged: 0,
      isColumnFilterPresent: 0,
      getFilterInstance: 0,
      getColumnFilterInstance: 0,
      destroyFilter: 0,
      setFilterModel: 0,
      getFilterModel: 0,
      getColumnFilterModel: 0,
      setColumnFilterModel: 0,
      showColumnFilter: 0,
      isQuickFilterPresent: 0,
      getQuickFilter: 0,
      resetQuickFilter: 0,
      paginationIsLastPageFound: 0,
      paginationGetPageSize: 0,
      paginationGetCurrentPage: 0,
      paginationGetTotalPages: 0,
      paginationGetRowCount: 0,
      paginationGoToNextPage: 0,
      paginationGoToPreviousPage: 0,
      paginationGoToFirstPage: 0,
      paginationGoToLastPage: 0,
      paginationGoToPage: 0,
      expandAll: 0,
      collapseAll: 0,
      onRowHeightChanged: 0,
      setRowCount: 0,
      getCacheBlockState: 0,
      isLastRowIndexKnown: 0,
    }),
    ...Ci('@ag-grid-community/client-side-row-model', {
      onGroupExpandedOrCollapsed: 0,
      refreshClientSideRowModel: 0,
      isRowDataEmpty: 0,
      forEachLeafNode: 0,
      forEachNodeAfterFilter: 0,
      forEachNodeAfterFilterAndSort: 0,
      resetRowHeights: 0,
      applyTransaction: 0,
      applyTransactionAsync: 0,
      flushAsyncTransactions: 0,
      getBestCostNodeSelection: 0,
    }),
    ...Ci('@ag-grid-community/csv-export', {
      getDataAsCsv: 0,
      exportDataAsCsv: 0,
    }),
    ...Ci('@ag-grid-community/infinite-row-model', {
      refreshInfiniteCache: 0,
      purgeInfiniteCache: 0,
      getInfiniteRowCount: 0,
    }),
    ...Ci('@ag-grid-enterprise/advanced-filter', {
      getAdvancedFilterModel: 0,
      setAdvancedFilterModel: 0,
      showAdvancedFilterBuilder: 0,
      hideAdvancedFilterBuilder: 0,
    }),
    ...Ci('@ag-grid-enterprise/charts', {
      getChartModels: 0,
      getChartRef: 0,
      getChartImageDataURL: 0,
      downloadChart: 0,
      openChartToolPanel: 0,
      closeChartToolPanel: 0,
      createRangeChart: 0,
      createPivotChart: 0,
      createCrossFilterChart: 0,
      updateChart: 0,
      restoreChart: 0,
    }),
    ...Ci('@ag-grid-enterprise/clipboard', {
      copyToClipboard: 0,
      cutToClipboard: 0,
      copySelectedRowsToClipboard: 0,
      copySelectedRangeToClipboard: 0,
      copySelectedRangeDown: 0,
      pasteFromClipboard: 0,
    }),
    ...Ci('@ag-grid-enterprise/excel-export', {
      getDataAsExcel: 0,
      exportDataAsExcel: 0,
      getSheetDataForExcel: 0,
      getMultipleSheetsAsExcel: 0,
      exportMultipleSheetsAsExcel: 0,
    }),
    ...Ci('@ag-grid-enterprise/master-detail', {
      addDetailGridInfo: 0,
      removeDetailGridInfo: 0,
      getDetailGridInfo: 0,
      forEachDetailGridInfo: 0,
    }),
    ...Ci('@ag-grid-enterprise/menu', {
      showContextMenu: 0,
      showColumnChooser: 0,
      hideColumnChooser: 0,
    }),
    ...Ci('@ag-grid-enterprise/range-selection', {
      getCellRanges: 0,
      addCellRange: 0,
      clearRangeSelection: 0,
      clearCellSelection: 0,
    }),
    ...Ci('@ag-grid-enterprise/row-grouping', {
      addAggFunc: 0,
      addAggFuncs: 0,
      clearAggFuncs: 0,
      setColumnAggFunc: 0,
      isPivotMode: 0,
      getPivotResultColumn: 0,
      setValueColumns: 0,
      getValueColumns: 0,
      removeValueColumn: 0,
      removeValueColumns: 0,
      addValueColumn: 0,
      addValueColumns: 0,
      setRowGroupColumns: 0,
      removeRowGroupColumn: 0,
      removeRowGroupColumns: 0,
      addRowGroupColumn: 0,
      addRowGroupColumns: 0,
      getRowGroupColumns: 0,
      moveRowGroupColumn: 0,
      setPivotColumns: 0,
      removePivotColumn: 0,
      removePivotColumns: 0,
      addPivotColumn: 0,
      addPivotColumns: 0,
      getPivotColumns: 0,
      setPivotResultColumns: 0,
      getPivotResultColumns: 0,
    }),
    ...Ci('@ag-grid-enterprise/server-side-row-model', {
      getServerSideSelectionState: 0,
      setServerSideSelectionState: 0,
      applyServerSideTransaction: 0,
      applyServerSideTransactionAsync: 0,
      applyServerSideRowData: 0,
      retryServerSideLoads: 0,
      flushServerSideAsyncTransactions: 0,
      refreshServerSide: 0,
      getServerSideGroupLevelState: 0,
    }),
    ...Ci('@ag-grid-enterprise/side-bar', {
      isSideBarVisible: 0,
      setSideBarVisible: 0,
      setSideBarPosition: 0,
      openToolPanel: 0,
      closeToolPanel: 0,
      getOpenedToolPanel: 0,
      refreshToolPanel: 0,
      isToolPanelShowing: 0,
      getToolPanelInstance: 0,
      getSideBar: 0,
    }),
    ...Ci('@ag-grid-enterprise/status-bar', { getStatusPanel: 0 }),
  },
  Cc = {
    isDestroyed: () => !0,
    destroy() {},
    preConstruct() {},
    postConstruct() {},
    preWireBeans() {},
    wireBeans() {},
  },
  JA = (e, t) => e.eventService.dispatchEvent(t),
  qv = class {}
Reflect.defineProperty(qv, 'name', { value: 'GridApi' })
var ZA = class extends X {
  constructor() {
    super(),
      (this.beanName = 'apiFunctionService'),
      (this.api = new qv()),
      (this.fns = { ...Cc, dispatchEvent: JA }),
      (this.beans = null),
      (this.preDestroyLink = '')
    const { api: e } = this
    for (const t in Ig) e[t] = this.makeApi(t)[t]
  }
  wireBeans(e) {
    this.beans = e
  }
  postConstruct() {
    this.preDestroyLink = this.frameworkOverrides.getDocLink(
      'grid-lifecycle/#grid-pre-destroyed',
    )
  }
  addFunction(e, t) {
    var n
    const { fns: i, beans: s } = this
    i !== Cc &&
      (i[e] =
        ((n = s == null ? void 0 : s.validationService) == null
          ? void 0
          : n.validateApiFunction(e, t)) ?? t)
  }
  makeApi(e) {
    return {
      [e]: (...t) => {
        const {
          beans: i,
          fns: { [e]: s },
        } = this
        return s ? s(i, ...t) : this.apiNotFound(e)
      },
    }
  }
  apiNotFound(e) {
    const { beans: t, gos: i, preDestroyLink: s } = this
    if (!t)
      te(`Grid API function ${e}() cannot be called as the grid has been destroyed.
Either clear local references to the grid api, when it is destroyed, or check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.
To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${s}`)
    else {
      const n = Ig[e]
      i.assertModuleRegistered(n, `api.${e}`) &&
        te(`API function '${e}' not registered to module '${n}'`)
    }
  }
  destroy() {
    super.destroy(), (this.fns = Cc), (this.beans = null)
  }
}
function eO(e) {
  return { beanName: 'gridApi', bean: e.getBean('apiFunctionService').api }
}
var tO = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'columnDefFactory')
    }
    buildColumnDefs(e, t, i) {
      const s = [],
        n = {}
      return (
        e.forEach((r) => {
          const o = this.createDefFromColumn(r, t, i)
          let a = !0,
            l = o,
            c = r.getOriginalParent(),
            u = null
          for (; c; ) {
            let h = null
            if (c.isPadding()) {
              c = c.getOriginalParent()
              continue
            }
            const g = n[c.getGroupId()]
            if (g) {
              g.children.push(l), (a = !1)
              break
            }
            if (
              ((h = this.createDefFromGroup(c)),
              h &&
                ((h.children = [l]),
                (n[h.groupId] = h),
                (l = h),
                (c = c.getOriginalParent())),
              c != null && u === c)
            ) {
              a = !1
              break
            }
            u = c
          }
          a && s.push(l)
        }),
        s
      )
    }
    createDefFromGroup(e) {
      const t = Kc(e.getColGroupDef(), ['children'])
      return t && (t.groupId = e.getGroupId()), t
    }
    createDefFromColumn(e, t, i) {
      const s = Kc(e.getColDef())
      return (
        (s.colId = e.getColId()),
        (s.width = e.getActualWidth()),
        (s.rowGroup = e.isRowGroupActive()),
        (s.rowGroupIndex = e.isRowGroupActive() ? t.indexOf(e) : null),
        (s.pivot = e.isPivotActive()),
        (s.pivotIndex = e.isPivotActive() ? i.indexOf(e) : null),
        (s.aggFunc = e.isValueActive() ? e.getAggFunc() : null),
        (s.hide = e.isVisible() ? void 0 : !0),
        (s.pinned = e.isPinned() ? e.getPinned() : null),
        (s.sort = e.getSort() ? e.getSort() : null),
        (s.sortIndex = e.getSortIndex() != null ? e.getSortIndex() : null),
        s
      )
    }
  },
  iO = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'columnEventDispatcher')
    }
    visibleCols(e) {
      this.eventService.dispatchEvent({
        type: 'displayedColumnsChanged',
        source: e,
      })
    }
    gridColumns() {
      this.eventService.dispatchEvent({ type: 'gridColumnsChanged' })
    }
    headerHeight(e) {
      this.eventService.dispatchEvent({
        type: 'columnHeaderHeightChanged',
        column: e,
        columns: [e],
        source: 'autosizeColumnHeaderHeight',
      })
    }
    groupHeaderHeight(e) {
      this.eventService.dispatchEvent({
        type: 'columnGroupHeaderHeightChanged',
        columnGroup: e,
        source: 'autosizeColumnGroupHeaderHeight',
      })
    }
    groupOpened(e) {
      this.eventService.dispatchEvent({
        type: 'columnGroupOpened',
        columnGroup: e.length === 1 ? e[0] : void 0,
        columnGroups: e,
      })
    }
    rowGroupChanged(e, t) {
      this.eventService.dispatchEvent({
        type: 'columnRowGroupChanged',
        columns: e,
        column: e.length === 1 ? e[0] : null,
        source: t,
      })
    }
    genericColumnEvent(e, t, i) {
      this.eventService.dispatchEvent({
        type: e,
        columns: t,
        column: t.length === 1 ? t[0] : null,
        source: i,
      })
    }
    pivotModeChanged() {
      this.eventService.dispatchEvent({ type: 'columnPivotModeChanged' })
    }
    virtualColumnsChanged(e) {
      this.eventService.dispatchEvent({
        type: 'virtualColumnsChanged',
        afterScroll: e,
      })
    }
    newColumnsLoaded(e) {
      this.eventService.dispatchEvent({ type: 'newColumnsLoaded', source: e })
    }
    everythingChanged(e) {
      this.eventService.dispatchEvent({
        type: 'columnEverythingChanged',
        source: e,
      })
    }
    columnMoved(e) {
      const { movedColumns: t, source: i, toIndex: s, finished: n } = e
      this.eventService.dispatchEvent({
        type: 'columnMoved',
        columns: t,
        column: t && t.length === 1 ? t[0] : null,
        toIndex: s,
        finished: n,
        source: i,
      })
    }
    columnPinned(e, t) {
      if (!e.length) return
      const i = e.length === 1 ? e[0] : null,
        s = this.getCommonValue(e, (n) => n.getPinned())
      this.eventService.dispatchEvent({
        type: 'columnPinned',
        pinned: s ?? null,
        columns: e,
        column: i,
        source: t,
      })
    }
    columnVisible(e, t) {
      if (!e.length) return
      const i = e.length === 1 ? e[0] : null,
        s = this.getCommonValue(e, (n) => n.isVisible())
      this.eventService.dispatchEvent({
        type: 'columnVisible',
        visible: s,
        columns: e,
        column: i,
        source: t,
      })
    }
    getCommonValue(e, t) {
      if (!e || e.length == 0) return
      const i = t(e[0])
      for (let s = 1; s < e.length; s++) if (i !== t(e[s])) return
      return i
    }
    columnChanged(e, t, i) {
      this.eventService.dispatchEvent({
        type: e,
        columns: t,
        column: t && t.length == 1 ? t[0] : null,
        source: i,
      })
    }
    columnResized(e, t, i, s = null) {
      e &&
        e.length &&
        this.eventService.dispatchEvent({
          type: 'columnResized',
          columns: e,
          column: e.length === 1 ? e[0] : null,
          flexColumns: s,
          finished: t,
          source: i,
        })
    }
  },
  sO = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'columnGetStateService')
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.funcColsService = e.funcColsService)
    }
    getColumnState() {
      const e = this.columnModel.getColDefCols()
      if (ot(e) || !this.columnModel.isAlive()) return []
      const i = this.columnModel
        .getAllCols()
        .map((s) => this.createStateItemFromColumn(s))
      return this.orderColumnStateList(i), i
    }
    createStateItemFromColumn(e) {
      const t = this.funcColsService.getRowGroupColumns(),
        i = this.funcColsService.getPivotColumns(),
        s = e.isRowGroupActive() ? t.indexOf(e) : null,
        n = e.isPivotActive() ? i.indexOf(e) : null,
        r = e.isValueActive() ? e.getAggFunc() : null,
        o = e.getSort() != null ? e.getSort() : null,
        a = e.getSortIndex() != null ? e.getSortIndex() : null,
        l = e.getFlex() != null && e.getFlex() > 0 ? e.getFlex() : null
      return {
        colId: e.getColId(),
        width: e.getActualWidth(),
        hide: !e.isVisible(),
        pinned: e.getPinned(),
        sort: o,
        sortIndex: a,
        aggFunc: r,
        rowGroup: e.isRowGroupActive(),
        rowGroupIndex: s,
        pivot: e.isPivotActive(),
        pivotIndex: n,
        flex: l,
      }
    }
    orderColumnStateList(e) {
      const t = this.columnModel.getCols(),
        i = new Map(t.map((s, n) => [s.getColId(), n]))
      e.sort((s, n) => {
        const r = i.has(s.colId) ? i.get(s.colId) : -1,
          o = i.has(n.colId) ? i.get(n.colId) : -1
        return r - o
      })
    }
  },
  nO = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'columnGroupStateService')
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.columnAnimationService = e.columnAnimationService),
        (this.eventDispatcher = e.columnEventDispatcher),
        (this.visibleColsService = e.visibleColsService)
    }
    getColumnGroupState() {
      const e = [],
        t = this.columnModel.getColTree()
      return (
        _s(null, t, (i) => {
          wi(i) && e.push({ groupId: i.getGroupId(), open: i.isExpanded() })
        }),
        e
      )
    }
    resetColumnGroupState(e) {
      const t = this.columnModel.getColDefColTree()
      if (!t) return
      const i = []
      _s(null, t, (s) => {
        if (wi(s)) {
          const n = s.getColGroupDef(),
            r = { groupId: s.getGroupId(), open: n ? n.openByDefault : void 0 }
          i.push(r)
        }
      }),
        this.setColumnGroupState(i, e)
    }
    setColumnGroupState(e, t) {
      if (!this.columnModel.getColTree()) return
      this.columnAnimationService.start()
      const s = []
      e.forEach((n) => {
        const r = n.groupId,
          o = n.open,
          a = this.columnModel.getProvidedColGroup(r)
        a && a.isExpanded() !== o && (a.setExpanded(o), s.push(a))
      }),
        this.visibleColsService.refresh(t, !0),
        s.length && this.eventDispatcher.groupOpened(s),
        this.columnAnimationService.finish()
    }
  },
  rO = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'columnViewportService'),
        (this.colsWithinViewport = []),
        (this.headerColsWithinViewport = []),
        (this.colsWithinViewportHash = ''),
        (this.rowsOfHeadersToRenderLeft = {}),
        (this.rowsOfHeadersToRenderRight = {}),
        (this.rowsOfHeadersToRenderCenter = {})
    }
    wireBeans(e) {
      ;(this.visibleColsService = e.visibleColsService),
        (this.columnModel = e.columnModel),
        (this.eventDispatcher = e.columnEventDispatcher)
    }
    postConstruct() {
      this.suppressColumnVirtualisation = this.gos.get(
        'suppressColumnVirtualisation',
      )
    }
    setScrollPosition(e, t, i = !1) {
      const s = this.visibleColsService.isBodyWidthDirty()
      if (!(e === this.scrollWidth && t === this.scrollPosition && !s)) {
        if (
          ((this.scrollWidth = e),
          (this.scrollPosition = t),
          this.visibleColsService.setBodyWidthDirty(),
          this.gos.get('enableRtl'))
        ) {
          const r = this.visibleColsService.getBodyContainerWidth()
          ;(this.viewportLeft = r - this.scrollPosition - this.scrollWidth),
            (this.viewportRight = r - this.scrollPosition)
        } else
          (this.viewportLeft = this.scrollPosition),
            (this.viewportRight = this.scrollWidth + this.scrollPosition)
        this.columnModel.isReady() && this.checkViewportColumns(i)
      }
    }
    getHeadersToRender(e, t) {
      let i
      switch (e) {
        case 'left':
          i = this.rowsOfHeadersToRenderLeft[t]
          break
        case 'right':
          i = this.rowsOfHeadersToRenderRight[t]
          break
        default:
          i = this.rowsOfHeadersToRenderCenter[t]
          break
      }
      return i || []
    }
    extractViewportColumns() {
      const e = this.visibleColsService.getCenterCols()
      this.isColumnVirtualisationSuppressed()
        ? ((this.colsWithinViewport = e), (this.headerColsWithinViewport = e))
        : ((this.colsWithinViewport = e.filter(
            this.isColumnInRowViewport.bind(this),
          )),
          (this.headerColsWithinViewport = e.filter(
            this.isColumnInHeaderViewport.bind(this),
          )))
    }
    isColumnVirtualisationSuppressed() {
      return this.suppressColumnVirtualisation || this.viewportRight === 0
    }
    clear() {
      ;(this.rowsOfHeadersToRenderLeft = {}),
        (this.rowsOfHeadersToRenderRight = {}),
        (this.rowsOfHeadersToRenderCenter = {}),
        (this.colsWithinViewportHash = '')
    }
    isColumnInHeaderViewport(e) {
      return e.isAutoHeaderHeight() || this.isAnyParentAutoHeaderHeight(e)
        ? !0
        : this.isColumnInRowViewport(e)
    }
    isAnyParentAutoHeaderHeight(e) {
      for (; e; ) {
        if (e.isAutoHeaderHeight()) return !0
        e = e.getParent()
      }
      return !1
    }
    isColumnInRowViewport(e) {
      if (e.isAutoHeight()) return !0
      const t = e.getLeft() || 0,
        i = t + e.getActualWidth(),
        s = this.viewportLeft - 200,
        n = this.viewportRight + 200,
        r = t < s && i < s,
        o = t > n && i > n
      return !r && !o
    }
    getViewportColumns() {
      const e = this.visibleColsService.getLeftCols(),
        t = this.visibleColsService.getRightCols()
      return this.colsWithinViewport.concat(e).concat(t)
    }
    getColsWithinViewport(e) {
      if (!this.columnModel.isColSpanActive()) return this.colsWithinViewport
      const t = (n) => {
          const r = n.getLeft()
          return ue(r) && r > this.viewportLeft
        },
        i = this.isColumnVirtualisationSuppressed()
          ? void 0
          : this.isColumnInRowViewport.bind(this),
        s = this.visibleColsService.getColsCenter()
      return this.visibleColsService.getColsForRow(e, s, i, t)
    }
    checkViewportColumns(e = !1) {
      this.extractViewport() && this.eventDispatcher.virtualColumnsChanged(e)
    }
    calculateHeaderRows() {
      ;(this.rowsOfHeadersToRenderLeft = {}),
        (this.rowsOfHeadersToRenderRight = {}),
        (this.rowsOfHeadersToRenderCenter = {})
      const e = {},
        t = this.visibleColsService.getLeftCols(),
        i = this.visibleColsService.getRightCols()
      this.headerColsWithinViewport
        .concat(t)
        .concat(i)
        .forEach((r) => (e[r.getId()] = !0))
      const n = (r, o, a) => {
        let l = !1
        for (let c = 0; c < r.length; c++) {
          const u = r[c]
          let h = !1
          if (cn(u)) h = e[u.getId()] === !0
          else {
            const f = u.getDisplayedChildren()
            f && (h = n(f, o, a + 1))
          }
          h && ((l = !0), o[a] || (o[a] = []), o[a].push(u))
        }
        return l
      }
      n(
        this.visibleColsService.getTreeLeft(),
        this.rowsOfHeadersToRenderLeft,
        0,
      ),
        n(
          this.visibleColsService.getTreeRight(),
          this.rowsOfHeadersToRenderRight,
          0,
        ),
        n(
          this.visibleColsService.getTreeCenter(),
          this.rowsOfHeadersToRenderCenter,
          0,
        )
    }
    extractViewport() {
      const e = (s) => `${s.getId()}-${s.getPinned() || 'normal'}`
      this.extractViewportColumns()
      const t = this.getViewportColumns().map(e).join('#'),
        i = this.colsWithinViewportHash !== t
      return (
        i && ((this.colsWithinViewportHash = t), this.calculateHeaderRows()), i
      )
    }
  },
  oO = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'agComponentUtils')
    }
    wireBeans(e) {
      this.componentMetadataProvider = e.componentMetadataProvider
    }
    adaptFunction(e, t) {
      const i = this.componentMetadataProvider.retrieve(e)
      return i && i.functionAdapter ? i.functionAdapter(t) : null
    }
    adaptCellRendererFunction(e) {
      class t {
        refresh() {
          return !1
        }
        getGui() {
          return this.eGui
        }
        init(s) {
          const n = e(s),
            r = typeof n
          if (r === 'string' || r === 'number' || r === 'boolean') {
            this.eGui = bo('<span>' + n + '</span>')
            return
          }
          if (n == null) {
            this.eGui = bo('<span></span>')
            return
          }
          this.eGui = n
        }
      }
      return t
    }
    doesImplementIComponent(e) {
      return e ? e.prototype && 'getGui' in e.prototype : !1
    }
  },
  aO = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'componentMetadataProvider')
    }
    wireBeans(e) {
      this.agComponentUtils = e.agComponentUtils
    }
    postConstruct() {
      this.componentMetaData = {
        dateComponent: {
          mandatoryMethodList: ['getDate', 'setDate'],
          optionalMethodList: [
            'afterGuiAttached',
            'setInputPlaceholder',
            'setInputAriaLabel',
            'setDisabled',
            'onParamsUpdated',
            'refresh',
          ],
        },
        detailCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ['refresh'],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(
            this.agComponentUtils,
          ),
        },
        dragAndDropImageComponent: {
          mandatoryMethodList: ['setIcon', 'setLabel'],
          optionalMethodList: [],
        },
        headerComponent: {
          mandatoryMethodList: [],
          optionalMethodList: ['refresh'],
        },
        headerGroupComponent: {
          mandatoryMethodList: [],
          optionalMethodList: [],
        },
        loadingCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: [],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(
            this.agComponentUtils,
          ),
        },
        loadingOverlayComponent: {
          mandatoryMethodList: [],
          optionalMethodList: ['refresh'],
        },
        noRowsOverlayComponent: {
          mandatoryMethodList: [],
          optionalMethodList: ['refresh'],
        },
        floatingFilterComponent: {
          mandatoryMethodList: ['onParentModelChanged'],
          optionalMethodList: [
            'afterGuiAttached',
            'onParamsUpdated',
            'refresh',
          ],
        },
        cellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ['refresh', 'afterGuiAttached'],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(
            this.agComponentUtils,
          ),
        },
        cellEditor: {
          mandatoryMethodList: ['getValue'],
          optionalMethodList: [
            'isPopup',
            'isCancelBeforeStart',
            'isCancelAfterEnd',
            'getPopupPosition',
            'focusIn',
            'focusOut',
            'afterGuiAttached',
            'refresh',
          ],
        },
        innerRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ['afterGuiAttached'],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(
            this.agComponentUtils,
          ),
        },
        fullWidthCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ['refresh', 'afterGuiAttached'],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(
            this.agComponentUtils,
          ),
        },
        groupRowRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ['afterGuiAttached'],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(
            this.agComponentUtils,
          ),
        },
        filter: {
          mandatoryMethodList: [
            'isFilterActive',
            'doesFilterPass',
            'getModel',
            'setModel',
          ],
          optionalMethodList: [
            'afterGuiAttached',
            'afterGuiDetached',
            'onNewRowsLoaded',
            'getModelAsString',
            'onFloatingFilterChanged',
            'onAnyFilterChanged',
            'refresh',
          ],
        },
        statusPanel: {
          mandatoryMethodList: [],
          optionalMethodList: ['refresh'],
        },
        toolPanel: {
          mandatoryMethodList: [],
          optionalMethodList: ['refresh', 'getState'],
        },
        tooltipComponent: { mandatoryMethodList: [], optionalMethodList: [] },
        menuItem: {
          mandatoryMethodList: [],
          optionalMethodList: [
            'setActive',
            'select',
            'setExpanded',
            'configureDefaults',
          ],
        },
      }
    }
    retrieve(e) {
      return this.componentMetaData[e]
    }
  },
  lO = [
    'rowPositionUtils',
    'cellPositionUtils',
    'headerPositionUtils',
    'paginationAutoPageSizeService',
    'apiFunctionService',
    'gridApi',
    'userComponentRegistry',
    'agComponentUtils',
    'componentMetadataProvider',
    'resizeObserverService',
    'userComponentFactory',
    'rowContainerHeightService',
    'horizontalResizeService',
    'localeService',
    'validationService',
    'pinnedRowModel',
    'dragService',
    'visibleColsService',
    'eventService',
    'gos',
    'popupService',
    'selectionService',
    'columnFilterService',
    'quickFilterService',
    'filterManager',
    'columnModel',
    'headerNavigationService',
    'pageBoundsService',
    'paginationService',
    'pageBoundsListener',
    'rowRenderer',
    'expressionService',
    'columnFactory',
    'alignedGridsService',
    'navigationService',
    'valueCache',
    'valueService',
    'loggerFactory',
    'autoWidthCalculator',
    'filterMenuFactory',
    'dragAndDropService',
    'focusService',
    'mouseEventService',
    'environment',
    'cellNavigationService',
    'stylingService',
    'scrollVisibleService',
    'sortController',
    'columnHoverService',
    'columnAnimationService',
    'selectableService',
    'autoColService',
    'controlsColService',
    'changeDetectionService',
    'animationFrameService',
    'undoRedoService',
    'columnDefFactory',
    'rowCssClassCalculator',
    'rowNodeBlockLoader',
    'rowNodeSorter',
    'ctrlsService',
    'pinnedWidthService',
    'rowNodeEventThrottle',
    'ctrlsFactory',
    'dataTypeService',
    'syncService',
    'overlayService',
    'stateService',
    'expansionService',
    'apiEventService',
    'ariaAnnouncementService',
    'menuService',
    'columnApplyStateService',
    'columnEventDispatcher',
    'columnMoveService',
    'columnAutosizeService',
    'columnGetStateService',
    'columnGroupStateService',
    'columnSizeService',
    'funcColsService',
    'columnNameService',
    'columnViewportService',
    'pivotResultColsService',
    'showRowGroupColsService',
  ],
  Tg = Object.fromEntries(lO.map((e, t) => [e, t]))
function cO(e, t) {
  const i = (e.beanName ? Tg[e.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER,
    s = (t.beanName ? Tg[t.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER
  return i - s
}
function uO(e, t) {
  return (e == null ? void 0 : e.beanName) === 'gridDestroyService' ? -1 : 0
}
var dO = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'ctrlsFactory'),
        (this.registry = {})
    }
    register(e) {
      this.registry[e.name] = e.classImp
    }
    getInstance(e, ...t) {
      const i = this.registry[e]
      if (i != null) return new i(...t)
    }
  },
  hO = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'ctrlsService'),
        (this.params = {
          gridCtrl: void 0,
          gridBodyCtrl: void 0,
          center: void 0,
          left: void 0,
          right: void 0,
          bottomCenter: void 0,
          bottomLeft: void 0,
          bottomRight: void 0,
          topCenter: void 0,
          topLeft: void 0,
          topRight: void 0,
          stickyTopCenter: void 0,
          stickyTopLeft: void 0,
          stickyTopRight: void 0,
          stickyBottomCenter: void 0,
          stickyBottomLeft: void 0,
          stickyBottomRight: void 0,
          fakeHScrollComp: void 0,
          fakeVScrollComp: void 0,
          gridHeaderCtrl: void 0,
          centerHeader: void 0,
          leftHeader: void 0,
          rightHeader: void 0,
        }),
        (this.ready = !1),
        (this.readyCallbacks = []),
        (this.runReadyCallbacksAsync = !1)
    }
    wireBeans(e) {
      var t, i
      this.runReadyCallbacksAsync =
        ((i = (t = e.frameworkOverrides).runWhenReadyAsync) == null
          ? void 0
          : i.call(t)) ?? !1
    }
    postConstruct() {
      this.addEventListener(
        'ready',
        () => {
          this.updateReady(),
            this.ready &&
              (this.readyCallbacks.forEach((e) => e(this.params)),
              (this.readyCallbacks.length = 0))
        },
        this.runReadyCallbacksAsync,
      )
    }
    updateReady() {
      this.ready = Object.values(this.params).every(
        (e) => (e == null ? void 0 : e.isAlive()) ?? !1,
      )
    }
    whenReady(e, t) {
      this.ready ? t(this.params) : this.readyCallbacks.push(t),
        e.addDestroyFunc(() => {
          const i = this.readyCallbacks.indexOf(t)
          i >= 0 && this.readyCallbacks.splice(i, 1)
        })
    }
    register(e, t) {
      ;(this.params[e] = t),
        this.updateReady(),
        this.ready && this.dispatchLocalEvent({ type: 'ready' }),
        t.addDestroyFunc(() => {
          this.updateReady()
        })
    }
    get(e) {
      return this.params[e]
    }
    getGridBodyCtrl() {
      return this.params.gridBodyCtrl
    }
    getHeaderRowContainerCtrls() {
      const { leftHeader: e, centerHeader: t, rightHeader: i } = this.params
      return [e, i, t]
    }
    getHeaderRowContainerCtrl(e) {
      const t = this.params
      switch (e) {
        case 'left':
          return t.leftHeader
        case 'right':
          return t.rightHeader
        default:
          return t.centerHeader
      }
    }
  },
  gO = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'cellPositionUtils')
    }
    createId(e) {
      const { rowIndex: t, rowPinned: i, column: s } = e
      return this.createIdFromValues({ rowIndex: t, column: s, rowPinned: i })
    }
    createIdFromValues(e) {
      const { rowIndex: t, rowPinned: i, column: s } = e
      return `${t}.${i ?? 'null'}.${s.getId()}`
    }
    equals(e, t) {
      const i = e.column === t.column,
        s = e.rowPinned === t.rowPinned,
        n = e.rowIndex === t.rowIndex
      return i && s && n
    }
  },
  fO = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'rowNodeEventThrottle'),
        (this.events = [])
    }
    wireBeans(e) {
      ;(this.animationFrameService = e.animationFrameService),
        (this.rowModel = e.rowModel)
    }
    postConstruct() {
      Pt(this.gos) && (this.clientSideRowModel = this.rowModel)
    }
    dispatchExpanded(e, t) {
      if (this.clientSideRowModel == null) {
        this.eventService.dispatchEvent(e)
        return
      }
      this.events.push(e)
      const i = () => {
        this.clientSideRowModel && this.clientSideRowModel.onRowGroupOpened(),
          this.events.forEach((s) => this.eventService.dispatchEvent(s)),
          (this.events = [])
      }
      t
        ? i()
        : (this.dispatchExpandedDebounced == null &&
            (this.dispatchExpandedDebounced =
              this.animationFrameService.debounce(i)),
          this.dispatchExpandedDebounced())
    }
  },
  pO = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'rowPositionUtils')
    }
    wireBeans(e) {
      ;(this.rowModel = e.rowModel),
        (this.pinnedRowModel = e.pinnedRowModel),
        (this.pageBoundsService = e.pageBoundsService)
    }
    getFirstRow() {
      let e = 0,
        t
      return (
        this.pinnedRowModel.getPinnedTopRowCount()
          ? (t = 'top')
          : this.rowModel.getRowCount()
            ? ((t = null), (e = this.pageBoundsService.getFirstRow()))
            : this.pinnedRowModel.getPinnedBottomRowCount() && (t = 'bottom'),
        t === void 0 ? null : { rowIndex: e, rowPinned: t }
      )
    }
    getLastRow() {
      let e,
        t = null
      const i = this.pinnedRowModel.getPinnedBottomRowCount(),
        s = this.pinnedRowModel.getPinnedTopRowCount()
      return (
        i
          ? ((t = 'bottom'), (e = i - 1))
          : this.rowModel.getRowCount()
            ? ((t = null), (e = this.pageBoundsService.getLastRow()))
            : s && ((t = 'top'), (e = s - 1)),
        e === void 0 ? null : { rowIndex: e, rowPinned: t }
      )
    }
    getRowNode(e) {
      switch (e.rowPinned) {
        case 'top':
          return this.pinnedRowModel.getPinnedTopRow(e.rowIndex)
        case 'bottom':
          return this.pinnedRowModel.getPinnedBottomRow(e.rowIndex)
        default:
          return this.rowModel.getRow(e.rowIndex)
      }
    }
    sameRow(e, t) {
      return !e && !t
        ? !0
        : (e && !t) || (!e && t)
          ? !1
          : e.rowIndex === t.rowIndex && e.rowPinned == t.rowPinned
    }
    before(e, t) {
      switch (e.rowPinned) {
        case 'top':
          if (t.rowPinned !== 'top') return !0
          break
        case 'bottom':
          if (t.rowPinned !== 'bottom') return !1
          break
        default:
          if (ue(t.rowPinned)) return t.rowPinned !== 'top'
          break
      }
      return e.rowIndex < t.rowIndex
    }
  },
  Ag = {
    cssName: '--ag-row-height',
    changeKey: 'rowHeightChanged',
    defaultValue: 42,
  },
  Og = {
    cssName: '--ag-header-height',
    changeKey: 'headerHeightChanged',
    defaultValue: 48,
  },
  Lg = {
    cssName: '--ag-list-item-height',
    changeKey: 'listItemHeightChanged',
    defaultValue: 24,
  },
  mO = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'environment'),
        (this.sizeEls = new Map()),
        (this.lastKnownValues = new Map()),
        (this.ancestorThemeClasses = []),
        (this.sizesMeasured = !1),
        (this.gridTheme = null)
    }
    wireBeans(e) {
      ;(this.resizeObserverService = e.resizeObserverService),
        (this.eGridDiv = e.eGridDiv)
    }
    postConstruct() {
      this.addManagedPropertyListener('theme', () =>
        this.handleThemeGridOptionChange(),
      ),
        this.handleThemeGridOptionChange(),
        this.addDestroyFunc(() => this.stopUsingTheme()),
        this.addManagedPropertyListener('rowHeight', () =>
          this.refreshRowHeightVariable(),
        ),
        (this.ancestorThemeClasses = this.readAncestorThemeClasses()),
        this.setUpThemeClassObservers(),
        this.getSizeEl(Ag),
        this.getSizeEl(Og),
        this.getSizeEl(Lg)
    }
    getDefaultRowHeight() {
      return this.getCSSVariablePixelValue(Ag)
    }
    getDefaultHeaderHeight() {
      return this.getCSSVariablePixelValue(Og)
    }
    getDefaultColumnMinWidth() {
      return Math.min(36, this.getDefaultRowHeight())
    }
    getDefaultListItemHeight() {
      return this.getCSSVariablePixelValue(Lg)
    }
    hasMeasuredSizes() {
      return this.sizesMeasured
    }
    getGridThemeClass() {
      var e
      return ((e = this.gridTheme) == null ? void 0 : e.getCssClass()) || null
    }
    getThemeClasses() {
      return this.gridTheme
        ? [this.gridTheme.getCssClass()]
        : this.ancestorThemeClasses
    }
    applyThemeClasses(e) {
      const t = this.getThemeClasses()
      for (const i of Array.from(e.classList))
        i.startsWith('ag-theme-') && !t.includes(i) && e.classList.remove(i)
      e.classList.add(...t)
    }
    refreshRowHeightVariable() {
      const e = this.eGridDiv.style.getPropertyValue('--ag-line-height').trim(),
        t = this.gos.get('rowHeight')
      if (t == null || isNaN(t) || !isFinite(t))
        return (
          e !== null &&
            this.eGridDiv.style.setProperty('--ag-line-height', null),
          -1
        )
      const i = `${t}px`
      return e != i
        ? (this.eGridDiv.style.setProperty('--ag-line-height', i), t)
        : e != ''
          ? parseFloat(e)
          : -1
    }
    getCSSVariablePixelValue(e) {
      const t = this.lastKnownValues.get(e)
      if (t != null) return t
      const i = this.measureSizeEl(e)
      return i === 'detached' || i === 'no-styles'
        ? e.defaultValue
        : (this.lastKnownValues.set(e, i), i)
    }
    measureSizeEl(e) {
      const t = this.getSizeEl(e)
      if (t.offsetParent == null) return 'detached'
      const i = t.offsetWidth
      return i === kg ? 'no-styles' : ((this.sizesMeasured = !0), i)
    }
    getSizeEl(e) {
      let t = this.sizeEls.get(e)
      if (t) return t
      let i = this.eMeasurementContainer
      i ||
        ((i = this.eMeasurementContainer = document.createElement('div')),
        (i.className = 'ag-measurement-container'),
        this.gos.get('theme') && this.applyThemeClasses(i),
        this.eGridDiv.appendChild(i)),
        (t = document.createElement('div')),
        (t.style.width = `var(${e.cssName}, ${kg}px)`),
        i.appendChild(t),
        this.sizeEls.set(e, t)
      let s = this.measureSizeEl(e)
      s === 'no-styles' &&
        te(
          `no value for ${e.cssName}. This usually means that the grid has been initialised before styles have been loaded. The default value of ${e.defaultValue} will be used and updated when styles load.`,
        )
      const n = this.resizeObserverService.observeResize(t, () => {
        const r = this.measureSizeEl(e)
        r === 'detached' ||
          r === 'no-styles' ||
          (this.lastKnownValues.set(e, r),
          r !== s && ((s = r), this.fireGridStylesChangedEvent(e.changeKey)))
      })
      return this.addDestroyFunc(() => n()), t
    }
    fireGridStylesChangedEvent(e) {
      this.eventService.dispatchEvent({ type: 'gridStylesChanged', [e]: !0 })
    }
    setUpThemeClassObservers() {
      const e = new MutationObserver(() => {
        const i = this.readAncestorThemeClasses()
        vO(i, this.ancestorThemeClasses) ||
          ((this.ancestorThemeClasses = i),
          this.fireGridStylesChangedEvent('themeChanged'))
      })
      let t = this.eGridDiv
      for (; t; )
        e.observe(t || this.eGridDiv, {
          attributes: !0,
          attributeFilter: ['class'],
        }),
          (t = t.parentElement)
      this.addDestroyFunc(() => e.disconnect())
    }
    readAncestorThemeClasses() {
      let e = this.eGridDiv
      const t = []
      for (; e; ) {
        const i = Array.from(e.classList).filter((s) =>
          s.startsWith('ag-theme-'),
        )
        for (const s of i) t.includes(s) || t.unshift(s)
        e = e.parentElement
      }
      return Object.freeze(t)
    }
    handleThemeGridOptionChange() {
      const { gos: e, eMeasurementContainer: t, gridTheme: i } = this,
        s = e.get('theme') || null
      s !== i &&
        (i == null || i.stopUse(),
        (this.gridTheme = s),
        s == null ||
          s.startUse({
            loadThemeGoogleFonts: e.get('loadThemeGoogleFonts'),
            container: this.eGridDiv,
          }),
        t && this.applyThemeClasses(t),
        this.fireGridStylesChangedEvent('themeChanged'))
    }
    stopUsingTheme() {
      var e
      ;(e = this.gridTheme) == null || e.stopUse(), (this.gridTheme = null)
    }
  },
  vO = (e, t) =>
    e.length === t.length && e.findIndex((i, s) => e[s] !== t[s]) === -1,
  kg = 15538,
  CO = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'eventService'),
        (this.globalEventService = new Dr())
    }
    wireBeans(e) {
      ;(this.globalEventListener = e.globalEventListener),
        (this.globalSyncEventListener = e.globalSyncEventListener)
    }
    postConstruct() {
      if (this.globalEventListener) {
        const e = Ta(this.gos)
        this.addGlobalListener(this.globalEventListener, e)
      }
      this.globalSyncEventListener &&
        this.addGlobalListener(this.globalSyncEventListener, !1)
    }
    addEventListener(e, t, i) {
      this.globalEventService.addEventListener(e, t, i)
    }
    removeEventListener(e, t, i) {
      this.globalEventService.removeEventListener(e, t, i)
    }
    addGlobalListener(e, t = !1) {
      this.globalEventService.addGlobalListener(e, t)
    }
    removeGlobalListener(e, t = !1) {
      this.globalEventService.removeGlobalListener(e, t)
    }
    dispatchLocalEvent() {}
    dispatchEvent(e) {
      this.globalEventService.dispatchEvent(this.gos.addGridCommonParams(e))
    }
    dispatchEventOnce(e) {
      this.globalEventService.dispatchEventOnce(this.gos.addGridCommonParams(e))
    }
  },
  xd = class Bi extends X {
    constructor() {
      super(...arguments), (this.beanName = 'focusService')
    }
    wireBeans(t) {
      ;(this.eGridDiv = t.eGridDiv),
        (this.columnModel = t.columnModel),
        (this.visibleColsService = t.visibleColsService),
        (this.headerNavigationService = t.headerNavigationService),
        (this.headerPositionUtils = t.headerPositionUtils),
        (this.rowRenderer = t.rowRenderer),
        (this.rowPositionUtils = t.rowPositionUtils),
        (this.cellPositionUtils = t.cellPositionUtils),
        (this.navigationService = t.navigationService),
        (this.ctrlsService = t.ctrlsService),
        (this.filterManager = t.filterManager),
        (this.rangeService = t.rangeService),
        (this.advancedFilterService = t.advancedFilterService),
        (this.overlayService = t.overlayService)
    }
    static addKeyboardModeEvents(t) {
      this.instanceCount > 0 ||
        (t.addEventListener('keydown', Bi.toggleKeyboardMode),
        t.addEventListener('mousedown', Bi.toggleKeyboardMode))
    }
    static removeKeyboardModeEvents(t) {
      this.instanceCount > 0 ||
        (t.removeEventListener('keydown', Bi.toggleKeyboardMode),
        t.removeEventListener('mousedown', Bi.toggleKeyboardMode))
    }
    static toggleKeyboardMode(t) {
      const i = Bi.keyboardModeActive,
        s = t.type === 'keydown'
      ;(s && (t.ctrlKey || t.metaKey || t.altKey)) ||
        (i !== s && (Bi.keyboardModeActive = s))
    }
    postConstruct() {
      const t = this.clearFocusedCell.bind(this)
      this.addManagedEventListeners({
        columnPivotModeChanged: t,
        newColumnsLoaded: this.onColumnEverythingChanged.bind(this),
        columnGroupOpened: t,
        columnRowGroupChanged: t,
      }),
        this.registerKeyboardFocusEvents(),
        this.ctrlsService.whenReady(this, (i) => {
          this.gridCtrl = i.gridCtrl
        })
    }
    registerKeyboardFocusEvents() {
      const t = Gt(this.gos)
      Bi.addKeyboardModeEvents(t),
        Bi.instanceCount++,
        this.addDestroyFunc(() => {
          Bi.instanceCount--, Bi.removeKeyboardModeEvents(t)
        })
    }
    onColumnEverythingChanged() {
      if (!this.focusedCellPosition) return
      const t = this.focusedCellPosition.column,
        i = this.columnModel.getCol(t.getId())
      t !== i && this.clearFocusedCell()
    }
    isKeyboardMode() {
      return Bi.keyboardModeActive
    }
    getFocusCellToUseAfterRefresh() {
      return this.gos.get('suppressFocusAfterRefresh') ||
        !this.focusedCellPosition ||
        this.isDomDataMissingInHierarchy(Lt(this.gos), On.DOM_DATA_KEY_ROW_CTRL)
        ? null
        : this.focusedCellPosition
    }
    getFocusHeaderToUseAfterRefresh() {
      return this.gos.get('suppressFocusAfterRefresh') ||
        !this.focusedHeaderPosition ||
        this.isDomDataMissingInHierarchy(
          Lt(this.gos),
          Sl.DOM_DATA_KEY_HEADER_CTRL,
        )
        ? null
        : this.focusedHeaderPosition
    }
    isDomDataMissingInHierarchy(t, i) {
      let s = t
      for (; s; ) {
        if (mo(this.gos, s, i)) return !1
        s = s.parentNode
      }
      return !0
    }
    getFocusedCell() {
      return this.focusedCellPosition
    }
    shouldRestoreFocus(t) {
      return this.isCellRestoreFocused(t)
        ? (setTimeout(() => {
            this.restoredFocusedCellPosition = null
          }, 0),
          !0)
        : !1
    }
    clearRestoreFocus() {
      ;(this.restoredFocusedCellPosition = null),
        (this.awaitRestoreFocusedCell = !1)
    }
    restoreFocusedCell(t, i) {
      ;(this.awaitRestoreFocusedCell = !0),
        setTimeout(() => {
          this.awaitRestoreFocusedCell && (this.setRestoreFocusedCell(t), i())
        })
    }
    isCellRestoreFocused(t) {
      return this.restoredFocusedCellPosition == null
        ? !1
        : this.cellPositionUtils.equals(t, this.restoredFocusedCellPosition)
    }
    setRestoreFocusedCell(t) {
      this.getFrameworkOverrides().renderingEngine === 'react' &&
        (this.restoredFocusedCellPosition = t)
    }
    getFocusEventParams(t) {
      const { rowIndex: i, rowPinned: s, column: n } = t,
        r = { rowIndex: i, rowPinned: s, column: n, isFullWidthCell: !1 },
        o = this.rowRenderer.getRowByPosition({ rowIndex: i, rowPinned: s })
      return o && (r.isFullWidthCell = o.isFullWidth()), r
    }
    clearFocusedCell() {
      if (
        ((this.restoredFocusedCellPosition = null),
        this.focusedCellPosition == null)
      )
        return
      const t = this.getFocusEventParams(this.focusedCellPosition)
      ;(this.focusedCellPosition = null),
        this.eventService.dispatchEvent({ type: 'cellFocusCleared', ...t })
    }
    setFocusedCell(t) {
      const {
          column: i,
          rowIndex: s,
          rowPinned: n,
          forceBrowserFocus: r = !1,
          preventScrollOnBrowserFocus: o = !1,
        } = t,
        a = this.columnModel.getCol(i)
      if (!a) {
        this.focusedCellPosition = null
        return
      }
      ;(this.focusedCellPosition = {
        rowIndex: s,
        rowPinned: As(n),
        column: a,
      }),
        this.eventService.dispatchEvent({
          type: 'cellFocused',
          ...this.getFocusEventParams(this.focusedCellPosition),
          forceBrowserFocus: r,
          preventScrollOnBrowserFocus: o,
        })
    }
    isCellFocused(t) {
      return this.focusedCellPosition == null
        ? !1
        : this.cellPositionUtils.equals(t, this.focusedCellPosition)
    }
    isRowNodeFocused(t) {
      return this.isRowFocused(t.rowIndex, t.rowPinned)
    }
    isHeaderWrapperFocused(t) {
      if (this.focusedHeaderPosition == null) return !1
      const i = t.getColumnGroupChild(),
        s = t.getRowIndex(),
        n = t.getPinned(),
        { column: r, headerRowIndex: o } = this.focusedHeaderPosition
      return i === r && s === o && n == r.getPinned()
    }
    clearFocusedHeader() {
      this.focusedHeaderPosition = null
    }
    getFocusedHeader() {
      return this.focusedHeaderPosition
    }
    setFocusedHeader(t, i) {
      this.focusedHeaderPosition = { headerRowIndex: t, column: i }
    }
    isHeaderFocusSuppressed() {
      return (
        this.gos.get('suppressHeaderFocus') || this.overlayService.isExclusive()
      )
    }
    isCellFocusSuppressed() {
      return (
        this.gos.get('suppressCellFocus') || this.overlayService.isExclusive()
      )
    }
    focusHeaderPosition(t) {
      var c
      if (this.isHeaderFocusSuppressed()) return !1
      const {
        direction: i,
        fromTab: s,
        allowUserOverride: n,
        event: r,
        fromCell: o,
        rowWithoutSpanValue: a,
      } = t
      let { headerPosition: l } = t
      if (
        o &&
        (c = this.filterManager) != null &&
        c.isAdvancedFilterHeaderActive()
      )
        return this.focusAdvancedFilter(l)
      if (n) {
        const u = this.getFocusedHeader(),
          h = this.headerNavigationService.getHeaderRowCount()
        if (s) {
          const g = this.gos.getCallback('tabToNextHeader')
          g &&
            (l = this.getHeaderPositionFromUserFunc({
              userFunc: g,
              direction: i,
              currentPosition: u,
              headerPosition: l,
              headerRowCount: h,
            }))
        } else {
          const g = this.gos.getCallback('navigateToNextHeader')
          if (g && r) {
            const f = {
              key: r.key,
              previousHeaderPosition: u,
              nextHeaderPosition: l,
              headerRowCount: h,
              event: r,
            }
            l = g(f)
          }
        }
      }
      return l
        ? this.focusProvidedHeaderPosition({
            headerPosition: l,
            direction: i,
            event: r,
            fromCell: o,
            rowWithoutSpanValue: a,
          })
        : !1
    }
    focusHeaderPositionFromUserFunc(t) {
      if (this.isHeaderFocusSuppressed()) return !1
      const { userFunc: i, headerPosition: s, direction: n, event: r } = t,
        o = this.getFocusedHeader(),
        a = this.headerNavigationService.getHeaderRowCount(),
        l = this.getHeaderPositionFromUserFunc({
          userFunc: i,
          direction: n,
          currentPosition: o,
          headerPosition: s,
          headerRowCount: a,
        })
      return (
        !!l &&
        this.focusProvidedHeaderPosition({
          headerPosition: l,
          direction: n,
          event: r,
        })
      )
    }
    getHeaderPositionFromUserFunc(t) {
      const {
          userFunc: i,
          direction: s,
          currentPosition: n,
          headerPosition: r,
          headerRowCount: o,
        } = t,
        l = i({
          backwards: s === 'Before',
          previousHeaderPosition: n,
          nextHeaderPosition: r,
          headerRowCount: o,
        })
      return l === !0 || l === null
        ? (l === null &&
            te(
              'Since v31.3 Returning `null` from tabToNextHeader is deprecated. Return `true` to stay on the current header, or `false` to let the browser handle the tab behaviour.',
            ),
          n)
        : l === !1
          ? null
          : l
    }
    focusProvidedHeaderPosition(t) {
      var h
      const {
          headerPosition: i,
          direction: s,
          fromCell: n,
          rowWithoutSpanValue: r,
          event: o,
        } = t,
        { column: a, headerRowIndex: l } = i
      if (l === -1)
        return (h = this.filterManager) != null &&
          h.isAdvancedFilterHeaderActive()
          ? this.focusAdvancedFilter(i)
          : this.focusGridView(a)
      this.headerNavigationService.scrollToColumn(a, s)
      const c = this.ctrlsService.getHeaderRowContainerCtrl(a.getPinned()),
        u = (c == null ? void 0 : c.focusHeader(i.headerRowIndex, a, o)) || !1
      return (
        u &&
          (r != null || n) &&
          this.headerNavigationService.setCurrentHeaderRowWithoutSpan(r ?? -1),
        u
      )
    }
    focusFirstHeader() {
      if (this.overlayService.isExclusive() && this.focusOverlay()) return !0
      let t = this.visibleColsService.getAllCols()[0]
      if (!t) return !1
      t.getParent() && (t = this.visibleColsService.getColGroupAtLevel(t, 0))
      const i = this.headerPositionUtils.getHeaderIndexToFocus(t, 0)
      return this.focusHeaderPosition({
        headerPosition: i,
        rowWithoutSpanValue: 0,
      })
    }
    focusLastHeader(t) {
      if (this.overlayService.isExclusive() && this.focusOverlay(!0)) return !0
      const i = this.headerNavigationService.getHeaderRowCount() - 1,
        s = rt(this.visibleColsService.getAllCols())
      return this.focusHeaderPosition({
        headerPosition: { headerRowIndex: i, column: s },
        rowWithoutSpanValue: -1,
        event: t,
      })
    }
    focusPreviousFromFirstCell(t) {
      var i
      return (i = this.filterManager) != null &&
        i.isAdvancedFilterHeaderActive()
        ? this.focusAdvancedFilter(null)
        : this.focusLastHeader(t)
    }
    isAnyCellFocused() {
      return !!this.focusedCellPosition
    }
    isRowFocused(t, i) {
      return this.focusedCellPosition == null
        ? !1
        : this.focusedCellPosition.rowIndex === t &&
            this.focusedCellPosition.rowPinned === As(i)
    }
    findFocusableElements(t, i, s = !1) {
      const n = vD
      let r = Um
      i && (r += ', ' + i), s && (r += ', [tabindex="-1"]')
      const o = Array.prototype.slice
          .apply(t.querySelectorAll(n))
          .filter((c) => fs(c)),
        a = Array.prototype.slice.apply(t.querySelectorAll(r))
      return a.length
        ? ((c, u) => c.filter((h) => u.indexOf(h) === -1))(o, a)
        : o
    }
    focusInto(t, i = !1, s = !1) {
      const n = this.findFocusableElements(t, null, s),
        r = i ? rt(n) : n[0]
      return r ? (r.focus({ preventScroll: !0 }), !0) : !1
    }
    findFocusableElementBeforeTabGuard(t, i) {
      if (!i) return null
      const s = this.findFocusableElements(t),
        n = s.indexOf(i)
      if (n === -1) return null
      let r = -1
      for (let o = n - 1; o >= 0; o--)
        if (s[o].classList.contains('ag-tab-guard-top')) {
          r = o
          break
        }
      return r <= 0 ? null : s[r - 1]
    }
    findNextFocusableElement(t = this.eGridDiv, i, s) {
      const n = this.findFocusableElements(
          t,
          i ? ':not([tabindex="-1"])' : null,
        ),
        r = Lt(this.gos)
      let o
      i ? (o = n.findIndex((l) => l.contains(r))) : (o = n.indexOf(r))
      const a = o + (s ? -1 : 1)
      return a < 0 || a >= n.length ? null : n[a]
    }
    isTargetUnderManagedComponent(t, i) {
      if (!i) return !1
      const s = t.querySelectorAll(`.${jn.FOCUS_MANAGED_CLASS}`)
      if (!s.length) return !1
      for (let n = 0; n < s.length; n++) if (s[n].contains(i)) return !0
      return !1
    }
    findTabbableParent(t, i = 5) {
      let s = 0
      for (; t && Zc(t) === null && ++s <= i; ) t = t.parentElement
      return Zc(t) === null ? null : t
    }
    focusOverlay(t) {
      var s
      const i =
        this.overlayService.isVisible() &&
        ((s = this.overlayService.getOverlayWrapper()) == null
          ? void 0
          : s.getGui())
      return !!i && this.focusInto(i, t)
    }
    focusGridViewFailed(t, i) {
      return (i && this.focusOverlay(t)) || (t && this.focusLastHeader())
    }
    focusGridView(t, i = !1, s = !0) {
      var r, o
      if (this.overlayService.isExclusive()) return s && this.focusOverlay(i)
      if (this.isCellFocusSuppressed())
        return i && !this.isHeaderFocusSuppressed()
          ? this.focusLastHeader()
          : s && this.focusOverlay(i)
            ? !0
            : this.focusNextGridCoreContainer(!1)
      const n = i
        ? this.rowPositionUtils.getLastRow()
        : this.rowPositionUtils.getFirstRow()
      if (n) {
        const { rowIndex: a, rowPinned: l } = n
        if (
          (t ?? (t = (r = this.getFocusedHeader()) == null ? void 0 : r.column),
          t && a !== void 0 && a !== null)
        ) {
          if (
            (this.navigationService.ensureCellVisible({
              rowIndex: a,
              column: t,
              rowPinned: l,
            }),
            i)
          ) {
            const c = this.rowRenderer.getRowByPosition(n)
            if (
              c != null &&
              c.isFullWidth() &&
              this.navigationService.tryToFocusFullWidthRow(n, i)
            )
              return !0
          }
          return (
            this.setFocusedCell({
              rowIndex: a,
              column: t,
              rowPinned: As(l),
              forceBrowserFocus: !0,
            }),
            (o = this.rangeService) == null ||
              o.setRangeToCell({ rowIndex: a, rowPinned: l, column: t }),
            !0
          )
        }
      }
      return !!((s && this.focusOverlay(i)) || (i && this.focusLastHeader()))
    }
    isGridFocused() {
      const t = Lt(this.gos)
      return !!t && this.eGridDiv.contains(t)
    }
    focusNextGridCoreContainer(t, i = !1) {
      return !i && this.gridCtrl.focusNextInnerContainer(t)
        ? !0
        : ((i || (!t && !this.gridCtrl.isDetailGrid())) &&
            this.gridCtrl.forceFocusOutOfContainer(t),
          !1)
    }
    focusAdvancedFilter(t) {
      var i
      return (
        (this.advancedFilterFocusColumn = t == null ? void 0 : t.column),
        ((i = this.advancedFilterService) == null
          ? void 0
          : i.getCtrl().focusHeaderComp()) ?? !1
      )
    }
    focusNextFromAdvancedFilter(t, i) {
      var n
      const s =
        (i ? void 0 : this.advancedFilterFocusColumn) ??
        ((n = this.visibleColsService.getAllCols()) == null ? void 0 : n[0])
      return t
        ? this.focusHeaderPosition({
            headerPosition: {
              column: s,
              headerRowIndex:
                this.headerNavigationService.getHeaderRowCount() - 1,
            },
          })
        : this.focusGridView(s)
    }
    clearAdvancedFilterColumn() {
      this.advancedFilterFocusColumn = void 0
    }
    addFocusableContainer(t) {
      this.gridCtrl.addFocusableContainer(t)
    }
    removeFocusableContainer(t) {
      this.gridCtrl.removeFocusableContainer(t)
    }
    focusGridInnerElement(t) {
      return this.gridCtrl.focusInnerElement(t)
    }
    allowFocusForNextGridCoreContainer(t) {
      this.gridCtrl.allowFocusForNextCoreContainer(t)
    }
  }
xd.keyboardModeActive = !1
xd.instanceCount = 0
var SO = xd,
  wO = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'pinnedWidthService')
    }
    wireBeans(e) {
      this.visibleColsService = e.visibleColsService
    }
    postConstruct() {
      const e = this.checkContainerWidths.bind(this)
      this.addManagedEventListeners({
        displayedColumnsChanged: e,
        displayedColumnsWidthChanged: e,
      }),
        this.addManagedPropertyListener('domLayout', e)
    }
    checkContainerWidths() {
      const e = ci(this.gos, 'print'),
        t = e ? 0 : this.visibleColsService.getColsLeftWidth(),
        i = e ? 0 : this.visibleColsService.getDisplayedColumnsRightWidth()
      t != this.leftWidth &&
        ((this.leftWidth = t),
        this.eventService.dispatchEvent({ type: 'leftPinnedWidthChanged' })),
        i != this.rightWidth &&
          ((this.rightWidth = i),
          this.eventService.dispatchEvent({ type: 'rightPinnedWidthChanged' }))
    }
    getPinnedRightWidth() {
      return this.rightWidth
    }
    getPinnedLeftWidth() {
      return this.leftWidth
    }
  },
  yO = class extends X {
    constructor() {
      super(...arguments), (this.additionalFocusableContainers = new Set())
    }
    wireBeans(e) {
      ;(this.beans = e),
        (this.focusService = e.focusService),
        (this.visibleColsService = e.visibleColsService)
    }
    setComp(e, t, i) {
      ;(this.view = e),
        (this.eGridHostDiv = t),
        (this.eGui = i),
        this.eGui.setAttribute('grid-id', this.beans.context.getGridId())
      const {
          dragAndDropService: s,
          mouseEventService: n,
          ctrlsService: r,
          resizeObserverService: o,
        } = this.beans,
        a = {
          getContainer: () => this.eGui,
          isInterestedIn: (c) => c === 1 || c === 0,
          getIconName: () => 'notAllowed',
        }
      s.addDropTarget(a),
        this.addDestroyFunc(() => s.removeDropTarget(a)),
        n.stampTopLevelGridCompWithGridInstance(t),
        this.createManagedBean(new Pd(this.view)),
        this.view.setRtlClass(this.gos.get('enableRtl') ? 'ag-rtl' : 'ag-ltr'),
        this.updateGridThemeClass(),
        this.addManagedEventListeners({
          gridStylesChanged: this.handleThemeChange.bind(this),
        })
      const l = o.observeResize(
        this.eGridHostDiv,
        this.onGridSizeChanged.bind(this),
      )
      this.addDestroyFunc(() => l()), r.register('gridCtrl', this)
    }
    isDetailGrid() {
      var t
      const e = this.focusService.findTabbableParent(this.getGui())
      return (
        ((t = e == null ? void 0 : e.getAttribute('row-id')) == null
          ? void 0
          : t.startsWith('detail')) || !1
      )
    }
    getOptionalSelectors() {
      var t, i, s, n, r
      const e = this.beans
      return {
        paginationSelector:
          (t = e.paginationService) == null
            ? void 0
            : t.getPaginationSelector(),
        gridHeaderDropZonesSelector:
          (i = e.columnDropZonesService) == null
            ? void 0
            : i.getDropZoneSelector(),
        sideBarSelector:
          (s = e.sideBarService) == null ? void 0 : s.getSideBarSelector(),
        statusBarSelector:
          (n = e.statusBarService) == null
            ? void 0
            : n.getStatusPanelSelector(),
        watermarkSelector:
          (r = e.licenseManager) == null ? void 0 : r.getWatermarkSelector(),
      }
    }
    onGridSizeChanged() {
      this.eventService.dispatchEvent({
        type: 'gridSizeChanged',
        clientWidth: this.eGridHostDiv.clientWidth,
        clientHeight: this.eGridHostDiv.clientHeight,
      })
    }
    destroyGridUi() {
      this.view.destroyGridUi()
    }
    getGui() {
      return this.eGui
    }
    setResizeCursor(e) {
      this.view.setCursor(e ? 'ew-resize' : null)
    }
    disableUserSelect(e) {
      this.view.setUserSelect(e ? 'none' : null)
    }
    focusNextInnerContainer(e) {
      const t = this.getFocusableContainers(),
        { indexWithFocus: i, nextIndex: s } = this.getNextFocusableIndex(t, e)
      if (s < 0 || s >= t.length) return !1
      if (s === 0) {
        if (i > 0) {
          const n = this.visibleColsService.getAllCols(),
            r = rt(n)
          if (this.focusService.focusGridView(r, !0)) return !0
        }
        return !1
      }
      return this.focusContainer(t[s], e)
    }
    focusInnerElement(e) {
      const t = this.gos.getCallback('focusGridInnerElement')
      if (t && t({ fromBottom: !!e })) return !0
      const i = this.getFocusableContainers(),
        s = this.visibleColsService.getAllCols()
      if (e) {
        if (i.length > 1) return this.focusContainer(rt(i), !0)
        const n = rt(s)
        if (this.focusService.focusGridView(n, !0)) return !0
      }
      if (
        this.gos.get('headerHeight') === 0 ||
        this.focusService.isHeaderFocusSuppressed()
      ) {
        if (this.focusService.focusGridView(s[0])) return !0
        for (let n = 1; n < i.length; n++)
          if (this.focusService.focusInto(i[n].getGui())) return !0
        return !1
      }
      return this.focusService.focusFirstHeader()
    }
    forceFocusOutOfContainer(e = !1) {
      this.view.forceFocusOutOfContainer(e)
    }
    addFocusableContainer(e) {
      this.additionalFocusableContainers.add(e)
    }
    removeFocusableContainer(e) {
      this.additionalFocusableContainers.delete(e)
    }
    allowFocusForNextCoreContainer(e) {
      var r
      const t = this.view.getFocusableContainers(),
        { nextIndex: i, indexWithFocus: s } = this.getNextFocusableIndex(t, e)
      if (s === -1 || i < 0 || i >= t.length) return
      const n = t[i]
      ;(r = n.setAllowFocus) == null || r.call(n, !0),
        setTimeout(() => {
          var o
          ;(o = n.setAllowFocus) == null || o.call(n, !1)
        })
    }
    getNextFocusableIndex(e, t) {
      const i = Lt(this.gos),
        s = e.findIndex((r) => r.getGui().contains(i)),
        n = s + (t ? -1 : 1)
      return { indexWithFocus: s, nextIndex: n }
    }
    focusContainer(e, t) {
      var s, n
      ;(s = e.setAllowFocus) == null || s.call(e, !0)
      const i = this.focusService.focusInto(e.getGui(), t)
      return (n = e.setAllowFocus) == null || n.call(e, !1), i
    }
    getFocusableContainers() {
      return [
        ...this.view.getFocusableContainers(),
        ...this.additionalFocusableContainers,
      ]
    }
    updateGridThemeClass() {
      const e = this.beans.environment.getGridThemeClass()
      e && this.view.setGridThemeClass(e)
    }
    handleThemeChange(e) {
      e.themeChanged && this.updateGridThemeClass()
    }
    destroy() {
      this.additionalFocusableContainers.clear(), super.destroy()
    }
  },
  bO = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'alignedGridsService'),
        (this.consuming = !1)
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.columnSizeService = e.columnSizeService),
        (this.ctrlsService = e.ctrlsService),
        (this.columnApplyStateService = e.columnApplyStateService)
    }
    getAlignedGridApis() {
      let e = this.gos.get('alignedGrids') ?? []
      const t = typeof e == 'function'
      typeof e == 'function' && (e = e())
      const i = () =>
        `See ${this.getFrameworkOverrides().getDocLink('aligned-grids')}`
      return e
        .map((n) => {
          var o
          if (!n) {
            ht('alignedGrids contains an undefined option.'),
              t ||
                ht(`You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`),
              ht(i())
            return
          }
          if (this.isGridApi(n)) return n
          const r = n
          return 'current' in r
            ? (o = r.current) == null
              ? void 0
              : o.api
            : (r.api ||
                ht(
                  `alignedGrids - No api found on the linked grid. If you are passing gridOptions to alignedGrids since v31 this is no longer valid. ${i()}`,
                ),
              r.api)
        })
        .filter((n) => !!n && !n.isDestroyed())
    }
    isGridApi(e) {
      return !!e && !!e.dispatchEvent
    }
    postConstruct() {
      const e = this.fireColumnEvent.bind(this)
      this.addManagedEventListeners({
        columnMoved: e,
        columnVisible: e,
        columnPinned: e,
        columnGroupOpened: e,
        columnResized: e,
        bodyScroll: this.fireScrollEvent.bind(this),
        alignedGridColumn: ({ event: t }) => this.onColumnEvent(t),
        alignedGridScroll: ({ event: t }) => this.onScrollEvent(t),
      })
    }
    fireEvent(e) {
      this.consuming ||
        this.getAlignedGridApis().forEach((t) => {
          t.isDestroyed() || t.dispatchEvent(e)
        })
    }
    onEvent(e) {
      ;(this.consuming = !0), e(), (this.consuming = !1)
    }
    fireColumnEvent(e) {
      this.fireEvent({ type: 'alignedGridColumn', event: e })
    }
    fireScrollEvent(e) {
      e.direction === 'horizontal' &&
        this.fireEvent({ type: 'alignedGridScroll', event: e })
    }
    onScrollEvent(e) {
      this.onEvent(() => {
        this.ctrlsService
          .getGridBodyCtrl()
          .getScrollFeature()
          .setHorizontalScrollPosition(e.left, !0)
      })
    }
    extractDataFromEvent(e, t) {
      const i = []
      return (
        e.columns
          ? e.columns.forEach((s) => {
              i.push(t(s))
            })
          : e.column && i.push(t(e.column)),
        i
      )
    }
    getMasterColumns(e) {
      return this.extractDataFromEvent(e, (t) => t)
    }
    getColumnIds(e) {
      return this.extractDataFromEvent(e, (t) => t.getColId())
    }
    onColumnEvent(e) {
      this.onEvent(() => {
        switch (e.type) {
          case 'columnMoved':
          case 'columnVisible':
          case 'columnPinned':
          case 'columnResized': {
            this.processColumnEvent(e)
            break
          }
          case 'columnGroupOpened': {
            this.processGroupOpenedEvent(e)
            break
          }
          case 'columnPivotChanged':
            te(
              'pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.',
            )
            break
        }
      })
    }
    processGroupOpenedEvent(e) {
      const { columnModel: t } = this
      e.columnGroups.forEach((i) => {
        let s = null
        i && (s = t.getProvidedColGroup(i.getGroupId())),
          !(i && !s) &&
            t.setColumnGroupOpened(s, i.isExpanded(), 'alignedGridChanged')
      })
    }
    processColumnEvent(e) {
      var c
      const t = e.column
      let i = null
      if ((t && (i = this.columnModel.getColDefCol(t.getColId())), t && !i))
        return
      const s = this.getMasterColumns(e),
        {
          columnApplyStateService: n,
          columnSizeService: r,
          ctrlsService: o,
        } = this
      switch (e.type) {
        case 'columnMoved':
          {
            const h = e.api.getColumnState().map((g) => ({ colId: g.colId }))
            n.applyColumnState(
              { state: h, applyOrder: !0 },
              'alignedGridChanged',
            )
          }
          break
        case 'columnVisible':
          {
            const h = e.api
              .getColumnState()
              .map((g) => ({ colId: g.colId, hide: g.hide }))
            n.applyColumnState({ state: h }, 'alignedGridChanged')
          }
          break
        case 'columnPinned':
          {
            const h = e.api
              .getColumnState()
              .map((g) => ({ colId: g.colId, pinned: g.pinned }))
            n.applyColumnState({ state: h }, 'alignedGridChanged')
          }
          break
        case 'columnResized': {
          const u = e,
            h = {}
          s.forEach((g) => {
            h[g.getId()] = { key: g.getColId(), newWidth: g.getActualWidth() }
          }),
            (c = u.flexColumns) == null ||
              c.forEach((g) => {
                h[g.getId()] && delete h[g.getId()]
              }),
            r.setColumnWidths(
              Object.values(h),
              !1,
              u.finished,
              'alignedGridChanged',
            )
          break
        }
      }
      const l = o.getGridBodyCtrl().isVerticalScrollShowing()
      this.getAlignedGridApis().forEach((u) => {
        u.setGridOption('alwaysShowVerticalScroll', l)
      })
    }
  },
  RO = {
    version: je,
    moduleName: '@ag-grid-community/aligned-grid',
    beans: [bO],
  }
function FO(e, t) {
  const i = e.columnModel.getColDefCol(t)
  return i ? i.getColDef() : null
}
function EO(e) {
  return e.columnModel.getColumnDefs()
}
function PO(e, t) {
  typeof t == 'number'
    ? e.columnSizeService.sizeColumnsToFit(t, 'api')
    : e.ctrlsService.getGridBodyCtrl().sizeColumnsToFit(t)
}
function xO(e, t, i) {
  e.columnModel.setColumnGroupOpened(t, i, 'api')
}
function DO(e, t, i) {
  return e.visibleColsService.getColumnGroup(t, i)
}
function MO(e, t) {
  return e.columnModel.getProvidedColGroup(t)
}
function IO(e, t, i) {
  return e.columnNameService.getDisplayNameForColumn(t, i) || ''
}
function TO(e, t, i) {
  return e.columnNameService.getDisplayNameForColumnGroup(t, i) || ''
}
function AO(e, t) {
  return e.columnModel.getColDefCol(t)
}
function OO(e) {
  return e.columnModel.getColDefCols()
}
function LO(e, t) {
  return e.columnApplyStateService.applyColumnState(t, 'api')
}
function kO(e) {
  return e.columnGetStateService.getColumnState()
}
function HO(e) {
  e.columnApplyStateService.resetColumnState('api')
}
function NO(e) {
  return e.columnGroupStateService.getColumnGroupState()
}
function GO(e, t) {
  e.columnGroupStateService.setColumnGroupState(t, 'api')
}
function BO(e) {
  e.columnGroupStateService.resetColumnGroupState('api')
}
function VO(e) {
  return (
    e.visibleColsService.isPinningLeft() ||
    e.visibleColsService.isPinningRight()
  )
}
function _O(e) {
  return e.visibleColsService.isPinningLeft()
}
function WO(e) {
  return e.visibleColsService.isPinningRight()
}
function $O(e, t) {
  return e.visibleColsService.getColAfter(t)
}
function zO(e, t) {
  return e.visibleColsService.getColBefore(t)
}
function UO(e, t, i) {
  e.columnModel.setColsVisible([t], i, 'api')
}
function jO(e, t, i) {
  e.columnModel.setColsVisible(t, i, 'api')
}
function YO(e, t, i) {
  e.columnModel.setColsPinned([t], i, 'api')
}
function KO(e, t, i) {
  e.columnModel.setColsPinned(t, i, 'api')
}
function qO(e) {
  return e.columnModel.getCols()
}
function QO(e) {
  return e.visibleColsService.getLeftCols()
}
function XO(e) {
  return e.visibleColsService.getCenterCols()
}
function JO(e) {
  return e.visibleColsService.getRightCols()
}
function ZO(e) {
  return e.visibleColsService.getAllCols()
}
function eL(e) {
  return e.columnViewportService.getViewportColumns()
}
function tL(e, t, i) {
  e.columnMoveService.moveColumns([t], i, 'api')
}
function iL(e, t, i) {
  e.columnMoveService.moveColumnByIndex(t, i, 'api')
}
function sL(e, t, i) {
  e.columnMoveService.moveColumns(t, i, 'api')
}
function nL(e, t, i, s = !0, n = 'api') {
  e.columnSizeService.setColumnWidths([{ key: t, newWidth: i }], !1, s, n)
}
function rL(e, t, i = !0, s = 'api') {
  e.columnSizeService.setColumnWidths(t, !1, i, s)
}
function oL(e) {
  return e.visibleColsService.getTreeLeft()
}
function aL(e) {
  return e.visibleColsService.getTreeCenter()
}
function lL(e) {
  return e.visibleColsService.getTreeRight()
}
function cL(e) {
  return e.visibleColsService.getAllTrees()
}
function uL(e, t, i) {
  return e.columnAutosizeService.autoSizeCols({
    colKeys: [t],
    skipHeader: i,
    source: 'api',
  })
}
function dL(e, t, i) {
  e.columnAutosizeService.autoSizeCols({
    colKeys: t,
    skipHeader: i,
    source: 'api',
  })
}
function hL(e, t) {
  e.columnAutosizeService.autoSizeAllColumns('api', t)
}
var gL = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'dataTypeService'),
        (this.dataTypeDefinitions = {}),
        (this.isWaitingForRowData = !1),
        (this.isColumnTypeOverrideInDataTypeDefinitions = !1),
        (this.columnStateUpdatesPendingInference = {}),
        (this.columnStateUpdateListenerDestroyFuncs = [])
    }
    wireBeans(e) {
      ;(this.rowModel = e.rowModel),
        (this.columnModel = e.columnModel),
        (this.funcColsService = e.funcColsService),
        (this.valueService = e.valueService),
        (this.columnApplyStateService = e.columnApplyStateService),
        (this.filterManager = e.filterManager)
    }
    postConstruct() {
      ;(this.groupHideOpenParents = this.gos.get('groupHideOpenParents')),
        this.addManagedPropertyListener('groupHideOpenParents', () => {
          this.groupHideOpenParents = this.gos.get('groupHideOpenParents')
        }),
        this.processDataTypeDefinitions(),
        this.addManagedPropertyListener('dataTypeDefinitions', (e) => {
          this.processDataTypeDefinitions(),
            this.columnModel.recreateColumnDefs(bn(e.source))
        })
    }
    processDataTypeDefinitions() {
      const e = this.getDefaultDataTypes()
      ;(this.dataTypeDefinitions = {}), (this.formatValueFuncs = {})
      const t = (s) => (n) => {
        const { column: r, node: o, value: a } = n
        let l = r.getColDef().valueFormatter
        return (
          l === s.groupSafeValueFormatter && (l = s.valueFormatter),
          this.valueService.formatValue(r, o, a, l)
        )
      }
      Object.entries(e).forEach(([s, n]) => {
        const r = {
          ...n,
          groupSafeValueFormatter: this.createGroupSafeValueFormatter(n),
        }
        ;(this.dataTypeDefinitions[s] = r), (this.formatValueFuncs[s] = t(r))
      })
      const i = this.gos.get('dataTypeDefinitions') ?? {}
      ;(this.dataTypeMatchers = {}),
        Object.entries(i).forEach(([s, n]) => {
          const r = this.processDataTypeDefinition(n, i, [s], e)
          r &&
            ((this.dataTypeDefinitions[s] = r),
            n.dataTypeMatcher && (this.dataTypeMatchers[s] = n.dataTypeMatcher),
            (this.formatValueFuncs[s] = t(r)))
        }),
        this.checkObjectValueHandlers(e),
        ['dateString', 'text', 'number', 'boolean', 'date'].forEach((s) => {
          const n = this.dataTypeMatchers[s]
          n && delete this.dataTypeMatchers[s],
            (this.dataTypeMatchers[s] = n ?? e[s].dataTypeMatcher)
        })
    }
    mergeDataTypeDefinitions(e, t) {
      const i = { ...e, ...t }
      return (
        e.columnTypes &&
          t.columnTypes &&
          t.appendColumnTypes &&
          (i.columnTypes = [...ha(e.columnTypes), ...ha(t.columnTypes)]),
        i
      )
    }
    processDataTypeDefinition(e, t, i, s) {
      let n
      const r = e.extendsDataType
      if (
        (e.columnTypes && (this.isColumnTypeOverrideInDataTypeDefinitions = !0),
        e.extendsDataType === e.baseDataType)
      ) {
        let o = s[r]
        const a = t[r]
        if ((o && a && (o = a), !this.validateDataTypeDefinition(e, o, r)))
          return
        n = this.mergeDataTypeDefinitions(o, e)
      } else {
        if (i.includes(r)) {
          te(
            'Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.',
          )
          return
        }
        const o = t[r]
        if (!this.validateDataTypeDefinition(e, o, r)) return
        const a = this.processDataTypeDefinition(o, t, [...i, r], s)
        if (!a) return
        n = this.mergeDataTypeDefinitions(a, e)
      }
      return {
        ...n,
        groupSafeValueFormatter: this.createGroupSafeValueFormatter(n),
      }
    }
    validateDataTypeDefinition(e, t, i) {
      return t
        ? t.baseDataType !== e.baseDataType
          ? (te(
              'The "baseDataType" property of a data type definition must match that of its parent.',
            ),
            !1)
          : !0
        : (te(`The data type definition ${i} does not exist.`), !1)
    }
    createGroupSafeValueFormatter(e) {
      if (e.valueFormatter)
        return (t) => {
          var i, s
          if ((i = t.node) != null && i.group) {
            const n = (t.colDef.pivotValueColumn ?? t.column).getAggFunc()
            if (n) {
              if (n === 'first' || n === 'last') return e.valueFormatter(t)
              if (e.baseDataType === 'number' && n !== 'count') {
                if (typeof t.value == 'number') return e.valueFormatter(t)
                if (typeof t.value == 'object') {
                  if (!t.value) return
                  if ('toNumber' in t.value)
                    return e.valueFormatter({ ...t, value: t.value.toNumber() })
                  if ('value' in t.value)
                    return e.valueFormatter({ ...t, value: t.value.value })
                }
              }
              return
            }
            if (
              (this.gos.get('suppressGroupMaintainValueType') ||
                this.gos.get('groupDisplayType') === 'groupRows') &&
              !this.gos.get('treeData')
            )
              return
          } else if (
            this.groupHideOpenParents &&
            t.column.isRowGroupActive() &&
            typeof t.value == 'string' &&
            !((s = e.dataTypeMatcher) != null && s.call(e, t.value))
          )
            return
          return e.valueFormatter(t)
        }
    }
    updateColDefAndGetColumnType(e, t, i) {
      let { cellDataType: s } = t
      const { field: n } = t
      if (
        (s === void 0 && (s = e.cellDataType),
        (s == null || s === !0) &&
          (s = this.canInferCellDataType(e, t)
            ? this.inferCellDataType(n, i)
            : !1),
        !s)
      ) {
        e.cellDataType = !1
        return
      }
      const r = this.dataTypeDefinitions[s]
      if (!r) {
        te(`Missing data type definition - "${s}"`)
        return
      }
      return (
        (e.cellDataType = s),
        r.groupSafeValueFormatter &&
          (e.valueFormatter = r.groupSafeValueFormatter),
        r.valueParser && (e.valueParser = r.valueParser),
        r.suppressDefaultProperties ||
          this.setColDefPropertiesForBaseDataType(e, s, r, i),
        r.columnTypes
      )
    }
    addColumnListeners(e) {
      if (!this.isWaitingForRowData) return
      const t = this.columnStateUpdatesPendingInference[e.getColId()]
      if (!t) return
      const i = (s) => {
        t.add(s.key)
      }
      e.addEventListener('columnStateUpdated', i),
        this.columnStateUpdateListenerDestroyFuncs.push(() =>
          e.removeEventListener('columnStateUpdated', i),
        )
    }
    canInferCellDataType(e, t) {
      if (!Pt(this.gos)) return !1
      const i = {
        cellRenderer: !0,
        valueGetter: !0,
        valueParser: !0,
        refData: !0,
      }
      if (this.doColDefPropsPreventInference(t, i)) return !1
      const s = t.type === null ? e.type : t.type
      if (s) {
        const n = this.gos.get('columnTypes') ?? {}
        if (
          ha(s).some((o) => {
            const a = n[o.trim()]
            return a && this.doColDefPropsPreventInference(a, i)
          })
        )
          return !1
      }
      return !this.doColDefPropsPreventInference(e, i)
    }
    doColDefPropsPreventInference(e, t) {
      return [
        ['cellRenderer', 'agSparklineCellRenderer'],
        ['valueGetter', void 0],
        ['valueParser', void 0],
        ['refData', void 0],
      ].some(([i, s]) => this.doesColDefPropPreventInference(e, t, i, s))
    }
    doesColDefPropPreventInference(e, t, i, s) {
      if (!t[i]) return !1
      const n = e[i]
      return n === null ? ((t[i] = !1), !1) : s === void 0 ? !!n : n === s
    }
    inferCellDataType(e, t) {
      if (!e) return
      let i
      const s = this.getInitialData()
      if (s) {
        const r =
          e.indexOf('.') >= 0 && !this.gos.get('suppressFieldDotNotation')
        i = ro(s, e, r)
      } else this.initWaitForRowData(t)
      if (i == null) return
      const [n] = Object.entries(this.dataTypeMatchers).find(([r, o]) =>
        o(i),
      ) ?? ['object']
      return n
    }
    getInitialData() {
      const e = this.gos.get('rowData')
      if (e != null && e.length) return e[0]
      if (this.initialData) return this.initialData
      {
        const t = this.rowModel.getRootNode().allLeafChildren
        if (t != null && t.length) return t[0].data
      }
      return null
    }
    initWaitForRowData(e) {
      if (
        ((this.columnStateUpdatesPendingInference[e] = new Set()),
        this.isWaitingForRowData)
      )
        return
      this.isWaitingForRowData = !0
      const t = this.isColumnTypeOverrideInDataTypeDefinitions
      t && this.columnModel.queueResizeOperations()
      const [i] = this.addManagedEventListeners({
        rowDataUpdateStarted: (s) => {
          const { firstRowData: n } = s
          n &&
            (i == null || i(),
            (this.isWaitingForRowData = !1),
            this.processColumnsPendingInference(n, t),
            (this.columnStateUpdatesPendingInference = {}),
            t && this.columnModel.processResizeOperations(),
            this.eventService.dispatchEvent({ type: 'dataTypesInferred' }))
        },
      })
    }
    isPendingInference() {
      return this.isWaitingForRowData
    }
    processColumnsPendingInference(e, t) {
      this.initialData = e
      const i = []
      this.destroyColumnStateUpdateListeners()
      const s = {},
        n = {}
      Object.entries(this.columnStateUpdatesPendingInference).forEach(
        ([r, o]) => {
          const a = this.columnModel.getCol(r)
          if (!a) return
          const l = a.getColDef()
          if (!this.columnModel.resetColDefIntoCol(a, 'cellDataTypeInferred'))
            return
          const c = a.getColDef()
          if (t && c.type && c.type !== l.type) {
            const u = this.getUpdatedColumnState(a, o)
            u.rowGroup && u.rowGroupIndex == null && (s[r] = u),
              u.pivot && u.pivotIndex == null && (n[r] = u),
              i.push(u)
          }
        },
      ),
        t &&
          i.push(
            ...this.funcColsService.generateColumnStateForRowGroupAndPivotIndexes(
              s,
              n,
            ),
          ),
        i.length &&
          this.columnApplyStateService.applyColumnState(
            { state: i },
            'cellDataTypeInferred',
          ),
        (this.initialData = null)
    }
    getUpdatedColumnState(e, t) {
      const i = this.columnApplyStateService.getColumnStateFromColDef(e)
      return (
        t.forEach((s) => {
          delete i[s],
            s === 'rowGroup'
              ? delete i.rowGroupIndex
              : s === 'pivot' && delete i.pivotIndex
        }),
        i
      )
    }
    checkObjectValueHandlers(e) {
      const t = this.dataTypeDefinitions.object,
        i = e.object
      ;(this.hasObjectValueParser = t.valueParser !== i.valueParser),
        (this.hasObjectValueFormatter = t.valueFormatter !== i.valueFormatter)
    }
    getDateStringTypeDefinition(e) {
      return e
        ? (this.getDataTypeDefinition(e) ?? this.dataTypeDefinitions.dateString)
        : this.dataTypeDefinitions.dateString
    }
    getDateParserFunction(e) {
      return this.getDateStringTypeDefinition(e).dateParser
    }
    getDateFormatterFunction(e) {
      return this.getDateStringTypeDefinition(e).dateFormatter
    }
    getDataTypeDefinition(e) {
      const t = e.getColDef()
      if (t.cellDataType) return this.dataTypeDefinitions[t.cellDataType]
    }
    getBaseDataType(e) {
      var t
      return (t = this.getDataTypeDefinition(e)) == null
        ? void 0
        : t.baseDataType
    }
    checkType(e, t) {
      var s
      if (t == null) return !0
      const i =
        (s = this.getDataTypeDefinition(e)) == null ? void 0 : s.dataTypeMatcher
      return i ? i(t) : !0
    }
    validateColDef(e) {
      const t = (i) =>
        te(
          `Cell data type is "object" but no Value ${i} has been provided. Please either provide an object data type definition with a Value ${i}, or set "colDef.value${i}"`,
        )
      e.cellDataType === 'object' &&
        (e.valueFormatter ===
          this.dataTypeDefinitions.object.groupSafeValueFormatter &&
          !this.hasObjectValueFormatter &&
          t('Formatter'),
        e.editable &&
          e.valueParser === this.dataTypeDefinitions.object.valueParser &&
          !this.hasObjectValueParser &&
          t('Parser'))
    }
    getFormatValue(e) {
      return this.formatValueFuncs[e]
    }
    setColDefPropertiesForBaseDataType(e, t, i, s) {
      var r
      const n = this.formatValueFuncs[t]
      switch (i.baseDataType) {
        case 'number': {
          e.cellEditor = 'agNumberCellEditor'
          break
        }
        case 'boolean': {
          ;(e.cellEditor = 'agCheckboxCellEditor'),
            (e.cellRenderer = 'agCheckboxCellRenderer'),
            (e.suppressKeyboardEvent = (o) =>
              !!o.colDef.editable && o.event.key === Y.SPACE)
          break
        }
        case 'date': {
          ;(e.cellEditor = 'agDateCellEditor'), (e.keyCreator = n)
          break
        }
        case 'dateString': {
          ;(e.cellEditor = 'agDateStringCellEditor'), (e.keyCreator = n)
          break
        }
        case 'object': {
          ;(e.cellEditorParams = { useFormatter: !0 }),
            (e.comparator = (o, a) => {
              const l = this.columnModel.getColDefCol(s),
                c = l == null ? void 0 : l.getColDef()
              if (!l || !c) return 0
              const u = o == null ? '' : n({ column: l, node: null, value: o }),
                h = a == null ? '' : n({ column: l, node: null, value: a })
              return u === h ? 0 : u > h ? 1 : -1
            }),
            (e.keyCreator = n)
          break
        }
      }
      ;(r = this.filterManager) == null ||
        r.setColDefPropertiesForDataType(e, i, n)
    }
    getDefaultDataTypes() {
      const e = (i) => !!i.match('^\\d{4}-\\d{2}-\\d{2}$'),
        t = this.localeService.getLocaleTextFunc()
      return {
        number: {
          baseDataType: 'number',
          valueParser: (i) => {
            var s, n
            return ((n = (s = i.newValue) == null ? void 0 : s.trim) == null
              ? void 0
              : n.call(s)) === ''
              ? null
              : Number(i.newValue)
          },
          valueFormatter: (i) =>
            i.value == null
              ? ''
              : typeof i.value != 'number' || isNaN(i.value)
                ? t('invalidNumber', 'Invalid Number')
                : String(i.value),
          dataTypeMatcher: (i) => typeof i == 'number',
        },
        text: {
          baseDataType: 'text',
          valueParser: (i) => (i.newValue === '' ? null : _c(i.newValue)),
          dataTypeMatcher: (i) => typeof i == 'string',
        },
        boolean: {
          baseDataType: 'boolean',
          valueParser: (i) => {
            var s, n
            return i.newValue == null
              ? i.newValue
              : ((n = (s = i.newValue) == null ? void 0 : s.trim) == null
                    ? void 0
                    : n.call(s)) === ''
                ? null
                : String(i.newValue).toLowerCase() === 'true'
          },
          valueFormatter: (i) => (i.value == null ? '' : String(i.value)),
          dataTypeMatcher: (i) => typeof i == 'boolean',
        },
        date: {
          baseDataType: 'date',
          valueParser: (i) =>
            Mi(i.newValue == null ? null : String(i.newValue)),
          valueFormatter: (i) =>
            i.value == null
              ? ''
              : !(i.value instanceof Date) || isNaN(i.value.getTime())
                ? t('invalidDate', 'Invalid Date')
                : (zi(i.value, !1) ?? ''),
          dataTypeMatcher: (i) => i instanceof Date,
        },
        dateString: {
          baseDataType: 'dateString',
          dateParser: (i) => Mi(i) ?? void 0,
          dateFormatter: (i) => zi(i ?? null, !1) ?? void 0,
          valueParser: (i) => (e(String(i.newValue)) ? i.newValue : null),
          valueFormatter: (i) => (e(String(i.value)) ? i.value : ''),
          dataTypeMatcher: (i) => typeof i == 'string' && e(i),
        },
        object: {
          baseDataType: 'object',
          valueParser: () => null,
          valueFormatter: (i) => _c(i.value) ?? '',
        },
      }
    }
    destroyColumnStateUpdateListeners() {
      this.columnStateUpdateListenerDestroyFuncs.forEach((e) => e()),
        (this.columnStateUpdateListenerDestroyFuncs = [])
    }
    destroy() {
      ;(this.dataTypeDefinitions = {}),
        (this.dataTypeMatchers = {}),
        (this.formatValueFuncs = {}),
        (this.columnStateUpdatesPendingInference = {}),
        this.destroyColumnStateUpdateListeners(),
        super.destroy()
    }
  },
  fL = { version: je, moduleName: '@ag-grid-community/data-type', beans: [gL] },
  pL = {
    version: je,
    moduleName: '@ag-grid-community/column-api',
    apiFunctions: {
      getColumnDef: FO,
      getColumnDefs: EO,
      sizeColumnsToFit: PO,
      setColumnGroupOpened: xO,
      getColumnGroup: DO,
      getProvidedColumnGroup: MO,
      getDisplayNameForColumn: IO,
      getDisplayNameForColumnGroup: TO,
      getColumn: AO,
      getColumns: OO,
      applyColumnState: LO,
      getColumnState: kO,
      resetColumnState: HO,
      getColumnGroupState: NO,
      setColumnGroupState: GO,
      resetColumnGroupState: BO,
      isPinning: VO,
      isPinningLeft: _O,
      isPinningRight: WO,
      getDisplayedColAfter: $O,
      getDisplayedColBefore: zO,
      setColumnVisible: UO,
      setColumnsVisible: jO,
      setColumnPinned: YO,
      setColumnsPinned: KO,
      getAllGridColumns: qO,
      getDisplayedLeftColumns: QO,
      getDisplayedCenterColumns: XO,
      getDisplayedRightColumns: JO,
      getAllDisplayedColumns: ZO,
      getAllDisplayedVirtualColumns: eL,
      moveColumn: tL,
      moveColumnByIndex: iL,
      moveColumns: sL,
      setColumnWidth: nL,
      setColumnWidths: rL,
      getLeftDisplayedColumnGroups: oL,
      getCenterDisplayedColumnGroups: aL,
      getRightDisplayedColumnGroups: lL,
      getAllDisplayedColumnGroups: cL,
      autoSizeColumn: uL,
      autoSizeColumns: dL,
      autoSizeAllColumns: hL,
    },
  }
function mL(e, t) {
  e.ctrlsService.getGridBodyCtrl().getRowDragFeature().addRowDropZone(t)
}
function vL(e, t) {
  const i = e.dragAndDropService.findExternalZone(t)
  i && e.dragAndDropService.removeDropTarget(i)
}
function CL(e, t) {
  return e.ctrlsService.getGridBodyCtrl().getRowDragFeature().getRowDropZone(t)
}
var SL = {
  version: je,
  moduleName: '@ag-grid-community/drag-api',
  apiFunctions: {
    addRowDropZone: mL,
    removeRowDropZone: vL,
    getRowDropZoneParams: CL,
  },
}
function wL(e) {
  return e.pinnedRowModel.getPinnedTopRowCount()
}
function yL(e) {
  return e.pinnedRowModel.getPinnedBottomRowCount()
}
function bL(e, t) {
  return e.pinnedRowModel.getPinnedTopRow(t)
}
function RL(e, t) {
  return e.pinnedRowModel.getPinnedBottomRow(t)
}
var FL = {
  version: je,
  moduleName: '@ag-grid-community/pinned-row-api',
  apiFunctions: {
    getPinnedTopRowCount: wL,
    getPinnedBottomRowCount: yL,
    getPinnedTopRow: bL,
    getPinnedBottomRow: RL,
  },
}
function EL(e) {
  e.overlayService.showLoadingOverlay()
}
function PL(e) {
  e.overlayService.showNoRowsOverlay()
}
function xL(e) {
  e.overlayService.hideOverlay()
}
var DL = {
  version: je,
  moduleName: '@ag-grid-community/overlay-api',
  apiFunctions: {
    showLoadingOverlay: EL,
    showNoRowsOverlay: PL,
    hideOverlay: xL,
  },
}
function ML(e, t, i) {
  if (!t) return
  const s = e.ctrlsService.getGridBodyCtrl().getGui(),
    n = `aria-${t}`
  i === null ? s.removeAttribute(n) : s.setAttribute(n, i)
}
function IL(e, t = {}) {
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.refreshCells(t))
}
function TL(e, t = {}) {
  const i = (s) =>
    te(
      `Since v31.1 api.flashCells parameter '${s}Delay' is deprecated. Please use '${s}Duration' instead.`,
    )
  ue(t.fadeDelay) && i('fade'),
    ue(t.flashDelay) && i('flash'),
    e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.flashCells(t))
}
function AL(e) {
  e.frameworkOverrides.wrapIncoming(() =>
    e.ctrlsService.getHeaderRowContainerCtrls().forEach((t) => t.refresh()),
  )
}
function OL(e) {
  return e.animationFrameService.isQueueEmpty()
}
function LL(e) {
  e.animationFrameService.flushAllFrames()
}
function kL(e) {
  return { rowHeight: In(e.gos), headerHeight: e.columnModel.getHeaderHeight() }
}
function HL(e, t = {}) {
  return e.rowRenderer.getCellRendererInstances(t).map(ao)
}
var NL = {
  version: je,
  moduleName: '@ag-grid-community/render-api',
  apiFunctions: {
    setGridAriaProperty: ML,
    refreshCells: IL,
    flashCells: TL,
    refreshHeader: AL,
    isAnimationFrameQueueEmpty: OL,
    flushAllAnimationFrames: LL,
    getSizesForCurrentTheme: kL,
    getCellRendererInstances: HL,
  },
}
function GL(e) {
  e.valueCache.expire()
}
function BL(e, t, i) {
  return Qv(e, { colKey: t, rowNode: i })
}
function Qv(e, t) {
  const { colKey: i, rowNode: s, useFormatter: n } = t,
    r = e.columnModel.getColDefCol(i) ?? e.columnModel.getCol(i)
  if (ot(r)) return null
  const o = e.valueService.getValueForDisplay(r, s)
  return n ? (e.valueService.formatValue(r, s, o) ?? hs(o, !0)) : o
}
function VL(e) {
  return e.context.getGridId()
}
function _L(e) {
  e.gridDestroyService.destroy()
}
function WL(e) {
  return e.gridDestroyService.isDestroyCalled()
}
function $L(e, t) {
  return e.gos.get(t)
}
function zL(e, t, i) {
  Xv(e, { [t]: i })
}
function Xv(e, t) {
  e.gos.updateGridOptions({ options: t })
}
function UL(e, t, i) {
  e.apiEventService.addEventListener(t, i)
}
function jL(e, t, i) {
  e.apiEventService.removeEventListener(t, i)
}
function YL(e, t) {
  e.apiEventService.addGlobalListener(t)
}
function KL(e, t) {
  e.apiEventService.removeGlobalListener(t)
}
function qL(e) {
  return e.focusService.getFocusedCell()
}
function QL(e) {
  return e.focusService.clearFocusedCell()
}
function XL(e, t, i, s) {
  e.focusService.setFocusedCell({
    rowIndex: t,
    column: i,
    rowPinned: s,
    forceBrowserFocus: !0,
  })
}
function JL(e, t) {
  return e.navigationService.tabToNextCell(!1, t)
}
function ZL(e, t) {
  return e.navigationService.tabToNextCell(!0, t)
}
function ek(e, t, i = !1) {
  const s = e.headerNavigationService.getHeaderPositionForColumn(t, i)
  s && e.focusService.focusHeaderPosition({ headerPosition: s })
}
function tk(e, t, i) {
  const s = e.columnModel.getCol(t)
  e.menuService.showColumnMenu({
    column: s,
    buttonElement: i,
    positionBy: 'button',
  })
}
function ik(e, t, i) {
  let s = e.columnModel.getCol(t)
  if ((s || (s = e.columnModel.getColDefCol(t)), !s)) {
    ht(`column '${t}' not found`)
    return
  }
  e.menuService.showColumnMenu({
    column: s,
    mouseEvent: i,
    positionBy: 'mouse',
  })
}
function sk(e, t) {
  const i = e.columnModel.getCol(t)
  if (!i) {
    ht(`column '${t}' not found`)
    return
  }
  e.menuService.showColumnMenu({ column: i, positionBy: 'auto' })
}
function nk(e) {
  e.menuService.hidePopupMenu()
}
function rk(e, t = {}) {
  const i = t ? t.rowNodes : void 0
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.redrawRows(i))
}
function ok(e, t, i, s, n) {
  e.expansionService.setRowNodeExpanded(t, i, s, n)
}
function ak(e, t) {
  return e.rowModel.getRowNode(t)
}
function lk(e, t, i, s) {
  e.rowRenderer.addRenderedRowListener(t, i, s)
}
function ck(e) {
  return e.rowRenderer.getRenderedNodes()
}
function uk(e, t, i) {
  e.rowModel.forEachNode(t, i)
}
function dk(e) {
  return Jv(e)
}
function Jv(e) {
  return e.rowRenderer.getFirstVirtualRenderedRow()
}
function hk(e) {
  return Zv(e)
}
function Zv(e) {
  return e.rowRenderer.getLastVirtualRenderedRow()
}
function gk(e, t) {
  return e.rowModel.getRow(t)
}
function fk(e) {
  return e.rowModel.getRowCount()
}
function pk(e) {
  return e.rowModel
}
function mk(e, t) {
  if (
    !t.nodes.every((a) =>
      a.rowPinned
        ? (te('cannot select pinned rows'), !1)
        : a.id === void 0
          ? (te('cannot select node until id for node is known'), !1)
          : !0,
    )
  )
    return
  const { nodes: s, source: n, newValue: r } = t,
    o = s
  e.selectionService.setNodesSelected({
    nodes: o,
    source: n ?? 'api',
    newValue: r,
  })
}
function vk(e, t = 'apiSelectAll') {
  e.selectionService.selectAllRowNodes({ source: t })
}
function Ck(e, t = 'apiSelectAll') {
  e.selectionService.deselectAllRowNodes({ source: t })
}
function Sk(e, t = 'apiSelectAllFiltered') {
  e.selectionService.selectAllRowNodes({ source: t, justFiltered: !0 })
}
function wk(e, t = 'apiSelectAllFiltered') {
  e.selectionService.deselectAllRowNodes({ source: t, justFiltered: !0 })
}
function yk(e, t = 'apiSelectAllCurrentPage') {
  e.selectionService.selectAllRowNodes({ source: t, justCurrentPage: !0 })
}
function bk(e, t = 'apiSelectAllCurrentPage') {
  e.selectionService.deselectAllRowNodes({ source: t, justCurrentPage: !0 })
}
function Rk(e) {
  return e.selectionService.getSelectedNodes()
}
function Fk(e) {
  return e.selectionService.getSelectedRows()
}
function Ek(e) {
  e.sortController.onSortChanged('api')
}
var Pk = {
    version: je,
    moduleName: '@ag-grid-community/core-api',
    apiFunctions: {
      getGridId: VL,
      destroy: _L,
      isDestroyed: WL,
      getGridOption: $L,
      setGridOption: zL,
      updateGridOptions: Xv,
    },
  },
  xk = {
    version: je,
    moduleName: '@ag-grid-community/row-selection-api',
    apiFunctions: {
      setNodesSelected: mk,
      selectAll: vk,
      deselectAll: Ck,
      selectAllFiltered: Sk,
      deselectAllFiltered: wk,
      selectAllOnCurrentPage: yk,
      deselectAllOnCurrentPage: bk,
      getSelectedNodes: Rk,
      getSelectedRows: Fk,
    },
  },
  Dk = {
    version: je,
    moduleName: '@ag-grid-community/row-api',
    apiFunctions: {
      redrawRows: rk,
      setRowNodeExpanded: ok,
      getRowNode: ak,
      addRenderedRowListener: lk,
      getRenderedNodes: ck,
      forEachNode: uk,
      getFirstDisplayedRow: dk,
      getFirstDisplayedRowIndex: Jv,
      getLastDisplayedRow: hk,
      getLastDisplayedRowIndex: Zv,
      getDisplayedRowAtIndex: gk,
      getDisplayedRowCount: fk,
      getModel: pk,
    },
  },
  Mk = {
    version: je,
    moduleName: '@ag-grid-community/scroll-api',
    apiFunctions: {
      getVerticalPixelRange: fA,
      getHorizontalPixelRange: pA,
      ensureColumnVisible: zv,
      ensureIndexVisible: Uv,
      ensureNodeVisible: mA,
    },
  },
  Ik = {
    version: je,
    moduleName: '@ag-grid-community/keyboard-navigation-api',
    apiFunctions: {
      getFocusedCell: qL,
      clearFocusedCell: QL,
      setFocusedCell: XL,
      setFocusedHeader: ek,
      tabToNextCell: JL,
      tabToPreviousCell: ZL,
    },
  },
  Tk = {
    version: je,
    moduleName: '@ag-grid-community/event-api',
    apiFunctions: {
      addEventListener: UL,
      addGlobalListener: YL,
      removeEventListener: jL,
      removeGlobalListener: KL,
    },
  },
  Ak = {
    version: je,
    moduleName: '@ag-grid-community/cell-api',
    apiFunctions: { expireValueCache: GL, getValue: BL, getCellValue: Qv },
  },
  Ok = {
    version: je,
    moduleName: '@ag-grid-community/menu-api',
    apiFunctions: {
      showColumnMenuAfterButtonClick: tk,
      showColumnMenuAfterMouseClick: ik,
      showColumnMenu: sk,
      hidePopupMenu: nk,
    },
  },
  Lk = {
    version: je,
    moduleName: '@ag-grid-community/sort-api',
    apiFunctions: { onSortChanged: Ek },
  },
  kk = {
    version: je,
    moduleName: '@ag-grid-community/api',
    dependantModules: [Pk, FL, xk, pL, Dk, SL, Mk, DL, Ik, Tk, NL, Ak, Ok, Lk],
  }
function Hk(e) {
  var t
  return ((t = e.stateService) == null ? void 0 : t.getState()) ?? {}
}
function Nk(e) {
  switch (((e = { ...e }), e.version || (e.version = '32.1.0'), e.version)) {
    case '32.1.0':
      e = Gk(e)
  }
  return e
}
function Gk(e) {
  return (e.cellSelection = Bk(e, 'rangeSelection')), e
}
function Bk(e, t) {
  if (e && typeof e == 'object') return e[t]
}
var Vk = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'stateService'),
        (this.suppressEvents = !0),
        (this.queuedUpdateSources = new Set()),
        (this.dispatchStateUpdateEventDebounced = bi(
          () => this.dispatchQueuedStateUpdateEvents(),
          0,
        )),
        (this.onRowGroupOpenedDebounced = bi(
          () =>
            this.updateCachedState(
              'rowGroupExpansion',
              this.getRowGroupExpansionState(),
            ),
          0,
        )),
        (this.onRowSelectedDebounced = bi(() => {
          this.staleStateKeys.delete('rowSelection'),
            this.updateCachedState('rowSelection', this.getRowSelectionState())
        }, 0)),
        (this.staleStateKeys = new Set())
    }
    wireBeans(e) {
      ;(this.filterManager = e.filterManager),
        (this.ctrlsService = e.ctrlsService),
        (this.pivotResultColsService = e.pivotResultColsService),
        (this.focusService = e.focusService),
        (this.columnModel = e.columnModel),
        (this.visibleColsService = e.visibleColsService),
        (this.columnGroupStateService = e.columnGroupStateService),
        (this.columnGetStateService = e.columnGetStateService),
        (this.paginationService = e.paginationService),
        (this.selectionService = e.selectionService),
        (this.expansionService = e.expansionService),
        (this.columnAnimationService = e.columnAnimationService),
        (this.columnApplyStateService = e.columnApplyStateService),
        (this.sideBarService = e.sideBarService),
        (this.rangeService = e.rangeService)
    }
    postConstruct() {
      ;(this.isClientSideRowModel = Pt(this.gos)),
        (this.cachedState = this.getInitialState()),
        this.setCachedStateValue('version', je),
        this.ctrlsService.whenReady(this, () =>
          this.suppressEventsAndDispatchInitEvent(() =>
            this.setupStateOnGridReady(),
          ),
        )
      const [e, t, i] = this.addManagedEventListeners({
        newColumnsLoaded: ({ source: s }) => {
          s === 'gridInitializing' &&
            (e(),
            this.suppressEventsAndDispatchInitEvent(() =>
              this.setupStateOnColumnsInitialised(),
            ))
        },
        rowCountReady: () => {
          t == null || t(),
            this.suppressEventsAndDispatchInitEvent(() =>
              this.setupStateOnRowCountReady(),
            )
        },
        firstDataRendered: () => {
          i == null || i(),
            this.suppressEventsAndDispatchInitEvent(() =>
              this.setupStateOnFirstDataRendered(),
            )
        },
      })
    }
    getInitialState() {
      return Nk(this.gos.get('initialState') ?? {})
    }
    getState() {
      return (
        this.staleStateKeys.size && this.refreshStaleState(), this.cachedState
      )
    }
    setupStateOnGridReady() {
      this.updateCachedState('sideBar', this.getSideBarState())
      const e = () => this.updateCachedState('sideBar', this.getSideBarState())
      this.addManagedEventListeners({
        toolPanelVisibleChanged: e,
        sideBarUpdated: e,
      })
    }
    setupStateOnColumnsInitialised() {
      const e = this.getInitialState()
      this.setColumnState(e),
        this.setColumnGroupState(e),
        this.updateColumnState([
          'aggregation',
          'columnOrder',
          'columnPinning',
          'columnSizing',
          'columnVisibility',
          'pivot',
          'pivot',
          'rowGroup',
          'sort',
        ]),
        this.updateCachedState('columnGroup', this.getColumnGroupState())
      const t = (i) => () => this.updateColumnState([i])
      this.addManagedEventListeners({
        columnValueChanged: t('aggregation'),
        columnMoved: t('columnOrder'),
        columnPinned: t('columnPinning'),
        columnResized: t('columnSizing'),
        columnVisible: t('columnVisibility'),
        columnPivotChanged: t('pivot'),
        columnPivotModeChanged: t('pivot'),
        columnRowGroupChanged: t('rowGroup'),
        sortChanged: t('sort'),
        newColumnsLoaded: () =>
          this.updateColumnState([
            'aggregation',
            'columnOrder',
            'columnPinning',
            'columnSizing',
            'columnVisibility',
            'pivot',
            'rowGroup',
            'sort',
          ]),
        columnGroupOpened: () =>
          this.updateCachedState('columnGroup', this.getColumnGroupState()),
      })
    }
    setupStateOnRowCountReady() {
      const {
          filter: e,
          rowGroupExpansion: t,
          rowSelection: i,
          pagination: s,
        } = this.getInitialState(),
        n = this.gos.get('advancedFilterModel')
      ;(e || n) && this.setFilterState(e, n),
        t && this.setRowGroupExpansionState(t),
        i && this.setRowSelectionState(i),
        s && this.setPaginationState(s),
        this.updateCachedState('filter', this.getFilterState()),
        this.updateCachedState(
          'rowGroupExpansion',
          this.getRowGroupExpansionState(),
        ),
        this.updateCachedState('rowSelection', this.getRowSelectionState()),
        this.updateCachedState('pagination', this.getPaginationState())
      const r = () =>
        this.updateCachedState(
          'rowGroupExpansion',
          this.getRowGroupExpansionState(),
        )
      this.addManagedEventListeners({
        filterChanged: () =>
          this.updateCachedState('filter', this.getFilterState()),
        rowGroupOpened: () => this.onRowGroupOpenedDebounced(),
        expandOrCollapseAll: r,
        columnRowGroupChanged: r,
        rowDataUpdated: () => {
          this.gos.get('groupDefaultExpanded') !== 0 &&
            setTimeout(() => {
              r()
            })
        },
        selectionChanged: () => {
          this.staleStateKeys.add('rowSelection'), this.onRowSelectedDebounced()
        },
        paginationChanged: (o) => {
          ;(o.newPage || o.newPageSize) &&
            this.updateCachedState('pagination', this.getPaginationState())
        },
      })
    }
    setupStateOnFirstDataRendered() {
      const {
        scroll: e,
        cellSelection: t,
        focusedCell: i,
        columnOrder: s,
      } = this.getInitialState()
      i && this.setFocusedCellState(i),
        t && this.setCellSelectionState(t),
        e && this.setScrollState(e),
        this.setColumnPivotState(!!(s != null && s.orderedColIds)),
        this.updateCachedState('sideBar', this.getSideBarState()),
        this.updateCachedState('focusedCell', this.getFocusedCellState())
      const n = this.getRangeSelectionState()
      this.updateCachedState('rangeSelection', n),
        this.updateCachedState('cellSelection', n),
        this.updateCachedState('scroll', this.getScrollState()),
        this.addManagedEventListeners({
          cellFocused: () =>
            this.updateCachedState('focusedCell', this.getFocusedCellState()),
          cellSelectionChanged: (r) => {
            if (r.finished) {
              const o = this.getRangeSelectionState()
              this.updateCachedState('rangeSelection', o),
                this.updateCachedState('cellSelection', o)
            }
          },
          bodyScrollEnd: () =>
            this.updateCachedState('scroll', this.getScrollState()),
        })
    }
    getColumnState() {
      const e = this.columnModel.isPivotMode(),
        t = [],
        i = [],
        s = [],
        n = [],
        r = [],
        o = [],
        a = [],
        l = [],
        c = []
      let u = 0
      const h = this.columnGetStateService.getColumnState()
      for (let g = 0; g < h.length; g++) {
        const {
          colId: f,
          sort: p,
          sortIndex: v,
          rowGroup: m,
          rowGroupIndex: C,
          aggFunc: w,
          pivot: S,
          pivotIndex: y,
          pinned: F,
          hide: R,
          width: b,
          flex: x,
        } = h[g]
        c.push(f),
          p && (t[v ?? u++] = { colId: f, sort: p }),
          m && (i[C ?? 0] = f),
          typeof w == 'string' && s.push({ colId: f, aggFunc: w }),
          S && (n[y ?? 0] = f),
          F && (F === 'right' ? o : r).push(f),
          R && a.push(f),
          (x || b) && l.push({ colId: f, flex: x ?? void 0, width: b })
      }
      return {
        sort: t.length ? { sortModel: t } : void 0,
        rowGroup: i.length ? { groupColIds: i } : void 0,
        aggregation: s.length ? { aggregationModel: s } : void 0,
        pivot: n.length || e ? { pivotMode: e, pivotColIds: n } : void 0,
        columnPinning:
          r.length || o.length ? { leftColIds: r, rightColIds: o } : void 0,
        columnVisibility: a.length ? { hiddenColIds: a } : void 0,
        columnSizing: l.length ? { columnSizingModel: l } : void 0,
        columnOrder: c.length ? { orderedColIds: c } : void 0,
      }
    }
    setColumnState(e) {
      const {
          sort: t,
          rowGroup: i,
          aggregation: s,
          pivot: n,
          columnPinning: r,
          columnVisibility: o,
          columnSizing: a,
          columnOrder: l,
          partialColumnState: c,
        } = e,
        u = {},
        h = (m) => {
          let C = u[m]
          return C || ((C = { colId: m }), (u[m] = C), C)
        },
        g = c
          ? {}
          : {
              sort: null,
              sortIndex: null,
              rowGroup: null,
              rowGroupIndex: null,
              aggFunc: null,
              pivot: null,
              pivotIndex: null,
              pinned: null,
              hide: null,
              flex: null,
            }
      t &&
        (t.sortModel.forEach(({ colId: m, sort: C }, w) => {
          const S = h(m)
          ;(S.sort = C), (S.sortIndex = w)
        }),
        (g.sort = null),
        (g.sortIndex = null)),
        i &&
          (i.groupColIds.forEach((m, C) => {
            const w = h(m)
            ;(w.rowGroup = !0), (w.rowGroupIndex = C)
          }),
          (g.rowGroup = null),
          (g.rowGroupIndex = null)),
        s &&
          (s.aggregationModel.forEach(({ colId: m, aggFunc: C }) => {
            h(m).aggFunc = C
          }),
          (g.aggFunc = null)),
        n &&
          (n.pivotColIds.forEach((m, C) => {
            const w = h(m)
            ;(w.pivot = !0), (w.pivotIndex = C)
          }),
          this.gos.updateGridOptions({
            options: { pivotMode: n.pivotMode },
            source: 'gridInitializing',
          }),
          (g.pivot = null),
          (g.pivotIndex = null)),
        r &&
          (r.leftColIds.forEach((m) => {
            h(m).pinned = 'left'
          }),
          r.rightColIds.forEach((m) => {
            h(m).pinned = 'right'
          }),
          (g.pinned = null)),
        o &&
          (o.hiddenColIds.forEach((m) => {
            h(m).hide = !0
          }),
          (g.hide = null)),
        a &&
          (a.columnSizingModel.forEach(({ colId: m, flex: C, width: w }) => {
            const S = h(m)
            ;(S.flex = C ?? null), (S.width = w)
          }),
          (g.flex = null))
      const f = l == null ? void 0 : l.orderedColIds,
        p = !!(f != null && f.length),
        v = p ? f.map((m) => h(m)) : Object.values(u)
      v.length &&
        ((this.columnStates = v),
        this.columnApplyStateService.applyColumnState(
          { state: v, applyOrder: p, defaultState: g },
          'gridInitializing',
        ))
    }
    setColumnPivotState(e) {
      const t = this.columnStates
      this.columnStates = void 0
      const i = this.columnGroupStates
      if (
        ((this.columnGroupStates = void 0),
        !!this.pivotResultColsService.isPivotResultColsPresent())
      ) {
        if (t) {
          const s = []
          for (const n of t)
            this.pivotResultColsService.getPivotResultCol(n.colId) && s.push(n)
          this.columnApplyStateService.applyColumnState(
            { state: s, applyOrder: e },
            'gridInitializing',
          )
        }
        i &&
          this.columnGroupStateService.setColumnGroupState(
            i,
            'gridInitializing',
          )
      }
    }
    getColumnGroupState() {
      const e = this.columnGroupStateService.getColumnGroupState(),
        t = []
      return (
        e.forEach(({ groupId: i, open: s }) => {
          s && t.push(i)
        }),
        t.length ? { openColumnGroupIds: t } : void 0
      )
    }
    setColumnGroupState(e) {
      var n
      if (!Object.prototype.hasOwnProperty.call(e, 'columnGroup')) return
      const t = new Set(
          (n = e.columnGroup) == null ? void 0 : n.openColumnGroupIds,
        ),
        s = this.columnGroupStateService
          .getColumnGroupState()
          .map(({ groupId: r }) => {
            const o = t.has(r)
            return o && t.delete(r), { groupId: r, open: o }
          })
      t.forEach((r) => {
        s.push({ groupId: r, open: !0 })
      }),
        s.length && (this.columnGroupStates = s),
        this.columnGroupStateService.setColumnGroupState(s, 'gridInitializing')
    }
    getFilterState() {
      var i, s
      let e = (i = this.filterManager) == null ? void 0 : i.getFilterModel()
      e && Object.keys(e).length === 0 && (e = void 0)
      const t =
        ((s = this.filterManager) == null
          ? void 0
          : s.getAdvancedFilterModel()) ?? void 0
      return e || t ? { filterModel: e, advancedFilterModel: t } : void 0
    }
    setFilterState(e, t) {
      var n, r
      const { filterModel: i, advancedFilterModel: s } = e ?? {
        advancedFilterModel: t,
      }
      i &&
        ((n = this.filterManager) == null ||
          n.setFilterModel(i, 'columnFilter')),
        s && ((r = this.filterManager) == null || r.setAdvancedFilterModel(s))
    }
    getRangeSelectionState() {
      var t
      const e =
        (t = this.rangeService) == null
          ? void 0
          : t.getCellRanges().map((i) => {
              const {
                id: s,
                type: n,
                startRow: r,
                endRow: o,
                columns: a,
                startColumn: l,
              } = i
              return {
                id: s,
                type: n,
                startRow: r,
                endRow: o,
                colIds: a.map((c) => c.getColId()),
                startColId: l.getColId(),
              }
            })
      return e != null && e.length ? { cellRanges: e } : void 0
    }
    setCellSelectionState(e) {
      const {
        gos: t,
        rangeService: i,
        columnModel: s,
        visibleColsService: n,
      } = this
      if (!Vs(t) || !i) return
      const r = []
      if (
        (e.cellRanges.forEach((o) => {
          const a = []
          if (
            (o.colIds.forEach((c) => {
              const u = s.getCol(c)
              u && a.push(u)
            }),
            !a.length)
          )
            return
          let l = s.getCol(o.startColId)
          if (!l) {
            const c = n.getAllCols(),
              u = new Set(a)
            l = c.find((h) => u.has(h))
          }
          r.push({ ...o, columns: a, startColumn: l })
        }),
        mx(t) && vx(t) && r.length > 1)
      )
        return te(
          'cannot add multiple ranges when `cellSelection.suppressMultiRanges = true`',
        )
      i.setCellRanges(r)
    }
    getScrollState() {
      var s
      if (!this.isClientSideRowModel) return
      const e =
          (s = this.ctrlsService.getGridBodyCtrl()) == null
            ? void 0
            : s.getScrollFeature(),
        { left: t } = (e == null ? void 0 : e.getHScrollPosition()) ?? {
          left: 0,
        },
        { top: i } = (e == null ? void 0 : e.getVScrollPosition()) ?? { top: 0 }
      return i || t ? { top: i, left: t } : void 0
    }
    setScrollState(e) {
      var s
      if (!this.isClientSideRowModel) return
      const { top: t, left: i } = e
      ;(s = this.ctrlsService.getGridBodyCtrl()) == null ||
        s.getScrollFeature().setScrollPosition(t, i)
    }
    getSideBarState() {
      var e, t
      return (t =
        (e = this.sideBarService) == null ? void 0 : e.getSideBarComp()) == null
        ? void 0
        : t.getState()
    }
    getFocusedCellState() {
      if (!this.isClientSideRowModel) return
      const e = this.focusService.getFocusedCell()
      if (e) {
        const { column: t, rowIndex: i, rowPinned: s } = e
        return { colId: t.getColId(), rowIndex: i, rowPinned: s }
      }
    }
    setFocusedCellState(e) {
      if (!this.isClientSideRowModel) return
      const { colId: t, rowIndex: i, rowPinned: s } = e
      this.focusService.setFocusedCell({
        column: this.columnModel.getCol(t),
        rowIndex: i,
        rowPinned: s,
        forceBrowserFocus: !0,
        preventScrollOnBrowserFocus: !0,
      })
    }
    getPaginationState() {
      if (!this.paginationService) return
      const e = this.paginationService.getCurrentPage(),
        t = this.gos.get('paginationAutoPageSize')
          ? void 0
          : this.paginationService.getPageSize()
      if (!(!e && !t)) return { page: e, pageSize: t }
    }
    setPaginationState(e) {
      this.paginationService &&
        (e.pageSize &&
          !this.gos.get('paginationAutoPageSize') &&
          this.paginationService.setPageSize(e.pageSize, 'initialState'),
        typeof e.page == 'number' && this.paginationService.setPage(e.page))
    }
    getRowSelectionState() {
      var i
      const e = this.selectionService.getSelectionState()
      return !e ||
        (!Array.isArray(e) &&
          (e.selectAll === !1 || e.selectAllChildren === !1) &&
          !((i = e == null ? void 0 : e.toggledNodes) != null && i.length))
        ? void 0
        : e
    }
    setRowSelectionState(e) {
      this.selectionService.setSelectionState(e, 'gridInitializing')
    }
    getRowGroupExpansionState() {
      const e = this.expansionService.getExpandedRows()
      return e.length ? { expandedRowGroupIds: e } : void 0
    }
    setRowGroupExpansionState(e) {
      this.expansionService.expandRows(e.expandedRowGroupIds)
    }
    updateColumnState(e) {
      const t = this.getColumnState()
      let i = !1
      Object.entries(t).forEach(([s, n]) => {
        po(n, this.cachedState[s]) || (i = !0)
      }),
        (this.cachedState = { ...this.cachedState, ...t }),
        i && this.dispatchStateUpdateEvent(e)
    }
    updateCachedState(e, t) {
      const i = this.cachedState[e]
      this.setCachedStateValue(e, t),
        po(t, i) || this.dispatchStateUpdateEvent([e])
    }
    setCachedStateValue(e, t) {
      this.cachedState = { ...this.cachedState, [e]: t }
    }
    refreshStaleState() {
      this.staleStateKeys.forEach((e) => {
        switch (e) {
          case 'rowSelection':
            this.setCachedStateValue(e, this.getRowSelectionState())
            break
        }
      }),
        this.staleStateKeys.clear()
    }
    dispatchStateUpdateEvent(e) {
      this.suppressEvents ||
        (e.forEach((t) => this.queuedUpdateSources.add(t)),
        this.dispatchStateUpdateEventDebounced())
    }
    dispatchQueuedStateUpdateEvents() {
      const e = Array.from(this.queuedUpdateSources)
      this.queuedUpdateSources.clear(),
        this.eventService.dispatchEvent({
          type: 'stateUpdated',
          sources: e,
          state: this.cachedState,
        })
    }
    suppressEventsAndDispatchInitEvent(e) {
      ;(this.suppressEvents = !0),
        this.columnAnimationService.setSuppressAnimation(!0),
        e(),
        setTimeout(() => {
          ;(this.suppressEvents = !1),
            this.queuedUpdateSources.clear(),
            this.isAlive() &&
              (this.columnAnimationService.setSuppressAnimation(!1),
              this.dispatchStateUpdateEvent(['gridInitializing']))
        })
    }
  },
  eC = {
    version: je,
    moduleName: '@ag-grid-community/state-core',
    beans: [Vk],
  },
  _k = {
    version: je,
    moduleName: '@ag-grid-community/state-api',
    apiFunctions: { getState: Hk },
    dependantModules: [eC],
  },
  Wk = {
    version: je,
    moduleName: '@ag-grid-community/state',
    dependantModules: [eC, _k],
  }
function $k(e) {
  return e.rowModel.isLastRowIndexKnown()
}
function zk(e) {
  var t
  return ((t = e.paginationService) == null ? void 0 : t.getPageSize()) ?? 100
}
function Uk(e) {
  var t
  return ((t = e.paginationService) == null ? void 0 : t.getCurrentPage()) ?? 0
}
function jk(e) {
  var t
  return ((t = e.paginationService) == null ? void 0 : t.getTotalPages()) ?? 1
}
function Yk(e) {
  return e.paginationService
    ? e.paginationService.getMasterRowCount()
    : e.rowModel.getRowCount()
}
function Kk(e) {
  var t
  ;(t = e.paginationService) == null || t.goToNextPage()
}
function qk(e) {
  var t
  ;(t = e.paginationService) == null || t.goToPreviousPage()
}
function Qk(e) {
  var t
  ;(t = e.paginationService) == null || t.goToFirstPage()
}
function Xk(e) {
  var t
  ;(t = e.paginationService) == null || t.goToLastPage()
}
function Jk(e, t) {
  var i
  ;(i = e.paginationService) == null || i.goToPage(t)
}
var Zk = class extends X {
  constructor() {
    super(...arguments), (this.beanName = 'paginationAutoPageSizeService')
  }
  wireBeans(e) {
    ;(this.ctrlsService = e.ctrlsService),
      (this.paginationService = e.paginationService)
  }
  postConstruct() {
    this.ctrlsService.whenReady(this, (e) => {
      this.centerRowsCtrl = e.center
      const t = this.checkPageSize.bind(this)
      this.addManagedEventListeners({
        bodyHeightChanged: t,
        scrollVisibilityChanged: t,
      }),
        this.addManagedPropertyListener(
          'paginationAutoPageSize',
          this.onPaginationAutoSizeChanged.bind(this),
        ),
        this.checkPageSize()
    })
  }
  notActive() {
    return (
      !this.gos.get('paginationAutoPageSize') || this.centerRowsCtrl == null
    )
  }
  onPaginationAutoSizeChanged() {
    this.notActive()
      ? this.paginationService.unsetAutoCalculatedPageSize()
      : this.checkPageSize()
  }
  checkPageSize() {
    if (this.notActive()) return
    const e = this.centerRowsCtrl.getViewportSizeFeature().getBodyHeight()
    if (e > 0) {
      const t = () => {
        const i = Math.max(In(this.gos), 1),
          s = Math.floor(e / i)
        this.paginationService.setPageSize(s, 'autoCalculated')
      }
      this.isBodyRendered
        ? bi(() => t(), 50)()
        : (t(), (this.isBodyRendered = !0))
    } else this.isBodyRendered = !1
  }
}
function eH(e, t, i) {
  e.addManagedElementListeners(t, {
    keydown: (s) => {
      if (!s.defaultPrevented && s.key === Y.TAB) {
        const n = s.shiftKey
        i.findNextFocusableElement(t, !1, n) ||
          (i.focusNextGridCoreContainer(n) && s.preventDefault())
      }
    },
  })
}
var Qr = 'paginationPageSizeSelector',
  tH = class extends yt {
    constructor() {
      super('<span class="ag-paging-page-size"></span>'),
        (this.hasEmptyOption = !1),
        (this.handlePageSizeItemSelected = () => {
          if (!this.selectPageSizeComp) return
          const e = this.selectPageSizeComp.getValue()
          if (!e) return
          const t = Number(e)
          isNaN(t) ||
            t < 1 ||
            t === this.paginationService.getPageSize() ||
            (this.paginationService.setPageSize(t, 'pageSizeSelector'),
            this.hasEmptyOption && this.toggleSelectDisplay(!0),
            this.selectPageSizeComp.getFocusableElement().focus())
        })
    }
    wireBeans(e) {
      this.paginationService = e.paginationService
    }
    postConstruct() {
      this.addManagedPropertyListener(Qr, () => {
        this.onPageSizeSelectorValuesChange()
      }),
        this.addManagedEventListeners({
          paginationChanged: (e) => this.handlePaginationChanged(e),
        })
    }
    handlePaginationChanged(e) {
      if (!this.selectPageSizeComp || !(e != null && e.newPageSize)) return
      const t = this.paginationService.getPageSize()
      this.getPageSizeSelectorValues().includes(t)
        ? this.selectPageSizeComp.setValue(t.toString())
        : this.hasEmptyOption
          ? this.selectPageSizeComp.setValue('')
          : this.toggleSelectDisplay(!0)
    }
    toggleSelectDisplay(e) {
      this.selectPageSizeComp && !e && this.reset(),
        e && (this.reloadPageSizesSelector(), this.selectPageSizeComp)
    }
    reset() {
      Ni(this.getGui()),
        this.selectPageSizeComp &&
          (this.selectPageSizeComp = this.destroyBean(this.selectPageSizeComp))
    }
    onPageSizeSelectorValuesChange() {
      this.selectPageSizeComp &&
        this.shouldShowPageSizeSelector() &&
        this.reloadPageSizesSelector()
    }
    shouldShowPageSizeSelector() {
      return (
        this.gos.get('pagination') &&
        !this.gos.get('suppressPaginationPanel') &&
        !this.gos.get('paginationAutoPageSize') &&
        this.gos.get(Qr) !== !1
      )
    }
    reloadPageSizesSelector() {
      const e = this.getPageSizeSelectorValues(),
        t = this.paginationService.getPageSize(),
        i = !t || !e.includes(t)
      if (i) {
        const n = this.gos.exists('paginationPageSize'),
          r = this.gos.get(Qr) !== !0
        te(
          `'paginationPageSize=${t}'${n ? '' : ' (default value)'}, but ${t} is not included in${r ? '' : ' the default'} paginationPageSizeSelector=[${e.join(', ')}].`,
        ),
          r ||
            te(
              `Either set '${Qr}' to an array that includes ${t} or to 'false' to disable the page size selector.`,
            ),
          e.unshift('')
      }
      const s = String(i ? '' : t)
      this.selectPageSizeComp
        ? (gn(this.pageSizeOptions, e) ||
            (this.selectPageSizeComp
              .clearOptions()
              .addOptions(this.createPageSizeSelectOptions(e)),
            (this.pageSizeOptions = e)),
          this.selectPageSizeComp.setValue(s, !0))
        : this.createPageSizeSelectorComp(e, s),
        (this.hasEmptyOption = i)
    }
    createPageSizeSelectOptions(e) {
      return e.map((t) => ({ value: String(t) }))
    }
    createPageSizeSelectorComp(e, t) {
      const i = this.localeService.getLocaleTextFunc(),
        s = i('pageSizeSelectorLabel', 'Page Size:'),
        n = i('ariaPageSizeSelectorLabel', 'Page Size')
      ;(this.selectPageSizeComp = this.createManagedBean(new vd())
        .addOptions(this.createPageSizeSelectOptions(e))
        .setValue(t)
        .setAriaLabel(n)
        .setLabel(s)
        .onValueChange(() => this.handlePageSizeItemSelected())),
        this.appendChild(this.selectPageSizeComp)
    }
    getPageSizeSelectorValues() {
      const e = [20, 50, 100],
        t = this.gos.get(Qr)
      return !Array.isArray(t) || Hi(t) ? e : [...t].sort((i, s) => i - s)
    }
    destroy() {
      this.toggleSelectDisplay(!1), super.destroy()
    }
  },
  iH = { selector: 'AG-PAGE-SIZE-SELECTOR', component: tH },
  sH = class extends jA {
    constructor() {
      super(),
        (this.btFirst = Le),
        (this.btPrevious = Le),
        (this.btNext = Le),
        (this.btLast = Le),
        (this.lbRecordCount = Le),
        (this.lbFirstRowOnPage = Le),
        (this.lbLastRowOnPage = Le),
        (this.lbCurrent = Le),
        (this.lbTotal = Le),
        (this.pageSizeComp = Le),
        (this.previousAndFirstButtonsDisabled = !1),
        (this.nextButtonDisabled = !1),
        (this.lastButtonDisabled = !1),
        (this.areListenersSetup = !1),
        (this.allowFocusInnerElement = !1)
    }
    wireBeans(e) {
      ;(this.rowModel = e.rowModel),
        (this.paginationService = e.paginationService),
        (this.focusService = e.focusService),
        (this.ariaAnnouncementService = e.ariaAnnouncementService)
    }
    postConstruct() {
      const e = this.gos.get('enableRtl')
      this.setTemplate(this.getTemplate(), [iH])
      const { btFirst: t, btPrevious: i, btNext: s, btLast: n } = this
      this.activateTabIndex([t, i, s, n]),
        t.insertAdjacentElement(
          'afterbegin',
          Li(e ? 'last' : 'first', this.gos),
        ),
        i.insertAdjacentElement(
          'afterbegin',
          Li(e ? 'next' : 'previous', this.gos),
        ),
        s.insertAdjacentElement(
          'afterbegin',
          Li(e ? 'previous' : 'next', this.gos),
        ),
        n.insertAdjacentElement(
          'afterbegin',
          Li(e ? 'first' : 'last', this.gos),
        ),
        this.addManagedPropertyListener(
          'pagination',
          this.onPaginationChanged.bind(this),
        ),
        this.addManagedPropertyListener(
          'suppressPaginationPanel',
          this.onPaginationChanged.bind(this),
        ),
        this.addManagedPropertyListeners(
          [
            'paginationPageSizeSelector',
            'paginationAutoPageSize',
            'suppressPaginationPanel',
          ],
          () => this.onPageSizeRelatedOptionsChange(),
        ),
        this.pageSizeComp.toggleSelectDisplay(
          this.pageSizeComp.shouldShowPageSizeSelector(),
        ),
        this.initialiseTabGuard({
          onTabKeyDown: () => {},
          focusInnerElement: (r) => {
            this.allowFocusInnerElement
              ? this.tabGuardFeature.getTabGuardCtrl().focusInnerElement(r)
              : this.focusService.focusGridInnerElement(r)
          },
          forceFocusOutWhenTabGuardsAreEmpty: !0,
        }),
        this.onPaginationChanged()
    }
    setAllowFocus(e) {
      this.allowFocusInnerElement = e
    }
    onPaginationChanged() {
      const t =
        this.gos.get('pagination') && !this.gos.get('suppressPaginationPanel')
      this.setDisplayed(t),
        t &&
          (this.setupListeners(),
          this.enableOrDisableButtons(),
          this.updateLabels(),
          this.onPageSizeRelatedOptionsChange())
    }
    onPageSizeRelatedOptionsChange() {
      this.pageSizeComp.toggleSelectDisplay(
        this.pageSizeComp.shouldShowPageSizeSelector(),
      )
    }
    setupListeners() {
      this.areListenersSetup ||
        (this.addManagedEventListeners({
          paginationChanged: this.onPaginationChanged.bind(this),
        }),
        [
          { el: this.btFirst, fn: this.onBtFirst.bind(this) },
          { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
          { el: this.btNext, fn: this.onBtNext.bind(this) },
          { el: this.btLast, fn: this.onBtLast.bind(this) },
        ].forEach((e) => {
          const { el: t, fn: i } = e
          this.addManagedListeners(t, {
            click: i,
            keydown: (s) => {
              ;(s.key === Y.ENTER || s.key === Y.SPACE) &&
                (s.preventDefault(), i())
            },
          })
        }),
        eH(this, this.getGui(), this.focusService),
        (this.areListenersSetup = !0))
    }
    onBtFirst() {
      this.previousAndFirstButtonsDisabled ||
        this.paginationService.goToFirstPage()
    }
    formatNumber(e) {
      const t = this.gos.getCallback('paginationNumberFormatter')
      if (t) return t({ value: e })
      const i = this.localeService.getLocaleTextFunc(),
        s = i('thousandSeparator', ','),
        n = i('decimalSeparator', '.')
      return $M(e, s, n)
    }
    getTemplate() {
      const e = this.localeService.getLocaleTextFunc(),
        t = e('page', 'Page'),
        i = e('to', 'to'),
        s = e('of', 'of'),
        n = e('firstPage', 'First Page'),
        r = e('previousPage', 'Previous Page'),
        o = e('nextPage', 'Next Page'),
        a = e('lastPage', 'Last Page'),
        l = this.getCompId()
      return `<div class="ag-paging-panel ag-unselectable" id="ag-${l}">
                <ag-page-size-selector data-ref="pageSizeComp"></ag-page-size-selector>
                <span class="ag-paging-row-summary-panel">
                    <span id="ag-${l}-first-row" data-ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${l}-to">${i}</span>
                    <span id="ag-${l}-last-row" data-ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${l}-of">${s}</span>
                    <span id="ag-${l}-row-count" data-ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div data-ref="btFirst" class="ag-button ag-paging-button" role="button" aria-label="${n}"></div>
                    <div data-ref="btPrevious" class="ag-button ag-paging-button" role="button" aria-label="${r}"></div>
                    <span class="ag-paging-description">
                        <span id="ag-${l}-start-page">${t}</span>
                        <span id="ag-${l}-start-page-number" data-ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-${l}-of-page">${s}</span>
                        <span id="ag-${l}-of-page-number" data-ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div data-ref="btNext" class="ag-button ag-paging-button" role="button" aria-label="${o}"></div>
                    <div data-ref="btLast" class="ag-button ag-paging-button" role="button" aria-label="${a}"></div>
                </span>
            </div>`
    }
    onBtNext() {
      this.nextButtonDisabled || this.paginationService.goToNextPage()
    }
    onBtPrevious() {
      this.previousAndFirstButtonsDisabled ||
        this.paginationService.goToPreviousPage()
    }
    onBtLast() {
      this.lastButtonDisabled || this.paginationService.goToLastPage()
    }
    enableOrDisableButtons() {
      const e = this.paginationService.getCurrentPage(),
        t = this.rowModel.isLastRowIndexKnown(),
        i = this.paginationService.getTotalPages()
      ;(this.previousAndFirstButtonsDisabled = e === 0),
        this.toggleButtonDisabled(
          this.btFirst,
          this.previousAndFirstButtonsDisabled,
        ),
        this.toggleButtonDisabled(
          this.btPrevious,
          this.previousAndFirstButtonsDisabled,
        )
      const s = this.isZeroPagesToDisplay(),
        n = e === i - 1
      ;(this.nextButtonDisabled = n || s),
        (this.lastButtonDisabled = !t || s || e === i - 1),
        this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled),
        this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled)
    }
    toggleButtonDisabled(e, t) {
      sD(e, t), e.classList.toggle('ag-disabled', t)
    }
    isZeroPagesToDisplay() {
      const e = this.rowModel.isLastRowIndexKnown(),
        t = this.paginationService.getTotalPages()
      return e && t === 0
    }
    updateLabels() {
      const e = this.rowModel.isLastRowIndexKnown(),
        t = this.paginationService.getTotalPages(),
        i = this.paginationService.getMasterRowCount(),
        s = e ? i : null
      if (s === 1) {
        const w = this.rowModel.getRow(0)
        if (w && w.group && !(w.groupData || w.aggData)) {
          this.setTotalLabelsToZero()
          return
        }
      }
      const n = this.paginationService.getCurrentPage(),
        r = this.paginationService.getPageSize()
      let o, a
      this.isZeroPagesToDisplay()
        ? (o = a = 0)
        : ((o = r * n + 1), (a = o + r - 1), e && a > s && (a = s))
      const l = o + r - 1,
        c = !e && i < l,
        u = this.formatNumber(o)
      this.lbFirstRowOnPage.textContent = u
      let h
      const g = this.localeService.getLocaleTextFunc()
      c ? (h = g('pageLastRowUnknown', '?')) : (h = this.formatNumber(a)),
        (this.lbLastRowOnPage.textContent = h)
      const p = t > 0 ? n + 1 : 0,
        v = this.formatNumber(p)
      this.lbCurrent.textContent = v
      let m, C
      if (e) (m = this.formatNumber(t)), (C = this.formatNumber(s))
      else {
        const w = g('more', 'more')
        ;(m = w), (C = w)
      }
      ;(this.lbTotal.textContent = m),
        (this.lbRecordCount.textContent = C),
        this.announceAriaStatus(u, h, C, v, m)
    }
    announceAriaStatus(e, t, i, s, n) {
      const r = this.localeService.getLocaleTextFunc(),
        o = r('page', 'Page'),
        a = r('to', 'to'),
        l = r('of', 'of'),
        c = `${e} ${a} ${t} ${l} ${i}`,
        u = `${o} ${s} ${l} ${n}`
      c !== this.ariaRowStatus &&
        ((this.ariaRowStatus = c),
        this.ariaAnnouncementService.announceValue(c, 'paginationRow')),
        u !== this.ariaPageStatus &&
          ((this.ariaPageStatus = u),
          this.ariaAnnouncementService.announceValue(u, 'paginationPage'))
    }
    setTotalLabelsToZero() {
      const e = this.formatNumber(0)
      ;(this.lbFirstRowOnPage.textContent = e),
        (this.lbCurrent.textContent = e),
        (this.lbLastRowOnPage.textContent = e),
        (this.lbTotal.textContent = e),
        (this.lbRecordCount.textContent = e),
        this.announceAriaStatus(e, e, e, e, e)
    }
  },
  nH = { selector: 'AG-PAGINATION', component: sH },
  rH = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'paginationService'),
        (this.currentPage = 0),
        (this.topDisplayedRowIndex = 0),
        (this.bottomDisplayedRowIndex = 0),
        (this.masterRowCount = 0)
    }
    wireBeans(e) {
      ;(this.rowModel = e.rowModel),
        (this.pageBoundsService = e.pageBoundsService)
    }
    postConstruct() {
      ;(this.active = this.gos.get('pagination')),
        (this.pageSizeFromGridOptions = this.gos.get('paginationPageSize')),
        (this.paginateChildRows = this.isPaginateChildRows()),
        this.addManagedPropertyListener(
          'pagination',
          this.onPaginationGridOptionChanged.bind(this),
        ),
        this.addManagedPropertyListener(
          'paginationPageSize',
          this.onPageSizeGridOptionChanged.bind(this),
        )
    }
    getPaginationSelector() {
      return nH
    }
    isPaginateChildRows() {
      return this.gos.get('groupRemoveSingleChildren') ||
        this.gos.get('groupRemoveLowestSingleChildren')
        ? !0
        : this.gos.get('paginateChildRows')
    }
    onPaginationGridOptionChanged() {
      ;(this.active = this.gos.get('pagination')),
        this.calculatePages(),
        this.dispatchPaginationChangedEvent({ keepRenderedRows: !0 })
    }
    onPageSizeGridOptionChanged() {
      this.setPageSize(this.gos.get('paginationPageSize'), 'gridOptions')
    }
    goToPage(e) {
      !this.active ||
        this.currentPage === e ||
        typeof this.currentPage != 'number' ||
        ((this.currentPage = e),
        this.calculatePages(),
        this.dispatchPaginationChangedEvent({ newPage: !0 }))
    }
    isRowPresent(e) {
      return (
        e.rowIndex >= this.topDisplayedRowIndex &&
        e.rowIndex <= this.bottomDisplayedRowIndex
      )
    }
    getPageForIndex(e) {
      return Math.floor(e / this.pageSize)
    }
    goToPageWithIndex(e) {
      if (!this.active) return
      const t = this.getPageForIndex(e)
      this.goToPage(t)
    }
    isRowInPage(e) {
      return this.active
        ? this.getPageForIndex(e.rowIndex) === this.currentPage
        : !0
    }
    getCurrentPage() {
      return this.currentPage
    }
    goToNextPage() {
      this.goToPage(this.currentPage + 1)
    }
    goToPreviousPage() {
      this.goToPage(this.currentPage - 1)
    }
    goToFirstPage() {
      this.goToPage(0)
    }
    goToLastPage() {
      const e = this.rowModel.getRowCount(),
        t = Math.floor(e / this.pageSize)
      this.goToPage(t)
    }
    getPageSize() {
      return this.pageSize
    }
    getTotalPages() {
      return this.totalPages
    }
    setPage(e) {
      this.currentPage = e
    }
    get pageSize() {
      return ue(this.pageSizeAutoCalculated) &&
        this.gos.get('paginationAutoPageSize')
        ? this.pageSizeAutoCalculated
        : ue(this.pageSizeFromPageSizeSelector)
          ? this.pageSizeFromPageSizeSelector
          : ue(this.pageSizeFromInitialState)
            ? this.pageSizeFromInitialState
            : ue(this.pageSizeFromGridOptions)
              ? this.pageSizeFromGridOptions
              : this.defaultPageSize
    }
    calculatePages() {
      this.active
        ? this.paginateChildRows
          ? this.calculatePagesAllRows()
          : this.calculatePagesMasterRowsOnly()
        : this.calculatedPagesNotActive(),
        this.pageBoundsService.calculateBounds(
          this.topDisplayedRowIndex,
          this.bottomDisplayedRowIndex,
        )
    }
    unsetAutoCalculatedPageSize() {
      if (this.pageSizeAutoCalculated === void 0) return
      const e = this.pageSizeAutoCalculated
      ;(this.pageSizeAutoCalculated = void 0),
        this.pageSize !== e &&
          (this.calculatePages(),
          this.dispatchPaginationChangedEvent({ newPageSize: !0 }))
    }
    setPageSize(e, t) {
      const i = this.pageSize
      switch (t) {
        case 'autoCalculated':
          this.pageSizeAutoCalculated = e
          break
        case 'pageSizeSelector':
          ;(this.pageSizeFromPageSizeSelector = e),
            this.currentPage !== 0 && this.goToFirstPage()
          break
        case 'initialState':
          this.pageSizeFromInitialState = e
          break
        case 'gridOptions':
          ;(this.pageSizeFromGridOptions = e),
            (this.pageSizeFromInitialState = void 0),
            (this.pageSizeFromPageSizeSelector = void 0),
            this.currentPage !== 0 && this.goToFirstPage()
          break
      }
      i !== this.pageSize &&
        (this.calculatePages(),
        this.dispatchPaginationChangedEvent({
          newPageSize: !0,
          keepRenderedRows: !0,
        }))
    }
    setZeroRows() {
      ;(this.masterRowCount = 0),
        (this.topDisplayedRowIndex = 0),
        (this.bottomDisplayedRowIndex = -1),
        (this.currentPage = 0),
        (this.totalPages = 0)
    }
    adjustCurrentPageIfInvalid() {
      this.currentPage >= this.totalPages &&
        (this.currentPage = this.totalPages - 1),
        (!isFinite(this.currentPage) ||
          isNaN(this.currentPage) ||
          this.currentPage < 0) &&
          (this.currentPage = 0)
    }
    calculatePagesMasterRowsOnly() {
      if (
        ((this.masterRowCount = this.rowModel.getTopLevelRowCount()),
        this.masterRowCount <= 0)
      ) {
        this.setZeroRows()
        return
      }
      const e = this.masterRowCount - 1
      ;(this.totalPages = Math.floor(e / this.pageSize) + 1),
        this.adjustCurrentPageIfInvalid()
      const t = this.pageSize * this.currentPage
      let i = this.pageSize * (this.currentPage + 1) - 1
      if (
        (i > e && (i = e),
        (this.topDisplayedRowIndex =
          this.rowModel.getTopLevelRowDisplayedIndex(t)),
        i === e)
      )
        this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1
      else {
        const s = this.rowModel.getTopLevelRowDisplayedIndex(i + 1)
        this.bottomDisplayedRowIndex = s - 1
      }
    }
    getMasterRowCount() {
      return this.masterRowCount
    }
    calculatePagesAllRows() {
      if (
        ((this.masterRowCount = this.rowModel.getRowCount()),
        this.masterRowCount === 0)
      ) {
        this.setZeroRows()
        return
      }
      const e = this.masterRowCount - 1
      ;(this.totalPages = Math.floor(e / this.pageSize) + 1),
        this.adjustCurrentPageIfInvalid(),
        (this.topDisplayedRowIndex = this.pageSize * this.currentPage),
        (this.bottomDisplayedRowIndex =
          this.pageSize * (this.currentPage + 1) - 1),
        this.bottomDisplayedRowIndex > e && (this.bottomDisplayedRowIndex = e)
    }
    calculatedPagesNotActive() {
      this.setPageSize(void 0, 'autoCalculated'),
        (this.totalPages = 1),
        (this.currentPage = 0),
        (this.topDisplayedRowIndex = 0),
        (this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1)
    }
    dispatchPaginationChangedEvent(e) {
      const {
        keepRenderedRows: t = !1,
        newPage: i = !1,
        newPageSize: s = !1,
      } = e
      this.eventService.dispatchEvent({
        type: 'paginationChanged',
        animate: !1,
        newData: !1,
        newPage: i,
        newPageSize: s,
        keepRenderedRows: t,
      })
    }
  },
  tC = {
    version: je,
    moduleName: '@ag-grid-community/pagination-core',
    beans: [rH, Zk],
  },
  oH = {
    version: je,
    moduleName: '@ag-grid-community/pagination-api',
    dependantModules: [tC],
    apiFunctions: {
      paginationIsLastPageFound: $k,
      paginationGetPageSize: zk,
      paginationGetCurrentPage: Uk,
      paginationGetTotalPages: jk,
      paginationGetRowCount: Yk,
      paginationGoToNextPage: Kk,
      paginationGoToPreviousPage: qk,
      paginationGoToFirstPage: Qk,
      paginationGoToLastPage: Xk,
      paginationGoToPage: Jk,
    },
  },
  aH = {
    version: je,
    moduleName: '@ag-grid-community/pagination',
    dependantModules: [tC, oH],
  },
  Pi = 'clientSide',
  Si = 'serverSide',
  er = 'infinite',
  lH = {
    onGroupExpandedOrCollapsed: [Pi],
    refreshClientSideRowModel: [Pi],
    isRowDataEmpty: [Pi],
    forEachLeafNode: [Pi],
    forEachNodeAfterFilter: [Pi],
    forEachNodeAfterFilterAndSort: [Pi],
    resetRowHeights: [Pi],
    applyTransaction: [Pi],
    applyTransactionAsync: [Pi],
    flushAsyncTransactions: [Pi],
    getBestCostNodeSelection: [Pi],
    getServerSideSelectionState: [Si],
    setServerSideSelectionState: [Si],
    applyServerSideTransaction: [Si],
    applyServerSideTransactionAsync: [Si],
    applyServerSideRowData: [Si],
    retryServerSideLoads: [Si],
    flushServerSideAsyncTransactions: [Si],
    refreshServerSide: [Si],
    getServerSideGroupLevelState: [Si],
    refreshInfiniteCache: [er],
    purgeInfiniteCache: [er],
    getInfiniteRowCount: [er],
    isLastRowIndexKnown: [er, Si],
    expandAll: [Pi, Si],
    collapseAll: [Pi, Si],
    onRowHeightChanged: [Pi, Si],
    setRowCount: [er, Si],
    getCacheBlockState: [er, Si],
  },
  cH = {
    getValue: { version: 'v31.3', new: 'getCellValue' },
    getFirstDisplayedRow: {
      version: 'v31.1',
      new: 'getFirstDisplayedRowIndex',
    },
    getLastDisplayedRow: { version: 'v31.1', new: 'getLastDisplayedRowIndex' },
    getModel: {
      version: 'v31.1',
      message: 'Please use the appropriate grid API methods instead.',
    },
    setColumnVisible: {
      version: 'v31.1',
      old: 'setColumnVisible(key,visible)',
      new: 'setColumnsVisible([key],visible)',
    },
    setColumnPinned: {
      version: 'v31.1',
      old: 'setColumnPinned(key,pinned)',
      new: 'setColumnsPinned([key],pinned)',
    },
    moveColumn: {
      version: 'v31.1',
      old: 'moveColumn(key, toIndex)',
      new: 'moveColumns([key], toIndex)',
    },
    setColumnWidth: {
      version: 'v31.1',
      old: 'setColumnWidth(col, width)',
      new: 'setColumnWidths([{key: col, newWidth: width}])',
    },
    autoSizeColumn: {
      version: 'v31.1',
      old: 'autoSizeColumn(key, skipHeader)',
      new: 'autoSizeColumns([key], skipHeader)',
    },
    addAggFunc: {
      version: 'v31.1',
      old: 'addAggFunc(key, func)',
      new: 'addAggFuncs({ key: func })',
    },
    removeValueColumn: {
      version: 'v31.1',
      old: 'removeValueColumn(colKey)',
      new: 'removeValueColumns([colKey])',
    },
    addValueColumn: {
      version: 'v31.1',
      old: 'addValueColumn(colKey)',
      new: 'addValueColumns([colKey])',
    },
    removeRowGroupColumn: {
      version: 'v31.1',
      old: 'removeRowGroupColumn(colKey)',
      new: 'removeRowGroupColumns([colKey])',
    },
    addRowGroupColumn: {
      version: 'v31.1',
      old: 'addRowGroupColumn(colKey)',
      new: 'addRowGroupColumns([colKey])',
    },
    removePivotColumn: {
      version: 'v31.1',
      old: 'removePivotColumn(colKey)',
      new: 'removePivotColumns([colKey])',
    },
    addPivotColumn: {
      version: 'v31.1',
      old: 'addPivotColumn(colKey)',
      new: 'addPivotColumns([colKey])',
    },
    showColumnMenuAfterButtonClick: {
      version: 'v31.1',
      message:
        "Use 'IHeaderParams.showColumnMenu' within a header component, or 'api.showColumnMenu' elsewhere.",
    },
    showColumnMenuAfterMouseClick: {
      version: 'v31.1',
      message:
        "Use 'IHeaderParams.showColumnMenuAfterMouseClick' within a header component, or 'api.showColumnMenu' elsewhere.",
    },
    getFilterInstance: {
      version: 'v31.1',
      message:
        "'getFilterInstance' is deprecated. To get/set individual filter models, use 'getColumnFilterModel' or 'setColumnFilterModel' instead. To get hold of the filter instance, use 'getColumnFilterInstance' which returns the instance asynchronously.",
    },
    showLoadingOverlay: {
      version: 'v32',
      message:
        '`showLoadingOverlay` is deprecated. Use the grid option "loading"=true instead or setGridOption("loading", true).',
    },
    clearRangeSelection: {
      version: 'v32.2',
      message: 'Use `clearCellSelection` instead.',
    },
    getInfiniteRowCount: {
      version: 'v32.2',
      old: 'getInfiniteRowCount()',
      new: 'getDisplayedRowCount()',
    },
  }
function uH(e, t, i) {
  const s = cH[e]
  if (s) {
    const { version: r, new: o, old: a, message: l } = s,
      c = a ?? e
    return (...u) => {
      const h = o ? `Please use ${o} instead. ` : ''
      return (
        te(`Since ${r} api.${c} is deprecated. ${h}${l ?? ''}`), t.apply(t, u)
      )
    }
  }
  const n = lH[e]
  return n
    ? (...r) => {
        const o = i.rowModel.getType()
        if (!n.includes(o)) {
          ht(
            `api.${e} can only be called when gridOptions.rowModelType is ${n.join(' or ')}`,
          )
          return
        }
        return t.apply(t, r)
      }
    : t
}
var dH = {
    columnsMenuParams: {
      version: '31.1',
      message: 'Use `columnChooserParams` instead.',
    },
    suppressMenu: {
      version: '31.1',
      message: 'Use `suppressHeaderMenuButton` instead.',
    },
    suppressCellFlash: {
      version: '31.2',
      message: 'Use `enableCellChangeFlash={false}` in the ColDef',
    },
    checkboxSelection: {
      version: '32.2',
      message: 'Use `rowSelection.checkboxes` in `GridOptions` instead.',
    },
    headerCheckboxSelection: {
      version: '32.2',
      message:
        'Use `rowSelection.headerCheckbox = true` in `GridOptions` instead.',
    },
    headerCheckboxSelectionFilteredOnly: {
      version: '32.2',
      message:
        'Use `rowSelection.selectAll = "filtered"` in `GridOptions` instead.',
    },
    headerCheckboxSelectionCurrentPageOnly: {
      version: '32.2',
      message:
        'Use `rowSelection.selectAll = "currentPage"` in `GridOptions` instead.',
    },
    showDisabledCheckboxes: {
      version: '32.2',
      message:
        'Use `rowSelection.hideDisabledCheckboxes = true` in `GridOptions` instead.',
    },
  },
  Zs = (e, t) => {
    const i = t.rowModelType ?? 'clientSide'
    return i === 'clientSide' || i === 'serverSide'
      ? { module: '@ag-grid-enterprise/row-grouping' }
      : null
  },
  hH = {
    enableRowGroup: Zs,
    rowGroup: Zs,
    rowGroupIndex: Zs,
    enablePivot: Zs,
    enableValue: Zs,
    pivot: Zs,
    pivotIndex: Zs,
    aggFunc: Zs,
    cellEditor: (e) =>
      e.cellEditor === 'agRichSelect' ||
      e.cellEditor === 'agRichSelectCellEditor'
        ? { module: '@ag-grid-enterprise/rich-select' }
        : null,
    menuTabs: (e) => {
      var i
      const t = ['columnsMenuTab', 'generalMenuTab']
      return (i = e.menuTabs) != null && i.some((s) => t.includes(s))
        ? { module: '@ag-grid-enterprise/menu' }
        : null
    },
    columnsMenuParams: {
      module: [
        '@ag-grid-enterprise/menu',
        '@ag-grid-enterprise/column-tool-panel',
      ],
    },
    columnChooserParams: {
      module: [
        '@ag-grid-enterprise/menu',
        '@ag-grid-enterprise/column-tool-panel',
      ],
    },
    headerCheckboxSelection: {
      supportedRowModels: ['clientSide', 'serverSide'],
      validate: (e, { rowSelection: t }) =>
        t === 'multiple'
          ? null
          : 'headerCheckboxSelection is only supported with rowSelection=multiple',
    },
    headerCheckboxSelectionFilteredOnly: {
      supportedRowModels: ['clientSide'],
      validate: (e, { rowSelection: t }) =>
        t === 'multiple'
          ? null
          : 'headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple',
    },
    headerCheckboxSelectionCurrentPageOnly: {
      supportedRowModels: ['clientSide'],
      validate: (e, { rowSelection: t }) =>
        t === 'multiple'
          ? null
          : 'headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple',
    },
    children: () => ir,
  },
  gH = {
    headerName: void 0,
    columnGroupShow: void 0,
    headerClass: void 0,
    toolPanelClass: void 0,
    headerValueGetter: void 0,
    pivotKeys: void 0,
    groupId: void 0,
    colId: void 0,
    sort: void 0,
    initialSort: void 0,
    field: void 0,
    type: void 0,
    cellDataType: void 0,
    tooltipComponent: void 0,
    tooltipField: void 0,
    headerTooltip: void 0,
    cellClass: void 0,
    showRowGroup: void 0,
    filter: void 0,
    initialAggFunc: void 0,
    defaultAggFunc: void 0,
    aggFunc: void 0,
    pinned: void 0,
    initialPinned: void 0,
    chartDataType: void 0,
    cellAriaRole: void 0,
    cellEditorPopupPosition: void 0,
    headerGroupComponent: void 0,
    headerGroupComponentParams: void 0,
    cellStyle: void 0,
    cellRenderer: void 0,
    cellRendererParams: void 0,
    cellEditor: void 0,
    cellEditorParams: void 0,
    filterParams: void 0,
    pivotValueColumn: void 0,
    headerComponent: void 0,
    headerComponentParams: void 0,
    floatingFilterComponent: void 0,
    floatingFilterComponentParams: void 0,
    tooltipComponentParams: void 0,
    refData: void 0,
    columnsMenuParams: void 0,
    columnChooserParams: void 0,
    children: void 0,
    sortingOrder: void 0,
    allowedAggFuncs: void 0,
    menuTabs: void 0,
    pivotTotalColumnIds: void 0,
    cellClassRules: void 0,
    icons: void 0,
    sortIndex: void 0,
    initialSortIndex: void 0,
    flex: void 0,
    initialFlex: void 0,
    width: void 0,
    initialWidth: void 0,
    minWidth: void 0,
    maxWidth: void 0,
    rowGroupIndex: void 0,
    initialRowGroupIndex: void 0,
    pivotIndex: void 0,
    initialPivotIndex: void 0,
    suppressCellFlash: void 0,
    suppressColumnsToolPanel: void 0,
    suppressFiltersToolPanel: void 0,
    openByDefault: void 0,
    marryChildren: void 0,
    suppressStickyLabel: void 0,
    hide: void 0,
    initialHide: void 0,
    rowGroup: void 0,
    initialRowGroup: void 0,
    pivot: void 0,
    initialPivot: void 0,
    checkboxSelection: void 0,
    showDisabledCheckboxes: void 0,
    headerCheckboxSelection: void 0,
    headerCheckboxSelectionFilteredOnly: void 0,
    headerCheckboxSelectionCurrentPageOnly: void 0,
    suppressMenu: void 0,
    suppressHeaderMenuButton: void 0,
    suppressMovable: void 0,
    lockPosition: void 0,
    lockVisible: void 0,
    lockPinned: void 0,
    unSortIcon: void 0,
    suppressSizeToFit: void 0,
    suppressAutoSize: void 0,
    enableRowGroup: void 0,
    enablePivot: void 0,
    enableValue: void 0,
    editable: void 0,
    suppressPaste: void 0,
    suppressNavigable: void 0,
    enableCellChangeFlash: void 0,
    rowDrag: void 0,
    dndSource: void 0,
    autoHeight: void 0,
    wrapText: void 0,
    sortable: void 0,
    resizable: void 0,
    singleClickEdit: void 0,
    floatingFilter: void 0,
    cellEditorPopup: void 0,
    suppressFillHandle: void 0,
    wrapHeaderText: void 0,
    autoHeaderHeight: void 0,
    dndSourceOnRowDrag: void 0,
    valueGetter: void 0,
    valueSetter: void 0,
    filterValueGetter: void 0,
    keyCreator: void 0,
    valueFormatter: void 0,
    valueParser: void 0,
    comparator: void 0,
    equals: void 0,
    pivotComparator: void 0,
    suppressKeyboardEvent: void 0,
    suppressHeaderKeyboardEvent: void 0,
    colSpan: void 0,
    rowSpan: void 0,
    getQuickFilterText: void 0,
    onCellValueChanged: void 0,
    onCellClicked: void 0,
    onCellDoubleClicked: void 0,
    onCellContextMenu: void 0,
    rowDragText: void 0,
    tooltipValueGetter: void 0,
    cellRendererSelector: void 0,
    cellEditorSelector: void 0,
    suppressSpanHeaderHeight: void 0,
    useValueFormatterForExport: void 0,
    useValueParserForImport: void 0,
    mainMenuItems: void 0,
    contextMenuItems: void 0,
    suppressFloatingFilterButton: void 0,
    suppressHeaderFilterButton: void 0,
    suppressHeaderContextMenu: void 0,
    loadingCellRenderer: void 0,
    loadingCellRendererParams: void 0,
    loadingCellRendererSelector: void 0,
    context: void 0,
  },
  fH = Object.keys(gH),
  ir = {
    objectName: 'colDef',
    allProperties: fH,
    docsUrl: 'column-properties/',
    deprecations: dH,
    validations: hH,
  },
  pH = () => ({
    advancedFilterModel: {
      version: '31',
      message: 'Use `initialState.filter.advancedFilterModel` instead.',
    },
    suppressAsyncEvents: {
      version: '31',
      message: 'Events should be handled asynchronously.',
    },
    cellFadeDelay: { version: '31.1', renamed: 'cellFadeDuration' },
    cellFlashDelay: { version: '31.1', renamed: 'cellFlashDuration' },
    suppressServerSideInfiniteScroll: { version: '31.1' },
    serverSideSortOnServer: { version: '31.1' },
    serverSideFilterOnServer: { version: '31.1' },
    enableCellChangeFlash: {
      version: '31.2',
      message:
        'Use `enableCellChangeFlash` in the `ColDef` or `defaultColDef` for all columns.',
    },
    groupIncludeFooter: {
      version: '31.3',
      message: 'Use `groupTotalRow` instead.',
    },
    groupIncludeTotalFooter: {
      version: '31.3',
      message: 'Use `grandTotalRow` instead.',
    },
    suppressLoadingOverlay: {
      version: '32',
      message: 'Use `loading`=false instead.',
    },
    enableFillHandle: {
      version: '32.2',
      message: 'Use `cellSelection.handle` instead.',
    },
    enableRangeHandle: {
      version: '32.2',
      message: 'Use `cellSelection.handle` instead.',
    },
    enableRangeSelection: {
      version: '32.2',
      message: 'Use `cellSelection = true` instead.',
    },
    suppressMultiRangeSelection: {
      version: '32.2',
      message: 'Use `cellSelection.suppressMultiRanges` instead.',
    },
    suppressClearOnFillReduction: {
      version: '32.2',
      message:
        'Use `cellSelection.handle.suppressClearOnFillReduction` instead.',
    },
    fillHandleDirection: {
      version: '32.2',
      message: 'Use `cellSelection.handle.direction` instead.',
    },
    fillOperation: {
      version: '32.2',
      message: 'Use `cellSelection.handle.setFillValue` instead.',
    },
    suppressRowClickSelection: {
      version: '32.2',
      message: 'Use `rowSelection.enableClickSelection` instead.',
    },
    suppressRowDeselection: {
      version: '32.2',
      message: 'Use `rowSelection.enableClickSelection` instead.',
    },
    rowMultiSelectWithClick: {
      version: '32.2',
      message: 'Use `rowSelection.enableSelectionWithoutKeys` instead.',
    },
    groupSelectsChildren: {
      version: '32.2',
      message: 'Use `rowSelection.groupSelects = "descendants"` instead.',
    },
    groupSelectsFiltered: {
      version: '32.2',
      message:
        'Use `rowSelection.groupSelects = "filteredDescendants"` instead.',
    },
    isRowSelectable: {
      version: '32.2',
      message: 'Use `selectionOptions.isRowSelectable` instead.',
    },
    suppressCopySingleCellRanges: {
      version: '32.2',
      message: 'Use `rowSelection.copySelectedRows` instead.',
    },
    suppressCopyRowsToClipboard: {
      version: '32.2',
      message: 'Use `rowSelection.copySelectedRows` instead.',
    },
    onRangeSelectionChanged: {
      version: '32.2',
      message: 'Use `onCellSelectionChanged` instead.',
    },
    onRangeDeleteStart: {
      version: '32.2',
      message: 'Use `onCellSelectionDeleteStart` instead.',
    },
    onRangeDeleteEnd: {
      version: '32.2',
      message: 'Use `onCellSelectionDeleteEnd` instead.',
    },
    suppressBrowserResizeObserver: {
      version: '32.2',
      message:
        "The grid always uses the browser's ResizeObserver, this grid option has no effect.",
    },
    onColumnEverythingChanged: {
      version: '32.2',
      message:
        'Either use `onDisplayedColumnsChanged` which is fired at the same time, or use one of the more specific column events.',
    },
  }),
  mH = {
    suppressContextMenu: !1,
    preventDefaultOnContextMenu: !1,
    allowContextMenuWithControlKey: !1,
    suppressMenuHide: !0,
    enableBrowserTooltips: !1,
    tooltipTrigger: 'hover',
    tooltipShowDelay: 2e3,
    tooltipHideDelay: 1e4,
    tooltipMouseTrack: !1,
    tooltipShowMode: 'standard',
    tooltipInteraction: !1,
    copyHeadersToClipboard: !1,
    copyGroupHeadersToClipboard: !1,
    clipboardDelimiter: '	',
    suppressCopyRowsToClipboard: !1,
    suppressCopySingleCellRanges: !1,
    suppressLastEmptyLineOnPaste: !1,
    suppressClipboardPaste: !1,
    suppressClipboardApi: !1,
    suppressCutToClipboard: !1,
    maintainColumnOrder: !1,
    enableStrictPivotColumnOrder: !1,
    suppressFieldDotNotation: !1,
    allowDragFromColumnsToolPanel: !1,
    suppressMovableColumns: !1,
    suppressColumnMoveAnimation: !1,
    suppressMoveWhenColumnDragging: !1,
    suppressDragLeaveHidesColumns: !1,
    suppressRowGroupHidesColumns: !1,
    suppressAutoSize: !1,
    autoSizePadding: 20,
    skipHeaderOnAutoSize: !1,
    singleClickEdit: !1,
    suppressClickEdit: !1,
    readOnlyEdit: !1,
    stopEditingWhenCellsLoseFocus: !1,
    enterNavigatesVertically: !1,
    enterNavigatesVerticallyAfterEdit: !1,
    enableCellEditingOnBackspace: !1,
    undoRedoCellEditing: !1,
    undoRedoCellEditingLimit: 10,
    suppressCsvExport: !1,
    suppressExcelExport: !1,
    cacheQuickFilter: !1,
    includeHiddenColumnsInQuickFilter: !1,
    excludeChildrenWhenTreeDataFiltering: !1,
    enableAdvancedFilter: !1,
    includeHiddenColumnsInAdvancedFilter: !1,
    enableCharts: !1,
    masterDetail: !1,
    keepDetailRows: !1,
    keepDetailRowsCount: 10,
    detailRowAutoHeight: !1,
    tabIndex: 0,
    rowBuffer: 10,
    valueCache: !1,
    valueCacheNeverExpires: !1,
    enableCellExpressions: !1,
    suppressTouch: !1,
    suppressFocusAfterRefresh: !1,
    suppressAsyncEvents: !1,
    suppressBrowserResizeObserver: !1,
    suppressPropertyNamesCheck: !1,
    suppressChangeDetection: !1,
    debug: !1,
    suppressLoadingOverlay: !1,
    suppressNoRowsOverlay: !1,
    pagination: !1,
    paginationPageSize: 100,
    paginationPageSizeSelector: !0,
    paginationAutoPageSize: !1,
    paginateChildRows: !1,
    suppressPaginationPanel: !1,
    pivotMode: !1,
    pivotPanelShow: 'never',
    pivotDefaultExpanded: 0,
    pivotSuppressAutoColumn: !1,
    suppressExpandablePivotGroups: !1,
    functionsReadOnly: !1,
    suppressAggFuncInHeader: !1,
    alwaysAggregateAtRootLevel: !1,
    aggregateOnlyChangedColumns: !1,
    suppressAggFilteredOnly: !1,
    removePivotHeaderRowWhenSingleValueColumn: !1,
    animateRows: !0,
    enableCellChangeFlash: !1,
    cellFlashDelay: 500,
    cellFlashDuration: 500,
    cellFadeDelay: 1e3,
    cellFadeDuration: 1e3,
    allowShowChangeAfterFilter: !1,
    domLayout: 'normal',
    ensureDomOrder: !1,
    enableRtl: !1,
    suppressColumnVirtualisation: !1,
    suppressMaxRenderedRowRestriction: !1,
    suppressRowVirtualisation: !1,
    rowDragManaged: !1,
    suppressRowDrag: !1,
    suppressMoveWhenRowDragging: !1,
    rowDragEntireRow: !1,
    rowDragMultiRow: !1,
    embedFullWidthRows: !1,
    groupDisplayType: 'singleColumn',
    groupDefaultExpanded: 0,
    groupMaintainOrder: !1,
    groupSelectsChildren: !1,
    groupIncludeTotalFooter: !1,
    groupSuppressBlankHeader: !1,
    groupSelectsFiltered: !1,
    showOpenedGroup: !1,
    groupRemoveSingleChildren: !1,
    groupRemoveLowestSingleChildren: !1,
    groupHideOpenParents: !1,
    groupAllowUnbalanced: !1,
    rowGroupPanelShow: 'never',
    suppressMakeColumnVisibleAfterUnGroup: !1,
    treeData: !1,
    rowGroupPanelSuppressSort: !1,
    suppressGroupRowsSticky: !1,
    rowModelType: 'clientSide',
    asyncTransactionWaitMillis: 50,
    suppressModelUpdateAfterUpdateTransaction: !1,
    cacheOverflowSize: 1,
    infiniteInitialRowCount: 1,
    serverSideInitialRowCount: 1,
    suppressServerSideInfiniteScroll: !1,
    cacheBlockSize: 100,
    maxBlocksInCache: -1,
    maxConcurrentDatasourceRequests: 2,
    blockLoadDebounceMillis: 0,
    purgeClosedRowNodes: !1,
    serverSideSortAllLevels: !1,
    serverSideOnlyRefreshFilteredGroups: !1,
    serverSideSortOnServer: !1,
    serverSideFilterOnServer: !1,
    serverSidePivotResultFieldSeparator: '_',
    viewportRowModelPageSize: 5,
    viewportRowModelBufferSize: 5,
    alwaysShowHorizontalScroll: !1,
    alwaysShowVerticalScroll: !1,
    debounceVerticalScrollbar: !1,
    suppressHorizontalScroll: !1,
    suppressScrollOnNewData: !1,
    suppressScrollWhenPopupsAreOpen: !1,
    suppressAnimationFrame: !1,
    suppressMiddleClickScrolls: !1,
    suppressPreventDefaultOnMouseWheel: !1,
    rowMultiSelectWithClick: !1,
    suppressRowDeselection: !1,
    suppressRowClickSelection: !1,
    suppressCellFocus: !1,
    suppressHeaderFocus: !1,
    suppressMultiRangeSelection: !1,
    enableCellTextSelection: !1,
    enableRangeSelection: !1,
    enableRangeHandle: !1,
    enableFillHandle: !1,
    fillHandleDirection: 'xy',
    suppressClearOnFillReduction: !1,
    accentedSort: !1,
    unSortIcon: !1,
    suppressMultiSort: !1,
    alwaysMultiSort: !1,
    suppressMaintainUnsortedOrder: !1,
    suppressRowHoverHighlight: !1,
    suppressRowTransform: !1,
    columnHoverHighlight: !1,
    deltaSort: !1,
    enableGroupEdit: !1,
    suppressGroupMaintainValueType: !1,
    groupLockGroupColumns: 0,
    serverSideEnableClientSideSort: !1,
    suppressServerSideFullWidthLoadingRow: !1,
    pivotMaxGeneratedColumns: -1,
    columnMenu: 'new',
    reactiveCustomComponents: !0,
    suppressSetFilterByDefault: !1,
  },
  vH = () => ({
    sideBar: { module: '@ag-grid-enterprise/side-bar' },
    statusBar: { module: '@ag-grid-enterprise/status-bar' },
    enableCharts: { module: '@ag-grid-enterprise/charts' },
    getMainMenuItems: { module: '@ag-grid-enterprise/menu' },
    getContextMenuItems: { module: '@ag-grid-enterprise/menu' },
    allowContextMenuWithControlKey: { module: '@ag-grid-enterprise/menu' },
    enableAdvancedFilter: { module: '@ag-grid-enterprise/advanced-filter' },
    treeData: {
      supportedRowModels: ['clientSide', 'serverSide'],
      module: '@ag-grid-enterprise/row-grouping',
      validate: (e) => {
        const t = e.rowModelType ?? 'clientSide'
        switch (t) {
          case 'clientSide': {
            const i = `treeData requires 'getDataPath' in the ${t} row model.`
            return e.getDataPath ? null : i
          }
          case 'serverSide': {
            const i = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${t} row model.`
            return e.isServerSideGroup && e.getServerSideGroupKey ? null : i
          }
        }
        return null
      },
    },
    masterDetail: { module: '@ag-grid-enterprise/master-detail' },
    enableRangeSelection: { module: '@ag-grid-enterprise/range-selection' },
    enableRangeHandle: { dependencies: { enableRangeSelection: [!0] } },
    enableFillHandle: { dependencies: { enableRangeSelection: [!0] } },
    groupDefaultExpanded: { supportedRowModels: ['clientSide'] },
    groupIncludeFooter: {
      supportedRowModels: ['clientSide', 'serverSide'],
      validate: (e) => {
        switch (e.rowModelType ?? 'clientSide') {
          case 'clientSide':
            return null
          case 'serverSide':
            return e.suppressServerSideInfiniteScroll
              ? 'groupIncludeFooter is not supported alongside suppressServerSideInfiniteScroll'
              : null
        }
        return null
      },
    },
    groupHideOpenParents: {
      supportedRowModels: ['clientSide', 'serverSide'],
      dependencies: { groupTotalRow: [void 0, 'bottom'] },
    },
    groupIncludeTotalFooter: { supportedRowModels: ['clientSide'] },
    groupRemoveSingleChildren: {
      dependencies: {
        groupHideOpenParents: [void 0, !1],
        groupRemoveLowestSingleChildren: [void 0, !1],
      },
    },
    groupRemoveLowestSingleChildren: {
      dependencies: {
        groupHideOpenParents: [void 0, !1],
        groupRemoveSingleChildren: [void 0, !1],
      },
    },
    groupSelectsChildren: { dependencies: { rowSelection: ['multiple'] } },
    viewportDatasource: {
      supportedRowModels: ['viewport'],
      module: '@ag-grid-enterprise/viewport-row-model',
    },
    serverSideDatasource: {
      supportedRowModels: ['serverSide'],
      module: '@ag-grid-enterprise/server-side-row-model',
    },
    cacheBlockSize: { supportedRowModels: ['serverSide', 'infinite'] },
    datasource: {
      supportedRowModels: ['infinite'],
      module: '@ag-grid-community/infinite-row-model',
    },
    rowData: {
      supportedRowModels: ['clientSide'],
      module: '@ag-grid-community/client-side-row-model',
    },
    paginationPageSizeSelector: {
      validate: (e) => {
        const t = e.paginationPageSizeSelector
        return typeof t == 'boolean' || t == null || t.length
          ? null
          : `'paginationPageSizeSelector' cannot be an empty array.
                    If you want to hide the page size selector, set paginationPageSizeSelector to false.`
      },
    },
    rowSelection: {
      validate({ rowSelection: e }) {
        return e && typeof e == 'string'
          ? 'As of version 32.2.1, using `rowSelection` with the values "single" or "multiple" has been deprecated. Use the object value instead.'
          : e && typeof e != 'object'
            ? 'Expected `RowSelectionOptions` object for the `rowSelection` property.'
            : null
      },
    },
    cellSelection: { module: '@ag-grid-enterprise/range-selection' },
    columnDefs: () => ir,
    defaultColDef: () => ir,
    defaultColGroupDef: () => ir,
    autoGroupColumnDef: () => ir,
    selectionColumnDef: () => ir,
  }),
  CH = () => ({
    objectName: 'gridOptions',
    allProperties: [...Co.ALL_PROPERTIES, ...So.EVENT_CALLBACKS],
    propertyExceptions: ['api'],
    docsUrl: 'grid-options/',
    deprecations: pH(),
    validations: vH(),
  }),
  SH = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'validationService')
    }
    wireBeans(e) {
      ;(this.beans = e), (this.gridOptions = e.gridOptions)
    }
    postConstruct() {
      this.processGridOptions(this.gridOptions)
    }
    processGridOptions(e) {
      this.processOptions(e, CH())
    }
    validateApiFunction(e, t) {
      return uH(e, t, this.beans)
    }
    processOptions(e, t) {
      const {
        validations: i,
        deprecations: s,
        allProperties: n,
        propertyExceptions: r,
        objectName: o,
        docsUrl: a,
      } = t
      n &&
        this.gridOptions.suppressPropertyNamesCheck !== !0 &&
        this.checkProperties(e, [...(r ?? []), ...Object.keys(s)], n, o, a)
      const l = new Set()
      Object.keys(e).forEach((u) => {
        const h = s[u]
        if (h)
          if ('renamed' in h) {
            const { renamed: S, version: y } = h
            l.add(
              `As of v${y}, ${String(u)} is deprecated. Please use ${String(S)} instead.`,
            ),
              (e[S] = e[u])
          } else {
            const { message: S, version: y } = h
            l.add(`As of v${y}, ${String(u)} is deprecated. ${S ?? ''}`)
          }
        const g = e[u]
        if (g == null || g === !1) return
        const f = i[u]
        let p
        if (f)
          if (typeof f == 'function') {
            const S = f(e, this.gridOptions)
            if (!S) return
            if ('objectName' in S) {
              const y = e[u]
              if (Array.isArray(y)) {
                y.forEach((F) => {
                  this.processOptions(F, S)
                })
                return
              }
              this.processOptions(e[u], S)
              return
            }
            p = S
          } else p = f
        else return
        const {
          module: v,
          dependencies: m,
          validate: C,
          supportedRowModels: w,
        } = p
        if (w) {
          const S = this.gridOptions.rowModelType ?? 'clientSide'
          if (!w.includes(S)) {
            l.add(`${String(u)} is not supported with the '${S}' row model.`)
            return
          }
        }
        if (v) {
          const S = Array.isArray(v) ? v : [v]
          let y = !0
          if (
            (S.forEach((F) => {
              this.gos.assertModuleRegistered(F, String(u)) ||
                ((y = !1),
                l.add(`${String(u)} is only available when ${F} is loaded.`))
            }),
            !y)
          )
            return
        }
        if (m) {
          const S = this.checkForRequiredDependencies(u, m, e)
          if (S) {
            l.add(S)
            return
          }
        }
        if (C) {
          const S = C(e, this.gridOptions)
          if (S) {
            l.add(S)
            return
          }
        }
      }),
        l.size > 0 &&
          l.forEach((u) => {
            te(u)
          })
    }
    checkForRequiredDependencies(e, t, i) {
      const n = Object.entries(t).find(([a, l]) => {
        const c = i[a]
        return !l.includes(c)
      })
      if (!n) return null
      const [r, o] = n
      return o.length > 1
        ? `'${String(e)}' requires '${r}' to be one of [${o.join(', ')}].`
        : `'${String(e)}' requires '${r}' to be ${o[0]}.`
    }
    checkProperties(e, t, i, s, n) {
      const r = ['__ob__', '__v_skip', '__metadata__'],
        o = wH(Object.getOwnPropertyNames(e), [...r, ...t, ...i], i)
      if (
        (Qi(o, (a, l) => {
          let c = `invalid ${s} property '${a}' did you mean any of these: ${l.slice(0, 8).join(', ')}.`
          i.includes('context') &&
            (c += `
If you are trying to annotate ${s} with application data, use the '${s}.context' property instead.`),
            te(c)
        }),
        Object.keys(o).length > 0 && n)
      ) {
        const a = this.getFrameworkOverrides().getDocLink(n)
        te(`to see all the valid ${s} properties please check: ${a}`)
      }
    }
  }
function wH(e, t, i) {
  const s = {},
    n = e.filter((r) => !t.some((o) => o === r))
  return (
    n.length > 0 &&
      n.forEach(
        (r) => (s[r] = iv({ inputValue: r, allSuggestions: i }).values),
      ),
    s
  )
}
var yH = { version: je, moduleName: '@ag-grid-community/core' },
  bH = {
    version: je,
    moduleName: '@ag-grid-community/core-validations',
    beans: [SH],
  },
  iC = {
    version: je,
    moduleName: '@ag-grid-community/core-community-features',
    dependantModules: [yH, bH, LA, xI, Wk, fL, RO, aH, kk],
  },
  RH = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'gridDestroyService'),
        (this.destroyCalled = !1)
    }
    wireBeans(e) {
      this.beans = e
    }
    destroy() {
      var e, t
      this.destroyCalled ||
        (this.eventService.dispatchEvent({
          type: 'gridPreDestroyed',
          state:
            ((e = this.beans.stateService) == null ? void 0 : e.getState()) ??
            {},
        }),
        (this.destroyCalled = !0),
        (t = this.beans.ctrlsService.get('gridCtrl')) == null ||
          t.destroyGridUi(),
        this.beans.context.destroy(),
        super.destroy())
    }
    isDestroyCalled() {
      return this.destroyCalled
    }
  },
  fa = new Set(['gridPreDestroyed', 'fillStart', 'pasteStart']),
  FH = (e) =>
    e === 'checkboxSelected' ||
    e === 'rowClicked' ||
    e === 'spaceKey' ||
    e === 'uiSelectAll' ||
    e === 'uiSelectAllCurrentPage' ||
    e === 'uiSelectAllFiltered',
  EH = new Map([
    ...Co.BOOLEAN_PROPERTIES.map((e) => [e, $c]),
    ...Co.NUMBER_PROPERTIES.map((e) => [e, wv]),
    ['groupAggFiltering', (e) => (typeof e == 'function' ? e : $c(e))],
    ['pageSize', ls(1)],
    ['autoSizePadding', ls(0)],
    ['keepDetailRowsCount', ls(1)],
    ['rowBuffer', ls(0)],
    ['infiniteInitialRowCount', ls(1)],
    ['cacheOverflowSize', ls(1)],
    ['cacheBlockSize', ls(1)],
    ['serverSideInitialRowCount', ls(1)],
    ['viewportRowModelPageSize', ls(1)],
    ['viewportRowModelBufferSize', ls(0)],
  ])
function sC(e, t) {
  const i = EH.get(e)
  return i ? i(t) : t
}
function PH(e) {
  const t = {}
  return (
    Object.entries(e).forEach(([i, s]) => {
      const n = sC(i, s)
      t[i] = n
    }),
    t
  )
}
var nC = class rC extends X {
  constructor() {
    super(...arguments),
      (this.beanName = 'gos'),
      (this.domDataKey = '__AG_' + Math.random().toString()),
      (this.propertyEventService = new Dr()),
      (this.globalEventHandlerFactory = (t) => (i, s) => {
        if (!this.isAlive()) return
        const n = fa.has(i)
        if ((n && !t) || (!n && t)) return
        const r = So.getCallbackForEvent(i),
          o = this.gridOptions[r]
        typeof o == 'function' &&
          this.frameworkOverrides.wrapOutgoing(() => {
            o(s)
          })
      })
  }
  wireBeans(t) {
    ;(this.gridOptions = t.gridOptions),
      (this.eGridDiv = t.eGridDiv),
      (this.validationService = t.validationService),
      (this.environment = t.environment),
      (this.api = t.gridApi),
      (this.gridId = t.context.getGridId())
  }
  get gridOptionsContext() {
    return this.gridOptions.context
  }
  postConstruct() {
    const t = !this.get('suppressAsyncEvents')
    this.eventService.addGlobalListener(
      this.globalEventHandlerFactory().bind(this),
      t,
    ),
      this.eventService.addGlobalListener(
        this.globalEventHandlerFactory(!0).bind(this),
        !1,
      ),
      this.propertyEventService.setFrameworkOverrides(this.frameworkOverrides),
      this.addManagedEventListeners({
        gridOptionsChanged: ({ options: i }) => {
          this.updateGridOptions({
            options: i,
            force: !0,
            source: 'gridOptionsUpdated',
          })
        },
      })
  }
  get(t) {
    return this.gridOptions[t] ?? mH[t]
  }
  getCallback(t) {
    return this.mergeGridCommonParams(this.gridOptions[t])
  }
  exists(t) {
    return ue(this.gridOptions[t])
  }
  mergeGridCommonParams(t) {
    return (
      t &&
      ((s) => {
        const n = s
        return (n.api = this.api), (n.context = this.gridOptionsContext), t(n)
      })
    )
  }
  updateGridOptions({ options: t, force: i, source: s = 'api' }) {
    var o
    const n = { id: rC.changeSetId++, properties: [] },
      r = []
    Object.entries(t).forEach(([a, l]) => {
      s === 'api' &&
        Qx[a] &&
        te(`${a} is an initial property and cannot be updated.`)
      const c = sC(a, l),
        u = i || (typeof c == 'object' && s === 'api'),
        h = this.gridOptions[a]
      if (u || h !== c) {
        this.gridOptions[a] = c
        const g = {
          type: a,
          currentValue: c,
          previousValue: h,
          changeSet: n,
          source: s,
        }
        r.push(g)
      }
    }),
      (o = this.validationService) == null ||
        o.processGridOptions(this.gridOptions),
      (n.properties = r.map((a) => a.type)),
      r.forEach((a) => {
        this.gridOptions.debug &&
          Xi(
            `Updated property ${a.type} from`,
            a.previousValue,
            ' to ',
            a.currentValue,
          ),
          this.propertyEventService.dispatchEvent(a)
      })
  }
  addPropertyEventListener(t, i) {
    this.propertyEventService.addEventListener(t, i)
  }
  removePropertyEventListener(t, i) {
    this.propertyEventService.removeEventListener(t, i)
  }
  getDomDataKey() {
    return this.domDataKey
  }
  getGridCommonParams() {
    return { api: this.api, context: this.gridOptionsContext }
  }
  addGridCommonParams(t) {
    const i = t
    return (i.api = this.api), (i.context = this.gridOptionsContext), i
  }
  assertModuleRegistered(t, i) {
    return us.__assertRegistered(t, i, this.gridId)
  }
  isModuleRegistered(t) {
    return us.__isRegistered(t, this.gridId)
  }
}
nC.changeSetId = 0
var xH = nC,
  DH = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'headerPositionUtils')
    }
    wireBeans(e) {
      ;(this.visibleColsService = e.visibleColsService),
        (this.ctrlsService = e.ctrlsService)
    }
    findHeader(e, t) {
      let i, s
      if (
        (_t(e.column)
          ? (i = this.visibleColsService.getGroupAtDirection(e.column, t))
          : ((s = `getCol${t}`), (i = this.visibleColsService[s](e.column))),
        !i)
      )
        return
      const { headerRowIndex: n } = e
      if (this.getHeaderRowType(n) !== 'filter') {
        const a = [i]
        for (; i.getParent(); ) (i = i.getParent()), a.push(i)
        i = a[a.length - 1 - n]
      }
      const { column: r, headerRowIndex: o } = this.getHeaderIndexToFocus(i, n)
      return { column: r, headerRowIndex: o }
    }
    getHeaderIndexToFocus(e, t) {
      let i
      if (_t(e) && this.isAnyChildSpanningHeaderHeight(e) && e.isPadding()) {
        const s = e
        i = s.getLeafColumns()[0]
        let n = i
        for (; n !== s; ) t++, (n = n.getParent())
      }
      return { column: i || e, headerRowIndex: t }
    }
    isAnyChildSpanningHeaderHeight(e) {
      return e ? e.getLeafColumns().some((t) => t.isSpanHeaderHeight()) : !1
    }
    getColumnVisibleParent(e, t) {
      const i = this.getHeaderRowType(t),
        s = i === 'filter',
        n = i === 'column'
      let r = s ? e : e.getParent(),
        o = t - 1,
        a = o
      if (n && this.isAnyChildSpanningHeaderHeight(e.getParent())) {
        for (; r && r.isPadding(); ) (r = r.getParent()), o--
        ;(a = o), o < 0 && ((r = e), (o = t), (a = void 0))
      }
      return { column: r, headerRowIndex: o, headerRowIndexWithoutSpan: a }
    }
    getColumnVisibleChild(e, t, i = 'After') {
      const s = this.getHeaderRowType(t)
      let n = e,
        r = t + 1
      const o = r
      if (s === 'group') {
        const a = e.getDisplayedLeafColumns(),
          l = i === 'After' ? a[0] : rt(a),
          c = []
        let u = l
        for (; u.getParent() !== e; ) (u = u.getParent()), c.push(u)
        if (((n = l), l.isSpanHeaderHeight()))
          for (let h = c.length - 1; h >= 0; h--) {
            const g = c[h]
            if (!g.isPadding()) {
              n = g
              break
            }
            r++
          }
        else (n = rt(c)), n || (n = l)
      }
      return { column: n, headerRowIndex: r, headerRowIndexWithoutSpan: o }
    }
    getHeaderRowType(e) {
      const t = this.ctrlsService.getHeaderRowContainerCtrl()
      if (t) return t.getRowType(e)
    }
    findColAtEdgeForHeaderRow(e, t) {
      const i = this.visibleColsService.getAllCols(),
        s = i[t === 'start' ? 0 : i.length - 1]
      if (!s) return
      const n = this.ctrlsService.getHeaderRowContainerCtrl(s.getPinned()),
        r = n == null ? void 0 : n.getRowType(e)
      if (r == 'group') {
        const o = this.visibleColsService.getColGroupAtLevel(s, e)
        return { headerRowIndex: e, column: o }
      }
      return { headerRowIndex: r == null ? -1 : e, column: s }
    }
  },
  MH = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'localeService')
    }
    getLocaleTextFunc() {
      const e = this.gos.getCallback('getLocaleText')
      if (e)
        return (i, s, n) => e({ key: i, defaultValue: s, variableValues: n })
      const t = this.gos.get('localeText')
      return (i, s, n) => {
        let r = t && t[i]
        if (r && n && n.length) {
          let o = 0
          for (; !(o >= n.length || r.indexOf('${variable}') === -1); )
            r = r.replace('${variable}', n[o++])
        }
        return r ?? s
      }
    }
  },
  IH = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'apiEventService'),
        (this.syncEventListeners = new Map()),
        (this.asyncEventListeners = new Map()),
        (this.syncGlobalEventListeners = new Set()),
        (this.globalEventListenerPairs = new Map())
    }
    postConstruct() {
      this.frameworkEventWrappingService = new id(this.getFrameworkOverrides())
    }
    addEventListener(e, t) {
      const i = this.frameworkEventWrappingService.wrap(t),
        s = Ta(this.gos) && !fa.has(e),
        n = s ? this.asyncEventListeners : this.syncEventListeners
      n.has(e) || n.set(e, new Set()),
        n.get(e).add(i),
        this.eventService.addEventListener(e, i, s)
    }
    removeEventListener(e, t) {
      var r
      const i = this.frameworkEventWrappingService.unwrap(t),
        s = this.asyncEventListeners.get(e),
        n = !!(s != null && s.delete(i))
      n || (r = this.syncEventListeners.get(e)) == null || r.delete(i),
        this.eventService.removeEventListener(e, i, n)
    }
    addGlobalListener(e) {
      const t = this.frameworkEventWrappingService.wrapGlobal(e)
      if (Ta(this.gos)) {
        const s = (r, o) => {
            fa.has(r) && t(r, o)
          },
          n = (r, o) => {
            fa.has(r) || t(r, o)
          }
        this.globalEventListenerPairs.set(e, {
          syncListener: s,
          asyncListener: n,
        }),
          this.eventService.addGlobalListener(s, !1),
          this.eventService.addGlobalListener(n, !0)
      } else
        this.syncGlobalEventListeners.add(t),
          this.eventService.addGlobalListener(t, !1)
    }
    removeGlobalListener(e) {
      const t = this.frameworkEventWrappingService.unwrapGlobal(e)
      if (this.globalEventListenerPairs.has(t)) {
        const { syncListener: s, asyncListener: n } =
          this.globalEventListenerPairs.get(t)
        this.eventService.removeGlobalListener(s, !1),
          this.eventService.removeGlobalListener(n, !0),
          this.globalEventListenerPairs.delete(e)
      } else
        this.syncGlobalEventListeners.delete(t),
          this.eventService.removeGlobalListener(t, !1)
    }
    destroyEventListeners(e, t) {
      e.forEach((i, s) => {
        i.forEach((n) => this.eventService.removeEventListener(s, n, t)),
          i.clear()
      }),
        e.clear()
    }
    destroyGlobalListeners(e, t) {
      e.forEach((i) => this.eventService.removeGlobalListener(i, t)), e.clear()
    }
    destroy() {
      super.destroy(),
        this.destroyEventListeners(this.syncEventListeners, !1),
        this.destroyEventListeners(this.asyncEventListeners, !0),
        this.destroyGlobalListeners(this.syncGlobalEventListeners, !1),
        this.globalEventListenerPairs.forEach(
          ({ syncListener: e, asyncListener: t }) => {
            this.eventService.removeGlobalListener(e, !1),
              this.eventService.removeGlobalListener(t, !0)
          },
        ),
        this.globalEventListenerPairs.clear()
    }
  },
  TH = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'pageBoundsListener')
    }
    wireBeans(e) {
      ;(this.rowModel = e.rowModel),
        (this.paginationService = e.paginationService),
        (this.pageBoundsService = e.pageBoundsService)
    }
    postConstruct() {
      this.addManagedEventListeners({
        modelUpdated: this.onModelUpdated.bind(this),
        recalculateRowBounds: this.calculatePages.bind(this),
      }),
        this.onModelUpdated()
    }
    onModelUpdated(e) {
      this.calculatePages(),
        this.eventService.dispatchEvent({
          type: 'paginationChanged',
          animate: (e == null ? void 0 : e.animate) ?? !1,
          newData: (e == null ? void 0 : e.newData) ?? !1,
          newPage: (e == null ? void 0 : e.newPage) ?? !1,
          newPageSize: (e == null ? void 0 : e.newPageSize) ?? !1,
          keepRenderedRows: (e == null ? void 0 : e.keepRenderedRows) ?? !1,
        })
    }
    calculatePages() {
      this.paginationService
        ? this.paginationService.calculatePages()
        : this.pageBoundsService.calculateBounds(
            0,
            this.rowModel.getRowCount() - 1,
          )
    }
  },
  AH = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'pageBoundsService'),
        (this.pixelOffset = 0)
    }
    wireBeans(e) {
      this.rowModel = e.rowModel
    }
    getFirstRow() {
      return this.topRowBounds ? this.topRowBounds.rowIndex : -1
    }
    getLastRow() {
      return this.bottomRowBounds ? this.bottomRowBounds.rowIndex : -1
    }
    getCurrentPageHeight() {
      return ot(this.topRowBounds) || ot(this.bottomRowBounds)
        ? 0
        : Math.max(
            this.bottomRowBounds.rowTop +
              this.bottomRowBounds.rowHeight -
              this.topRowBounds.rowTop,
            0,
          )
    }
    getCurrentPagePixelRange() {
      const e = this.topRowBounds ? this.topRowBounds.rowTop : 0,
        t = this.bottomRowBounds
          ? this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight
          : 0
      return { pageFirstPixel: e, pageLastPixel: t }
    }
    calculateBounds(e, t) {
      ;(this.topRowBounds = this.rowModel.getRowBounds(e)),
        this.topRowBounds && (this.topRowBounds.rowIndex = e),
        (this.bottomRowBounds = this.rowModel.getRowBounds(t)),
        this.bottomRowBounds && (this.bottomRowBounds.rowIndex = t),
        this.calculatePixelOffset()
    }
    getPixelOffset() {
      return this.pixelOffset
    }
    calculatePixelOffset() {
      const e = ue(this.topRowBounds) ? this.topRowBounds.rowTop : 0
      this.pixelOffset !== e &&
        ((this.pixelOffset = e),
        this.eventService.dispatchEvent({
          type: 'paginationPixelOffsetChanged',
        }))
    }
  },
  OH = class extends X {
    constructor() {
      super(),
        (this.beanName = 'ariaAnnouncementService'),
        (this.descriptionContainer = null),
        (this.pendingAnnouncements = new Map()),
        (this.updateAnnouncement = bi(this.updateAnnouncement.bind(this), 200))
    }
    wireBeans(e) {
      this.eGridDiv = e.eGridDiv
    }
    postConstruct() {
      const e = Gt(this.gos),
        t = (this.descriptionContainer = e.createElement('div'))
      t.classList.add('ag-aria-description-container'),
        Gm(t, 'polite'),
        iD(t, 'additions text'),
        tD(t, !0),
        this.eGridDiv.appendChild(t)
    }
    announceValue(e, t) {
      this.pendingAnnouncements.set(t, e), this.updateAnnouncement()
    }
    updateAnnouncement() {
      if (!this.descriptionContainer) return
      const e = Array.from(this.pendingAnnouncements.values()).join('. ')
      this.pendingAnnouncements.clear(),
        (this.descriptionContainer.textContent = ''),
        setTimeout(() => {
          this.isAlive() &&
            this.descriptionContainer &&
            (this.descriptionContainer.textContent = e)
        }, 50)
    }
    destroy() {
      super.destroy()
      const { descriptionContainer: e } = this
      e && (Ni(e), e.parentElement && e.parentElement.removeChild(e)),
        (this.descriptionContainer = null),
        (this.eGridDiv = null),
        this.pendingAnnouncements.clear()
    }
  },
  LH = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'columnAnimationService'),
        (this.executeNextFuncs = []),
        (this.executeLaterFuncs = []),
        (this.active = !1),
        (this.activeNext = !1),
        (this.suppressAnimation = !1),
        (this.animationThreadCount = 0)
    }
    wireBeans(e) {
      this.ctrlsService = e.ctrlsService
    }
    postConstruct() {
      this.ctrlsService.whenReady(
        this,
        (e) => (this.gridBodyCtrl = e.gridBodyCtrl),
      )
    }
    isActive() {
      return this.active && !this.suppressAnimation
    }
    setSuppressAnimation(e) {
      this.suppressAnimation = e
    }
    start() {
      this.active ||
        this.gos.get('suppressColumnMoveAnimation') ||
        this.gos.get('enableRtl') ||
        (this.ensureAnimationCssClassPresent(),
        (this.active = !0),
        (this.activeNext = !0))
    }
    finish() {
      this.active &&
        this.flush(
          () => (this.activeNext = !1),
          () => (this.active = !1),
        )
    }
    executeNextVMTurn(e) {
      this.activeNext ? this.executeNextFuncs.push(e) : e()
    }
    executeLaterVMTurn(e) {
      this.active ? this.executeLaterFuncs.push(e) : e()
    }
    ensureAnimationCssClassPresent() {
      this.animationThreadCount++
      const e = this.animationThreadCount
      this.gridBodyCtrl.setColumnMovingCss(!0),
        this.executeLaterFuncs.push(() => {
          this.animationThreadCount === e &&
            this.gridBodyCtrl.setColumnMovingCss(!1)
        })
    }
    flush(e, t) {
      if (
        this.executeNextFuncs.length === 0 &&
        this.executeLaterFuncs.length === 0
      ) {
        e(), t()
        return
      }
      const i = (s) => {
        for (; s.length; ) {
          const n = s.pop()
          n && n()
        }
      }
      this.getFrameworkOverrides().wrapIncoming(() => {
        window.setTimeout(() => {
          e(), i(this.executeNextFuncs)
        }, 0),
          window.setTimeout(() => {
            t(), i(this.executeLaterFuncs)
          }, 200)
      })
    }
  },
  kH = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'columnHoverService')
    }
    setMouseOver(e) {
      this.updateState(e)
    }
    clearMouseOver() {
      this.updateState(null)
    }
    isHovered(e) {
      return !!this.selectedColumns && this.selectedColumns.indexOf(e) >= 0
    }
    updateState(e) {
      ;(this.selectedColumns = e),
        this.eventService.dispatchEvent({ type: 'columnHoverChanged' })
    }
  },
  HH = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'overlayService'),
        (this.state = 0),
        (this.showInitialOverlay = !0),
        (this.wrapperPadding = 0)
    }
    wireBeans(e) {
      ;(this.userComponentFactory = e.userComponentFactory),
        (this.rowModel = e.rowModel),
        (this.columnModel = e.columnModel),
        (this.ctrlsService = e.ctrlsService)
    }
    postConstruct() {
      this.isClientSide = Pt(this.gos)
      const e = () => this.updateOverlayVisibility()
      this.addManagedEventListeners({
        newColumnsLoaded: e,
        rowDataUpdated: e,
        gridSizeChanged: this.onGridSizeChanged.bind(this),
        rowCountReady: () => {
          ;(this.showInitialOverlay = !1), this.updateOverlayVisibility()
        },
      }),
        this.addManagedPropertyListener('loading', e)
    }
    setOverlayWrapperComp(e) {
      ;(this.overlayWrapperComp = e), this.updateOverlayVisibility()
    }
    isVisible() {
      return this.state !== 0 && !!this.overlayWrapperComp
    }
    isExclusive() {
      return this.state === 1 && !!this.overlayWrapperComp
    }
    getOverlayWrapper() {
      return this.overlayWrapperComp
    }
    showLoadingOverlay() {
      this.showInitialOverlay = !1
      const e = this.gos.get('loading')
      ;(!e && (e !== void 0 || this.gos.get('suppressLoadingOverlay'))) ||
        this.doShowLoadingOverlay()
    }
    showNoRowsOverlay() {
      ;(this.showInitialOverlay = !1),
        !(this.gos.get('loading') || this.gos.get('suppressNoRowsOverlay')) &&
          this.doShowNoRowsOverlay()
    }
    hideOverlay() {
      if (((this.showInitialOverlay = !1), this.gos.get('loading'))) {
        te(
          'Since v32, `api.hideOverlay()` does not hide the loading overlay when `loading=true`. Set `loading=false` instead.',
        )
        return
      }
      this.doHideOverlay()
    }
    updateOverlayVisibility() {
      if (!this.overlayWrapperComp) {
        this.state = 0
        return
      }
      let e = this.gos.get('loading')
      this.showInitialOverlay &&
        e === void 0 &&
        !this.gos.get('suppressLoadingOverlay') &&
        (e =
          !this.gos.get('columnDefs') ||
          !this.columnModel.isReady() ||
          (!this.gos.get('rowData') && this.isClientSide)),
        e
          ? this.state !== 1 && this.doShowLoadingOverlay()
          : ((this.showInitialOverlay = !1),
            this.rowModel.isEmpty() &&
            !this.gos.get('suppressNoRowsOverlay') &&
            this.isClientSide
              ? this.state !== 2 && this.doShowNoRowsOverlay()
              : this.state !== 0 && this.doHideOverlay())
    }
    doShowLoadingOverlay() {
      this.overlayWrapperComp &&
        ((this.state = 1),
        this.showOverlay(
          this.userComponentFactory.getLoadingOverlayCompDetails({}),
          'ag-overlay-loading-wrapper',
          'loadingOverlayComponentParams',
        ),
        this.updateExclusive())
    }
    doShowNoRowsOverlay() {
      this.overlayWrapperComp &&
        ((this.state = 2),
        this.showOverlay(
          this.userComponentFactory.getNoRowsOverlayCompDetails({}),
          'ag-overlay-no-rows-wrapper',
          'noRowsOverlayComponentParams',
        ),
        this.updateExclusive())
    }
    doHideOverlay() {
      this.overlayWrapperComp &&
        ((this.state = 0),
        this.overlayWrapperComp.hideOverlay(),
        this.updateExclusive())
    }
    showOverlay(e, t, i) {
      var n
      const s = e.newAgStackInstance()
      ;(n = this.overlayWrapperComp) == null ||
        n.showOverlay(s, t, this.isExclusive(), i),
        this.refreshWrapperPadding()
    }
    updateExclusive() {
      const e = this.exclusive
      ;(this.exclusive = this.isExclusive()),
        this.exclusive !== e &&
          this.eventService.dispatchEvent({ type: 'overlayExclusiveChanged' })
    }
    onGridSizeChanged() {
      this.refreshWrapperPadding()
    }
    refreshWrapperPadding() {
      if (!this.overlayWrapperComp) return
      let e = 0
      if (this.state === 2) {
        const t = this.ctrlsService.get('gridHeaderCtrl')
        e = (t == null ? void 0 : t.getHeaderHeight()) || 0
      } else this.wrapperPadding !== 0 && (e = 0)
      this.wrapperPadding !== e &&
        ((this.wrapperPadding = e),
        this.overlayWrapperComp.updateOverlayWrapperPaddingTop(e))
    }
  },
  NH = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'rowCssClassCalculator')
    }
    wireBeans(e) {
      this.stylingService = e.stylingService
    }
    getInitialRowClasses(e) {
      const t = []
      return (
        ue(e.extraCssClass) && t.push(e.extraCssClass),
        t.push('ag-row'),
        t.push(e.rowFocused ? 'ag-row-focus' : 'ag-row-no-focus'),
        e.fadeRowIn && t.push('ag-opacity-zero'),
        t.push(e.rowIsEven ? 'ag-row-even' : 'ag-row-odd'),
        e.rowNode.isRowPinned() && t.push('ag-row-pinned'),
        e.rowNode.isSelected() && t.push('ag-row-selected'),
        e.rowNode.footer && t.push('ag-row-footer'),
        t.push('ag-row-level-' + e.rowLevel),
        e.rowNode.stub && t.push('ag-row-loading'),
        e.fullWidthRow && t.push('ag-full-width-row'),
        e.expandable &&
          (t.push('ag-row-group'),
          t.push(
            e.rowNode.expanded
              ? 'ag-row-group-expanded'
              : 'ag-row-group-contracted',
          )),
        e.rowNode.dragging && t.push('ag-row-dragging'),
        gg(t, this.processClassesFromGridOptions(e.rowNode)),
        gg(t, this.preProcessRowClassRules(e.rowNode)),
        t.push(
          e.printLayout
            ? 'ag-row-position-relative'
            : 'ag-row-position-absolute',
        ),
        e.firstRowOnPage && t.push('ag-row-first'),
        e.lastRowOnPage && t.push('ag-row-last'),
        e.fullWidthRow &&
          (e.pinned === 'left' && t.push('ag-cell-last-left-pinned'),
          e.pinned === 'right' && t.push('ag-cell-first-right-pinned')),
        t
      )
    }
    processClassesFromGridOptions(e) {
      const t = [],
        i = (r) => {
          typeof r == 'string'
            ? t.push(r)
            : Array.isArray(r) && r.forEach((o) => t.push(o))
        },
        s = this.gos.get('rowClass')
      if (s) {
        if (typeof s == 'function')
          return (
            te(
              'rowClass should not be a function, please use getRowClass instead',
            ),
            []
          )
        i(s)
      }
      const n = this.gos.getCallback('getRowClass')
      if (n) {
        const r = { data: e.data, node: e, rowIndex: e.rowIndex },
          o = n(r)
        i(o)
      }
      return t
    }
    preProcessRowClassRules(e) {
      const t = []
      return (
        this.processRowClassRules(
          e,
          (i) => {
            t.push(i)
          },
          () => {},
        ),
        t
      )
    }
    processRowClassRules(e, t, i) {
      const s = this.gos.addGridCommonParams({
        data: e.data,
        node: e,
        rowIndex: e.rowIndex,
      })
      this.stylingService.processClassRules(
        void 0,
        this.gos.get('rowClassRules'),
        s,
        t,
        i,
      )
    }
    calculateRowLevel(e) {
      return e.group ? e.level : e.parent ? e.parent.level + 1 : 0
    }
  },
  GH = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'rowContainerHeightService'),
        (this.scrollY = 0),
        (this.uiBodyHeight = 0)
    }
    wireBeans(e) {
      this.ctrlsService = e.ctrlsService
    }
    postConstruct() {
      this.addManagedEventListeners({
        bodyHeightChanged: this.updateOffset.bind(this),
      }),
        (this.maxDivHeight = gD()),
        this.gos.get('debug') &&
          Xi('RowContainerHeightService - maxDivHeight = ' + this.maxDivHeight)
    }
    isStretching() {
      return this.stretching
    }
    getDivStretchOffset() {
      return this.divStretchOffset
    }
    updateOffset() {
      if (!this.stretching) return
      const t = this.ctrlsService
          .getGridBodyCtrl()
          .getScrollFeature()
          .getVScrollPosition().top,
        i = this.getUiBodyHeight()
      ;(t !== this.scrollY || i !== this.uiBodyHeight) &&
        ((this.scrollY = t), (this.uiBodyHeight = i), this.calculateOffset())
    }
    calculateOffset() {
      this.setUiContainerHeight(this.maxDivHeight),
        (this.pixelsToShave = this.modelHeight - this.uiContainerHeight),
        (this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight)
      const e = this.scrollY / this.maxScrollY,
        t = e * this.pixelsToShave
      this.gos.get('debug') &&
        Xi(
          `RowContainerHeightService - Div Stretch Offset = ${t} (${this.pixelsToShave} * ${e})`,
        ),
        this.setDivStretchOffset(t)
    }
    setUiContainerHeight(e) {
      e !== this.uiContainerHeight &&
        ((this.uiContainerHeight = e),
        this.eventService.dispatchEvent({ type: 'rowContainerHeightChanged' }))
    }
    clearOffset() {
      this.setUiContainerHeight(this.modelHeight),
        (this.pixelsToShave = 0),
        this.setDivStretchOffset(0)
    }
    setDivStretchOffset(e) {
      const t = typeof e == 'number' ? Math.floor(e) : null
      this.divStretchOffset !== t &&
        ((this.divStretchOffset = t),
        this.eventService.dispatchEvent({ type: 'heightScaleChanged' }))
    }
    setModelHeight(e) {
      ;(this.modelHeight = e),
        (this.stretching =
          e != null && this.maxDivHeight > 0 && e > this.maxDivHeight),
        this.stretching ? this.calculateOffset() : this.clearOffset()
    }
    getUiContainerHeight() {
      return this.uiContainerHeight
    }
    getRealPixelPosition(e) {
      return e - this.divStretchOffset
    }
    getUiBodyHeight() {
      const t = this.ctrlsService
        .getGridBodyCtrl()
        .getScrollFeature()
        .getVScrollPosition()
      return t.bottom - t.top
    }
    getScrollPositionForPixel(e) {
      if (this.pixelsToShave <= 0) return e
      const t = this.modelHeight - this.getUiBodyHeight(),
        i = e / t
      return this.maxScrollY * i
    }
  },
  BH = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'rowNodeSorter')
    }
    wireBeans(e) {
      ;(this.valueService = e.valueService),
        (this.columnModel = e.columnModel),
        (this.showRowGroupColsService = e.showRowGroupColsService)
    }
    postConstruct() {
      ;(this.isAccentedSort = this.gos.get('accentedSort')),
        (this.primaryColumnsSortGroups = cs(this.gos)),
        this.addManagedPropertyListener(
          'accentedSort',
          (e) => (this.isAccentedSort = e.currentValue),
        ),
        this.addManagedPropertyListener(
          'autoGroupColumnDef',
          () => (this.primaryColumnsSortGroups = cs(this.gos)),
        )
    }
    doFullSort(e, t) {
      const i = (n, r) => ({ currentPos: r, rowNode: n }),
        s = e.map(i)
      return s.sort(this.compareRowNodes.bind(this, t)), s.map((n) => n.rowNode)
    }
    compareRowNodes(e, t, i) {
      const s = t.rowNode,
        n = i.rowNode
      for (let r = 0, o = e.length; r < o; r++) {
        const a = e[r],
          l = a.sort === 'desc',
          c = this.getValue(s, a.column),
          u = this.getValue(n, a.column)
        let h
        const g = this.getComparator(a, s)
        if (
          (g ? (h = g(c, u, s, n, l)) : (h = dx(c, u, this.isAccentedSort)),
          !isNaN(h) && h !== 0)
        )
          return a.sort === 'asc' ? h : h * -1
      }
      return t.currentPos - i.currentPos
    }
    getComparator(e, t) {
      const i = e.column,
        s = i.getColDef().comparator
      if (s != null) return s
      if (!i.getColDef().showRowGroup) return
      const n = !t.group && i.getColDef().field
      if (!n) return
      const r = this.columnModel.getColDefCol(n)
      if (r) return r.getColDef().comparator
    }
    getValue(e, t) {
      var s, n, r
      if (!this.primaryColumnsSortGroups)
        return this.valueService.getValue(t, e, !1, !1)
      if (e.rowGroupColumn === t) {
        if (pl(this.gos, this.columnModel.isPivotActive())) {
          const l = (s = e.allLeafChildren) == null ? void 0 : s[0]
          return l ? this.valueService.getValue(t, l, !1, !1) : void 0
        }
        const a =
          (n = this.showRowGroupColsService) == null
            ? void 0
            : n.getShowRowGroupCol(t.getId())
        return a ? ((r = e.groupData) == null ? void 0 : r[a.getId()]) : void 0
      }
      if (!(e.group && t.getColDef().showRowGroup))
        return this.valueService.getValue(t, e, !1, !1)
    }
  },
  yl = class {
    constructor(e, t) {
      ;(this.active = !0),
        (this.nodeIdsToColumns = {}),
        (this.mapToItems = {}),
        (this.keepingColumns = e),
        (this.pathRoot = { rowNode: t, children: null }),
        (this.mapToItems[t.id] = this.pathRoot)
    }
    setInactive() {
      this.active = !1
    }
    isActive() {
      return this.active
    }
    depthFirstSearchChangedPath(e, t) {
      if (e.children)
        for (let i = 0; i < e.children.length; i++)
          this.depthFirstSearchChangedPath(e.children[i], t)
      t(e.rowNode)
    }
    depthFirstSearchEverything(e, t, i) {
      if (e.childrenAfterGroup)
        for (let s = 0; s < e.childrenAfterGroup.length; s++) {
          const n = e.childrenAfterGroup[s]
          n.childrenAfterGroup
            ? this.depthFirstSearchEverything(e.childrenAfterGroup[s], t, i)
            : i && t(n)
        }
      t(e)
    }
    forEachChangedNodeDepthFirst(e, t = !1, i = !1) {
      this.active && !i
        ? this.depthFirstSearchChangedPath(this.pathRoot, e)
        : this.depthFirstSearchEverything(this.pathRoot.rowNode, e, t)
    }
    executeFromRootNode(e) {
      e(this.pathRoot.rowNode)
    }
    createPathItems(e) {
      let t = e,
        i = 0
      for (; !this.mapToItems[t.id]; ) {
        const s = { rowNode: t, children: null }
        ;(this.mapToItems[t.id] = s), i++, (t = t.parent)
      }
      return i
    }
    populateColumnsMap(e, t) {
      if (!this.keepingColumns || !t) return
      let i = e
      for (; i; )
        this.nodeIdsToColumns[i.id] || (this.nodeIdsToColumns[i.id] = {}),
          t.forEach((s) => (this.nodeIdsToColumns[i.id][s.getId()] = !0)),
          (i = i.parent)
    }
    linkPathItems(e, t) {
      let i = e
      for (let s = 0; s < t; s++) {
        const n = this.mapToItems[i.id],
          r = this.mapToItems[i.parent.id]
        r.children || (r.children = []), r.children.push(n), (i = i.parent)
      }
    }
    addParentNode(e, t) {
      if (!e || e.isRowPinned()) return
      const i = this.createPathItems(e)
      this.linkPathItems(e, i), this.populateColumnsMap(e, t)
    }
    canSkip(e) {
      return this.active && !this.mapToItems[e.id]
    }
    getValueColumnsForNode(e, t) {
      if (!this.keepingColumns) return t
      const i = this.nodeIdsToColumns[e.id]
      return t.filter((n) => i[n.getId()])
    }
    getNotValueColumnsForNode(e, t) {
      if (!this.keepingColumns) return null
      const i = this.nodeIdsToColumns[e.id]
      return t.filter((n) => !i[n.getId()])
    }
  },
  oC = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'selectionService'),
        (this.selectedNodes = new Map()),
        (this.selectionCtx = new $A()),
        (this.rowSelectionMode = void 0)
    }
    wireBeans(e) {
      ;(this.rowModel = e.rowModel),
        (this.pageBoundsService = e.pageBoundsService)
    }
    postConstruct() {
      const { gos: e, rowModel: t, onRowSelected: i } = this
      this.selectionCtx.init(t),
        (this.rowSelectionMode = Oa(e)),
        (this.groupSelectsChildren = Gn(e)),
        this.addManagedPropertyListeners(
          ['groupSelectsChildren', 'rowSelection'],
          () => {
            const s = Gn(e),
              n = Oa(e)
            ;(s !== this.groupSelectsChildren || n !== this.rowSelectionMode) &&
              ((this.groupSelectsChildren = s),
              (this.rowSelectionMode = n),
              this.deselectAllRowNodes({ source: 'api' }))
          },
        ),
        this.addManagedEventListeners({ rowSelected: i.bind(this) })
    }
    destroy() {
      super.destroy(), this.resetNodes(), this.selectionCtx.reset()
    }
    isMultiSelect() {
      return this.rowSelectionMode === 'multiRow'
    }
    overrideSelectionValue(e, t) {
      if (!FH(t)) return e
      const i = this.selectionCtx.getRoot()
      return i ? (i.isSelected() ?? !1) : !0
    }
    setNodesSelected(e) {
      var h
      const {
        newValue: t,
        clearSelection: i,
        suppressFinishActions: s,
        rangeSelect: n,
        nodes: r,
        event: o,
        source: a,
      } = e
      if (r.length === 0) return 0
      if (r.length > 1 && !this.isMultiSelect())
        return te("cannot multi select unless selection mode is 'multiRow'"), 0
      const l = this.groupSelectsChildren && e.groupSelectsFiltered === !0,
        c = r.map((g) => (g.footer ? g.sibling : g))
      if (n) {
        if (c.length > 1)
          return te('cannot range select while selecting multiple rows'), 0
        const g = c[0],
          f = this.overrideSelectionValue(t, a)
        if (this.isMultiSelect()) {
          if (this.selectionCtx.isInRange(g)) {
            const p = this.selectionCtx.truncate(g)
            return (
              f && this.selectRange(p.discard, !1, a),
              this.selectRange(p.keep, f, a)
            )
          } else if (this.selectionCtx.getRoot() !== g) {
            const m = this.selectionCtx.extend(g, this.groupSelectsChildren)
            return (
              f && this.selectRange(m.discard, !1, a),
              this.selectRange(m.keep, f, a)
            )
          }
        }
      }
      s || this.selectionCtx.setRoot(c[0])
      let u = 0
      for (let g = 0; g < c.length; g++) {
        const f = c[g]
        ;(l && f.group) || (f.selectThisNode(t, o, a) && u++),
          this.groupSelectsChildren &&
            (h = f.childrenAfterGroup) != null &&
            h.length &&
            (u += this.selectChildren(f, t, l, a))
      }
      return (
        s ||
          (t &&
            (i || !this.isMultiSelect()) &&
            (u += this.clearOtherNodes(c[0], a)),
          u > 0 &&
            (this.updateGroupsFromChildrenSelections(a),
            this.dispatchSelectionChanged(a))),
        u
      )
    }
    selectRange(e, t, i) {
      let s = 0
      return (
        e.forEach((n) => {
          if (n.group && this.groupSelectsChildren) return
          n.selectThisNode(t, void 0, i) && s++
        }),
        s > 0 &&
          (this.updateGroupsFromChildrenSelections(i),
          this.dispatchSelectionChanged(i)),
        s
      )
    }
    selectChildren(e, t, i, s) {
      const n = i ? e.childrenAfterAggFilter : e.childrenAfterGroup
      return ot(n)
        ? 0
        : this.setNodesSelected({
            newValue: t,
            clearSelection: !1,
            suppressFinishActions: !0,
            groupSelectsFiltered: i,
            source: s,
            nodes: n,
          })
    }
    getSelectedNodes() {
      const e = []
      return (
        this.selectedNodes.forEach((t) => {
          t && e.push(t)
        }),
        e
      )
    }
    getSelectedRows() {
      const e = []
      return (
        this.selectedNodes.forEach((t) => {
          t && t.data && e.push(t.data)
        }),
        e
      )
    }
    getSelectionCount() {
      return this.selectedNodes.size
    }
    filterFromSelection(e) {
      const t = new Map()
      this.selectedNodes.forEach((i, s) => {
        i && e(i) && t.set(s, i)
      }),
        (this.selectedNodes = t)
    }
    updateGroupsFromChildrenSelections(e, t) {
      if (!this.groupSelectsChildren || !Pt(this.gos)) return !1
      const s = this.rowModel.getRootNode()
      t || ((t = new yl(!0, s)), t.setInactive())
      let n = !1
      return (
        t.forEachChangedNodeDepthFirst((r) => {
          if (r !== s) {
            const o = r.calculateSelectedFromChildren()
            n = r.selectThisNode(o === null ? !1 : o, void 0, e) || n
          }
        }),
        n
      )
    }
    clearOtherNodes(e, t) {
      const i = new Map()
      let s = 0
      return (
        this.selectedNodes.forEach((n) => {
          if (n && n.id !== e.id) {
            const r = this.selectedNodes.get(n.id)
            ;(s += r.setSelectedParams({
              newValue: !1,
              clearSelection: !1,
              suppressFinishActions: !0,
              source: t,
            })),
              this.groupSelectsChildren &&
                n.parent &&
                i.set(n.parent.id, n.parent)
          }
        }),
        i.forEach((n) => {
          const r = n.calculateSelectedFromChildren()
          n.selectThisNode(r === null ? !1 : r, void 0, t)
        }),
        s
      )
    }
    onRowSelected(e) {
      const t = e.node
      ;(this.groupSelectsChildren && t.group) ||
        (t.isSelected()
          ? this.selectedNodes.set(t.id, t)
          : this.selectedNodes.delete(t.id))
    }
    syncInRowNode(e, t) {
      this.syncInOldRowNode(e, t), this.syncInNewRowNode(e)
    }
    syncInOldRowNode(e, t) {
      if (ue(t) && e.id !== t.id && t) {
        const s = t.id
        this.selectedNodes.get(s) == e && this.selectedNodes.set(t.id, t)
      }
    }
    syncInNewRowNode(e) {
      this.selectedNodes.has(e.id)
        ? (e.setSelectedInitialValue(!0), this.selectedNodes.set(e.id, e))
        : e.setSelectedInitialValue(!1)
    }
    reset(e) {
      const t = this.getSelectionCount()
      this.resetNodes(), t && this.dispatchSelectionChanged(e)
    }
    resetNodes() {
      var e
      ;(e = this.selectedNodes) == null || e.clear()
    }
    getBestCostNodeSelection() {
      if (!Pt(this.gos)) return
      const t = this.rowModel.getTopLevelNodes()
      if (t === null) return
      const i = []
      function s(n) {
        for (let r = 0, o = n.length; r < o; r++) {
          const a = n[r]
          if (a.isSelected()) i.push(a)
          else {
            const l = a
            l.group && l.children && s(l.children)
          }
        }
      }
      return s(t), i
    }
    isEmpty() {
      let e = 0
      return (
        this.selectedNodes.forEach((t) => {
          t && e++
        }),
        e === 0
      )
    }
    deselectAllRowNodes(e) {
      const t = (o) => o.selectThisNode(!1, void 0, s),
        i = Pt(this.gos),
        { source: s, justFiltered: n, justCurrentPage: r } = e
      if (r || n) {
        if (!i) {
          ht(
            "selecting just filtered only works when gridOptions.rowModelType='clientSide'",
          )
          return
        }
        this.getNodesToSelect(n, r).forEach(t)
      } else
        this.selectedNodes.forEach((o) => {
          o && t(o)
        }),
          this.reset(s)
      this.selectionCtx.reset(),
        i &&
          this.groupSelectsChildren &&
          this.updateGroupsFromChildrenSelections(s),
        this.dispatchSelectionChanged(s)
    }
    getSelectedCounts(e, t) {
      let i = 0,
        s = 0
      const n = (r) => {
        ;(this.groupSelectsChildren && r.group) ||
          (r.isSelected() ? i++ : r.selectable && s++)
      }
      return (
        this.getNodesToSelect(e, t).forEach(n),
        { selectedCount: i, notSelectedCount: s }
      )
    }
    getSelectAllState(e, t) {
      const { selectedCount: i, notSelectedCount: s } = this.getSelectedCounts(
        e,
        t,
      )
      return i === 0 && s === 0 ? !1 : i > 0 && s > 0 ? null : i > 0
    }
    hasNodesToSelect(e = !1, t = !1) {
      return this.getNodesToSelect(e, t).filter((i) => i.selectable).length > 0
    }
    getNodesToSelect(e = !1, t = !1) {
      this.validateSelectAllType()
      const i = []
      if (t)
        return (
          this.forEachNodeOnPage((n) => {
            if (!n.group) {
              i.push(n)
              return
            }
            if (!n.expanded) {
              const r = (o) => {
                var a
                i.push(o),
                  (a = o.childrenAfterFilter) != null &&
                    a.length &&
                    o.childrenAfterFilter.forEach(r)
              }
              r(n)
              return
            }
            this.groupSelectsChildren || i.push(n)
          }),
          i
        )
      const s = this.rowModel
      return e
        ? (s.forEachNodeAfterFilter((n) => {
            i.push(n)
          }),
          i)
        : (s.forEachNode((n) => {
            i.push(n)
          }),
          i)
    }
    forEachNodeOnPage(e) {
      const t = this.pageBoundsService.getFirstRow(),
        i = this.pageBoundsService.getLastRow()
      for (let s = t; s <= i; s++) {
        const n = this.rowModel.getRow(s)
        n && e(n)
      }
    }
    selectAllRowNodes(e) {
      if (px(this.gos) && !Fm(this.gos))
        return te("cannot multi select unless selection mode is 'multiRow'")
      this.validateSelectAllType()
      const { source: t, justFiltered: i, justCurrentPage: s } = e,
        n = this.getNodesToSelect(i, s)
      n.forEach((r) => r.selectThisNode(!0, void 0, t)),
        this.selectionCtx.setRoot(n[0] ?? null),
        this.selectionCtx.setEndRange(rt(n) ?? null),
        Pt(this.gos) &&
          this.groupSelectsChildren &&
          this.updateGroupsFromChildrenSelections(t),
        this.dispatchSelectionChanged(t)
    }
    getSelectionState() {
      const e = []
      return (
        this.selectedNodes.forEach((t) => {
          t != null && t.id && e.push(t.id)
        }),
        e.length ? e : null
      )
    }
    setSelectionState(e, t) {
      if (!Array.isArray(e))
        return ht(
          'Invalid selection state. When using client-side row model, the state must conform to `string[]`.',
        )
      const i = new Set(e),
        s = []
      this.rowModel.forEachNode((n) => {
        i.has(n.id) && s.push(n)
      }),
        this.setNodesSelected({ newValue: !0, nodes: s, source: t })
    }
    dispatchSelectionChanged(e) {
      this.eventService.dispatchEvent({ type: 'selectionChanged', source: e })
    }
    validateSelectAllType() {
      if (!Pt(this.gos))
        throw new Error(
          `selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`,
        )
    }
  },
  VH = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'selectableService')
    }
    wireBeans(e) {
      ;(this.rowModel = e.rowModel),
        (this.selectionService = e.selectionService)
    }
    postConstruct() {
      this.addManagedPropertyListeners(
        ['isRowSelectable', 'rowSelection'],
        () => this.updateSelectable(),
      )
    }
    updateSelectableAfterGrouping() {
      this.updateSelectable(!0)
    }
    updateSelectable(e = !1) {
      const { gos: t } = this,
        i = Ia(t),
        s = Zu(t)
      if (!i || !s) return
      const n = Gn(t),
        r = Pt(t) && n,
        o = [],
        a = (l) => {
          if (e && !l.group) return
          if (r && l.group) {
            const u = l.childrenAfterGroup.some((h) => h.selectable === !0)
            l.setRowSelectable(u, !0)
            return
          }
          const c = (s == null ? void 0 : s(l)) ?? !0
          l.setRowSelectable(c, !0), !c && l.isSelected() && o.push(l)
        }
      if (r) {
        const l = this.rowModel
        new yl(!1, l.getRootNode()).forEachChangedNodeDepthFirst(a, !0, !0)
      } else this.rowModel.forEachNode(a)
      o.length &&
        this.selectionService.setNodesSelected({
          nodes: o,
          newValue: !1,
          source: 'selectableChanged',
        }),
        r &&
          this.selectionService instanceof oC &&
          this.selectionService.updateGroupsFromChildrenSelections(
            'selectableChanged',
          )
    }
  },
  Hg = ['asc', 'desc', null],
  _H = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'sortController')
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.funcColsService = e.funcColsService),
        (this.showRowGroupColsService = e.showRowGroupColsService)
    }
    progressSort(e, t, i) {
      const s = this.getNextSortDirection(e)
      this.setSortForColumn(e, s, t, i)
    }
    setSortForColumn(e, t, i, s) {
      t !== 'asc' && t !== 'desc' && (t = null)
      const n = cs(this.gos)
      let r = [e]
      if (n && e.getColDef().showRowGroup) {
        const l = this.funcColsService.getSourceColumnsForGroupColumn(e),
          c = l == null ? void 0 : l.filter((u) => u.isSortable())
        c && (r = [e, ...c])
      }
      r.forEach((l) => l.setSort(t, s))
      const o =
          (i || this.gos.get('alwaysMultiSort')) &&
          !this.gos.get('suppressMultiSort'),
        a = []
      if (!o) {
        const l = this.clearSortBarTheseColumns(r, s)
        a.push(...l)
      }
      this.updateSortIndex(e),
        a.push(...r),
        this.dispatchSortChangedEvents(s, a)
    }
    updateSortIndex(e) {
      var a
      const t = cs(this.gos),
        i =
          (a = this.showRowGroupColsService) == null
            ? void 0
            : a.getShowRowGroupCol(e.getId()),
        s = (t && i) || e,
        n = this.getColumnsWithSortingOrdered()
      this.columnModel.getAllCols().forEach((l) => l.setSortIndex(null))
      const r = n.filter((l) =>
        t && l.getColDef().showRowGroup ? !1 : l !== s,
      )
      ;(s.getSort() ? [...r, s] : r).forEach((l, c) => {
        l.setSortIndex(c)
      })
    }
    onSortChanged(e, t) {
      this.dispatchSortChangedEvents(e, t)
    }
    isSortActive() {
      const t = this.columnModel.getAllCols().filter((i) => !!i.getSort())
      return t && t.length > 0
    }
    dispatchSortChangedEvents(e, t) {
      const i = { type: 'sortChanged', source: e }
      t && (i.columns = t), this.eventService.dispatchEvent(i)
    }
    clearSortBarTheseColumns(e, t) {
      const i = []
      return (
        this.columnModel.getAllCols().forEach((s) => {
          e.includes(s) || (s.getSort() && i.push(s), s.setSort(void 0, t))
        }),
        i
      )
    }
    getNextSortDirection(e) {
      let t
      if (
        (e.getColDef().sortingOrder
          ? (t = e.getColDef().sortingOrder)
          : this.gos.get('sortingOrder')
            ? (t = this.gos.get('sortingOrder'))
            : (t = Hg),
        !Array.isArray(t) || t.length <= 0)
      )
        return (
          te(
            `sortingOrder must be an array with at least one element, currently it's ${t}`,
          ),
          null
        )
      const i = t.indexOf(e.getSort()),
        s = i < 0,
        n = i == t.length - 1
      let r
      return (
        s || n ? (r = t[0]) : (r = t[i + 1]),
        Hg.indexOf(r) < 0 ? (te('invalid sort type ', r), null) : r
      )
    }
    getIndexedSortMap() {
      let e = this.columnModel.getAllCols().filter((r) => !!r.getSort())
      if (this.columnModel.isPivotMode()) {
        const r = cs(this.gos)
        e = e.filter((o) => {
          var u
          const a = !!o.getAggFunc(),
            l = !o.isPrimary(),
            c = r
              ? (u = this.showRowGroupColsService) == null
                ? void 0
                : u.getShowRowGroupCol(o.getId())
              : o.getColDef().showRowGroup
          return a || l || c
        })
      }
      const t = this.funcColsService
          .getRowGroupColumns()
          .filter((r) => !!r.getSort()),
        i = {}
      e.forEach((r, o) => (i[r.getId()] = o)),
        e.sort((r, o) => {
          const a = r.getSortIndex(),
            l = o.getSortIndex()
          if (a != null && l != null) return a - l
          if (a == null && l == null) {
            const c = i[r.getId()],
              u = i[o.getId()]
            return c > u ? 1 : -1
          } else return l == null ? -1 : 1
        })
      const s = cs(this.gos) && !!t.length
      s &&
        (e = [
          ...new Set(
            e.map((r) => {
              var o
              return (
                ((o = this.showRowGroupColsService) == null
                  ? void 0
                  : o.getShowRowGroupCol(r.getId())) ?? r
              )
            }),
          ),
        ])
      const n = new Map()
      return (
        e.forEach((r, o) => n.set(r, o)),
        s &&
          t.forEach((r) => {
            const o = this.showRowGroupColsService.getShowRowGroupCol(r.getId())
            n.set(r, n.get(o))
          }),
        n
      )
    }
    getColumnsWithSortingOrdered() {
      return [...this.getIndexedSortMap().entries()]
        .sort(([e, t], [i, s]) => t - s)
        .map(([e]) => e)
    }
    getSortModel() {
      return this.getColumnsWithSortingOrdered()
        .filter((e) => e.getSort())
        .map((e) => ({ sort: e.getSort(), colId: e.getId() }))
    }
    getSortOptions() {
      return this.getColumnsWithSortingOrdered()
        .filter((e) => e.getSort())
        .map((e) => ({ sort: e.getSort(), column: e }))
    }
    canColumnDisplayMixedSort(e) {
      const t = cs(this.gos),
        i = !!e.getColDef().showRowGroup
      return t && i
    }
    getDisplaySortForColumn(e) {
      const t = this.funcColsService.getSourceColumnsForGroupColumn(e)
      if (!this.canColumnDisplayMixedSort(e) || !(t != null && t.length))
        return e.getSort()
      const s =
          e.getColDef().field != null || !!e.getColDef().valueGetter
            ? [e, ...t]
            : t,
        n = s[0].getSort()
      return s.every((o) => o.getSort() == n) ? n : 'mixed'
    }
    getDisplaySortIndexForColumn(e) {
      return this.getIndexedSortMap().get(e)
    }
  },
  WH = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'syncService'),
        (this.waitingForColumns = !1)
    }
    wireBeans(e) {
      ;(this.ctrlsService = e.ctrlsService),
        (this.columnModel = e.columnModel),
        (this.rowModel = e.rowModel)
    }
    postConstruct() {
      this.addManagedPropertyListener('columnDefs', (e) =>
        this.setColumnDefs(e),
      )
    }
    start() {
      this.ctrlsService.whenReady(this, () => {
        const e = this.gos.get('columnDefs')
        e ? this.setColumnsAndData(e) : (this.waitingForColumns = !0),
          this.gridReady()
      })
    }
    setColumnsAndData(e) {
      this.columnModel.setColumnDefs(e ?? [], 'gridInitializing'),
        this.rowModel.start()
    }
    gridReady() {
      this.eventService.dispatchEvent({ type: 'gridReady' })
      const e = this.gos.isModuleRegistered('@ag-grid-enterprise/core')
      this.gos.get('debug') && Xi(`initialised successfully, enterprise = ${e}`)
    }
    setColumnDefs(e) {
      const t = this.gos.get('columnDefs')
      if (t) {
        if (this.waitingForColumns) {
          ;(this.waitingForColumns = !1), this.setColumnsAndData(t)
          return
        }
        this.columnModel.setColumnDefs(t, bn(e.source))
      }
    }
  },
  $H = 'paste',
  zH = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'changeDetectionService')
    }
    wireBeans(e) {
      ;(this.rowModel = e.rowModel), (this.rowRenderer = e.rowRenderer)
    }
    postConstruct() {
      Pt(this.gos) && (this.clientSideRowModel = this.rowModel),
        this.addManagedEventListeners({
          cellValueChanged: this.onCellValueChanged.bind(this),
        })
    }
    onCellValueChanged(e) {
      e.source !== $H && this.doChangeDetection(e.node, e.column)
    }
    doChangeDetection(e, t) {
      if (this.gos.get('suppressChangeDetection')) return
      const i = [e]
      if (this.clientSideRowModel && !e.isRowPinned()) {
        const s = this.gos.get('aggregateOnlyChangedColumns'),
          n = new yl(s, this.clientSideRowModel.getRootNode())
        n.addParentNode(e.parent, [t]),
          this.clientSideRowModel.doAggregate(n),
          n.forEachChangedNodeDepthFirst((r) => {
            i.push(r)
          })
      }
      this.rowRenderer.refreshCells({ rowNodes: i })
    }
  },
  UH = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'expressionService'),
        (this.expressionToFunctionCache = {})
    }
    evaluate(e, t) {
      if (typeof e == 'string') return this.evaluateExpression(e, t)
      ht('value should be either a string or a function', e)
    }
    evaluateExpression(e, t) {
      try {
        return this.createExpressionFunction(e)(
          t.value,
          t.context,
          t.oldValue,
          t.newValue,
          t.value,
          t.node,
          t.data,
          t.colDef,
          t.rowIndex,
          t.api,
          t.getValue,
          t.column,
          t.columnGroup,
        )
      } catch (i) {
        return (
          Xi('Processing of the expression failed'),
          Xi('Expression = ', e),
          Xi('Params = ', t),
          Xi('Exception = ', i),
          null
        )
      }
    }
    createExpressionFunction(e) {
      if (this.expressionToFunctionCache[e])
        return this.expressionToFunctionCache[e]
      const t = this.createFunctionBody(e),
        i = new Function(
          'x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, getValue, column, columnGroup',
          t,
        )
      return (this.expressionToFunctionCache[e] = i), i
    }
    createFunctionBody(e) {
      return e.indexOf('return') >= 0 ? e : 'return ' + e + ';'
    }
  },
  jH = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'valueCache'),
        (this.cacheVersion = 0)
    }
    postConstruct() {
      ;(this.active = this.gos.get('valueCache')),
        (this.neverExpires = this.gos.get('valueCacheNeverExpires'))
    }
    onDataChanged() {
      this.neverExpires || this.expire()
    }
    expire() {
      this.cacheVersion++
    }
    setValue(e, t, i) {
      this.active &&
        (e.__cacheVersion !== this.cacheVersion &&
          ((e.__cacheVersion = this.cacheVersion), (e.__cacheData = {})),
        (e.__cacheData[t] = i))
    }
    getValue(e, t) {
      if (!(!this.active || e.__cacheVersion !== this.cacheVersion))
        return e.__cacheData[t]
    }
  },
  YH = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'valueService'),
        (this.initialised = !1),
        (this.isSsrm = !1)
    }
    wireBeans(e) {
      ;(this.expressionService = e.expressionService),
        (this.columnModel = e.columnModel),
        (this.valueCache = e.valueCache),
        (this.dataTypeService = e.dataTypeService)
    }
    postConstruct() {
      this.initialised || this.init()
    }
    init() {
      ;(this.isSsrm = ms(this.gos)),
        (this.cellExpressions = this.gos.get('enableCellExpressions')),
        (this.isTreeData = this.gos.get('treeData')),
        (this.initialised = !0)
      const e = (i) => this.callColumnCellValueChangedHandler(i),
        t = Ta(this.gos)
      this.eventService.addEventListener('cellValueChanged', e, t),
        this.addDestroyFunc(() =>
          this.eventService.removeEventListener('cellValueChanged', e, t),
        ),
        this.addManagedPropertyListener(
          'treeData',
          (i) => (this.isTreeData = i.currentValue),
        )
    }
    getValueForDisplay(e, t) {
      const i = t.leafGroup && this.columnModel.isPivotMode(),
        s = t.group && t.expanded && !t.footer && !i,
        n = this.gos.get('groupSuppressBlankHeader')
      if (!s || n) return this.getValue(e, t)
      let r = !1
      const o =
        this.gos.get('groupTotalRow') ?? this.gos.get('groupIncludeFooter')
      typeof o != 'function'
        ? (r = !!o)
        : (r = !!(
            this.gos.getCallback('groupTotalRow') ??
            this.gos.getCallback('groupIncludeFooter')
          )({ node: this }))
      const a = s && r
      return this.getValue(e, t, !1, a)
    }
    getValue(e, t, i = !1, s = !1) {
      if ((this.initialised || this.init(), !t)) return
      const n = e.getColDef(),
        r = n.field,
        o = e.getColId(),
        a = t.data
      let l
      const c = t.groupData && t.groupData[o] !== void 0,
        u = !s && t.aggData && t.aggData[o] !== void 0,
        h = this.isSsrm && s && !!e.getColDef().aggFunc,
        g =
          this.isSsrm &&
          t.footer &&
          t.field &&
          (e.getColDef().showRowGroup === !0 ||
            e.getColDef().showRowGroup === t.field)
      if (
        (i && n.filterValueGetter
          ? (l = this.executeFilterValueGetter(n.filterValueGetter, a, e, t))
          : this.isTreeData && u
            ? (l = t.aggData[o])
            : this.isTreeData && n.valueGetter
              ? (l = this.executeValueGetter(n.valueGetter, a, e, t))
              : this.isTreeData && r && a
                ? (l = ro(a, r, e.isFieldContainsDots()))
                : c
                  ? (l = t.groupData[o])
                  : u
                    ? (l = t.aggData[o])
                    : n.valueGetter
                      ? (l = this.executeValueGetter(n.valueGetter, a, e, t))
                      : g
                        ? (l = ro(a, t.field, e.isFieldContainsDots()))
                        : r &&
                          a &&
                          !h &&
                          (l = ro(a, r, e.isFieldContainsDots())),
        this.cellExpressions && typeof l == 'string' && l.indexOf('=') === 0)
      ) {
        const f = l.substring(1)
        l = this.executeValueGetter(f, a, e, t)
      }
      if (l == null) {
        const f = this.getOpenedGroup(t, e)
        if (f != null) return f
      }
      return l
    }
    parseValue(e, t, i, s) {
      const n = e.getColDef(),
        r = n.valueParser
      if (ue(r)) {
        const o = this.gos.addGridCommonParams({
          node: t,
          data: t == null ? void 0 : t.data,
          oldValue: s,
          newValue: i,
          colDef: n,
          column: e,
        })
        return typeof r == 'function'
          ? r(o)
          : this.expressionService.evaluate(r, o)
      }
      return i
    }
    getDeleteValue(e, t) {
      return ue(e.getColDef().valueParser)
        ? (this.parseValue(e, t, '', this.getValueForDisplay(e, t)) ?? null)
        : null
    }
    formatValue(e, t, i, s, n = !0) {
      let r = null,
        o
      const a = e.getColDef()
      if ((s ? (o = s) : n && (o = a.valueFormatter), o)) {
        const l = this.gos.addGridCommonParams({
          value: i,
          node: t,
          data: t ? t.data : null,
          colDef: a,
          column: e,
        })
        typeof o == 'function'
          ? (r = o(l))
          : (r = this.expressionService.evaluate(o, l))
      } else if (a.refData) return a.refData[i] || ''
      return r == null && Array.isArray(i) && (r = i.join(', ')), r
    }
    getOpenedGroup(e, t) {
      if (!this.gos.get('showOpenedGroup') || !t.getColDef().showRowGroup)
        return
      const s = t.getColDef().showRowGroup
      let n = e.parent
      for (; n != null; ) {
        if (n.rowGroupColumn && (s === !0 || s === n.rowGroupColumn.getColId()))
          return n.key
        n = n.parent
      }
    }
    setValue(e, t, i, s) {
      const n = this.columnModel.getColDefCol(t)
      if (!e || !n) return !1
      ot(e.data) && (e.data = {})
      const { field: r, valueSetter: o } = n.getColDef()
      if (ot(r) && ot(o))
        return (
          te(
            'you need either field or valueSetter set on colDef for editing to work',
          ),
          !1
        )
      if (this.dataTypeService && !this.dataTypeService.checkType(n, i))
        return (
          te(
            'Data type of the new value does not match the cell data type of the column',
          ),
          !1
        )
      const a = this.gos.addGridCommonParams({
        node: e,
        data: e.data,
        oldValue: this.getValue(n, e),
        newValue: i,
        colDef: n.getColDef(),
        column: n,
      })
      a.newValue = i
      let l
      if (
        (ue(o)
          ? typeof o == 'function'
            ? (l = o(a))
            : (l = this.expressionService.evaluate(o, a))
          : (l = this.setValueUsingField(
              e.data,
              r,
              i,
              n.isFieldContainsDots(),
            )),
        l === void 0 && (l = !0),
        !l)
      )
        return !1
      e.resetQuickFilterAggregateText(), this.valueCache.onDataChanged()
      const c = this.getValue(n, e)
      return (
        this.eventService.dispatchEvent({
          type: 'cellValueChanged',
          event: null,
          rowIndex: e.rowIndex,
          rowPinned: e.rowPinned,
          column: a.column,
          colDef: a.colDef,
          data: e.data,
          node: e,
          oldValue: a.oldValue,
          newValue: c,
          value: c,
          source: s,
        }),
        !0
      )
    }
    callColumnCellValueChangedHandler(e) {
      const t = e.colDef.onCellValueChanged
      typeof t == 'function' &&
        this.getFrameworkOverrides().wrapOutgoing(() => {
          t({
            node: e.node,
            data: e.data,
            oldValue: e.oldValue,
            newValue: e.newValue,
            colDef: e.colDef,
            column: e.column,
            api: e.api,
            context: e.context,
          })
        })
    }
    setValueUsingField(e, t, i, s) {
      if (!t) return !1
      let n = !1
      if (!s) (n = e[t] === i), n || (e[t] = i)
      else {
        const r = t.split('.')
        let o = e
        for (; r.length > 0 && o; ) {
          const a = r.shift()
          r.length === 0 ? ((n = o[a] === i), n || (o[a] = i)) : (o = o[a])
        }
      }
      return !n
    }
    executeFilterValueGetter(e, t, i, s) {
      const n = this.gos.addGridCommonParams({
        data: t,
        node: s,
        column: i,
        colDef: i.getColDef(),
        getValue: this.getValueCallback.bind(this, s),
      })
      return typeof e == 'function'
        ? e(n)
        : this.expressionService.evaluate(e, n)
    }
    executeValueGetter(e, t, i, s) {
      const n = i.getColId(),
        r = this.valueCache.getValue(s, n)
      if (r !== void 0) return r
      const o = this.gos.addGridCommonParams({
        data: t,
        node: s,
        column: i,
        colDef: i.getColDef(),
        getValue: this.getValueCallback.bind(this, s),
      })
      let a
      return (
        typeof e == 'function'
          ? (a = e(o))
          : (a = this.expressionService.evaluate(e, o)),
        this.valueCache.setValue(s, n, a),
        a
      )
    }
    getValueCallback(e, t) {
      const i = this.columnModel.getColDefCol(t)
      return i ? this.getValue(i, e) : null
    }
    getKeyForNode(e, t) {
      const i = this.getValue(e, t),
        s = e.getColDef().keyCreator
      let n = i
      if (s) {
        const r = this.gos.addGridCommonParams({
          value: i,
          colDef: e.getColDef(),
          column: e,
          node: t,
          data: t.data,
        })
        n = s(r)
      }
      return (
        typeof n == 'string' ||
          n == null ||
          ((n = String(n)),
          n === '[object Object]' &&
            te(
              'a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key',
            )),
        n
      )
    }
  },
  Dd = class wn {
    static applyGlobalGridOptions(t) {
      if (!wn.gridOptions) return t
      let i = {}
      return (
        yi(i, wn.gridOptions, !0, !0),
        wn.mergeStrategy === 'deep' ? yi(i, t, !0, !0) : (i = { ...i, ...t }),
        wn.gridOptions.context && (i.context = wn.gridOptions.context),
        t.context &&
          (wn.mergeStrategy === 'deep' &&
            i.context &&
            yi(t.context, i.context, !0, !0),
          (i.context = t.context)),
        i
      )
    }
  }
Dd.gridOptions = void 0
Dd.mergeStrategy = 'shallow'
var aC = Dd
function KH(e) {
  var t
  return (t = aC.gridOptions) == null ? void 0 : t[e]
}
var qH = 1,
  QH = class {
    create(e, t, i, s, n) {
      const r = aC.applyGlobalGridOptions(t),
        o = PH(r),
        a = o.gridId ?? String(qH++),
        l = this.getRegisteredModules(n, a),
        c = this.createBeansList(o.rowModelType, l, a),
        u = this.createProvidedBeans(e, o, n)
      if (!c) {
        ht('Failed to create grid.')
        return
      }
      const h = {
          providedBeanInstances: u,
          beanClasses: c,
          gridId: a,
          beanInitComparator: cO,
          beanDestroyComparator: uO,
          derivedBeans: [eO],
        },
        g = new gM(h)
      return (
        this.registerModuleUserComponents(g, l),
        this.registerControllers(g, l),
        this.registerModuleApiFunctions(g, l),
        i(g),
        g.getBean('syncService').start(),
        s && s(g),
        g.getBean('gridApi')
      )
    }
    registerControllers(e, t) {
      const i = e.getBean('ctrlsFactory')
      t.forEach((s) => {
        s.controllers && s.controllers.forEach((n) => i.register(n))
      })
    }
    getRegisteredModules(e, t) {
      const i = e ? e.modules : null,
        s = us.__getRegisteredModules(t),
        n = [],
        r = {},
        o = (a, l, c) => {
          ;((h) => {
            r[h.moduleName] ||
              ((r[h.moduleName] = !0), n.push(h), us.__register(h, a, c))
          })(l),
            l.dependantModules && l.dependantModules.forEach((h) => o(a, h, c))
        }
      return (
        o(!!(i != null && i.length) || !us.__isPackageBased(), iC, void 0),
        i && i.forEach((a) => o(!0, a, t)),
        s && s.forEach((a) => o(!us.__isPackageBased(), a, void 0)),
        n
      )
    }
    registerModuleUserComponents(e, t) {
      const i = this.extractModuleEntity(t, (n) =>
          n.userComponents ? n.userComponents : [],
        ),
        s = e.getBean('userComponentRegistry')
      i.forEach(({ name: n, classImp: r, params: o }) => {
        s.registerDefaultComponent(n, r, o)
      })
    }
    registerModuleApiFunctions(e, t) {
      const i = e.getBean('apiFunctionService')
      t.forEach((s) => {
        const n = s.apiFunctions
        n &&
          Object.keys(n).forEach((o) => {
            i == null || i.addFunction(o, n[o])
          })
      })
    }
    createProvidedBeans(e, t, i) {
      let s = i ? i.frameworkOverrides : null
      ot(s) && (s = new Kv())
      const n = {
        gridOptions: t,
        eGridDiv: e,
        globalEventListener: i ? i.globalEventListener : null,
        globalSyncEventListener: i ? i.globalSyncEventListener : null,
        frameworkOverrides: s,
      }
      return (
        i &&
          i.providedBeanInstances &&
          Object.assign(n, i.providedBeanInstances),
        n
      )
    }
    createBeansList(e = 'clientSide', t, i) {
      const s = t.filter((l) => !l.rowModel || l.rowModel === e),
        n = {
          clientSide: '@ag-grid-community/client-side-row-model',
          infinite: '@ag-grid-community/infinite-row-model',
          serverSide: '@ag-grid-enterprise/server-side-row-model',
          viewport: '@ag-grid-enterprise/viewport-row-model',
        }
      if (!n[e]) {
        ht('Could not find row model for rowModelType = ', e)
        return
      }
      if (!us.__assertRegistered(n[e], `rowModelType = '${e}'`, i)) return
      const r = [
          pO,
          gO,
          DH,
          RH,
          ZA,
          YD,
          oO,
          aO,
          KT,
          sv,
          GH,
          jT,
          MH,
          BA,
          vM,
          Yx,
          CO,
          xH,
          qA,
          oC,
          Hx,
          DI,
          AH,
          TH,
          NA,
          UH,
          kx,
          UT,
          jH,
          YH,
          kA,
          YT,
          fM,
          SO,
          zT,
          mO,
          XA,
          zA,
          $T,
          _H,
          kH,
          LH,
          VH,
          zH,
          qT,
          tO,
          NH,
          BH,
          hO,
          wO,
          fO,
          dO,
          WH,
          HH,
          QT,
          IH,
          OH,
          XT,
          Bx,
          iO,
          Vx,
          Nx,
          sO,
          nO,
          jx,
          Gx,
          zx,
          rO,
          Ux,
          Ix,
        ],
        o = this.extractModuleEntity(s, (l) => (l.beans ? l.beans : []))
      r.push(...o)
      const a = []
      return (
        r.forEach((l) => {
          a.indexOf(l) < 0 && a.push(l)
        }),
        a
      )
    }
    extractModuleEntity(e, t) {
      return [].concat(...e.map(t))
    }
  },
  lC = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'rowModelHelperService')
    }
    wireBeans(e) {
      this.rowModel = e.rowModel
    }
    postConstruct() {
      const e = this.rowModel
      switch (e.getType()) {
        case 'clientSide':
          this.clientSideRowModel = e
          break
        case 'infinite':
          this.infiniteRowModel = e
          break
        case 'serverSide':
          this.serverSideRowModel = e
          break
      }
    }
    getClientSideRowModel() {
      return this.clientSideRowModel
    }
    getInfiniteRowModel() {
      return this.infiniteRowModel
    }
    getServerSideRowModel() {
      return this.serverSideRowModel
    }
  }
function XH(e) {
  e.expansionService.expandAll(!0)
}
function JH(e) {
  e.expansionService.expandAll(!1)
}
function ZH(e) {
  var s, n
  const t =
      (s = e.rowModelHelperService) == null
        ? void 0
        : s.getClientSideRowModel(),
    i =
      (n = e.rowModelHelperService) == null ? void 0 : n.getServerSideRowModel()
  t ? t.onRowHeightChanged() : i && i.onRowHeightChanged()
}
function e1(e, t, i) {
  var r, o
  const s =
    (r = e.rowModelHelperService) == null ? void 0 : r.getServerSideRowModel()
  if (s) {
    if (e.funcColsService.isRowGroupEmpty()) {
      s.setRowCount(t, i)
      return
    }
    ht('setRowCount cannot be used while using row grouping.')
    return
  }
  const n =
    (o = e.rowModelHelperService) == null ? void 0 : o.getInfiniteRowModel()
  if (n) {
    n.setRowCount(t, i)
    return
  }
}
function t1(e) {
  var t
  return ((t = e.rowNodeBlockLoader) == null ? void 0 : t.getBlockState()) ?? {}
}
function i1(e) {
  return e.rowModel.isLastRowIndexKnown()
}
var s1 = {
    version: je,
    moduleName: '@ag-grid-community/csrm-ssrm-shared-api',
    apiFunctions: { expandAll: XH, collapseAll: JH, onRowHeightChanged: ZH },
  },
  n1 = {
    version: je,
    moduleName: '@ag-grid-community/ssrm-infinite-shared-api',
    apiFunctions: {
      setRowCount: e1,
      getCacheBlockState: t1,
      isLastRowIndexKnown: i1,
    },
  },
  r1 = class {
    wrap(e, t, i = [], s) {
      const n = this.createWrapper(e, s)
      return (
        t.forEach((r) => {
          this.createMethod(n, r, !0)
        }),
        i.forEach((r) => {
          this.createMethod(n, r, !1)
        }),
        n
      )
    }
    createMethod(e, t, i) {
      e.addMethod(t, this.createMethodProxy(e, t, i))
    }
    createMethodProxy(e, t, i) {
      return function () {
        return e.hasMethod(t)
          ? e.callMethod(t, arguments)
          : (i && te('Framework component is missing the method ' + t + '()'),
            null)
      }
    }
  },
  Or = typeof global > 'u' ? {} : global
Or.HTMLElement = typeof HTMLElement > 'u' ? {} : HTMLElement
Or.HTMLButtonElement = typeof HTMLButtonElement > 'u' ? {} : HTMLButtonElement
Or.HTMLSelectElement = typeof HTMLSelectElement > 'u' ? {} : HTMLSelectElement
Or.HTMLInputElement = typeof HTMLInputElement > 'u' ? {} : HTMLInputElement
Or.Node = typeof Node > 'u' ? {} : Node
Or.MouseEvent = typeof MouseEvent > 'u' ? {} : MouseEvent
var o1 = 'ROOT_NODE_ID',
  Sc = 0,
  a1 = class {
    constructor(e, t, i, s, n, r) {
      ;(this.nextId = 0),
        (this.rowCountReady = !1),
        (this.allNodesMap = {}),
        (this.rootNode = e),
        (this.gos = t),
        (this.eventService = i),
        (this.funcColsService = s),
        (this.beans = r),
        (this.selectionService = n),
        (this.rootNode.group = !0),
        (this.rootNode.level = -1),
        (this.rootNode.id = o1),
        (this.rootNode.allLeafChildren = []),
        (this.rootNode.childrenAfterGroup = []),
        (this.rootNode.childrenAfterSort = []),
        (this.rootNode.childrenAfterAggFilter = []),
        (this.rootNode.childrenAfterFilter = [])
    }
    getCopyOfNodesMap() {
      return Im(this.allNodesMap)
    }
    getRowNode(e) {
      return this.allNodesMap[e]
    }
    setRowData(e) {
      if (typeof e == 'string') {
        te('rowData must be an array.')
        return
      }
      ;(this.rowCountReady = !0), this.dispatchRowDataUpdateStartedEvent(e)
      const t = this.rootNode,
        i = this.rootNode.sibling
      ;(t.childrenAfterFilter = null),
        (t.childrenAfterGroup = null),
        (t.childrenAfterAggFilter = null),
        (t.childrenAfterSort = null),
        (t.childrenMapped = null),
        t.updateHasChildren(),
        (this.nextId = 0),
        (this.allNodesMap = {}),
        e
          ? (t.allLeafChildren = e.map((s, n) =>
              this.createNode(s, this.rootNode, Sc, n),
            ))
          : ((t.allLeafChildren = []), (t.childrenAfterGroup = [])),
        i &&
          ((i.childrenAfterFilter = t.childrenAfterFilter),
          (i.childrenAfterGroup = t.childrenAfterGroup),
          (i.childrenAfterAggFilter = t.childrenAfterAggFilter),
          (i.childrenAfterSort = t.childrenAfterSort),
          (i.childrenMapped = t.childrenMapped),
          (i.allLeafChildren = t.allLeafChildren))
    }
    updateRowData(e) {
      ;(this.rowCountReady = !0), this.dispatchRowDataUpdateStartedEvent(e.add)
      const t = {
          rowNodeTransaction: { remove: [], update: [], add: [] },
          rowsInserted: !1,
        },
        i = []
      return (
        this.executeRemove(e, t, i),
        this.executeUpdate(e, t, i),
        this.executeAdd(e, t),
        this.updateSelection(i, 'rowDataChanged'),
        t
      )
    }
    updateRowOrderFromRowData(e) {
      const t = this.rootNode.allLeafChildren,
        i = (t == null ? void 0 : t.length) ?? 0,
        s = new Map()
      let n = -1,
        r = -1
      for (let o = 0; o < i; ++o) {
        const a = t[o],
          l = a.data
        l !== e[o] && (r < 0 && (n = o), (r = o), s.set(l, a))
      }
      if (n < 0) return !1
      for (let o = n; o <= r; ++o) {
        const a = s.get(e[o])
        a !== void 0 && ((t[o] = a), (a.sourceRowIndex = o))
      }
      return !0
    }
    isRowCountReady() {
      return this.rowCountReady
    }
    dispatchRowDataUpdateStartedEvent(e) {
      this.eventService.dispatchEvent({
        type: 'rowDataUpdateStarted',
        firstRowData: e != null && e.length ? e[0] : null,
      })
    }
    updateSelection(e, t) {
      const i = e.length > 0
      i &&
        this.selectionService.setNodesSelected({
          newValue: !1,
          nodes: e,
          suppressFinishActions: !0,
          source: t,
        }),
        this.selectionService.updateGroupsFromChildrenSelections(t),
        i &&
          this.eventService.dispatchEvent({
            type: 'selectionChanged',
            source: t,
          })
    }
    executeAdd(e, t) {
      const i = e.add
      if (Hi(i)) return
      const s = this.rootNode.allLeafChildren
      let n = s.length
      if (
        typeof e.addIndex == 'number' &&
        ((n = this.sanitizeAddIndex(e.addIndex)),
        n > 0 && this.gos.get('treeData'))
      )
        for (let l = 0; l < s.length; l++) {
          const c = s[l]
          if ((c == null ? void 0 : c.rowIndex) == n - 1) {
            n = l + 1
            break
          }
        }
      const r = i.map((a, l) => this.createNode(a, this.rootNode, Sc, n + l))
      if (n < s.length) {
        const a = s.slice(0, n),
          l = s.slice(n, s.length),
          c = a.length + r.length
        for (let u = 0, h = l.length; u < h; ++u) l[u].sourceRowIndex = c + u
        ;(this.rootNode.allLeafChildren = [...a, ...r, ...l]),
          (t.rowsInserted = !0)
      } else this.rootNode.allLeafChildren = s.concat(r)
      const o = this.rootNode.sibling
      o && (o.allLeafChildren = s), (t.rowNodeTransaction.add = r)
    }
    sanitizeAddIndex(e) {
      var i
      const t =
        ((i = this.rootNode.allLeafChildren) == null ? void 0 : i.length) ?? 0
      return e < 0 || e >= t || Number.isNaN(e) ? t : Math.ceil(e)
    }
    executeRemove(e, { rowNodeTransaction: t }, i) {
      var o, a
      const { remove: s } = e
      if (Hi(s)) return
      const n = {}
      s.forEach((l) => {
        const c = this.lookupRowNode(l)
        c &&
          (c.isSelected() && i.push(c),
          c.clearRowTopAndRowIndex(),
          (n[c.id] = !0),
          delete this.allNodesMap[c.id],
          t.remove.push(c))
      }),
        (this.rootNode.allLeafChildren =
          ((o = this.rootNode.allLeafChildren) == null
            ? void 0
            : o.filter((l) => !n[l.id])) ?? null),
        (a = this.rootNode.allLeafChildren) == null ||
          a.forEach((l, c) => {
            l.sourceRowIndex = c
          })
      const r = this.rootNode.sibling
      r && (r.allLeafChildren = this.rootNode.allLeafChildren)
    }
    executeUpdate(e, { rowNodeTransaction: t }, i) {
      const { update: s } = e
      Hi(s) ||
        s.forEach((n) => {
          const r = this.lookupRowNode(n)
          r &&
            (r.updateData(n),
            !r.selectable && r.isSelected() && i.push(r),
            this.setMasterForRow(r, n, Sc, !1),
            t.update.push(r))
        })
    }
    lookupRowNode(e) {
      var s
      const t = Mr(this.gos)
      let i
      if (t) {
        const n = t({ data: e, level: 0 })
        if (((i = this.allNodesMap[n]), !i))
          return (
            ht(
              `could not find row id=${n}, data item was not found for this id`,
            ),
            null
          )
      } else if (
        ((i =
          (s = this.rootNode.allLeafChildren) == null
            ? void 0
            : s.find((n) => n.data === e)),
        !i)
      )
        return (
          ht('could not find data item as object was not found', e),
          ht('Consider using getRowId to help the Grid find matching row data'),
          null
        )
      return i || null
    }
    createNode(e, t, i, s) {
      const n = new Ls(this.beans)
      return (
        (n.sourceRowIndex = s),
        (n.group = !1),
        this.setMasterForRow(n, e, i, !0),
        t && (n.parent = t),
        (n.level = i),
        n.setDataAndId(e, this.nextId.toString()),
        this.allNodesMap[n.id] &&
          te(
            `duplicate node id '${n.id}' detected from getRowId callback, this could cause issues in your grid.`,
          ),
        (this.allNodesMap[n.id] = n),
        this.nextId++,
        n
      )
    }
    setMasterForRow(e, t, i, s) {
      if (this.gos.get('treeData')) e.setMaster(!1), s && (e.expanded = !1)
      else {
        if (this.gos.get('masterDetail')) {
          const o = this.gos.get('isRowMaster')
          o ? e.setMaster(o(t)) : e.setMaster(!0)
        } else e.setMaster(!1)
        if (s) {
          const o = this.funcColsService.getRowGroupColumns(),
            a = o ? o.length : 0,
            l = i + a
          e.expanded = e.master ? this.isExpanded(l) : !1
        }
      }
    }
    isExpanded(e) {
      const t = this.gos.get('groupDefaultExpanded')
      return t === -1 ? !0 : e < t
    }
  },
  l1 = class extends X {
    constructor() {
      super(...arguments),
        (this.beanName = 'rowModel'),
        (this.onRowHeightChanged_debounced = bi(
          this.onRowHeightChanged.bind(this),
          100,
        )),
        (this.rowsToDisplay = []),
        (this.hasStarted = !1),
        (this.shouldSkipSettingDataOnStart = !1),
        (this.isRefreshingModel = !1),
        (this.rowCountReady = !1)
    }
    wireBeans(e) {
      ;(this.beans = e),
        (this.columnModel = e.columnModel),
        (this.funcColsService = e.funcColsService),
        (this.selectionService = e.selectionService),
        (this.valueCache = e.valueCache),
        (this.environment = e.environment),
        (this.filterStage = e.filterStage),
        (this.sortStage = e.sortStage),
        (this.flattenStage = e.flattenStage),
        (this.groupStage = e.groupStage),
        (this.aggregationStage = e.aggregationStage),
        (this.pivotStage = e.pivotStage),
        (this.filterAggregatesStage = e.filterAggregatesStage)
    }
    postConstruct() {
      const e = this.refreshModel.bind(this, { step: 'group' }),
        t = !this.gos.get('suppressAnimationFrame'),
        i = this.refreshModel.bind(this, {
          step: 'group',
          afterColumnsChanged: !0,
          keepRenderedRows: !0,
          animate: t,
        })
      this.addManagedEventListeners({
        newColumnsLoaded: i,
        columnRowGroupChanged: e,
        columnValueChanged: this.onValueChanged.bind(this),
        columnPivotChanged: this.refreshModel.bind(this, { step: 'pivot' }),
        filterChanged: this.onFilterChanged.bind(this),
        sortChanged: this.onSortChanged.bind(this),
        columnPivotModeChanged: e,
        gridStylesChanged: this.onGridStylesChanges.bind(this),
        gridReady: this.onGridReady.bind(this),
      }),
        this.addPropertyListeners(),
        (this.rootNode = new Ls(this.beans)),
        (this.nodeManager = new a1(
          this.rootNode,
          this.gos,
          this.eventService,
          this.funcColsService,
          this.selectionService,
          this.beans,
        ))
    }
    addPropertyListeners() {
      const e = new Set(['treeData', 'masterDetail']),
        t = new Set([
          'groupDefaultExpanded',
          'groupAllowUnbalanced',
          'initialGroupOrderComparator',
          'groupHideOpenParents',
          'groupDisplayType',
        ]),
        i = new Set(['excludeChildrenWhenTreeDataFiltering']),
        s = new Set([
          'removePivotHeaderRowWhenSingleValueColumn',
          'pivotRowTotals',
          'pivotColumnGroupTotals',
          'suppressExpandablePivotGroups',
        ]),
        n = new Set([
          'getGroupRowAgg',
          'alwaysAggregateAtRootLevel',
          'groupIncludeTotalFooter',
          'suppressAggFilteredOnly',
          'grandTotalRow',
        ]),
        r = new Set(['postSortRows', 'groupDisplayType', 'accentedSort']),
        o = new Set([]),
        a = new Set([
          'groupRemoveSingleChildren',
          'groupRemoveLowestSingleChildren',
          'groupIncludeFooter',
          'groupTotalRow',
        ]),
        l = [...e, ...t, ...i, ...s, ...s, ...n, ...r, ...o, ...a]
      this.addManagedPropertyListeners(l, (c) => {
        var g
        const u = (g = c.changeSet) == null ? void 0 : g.properties
        if (!u) return
        const h = (f) => u.some((p) => f.has(p))
        if (h(e)) {
          this.setRowData(this.rootNode.allLeafChildren.map((f) => f.data))
          return
        }
        if (h(t)) {
          this.refreshModel({ step: 'group' })
          return
        }
        if (h(i)) {
          this.refreshModel({ step: 'filter' })
          return
        }
        if (h(s)) {
          this.refreshModel({ step: 'pivot' })
          return
        }
        if (h(n)) {
          this.refreshModel({ step: 'aggregate' })
          return
        }
        if (h(r)) {
          this.refreshModel({ step: 'sort' })
          return
        }
        if (h(o)) {
          this.refreshModel({ step: 'filter_aggregates' })
          return
        }
        h(a) && this.refreshModel({ step: 'map' })
      }),
        this.addManagedPropertyListener('rowHeight', () =>
          this.resetRowHeights(),
        )
    }
    start() {
      ;(this.hasStarted = !0),
        this.shouldSkipSettingDataOnStart
          ? this.dispatchUpdateEventsAndRefresh()
          : this.setInitialData()
    }
    setInitialData() {
      const e = this.gos.get('rowData')
      e && ((this.shouldSkipSettingDataOnStart = !0), this.setRowData(e))
    }
    ensureRowHeightsValid(e, t, i, s) {
      let n,
        r = !1
      do {
        n = !1
        const o = this.getRowIndexAtPixel(e),
          a = this.getRowIndexAtPixel(t),
          l = Math.max(o, i),
          c = Math.min(a, s)
        for (let u = l; u <= c; u++) {
          const h = this.getRow(u)
          if (h.rowHeightEstimated) {
            const g = ln(this.gos, h)
            h.setRowHeight(g.height), (n = !0), (r = !0)
          }
        }
        n && this.setRowTopAndRowIndex()
      } while (n)
      return r
    }
    setRowTopAndRowIndex() {
      const e = this.environment.getDefaultRowHeight()
      let t = 0
      const i = new Set(),
        s = ci(this.gos, 'normal')
      for (let n = 0; n < this.rowsToDisplay.length; n++) {
        const r = this.rowsToDisplay[n]
        if ((r.id != null && i.add(r.id), r.rowHeight == null)) {
          const o = ln(this.gos, r, s, e)
          r.setRowHeight(o.height, o.estimated)
        }
        r.setRowTop(t), r.setRowIndex(n), (t += r.rowHeight)
      }
      return i
    }
    clearRowTopAndRowIndex(e, t) {
      const i = e.isActive(),
        s = (r) => {
          r && r.id != null && !t.has(r.id) && r.clearRowTopAndRowIndex()
        },
        n = (r) => {
          if (
            (s(r),
            s(r.detailNode),
            s(r.sibling),
            r.hasChildren() && r.childrenAfterGroup)
          ) {
            const o = r.level == -1
            ;(i && !o && !r.expanded) || r.childrenAfterGroup.forEach(n)
          }
        }
      n(this.rootNode)
    }
    ensureRowsAtPixel(e, t, i = 0) {
      const s = this.getRowIndexAtPixel(t),
        n = this.getRow(s),
        r = !this.gos.get('suppressAnimationFrame')
      if (n === e[0]) return !1
      const o = this.rootNode.allLeafChildren
      return (
        e.forEach((a) => {
          Ri(o, a)
        }),
        e.forEach((a, l) => {
          La(o, a, Math.max(s + i, 0) + l)
        }),
        e.forEach((a, l) => {
          a.sourceRowIndex = l
        }),
        this.refreshModel({
          step: 'group',
          keepRenderedRows: !0,
          keepEditingRows: !0,
          animate: r,
          rowNodesOrderChanged: !0,
        }),
        !0
      )
    }
    highlightRowAtPixel(e, t) {
      const i = t != null ? this.getRowIndexAtPixel(t) : null,
        s = i != null ? this.getRow(i) : null
      if (!s || !e || t == null) {
        this.clearHighlightedRow()
        return
      }
      const n = this.getHighlightPosition(t, s),
        r = this.isHighlightingCurrentPosition(e, s, n),
        o = this.lastHighlightedRow != null && this.lastHighlightedRow !== s
      ;((r || o) && (this.clearHighlightedRow(), r)) ||
        (s.setHighlighted(n), (this.lastHighlightedRow = s))
    }
    getHighlightPosition(e, t) {
      if (!t) {
        const n = this.getRowIndexAtPixel(e)
        if (((t = this.getRow(n || 0)), !t)) return 1
      }
      const { rowTop: i, rowHeight: s } = t
      return e - i < s / 2 ? 0 : 1
    }
    getLastHighlightedRowNode() {
      return this.lastHighlightedRow
    }
    isHighlightingCurrentPosition(e, t, i) {
      if (e === t) return !0
      const s = i === 0 ? -1 : 1
      return this.getRow(t.rowIndex + s) === e
    }
    clearHighlightedRow() {
      this.lastHighlightedRow &&
        (this.lastHighlightedRow.setHighlighted(null),
        (this.lastHighlightedRow = null))
    }
    isLastRowIndexKnown() {
      return !0
    }
    getRowCount() {
      return this.rowsToDisplay ? this.rowsToDisplay.length : 0
    }
    getTopLevelRowCount() {
      if (this.rowsToDisplay.length === 0) return 0
      if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode)
        return 1
      const t = this.rootNode.childrenAfterAggFilter,
        i = this.rootNode.sibling ? 1 : 0
      return (t ? t.length : 0) + i
    }
    getTopLevelRowDisplayedIndex(e) {
      if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode)
        return e
      let i = e
      if (this.rowsToDisplay[0].footer) {
        if (e === 0) return 0
        i -= 1
      }
      const s = this.rowsToDisplay[this.rowsToDisplay.length - 1],
        n = i >= this.rootNode.childrenAfterSort.length
      if (s.footer && n) return s.rowIndex
      let r = this.rootNode.childrenAfterSort[i]
      if (this.gos.get('groupHideOpenParents'))
        for (
          ;
          r.expanded && r.childrenAfterSort && r.childrenAfterSort.length > 0;

        )
          r = r.childrenAfterSort[0]
      return r.rowIndex
    }
    getRowBounds(e) {
      if (ot(this.rowsToDisplay)) return null
      const t = this.rowsToDisplay[e]
      return t ? { rowTop: t.rowTop, rowHeight: t.rowHeight } : null
    }
    onRowGroupOpened() {
      const e = or(this.gos)
      this.refreshModel({ step: 'map', keepRenderedRows: !0, animate: e })
    }
    onFilterChanged(e) {
      if (e.afterDataChange) return
      const t = or(this.gos),
        s =
          e.columns.length === 0 || e.columns.some((n) => n.isPrimary())
            ? 'filter'
            : 'filter_aggregates'
      this.refreshModel({ step: s, keepRenderedRows: !0, animate: t })
    }
    onSortChanged() {
      const e = or(this.gos)
      this.refreshModel({
        step: 'sort',
        keepRenderedRows: !0,
        animate: e,
        keepEditingRows: !0,
      })
    }
    getType() {
      return 'clientSide'
    }
    onValueChanged() {
      this.columnModel.isPivotActive()
        ? this.refreshModel({ step: 'pivot' })
        : this.refreshModel({ step: 'aggregate' })
    }
    createChangePath(e) {
      const t = Hi(e),
        i = new yl(!1, this.rootNode)
      return t && i.setInactive(), i
    }
    isSuppressModelUpdateAfterUpdateTransaction(e) {
      if (
        !this.gos.get('suppressModelUpdateAfterUpdateTransaction') ||
        e.rowNodeTransactions == null
      )
        return !1
      const t = e.rowNodeTransactions.filter(
        (s) =>
          (s.add != null && s.add.length > 0) ||
          (s.remove != null && s.remove.length > 0),
      )
      return t == null || t.length == 0
    }
    buildRefreshModelParams(e) {
      let t = 'group'
      const i = {
        everything: 'group',
        group: 'group',
        filter: 'filter',
        map: 'map',
        aggregate: 'aggregate',
        filter_aggregates: 'filter_aggregates',
        sort: 'sort',
        pivot: 'pivot',
        nothing: 'nothing',
      }
      if ((ue(e) && (t = i[e]), ot(t))) {
        ht(
          `invalid step ${e}, available steps are ${Object.keys(i).join(', ')}`,
        )
        return
      }
      const s = !this.gos.get('suppressAnimationFrame')
      return { step: t, keepRenderedRows: !0, keepEditingRows: !0, animate: s }
    }
    refreshModel(e) {
      if (
        !this.hasStarted ||
        this.isRefreshingModel ||
        this.columnModel.isChangeEventsDispatching()
      )
        return
      const t =
        typeof e == 'object' && 'step' in e
          ? e
          : this.buildRefreshModelParams(e)
      if (!t || this.isSuppressModelUpdateAfterUpdateTransaction(t)) return
      const i = this.createChangePath(t.rowNodeTransactions)
      switch (((this.isRefreshingModel = !0), t.step)) {
        case 'group':
          this.doRowGrouping(
            t.rowNodeTransactions,
            i,
            !!t.rowNodesOrderChanged,
            !!t.afterColumnsChanged,
          )
        case 'filter':
          this.doFilter(i)
        case 'pivot':
          this.doPivot(i)
        case 'aggregate':
          this.doAggregate(i)
        case 'filter_aggregates':
          this.doFilterAggregates(i)
        case 'sort':
          this.doSort(t.rowNodeTransactions, i)
        case 'map':
          this.doRowsToDisplay()
      }
      const s = this.setRowTopAndRowIndex()
      this.clearRowTopAndRowIndex(i, s),
        (this.isRefreshingModel = !1),
        this.eventService.dispatchEvent({
          type: 'modelUpdated',
          animate: t.animate,
          keepRenderedRows: t.keepRenderedRows,
          newData: t.newData,
          newPage: !1,
          keepUndoRedoStack: t.keepUndoRedoStack,
        })
    }
    isEmpty() {
      const e =
        ot(this.rootNode.allLeafChildren) ||
        this.rootNode.allLeafChildren.length === 0
      return ot(this.rootNode) || e || !this.columnModel.isReady()
    }
    isRowsToRender() {
      return ue(this.rowsToDisplay) && this.rowsToDisplay.length > 0
    }
    getNodesInRangeForSelection(e, t) {
      let i = !1,
        s = !1
      const n = [],
        r = Gn(this.gos)
      return (
        this.forEachNodeAfterFilterAndSort((o) => {
          if (s) return
          if (i && (o === t || o === e) && ((s = !0), o.group && r)) {
            n.push(...o.allLeafChildren)
            return
          }
          if (!i) {
            if (o !== t && o !== e) return
            i = !0
          }
          if (!o.group || !r) {
            n.push(o)
            return
          }
        }),
        n
      )
    }
    setDatasource(e) {
      ht('should never call setDatasource on clientSideRowController')
    }
    getTopLevelNodes() {
      return this.rootNode ? this.rootNode.childrenAfterGroup : null
    }
    getRootNode() {
      return this.rootNode
    }
    getRow(e) {
      return this.rowsToDisplay[e]
    }
    isRowPresent(e) {
      return this.rowsToDisplay.indexOf(e) >= 0
    }
    getRowIndexAtPixel(e) {
      if (this.isEmpty() || this.rowsToDisplay.length === 0) return -1
      let t = 0,
        i = this.rowsToDisplay.length - 1
      if (e <= 0) return 0
      if (rt(this.rowsToDisplay).rowTop <= e)
        return this.rowsToDisplay.length - 1
      let n = -1,
        r = -1
      for (;;) {
        const o = Math.floor((t + i) / 2),
          a = this.rowsToDisplay[o]
        if (
          this.isRowInPixel(a, e) ||
          (a.rowTop < e ? (t = o + 1) : a.rowTop > e && (i = o - 1),
          n === t && r === i)
        )
          return o
        ;(n = t), (r = i)
      }
    }
    isRowInPixel(e, t) {
      const i = e.rowTop,
        s = e.rowTop + e.rowHeight
      return i <= t && s > t
    }
    forEachLeafNode(e) {
      this.rootNode.allLeafChildren &&
        this.rootNode.allLeafChildren.forEach((t, i) => e(t, i))
    }
    forEachNode(e, t = !1) {
      this.recursivelyWalkNodesAndCallback({
        nodes: [...(this.rootNode.childrenAfterGroup || [])],
        callback: e,
        recursionType: 0,
        index: 0,
        includeFooterNodes: t,
      })
    }
    forEachNodeAfterFilter(e, t = !1) {
      this.recursivelyWalkNodesAndCallback({
        nodes: [...(this.rootNode.childrenAfterAggFilter || [])],
        callback: e,
        recursionType: 1,
        index: 0,
        includeFooterNodes: t,
      })
    }
    forEachNodeAfterFilterAndSort(e, t = !1) {
      this.recursivelyWalkNodesAndCallback({
        nodes: [...(this.rootNode.childrenAfterSort || [])],
        callback: e,
        recursionType: 2,
        index: 0,
        includeFooterNodes: t,
      })
    }
    forEachPivotNode(e, t = !1) {
      this.recursivelyWalkNodesAndCallback({
        nodes: [this.rootNode],
        callback: e,
        recursionType: 3,
        index: 0,
        includeFooterNodes: t,
      })
    }
    recursivelyWalkNodesAndCallback(e) {
      const {
        nodes: t,
        callback: i,
        recursionType: s,
        includeFooterNodes: n,
      } = e
      let { index: r } = e
      const o = (a) => {
        var f
        const l = (f = t[0]) == null ? void 0 : f.parent
        if (!l) return
        const c = n && wm(this.gos),
          u = ym(this.gos),
          h = n && u({ node: l })
        if (l === this.rootNode) {
          c === a && (l.createFooter(), i(l.sibling, r++))
          return
        }
        h === a && (l.createFooter(), i(l.sibling, r++))
      }
      o('top')
      for (let a = 0; a < t.length; a++) {
        const l = t[a]
        if ((i(l, r++), l.hasChildren() && !l.footer)) {
          let c = null
          switch (s) {
            case 0:
              c = l.childrenAfterGroup
              break
            case 1:
              c = l.childrenAfterAggFilter
              break
            case 2:
              c = l.childrenAfterSort
              break
            case 3:
              c = l.leafGroup ? null : l.childrenAfterSort
              break
          }
          c &&
            (r = this.recursivelyWalkNodesAndCallback({
              nodes: [...c],
              callback: i,
              recursionType: s,
              index: r,
              includeFooterNodes: n,
            }))
        }
      }
      return o('bottom'), r
    }
    doAggregate(e) {
      var t
      ;(t = this.aggregationStage) == null ||
        t.execute({ rowNode: this.rootNode, changedPath: e })
    }
    doFilterAggregates(e) {
      this.filterAggregatesStage
        ? this.filterAggregatesStage.execute({
            rowNode: this.rootNode,
            changedPath: e,
          })
        : (this.rootNode.childrenAfterAggFilter =
            this.rootNode.childrenAfterFilter)
    }
    expandOrCollapseAll(e) {
      const t = this.gos.get('treeData'),
        i = this.columnModel.isPivotActive(),
        s = (n) => {
          n &&
            n.forEach((r) => {
              const o = () => {
                ;(r.expanded = e), s(r.childrenAfterGroup)
              }
              if (t) {
                ue(r.childrenAfterGroup) && o()
                return
              }
              if (i) {
                !r.leafGroup && o()
                return
              }
              r.group && o()
            })
        }
      this.rootNode && s(this.rootNode.childrenAfterGroup),
        this.refreshModel({ step: 'map' }),
        this.eventService.dispatchEvent({
          type: 'expandOrCollapseAll',
          source: e ? 'expandAll' : 'collapseAll',
        })
    }
    doSort(e, t) {
      this.sortStage.execute({
        rowNode: this.rootNode,
        rowNodeTransactions: e,
        changedPath: t,
      })
    }
    doRowGrouping(e, t, i, s) {
      if (this.groupStage)
        e
          ? this.groupStage.execute({
              rowNode: this.rootNode,
              rowNodeTransactions: e,
              rowNodesOrderChanged: i,
              changedPath: t,
            })
          : this.groupStage.execute({
              rowNode: this.rootNode,
              changedPath: t,
              afterColumnsChanged: s,
            }),
          Gn(this.gos) &&
            this.selectionService.updateGroupsFromChildrenSelections(
              'rowGroupChanged',
              t,
            ) &&
            this.eventService.dispatchEvent({
              type: 'selectionChanged',
              source: 'rowGroupChanged',
            })
      else {
        const n = this.rootNode,
          r = n.sibling
        ;(n.childrenAfterGroup = n.allLeafChildren),
          r && (r.childrenAfterGroup = n.childrenAfterGroup),
          this.rootNode.updateHasChildren()
      }
      this.nodeManager.isRowCountReady() &&
        ((this.rowCountReady = !0),
        this.eventService.dispatchEventOnce({ type: 'rowCountReady' }))
    }
    doFilter(e) {
      this.filterStage.execute({ rowNode: this.rootNode, changedPath: e })
    }
    doPivot(e) {
      var t
      ;(t = this.pivotStage) == null ||
        t.execute({ rowNode: this.rootNode, changedPath: e })
    }
    getNodeManager() {
      return this.nodeManager
    }
    getRowNode(e) {
      if (typeof e == 'string' && e.indexOf(Ls.ID_PREFIX_ROW_GROUP) == 0) {
        let i
        return (
          this.forEachNode((s) => {
            s.id === e && (i = s)
          }),
          i
        )
      }
      return this.nodeManager.getRowNode(e)
    }
    setRowData(e) {
      this.selectionService.reset('rowDataChanged'),
        this.nodeManager.setRowData(e),
        this.hasStarted && this.dispatchUpdateEventsAndRefresh()
    }
    dispatchUpdateEventsAndRefresh() {
      this.eventService.dispatchEvent({ type: 'rowDataUpdated' }),
        this.refreshModel({ step: 'group', newData: !0 })
    }
    batchUpdateRowData(e, t) {
      if (this.applyAsyncTransactionsTimeout == null) {
        this.rowDataTransactionBatch = []
        const i = this.gos.get('asyncTransactionWaitMillis')
        this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
          this.isAlive() && this.executeBatchUpdateRowData()
        }, i)
      }
      this.rowDataTransactionBatch.push({ rowDataTransaction: e, callback: t })
    }
    flushAsyncTransactions() {
      this.applyAsyncTransactionsTimeout != null &&
        (clearTimeout(this.applyAsyncTransactionsTimeout),
        this.executeBatchUpdateRowData())
    }
    executeBatchUpdateRowData() {
      var s
      this.valueCache.onDataChanged()
      const e = [],
        t = []
      let i = !1
      ;(s = this.rowDataTransactionBatch) == null ||
        s.forEach((n) => {
          const { rowNodeTransaction: r, rowsInserted: o } =
            this.nodeManager.updateRowData(n.rowDataTransaction)
          o && (i = !0),
            t.push(r),
            n.callback && e.push(n.callback.bind(null, r))
        }),
        this.commonUpdateRowData(t, i),
        e.length > 0 &&
          window.setTimeout(() => {
            e.forEach((n) => n())
          }, 0),
        t.length > 0 &&
          this.eventService.dispatchEvent({
            type: 'asyncTransactionsFlushed',
            results: t,
          }),
        (this.rowDataTransactionBatch = null),
        (this.applyAsyncTransactionsTimeout = void 0)
    }
    updateRowData(e) {
      this.valueCache.onDataChanged()
      const { rowNodeTransaction: t, rowsInserted: i } =
        this.nodeManager.updateRowData(e)
      return this.commonUpdateRowData([t], i), t
    }
    afterImmutableDataChange(e, t) {
      this.commonUpdateRowData([e], t)
    }
    commonUpdateRowData(e, t) {
      if (!this.hasStarted) return
      const i = !this.gos.get('suppressAnimationFrame')
      this.eventService.dispatchEvent({ type: 'rowDataUpdated' }),
        this.refreshModel({
          step: 'group',
          rowNodeTransactions: e,
          rowNodesOrderChanged: t,
          keepRenderedRows: !0,
          keepEditingRows: !0,
          animate: i,
        })
    }
    doRowsToDisplay() {
      this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode })
    }
    onRowHeightChanged() {
      this.refreshModel({
        step: 'map',
        keepRenderedRows: !0,
        keepEditingRows: !0,
        keepUndoRedoStack: !0,
      })
    }
    onRowHeightChangedDebounced() {
      this.onRowHeightChanged_debounced()
    }
    resetRowHeights() {
      const e = this.resetRowHeightsForAllRowNodes()
      this.rootNode.setRowHeight(this.rootNode.rowHeight, !0),
        this.rootNode.sibling &&
          this.rootNode.sibling.setRowHeight(
            this.rootNode.sibling.rowHeight,
            !0,
          ),
        e && this.onRowHeightChanged()
    }
    resetRowHeightsForAllRowNodes() {
      let e = !1
      return (
        this.forEachNode((t) => {
          t.setRowHeight(t.rowHeight, !0)
          const i = t.detailNode
          i && i.setRowHeight(i.rowHeight, !0),
            t.sibling && t.sibling.setRowHeight(t.sibling.rowHeight, !0),
            (e = !0)
        }),
        e
      )
    }
    onGridStylesChanges(e) {
      if (e.rowHeightChanged) {
        if (this.columnModel.isAutoRowHeightActive()) return
        this.resetRowHeights()
      }
    }
    onGridReady() {
      this.hasStarted || this.setInitialData()
    }
    isRowDataLoaded() {
      return this.rowCountReady
    }
    destroy() {
      super.destroy(), this.clearHighlightedRow()
    }
  }
function c1(e) {
  e.expansionService.onGroupExpandedOrCollapsed()
}
function u1(e, t) {
  var i, s
  ;(s =
    (i = e.rowModelHelperService) == null
      ? void 0
      : i.getClientSideRowModel()) == null || s.refreshModel(t)
}
function d1(e) {
  var t, i
  return (
    ((i =
      (t = e.rowModelHelperService) == null
        ? void 0
        : t.getClientSideRowModel()) == null
      ? void 0
      : i.isEmpty()) ?? !0
  )
}
function h1(e, t) {
  var i, s
  ;(s =
    (i = e.rowModelHelperService) == null
      ? void 0
      : i.getClientSideRowModel()) == null || s.forEachLeafNode(t)
}
function g1(e, t) {
  var i, s
  ;(s =
    (i = e.rowModelHelperService) == null
      ? void 0
      : i.getClientSideRowModel()) == null || s.forEachNodeAfterFilter(t)
}
function f1(e, t) {
  var i, s
  ;(s =
    (i = e.rowModelHelperService) == null
      ? void 0
      : i.getClientSideRowModel()) == null || s.forEachNodeAfterFilterAndSort(t)
}
function p1(e) {
  var t, i
  if (e.columnModel.isAutoRowHeightActive()) {
    te(
      'calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.',
    )
    return
  }
  ;(i =
    (t = e.rowModelHelperService) == null
      ? void 0
      : t.getClientSideRowModel()) == null || i.resetRowHeights()
}
function m1(e, t) {
  return e.frameworkOverrides.wrapIncoming(() => {
    var i, s
    return (s =
      (i = e.rowModelHelperService) == null
        ? void 0
        : i.getClientSideRowModel()) == null
      ? void 0
      : s.updateRowData(t)
  })
}
function v1(e, t, i) {
  e.frameworkOverrides.wrapIncoming(() => {
    var s, n
    return (n =
      (s = e.rowModelHelperService) == null
        ? void 0
        : s.getClientSideRowModel()) == null
      ? void 0
      : n.batchUpdateRowData(t, i)
  })
}
function C1(e) {
  e.frameworkOverrides.wrapIncoming(() => {
    var t, i
    return (i =
      (t = e.rowModelHelperService) == null
        ? void 0
        : t.getClientSideRowModel()) == null
      ? void 0
      : i.flushAsyncTransactions()
  })
}
function S1(e) {
  return e.selectionService.getBestCostNodeSelection()
}
var w1 = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'filterStage')
    }
    wireBeans(e) {
      this.filterManager = e.filterManager
    }
    execute(e) {
      const { changedPath: t } = e
      this.filter(t)
    }
    filter(e) {
      var i
      const t = !!((i = this.filterManager) != null && i.isChildFilterPresent())
      this.filterNodes(t, e)
    }
    filterNodes(e, t) {
      const i = (s, n) => {
        s.hasChildren() && e && !n
          ? (s.childrenAfterFilter = s.childrenAfterGroup.filter((r) => {
              const o =
                  r.childrenAfterFilter && r.childrenAfterFilter.length > 0,
                a =
                  r.data && this.filterManager.doesRowPassFilter({ rowNode: r })
              return o || a
            }))
          : (s.childrenAfterFilter = s.childrenAfterGroup),
          s.sibling && (s.sibling.childrenAfterFilter = s.childrenAfterFilter)
      }
      if (this.doingTreeDataFiltering()) {
        const s = (r, o) => {
            if (r.childrenAfterGroup)
              for (let a = 0; a < r.childrenAfterGroup.length; a++) {
                const l = r.childrenAfterGroup[a],
                  c = o || this.filterManager.doesRowPassFilter({ rowNode: l })
                l.childrenAfterGroup ? s(r.childrenAfterGroup[a], c) : i(l, c)
              }
            i(r, o)
          },
          n = (r) => s(r, !1)
        t.executeFromRootNode(n)
      } else {
        const s = (n) => i(n, !1)
        t.forEachChangedNodeDepthFirst(s, !0)
      }
    }
    doingTreeDataFiltering() {
      return (
        this.gos.get('treeData') &&
        !this.gos.get('excludeChildrenWhenTreeDataFiltering')
      )
    }
  },
  y1 = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'flattenStage')
    }
    wireBeans(e) {
      ;(this.beans = e), (this.columnModel = e.columnModel)
    }
    execute(e) {
      const t = e.rowNode,
        i = [],
        s = this.columnModel.isPivotMode(),
        n = s && t.leafGroup,
        r = n ? [t] : t.childrenAfterSort,
        o = this.getFlattenDetails()
      this.recursivelyAddToRowsToDisplay(o, r, i, s, 0)
      const a = i.length > 0
      if (!n && a && o.grandTotalRow) {
        t.createFooter()
        const c = o.grandTotalRow === 'top'
        this.addRowNodeToRowsToDisplay(o, t.sibling, i, 0, c)
      }
      return i
    }
    getFlattenDetails() {
      const e = this.gos.get('groupRemoveSingleChildren')
      return {
        groupRemoveLowestSingleChildren:
          !e && this.gos.get('groupRemoveLowestSingleChildren'),
        groupRemoveSingleChildren: e,
        isGroupMultiAutoColumn: bm(this.gos),
        hideOpenParents: this.gos.get('groupHideOpenParents'),
        grandTotalRow: wm(this.gos),
        groupTotalRow: ym(this.gos),
      }
    }
    recursivelyAddToRowsToDisplay(e, t, i, s, n) {
      if (!Hi(t))
        for (let r = 0; r < t.length; r++) {
          const o = t[r],
            a = o.hasChildren(),
            l = s && !a,
            c =
              e.groupRemoveSingleChildren &&
              a &&
              o.childrenAfterGroup.length === 1,
            u =
              e.groupRemoveLowestSingleChildren &&
              a &&
              o.leafGroup &&
              o.childrenAfterGroup.length === 1,
            h = s && o.leafGroup,
            g = e.hideOpenParents && o.expanded && !o.master && !h
          if (
            (!l && !g && !c && !u && this.addRowNodeToRowsToDisplay(e, o, i, n),
            !(s && o.leafGroup))
          ) {
            if (a) {
              const p = c || u
              if (o.expanded || p) {
                const v = e.groupTotalRow({ node: o })
                v || o.destroyFooter()
                const m = p ? n : n + 1
                v === 'top' &&
                  (o.createFooter(),
                  this.addRowNodeToRowsToDisplay(e, o.sibling, i, m)),
                  this.recursivelyAddToRowsToDisplay(
                    e,
                    o.childrenAfterSort,
                    i,
                    s,
                    m,
                  ),
                  v === 'bottom' &&
                    (o.createFooter(),
                    this.addRowNodeToRowsToDisplay(e, o.sibling, i, m))
              }
            } else if (o.master && o.expanded) {
              const p = this.createDetailNode(o)
              this.addRowNodeToRowsToDisplay(e, p, i, n)
            }
          }
        }
    }
    addRowNodeToRowsToDisplay(e, t, i, s, n) {
      n ? i.unshift(t) : i.push(t),
        t.setUiLevel(e.isGroupMultiAutoColumn ? 0 : s)
    }
    createDetailNode(e) {
      if (ue(e.detailNode)) return e.detailNode
      const t = new Ls(this.beans)
      return (
        (t.detail = !0),
        (t.selectable = !1),
        (t.parent = e),
        ue(e.id) && (t.id = 'detail_' + e.id),
        (t.data = e.data),
        (t.level = e.level + 1),
        (e.detailNode = t),
        t
      )
    }
  },
  b1 = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'immutableService')
    }
    wireBeans(e) {
      ;(this.rowModel = e.rowModel),
        (this.selectionService = e.selectionService)
    }
    postConstruct() {
      Pt(this.gos) &&
        ((this.clientSideRowModel = this.rowModel),
        this.addManagedPropertyListener('rowData', () =>
          this.onRowDataUpdated(),
        ))
    }
    isActive() {
      const e = this.gos.exists('getRowId')
      return this.gos.get('resetRowDataOnUpdate') ? !1 : e
    }
    setRowData(e) {
      const t = this.createTransactionForRowData(e)
      if (!t) return
      const i = this.clientSideRowModel.getNodeManager(),
        { rowNodeTransaction: s, rowsInserted: n } = i.updateRowData(t)
      let r = !1
      this.gos.get('suppressMaintainUnsortedOrder') ||
        (r = i.updateRowOrderFromRowData(e)),
        this.clientSideRowModel.afterImmutableDataChange(s, r || n)
    }
    createTransactionForRowData(e) {
      if (!Pt(this.gos))
        return ht('ImmutableService only works with ClientSideRowModel'), null
      const t = Mr(this.gos)
      if (t == null)
        return (
          ht(
            'ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!',
          ),
          null
        )
      const i = this.clientSideRowModel.getNodeManager().getCopyOfNodesMap(),
        s = [],
        n = [],
        r = []
      return (
        ue(e) &&
          e.forEach((o) => {
            const a = t({ data: o, level: 0 }),
              l = i[a]
            l ? (l.data !== o && n.push(o), (i[a] = void 0)) : r.push(o)
          }),
        Qi(i, (o, a) => {
          a && s.push(a.data)
        }),
        { remove: s, update: n, add: r }
      )
    }
    onRowDataUpdated() {
      const e = this.gos.get('rowData')
      e &&
        (this.isActive()
          ? this.setRowData(e)
          : (this.selectionService.reset('rowDataChanged'),
            this.clientSideRowModel.setRowData(e)))
    }
  },
  R1 = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'sortService')
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.funcColsService = e.funcColsService),
        (this.rowNodeSorter = e.rowNodeSorter),
        (this.showRowGroupColsService = e.showRowGroupColsService)
    }
    sort(e, t, i, s, n, r) {
      const o = this.gos.get('groupMaintainOrder'),
        a = this.columnModel.getCols().some((g) => g.isRowGroupActive())
      let l = {}
      i && s && (l = this.calculateDirtyNodes(s))
      const c = this.columnModel.isPivotMode(),
        u = this.gos.getCallback('postSortRows'),
        h = (g) => {
          var v
          this.pullDownGroupDataForHideOpenParents(g.childrenAfterAggFilter, !0)
          const f = c && g.leafGroup
          if (o && a && !g.leafGroup && !r) {
            const m =
                (v = this.funcColsService.getRowGroupColumns()) == null
                  ? void 0
                  : v[g.level + 1],
              C = (m == null ? void 0 : m.getSort()) === null,
              w = g.childrenAfterAggFilter.slice(0)
            if (g.childrenAfterSort && !C) {
              const S = {}
              g.childrenAfterSort.forEach((y, F) => {
                S[y.id] = F
              }),
                w.sort((y, F) => (S[y.id] ?? 0) - (S[F.id] ?? 0))
            }
            g.childrenAfterSort = w
          } else
            !t || f
              ? (g.childrenAfterSort = g.childrenAfterAggFilter.slice(0))
              : i
                ? (g.childrenAfterSort = this.doDeltaSort(g, l, n, e))
                : (g.childrenAfterSort = this.rowNodeSorter.doFullSort(
                    g.childrenAfterAggFilter,
                    e,
                  ))
          if (
            (g.sibling && (g.sibling.childrenAfterSort = g.childrenAfterSort),
            this.updateChildIndexes(g),
            u)
          ) {
            const m = { nodes: g.childrenAfterSort }
            u(m)
          }
        }
      n && n.forEachChangedNodeDepthFirst(h),
        this.updateGroupDataForHideOpenParents(n)
    }
    calculateDirtyNodes(e) {
      const t = {},
        i = (s) => {
          s && s.forEach((n) => (t[n.id] = !0))
        }
      return (
        e &&
          e.forEach((s) => {
            i(s.add), i(s.update), i(s.remove)
          }),
        t
      )
    }
    doDeltaSort(e, t, i, s) {
      const n = e.childrenAfterAggFilter,
        r = e.childrenAfterSort
      if (!r) return this.rowNodeSorter.doFullSort(n, s)
      const o = {},
        a = []
      n.forEach((h) => {
        t[h.id] || !i.canSkip(h) ? a.push(h) : (o[h.id] = !0)
      })
      const l = r.filter((h) => o[h.id]),
        c = (h, g) => ({ currentPos: g, rowNode: h }),
        u = a.map(c).sort((h, g) => this.rowNodeSorter.compareRowNodes(s, h, g))
      return this.mergeSortedArrays(s, u, l.map(c)).map(({ rowNode: h }) => h)
    }
    mergeSortedArrays(e, t, i) {
      const s = []
      let n = 0,
        r = 0
      for (; n < t.length && r < i.length; )
        this.rowNodeSorter.compareRowNodes(e, t[n], i[r]) < 0
          ? s.push(t[n++])
          : s.push(i[r++])
      for (; n < t.length; ) s.push(t[n++])
      for (; r < i.length; ) s.push(i[r++])
      return s
    }
    updateChildIndexes(e) {
      if (ot(e.childrenAfterSort)) return
      const t = e.childrenAfterSort
      for (let i = 0; i < t.length; i++) {
        const s = t[i],
          n = i === 0,
          r = i === e.childrenAfterSort.length - 1
        s.setFirstChild(n), s.setLastChild(r), s.setChildIndex(i)
      }
    }
    updateGroupDataForHideOpenParents(e) {
      if (!this.gos.get('groupHideOpenParents')) return
      if (this.gos.get('treeData'))
        return (
          te(
            "The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them.",
          ),
          !1
        )
      const t = (i) => {
        this.pullDownGroupDataForHideOpenParents(i.childrenAfterSort, !1),
          i.childrenAfterSort.forEach((s) => {
            s.hasChildren() && t(s)
          })
      }
      e && e.executeFromRootNode((i) => t(i))
    }
    pullDownGroupDataForHideOpenParents(e, t) {
      !this.gos.get('groupHideOpenParents') ||
        ot(e) ||
        e.forEach((i) => {
          var n
          ;(
            ((n = this.showRowGroupColsService) == null
              ? void 0
              : n.getShowRowGroupCols()) ?? []
          ).forEach((r) => {
            const o = r.getColDef().showRowGroup
            if (typeof o != 'string') {
              ht(
                'groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup',
              )
              return
            }
            const a = o,
              l = this.columnModel.getColDefCol(a)
            if (l !== i.rowGroupColumn)
              if (t) i.setGroupValue(r.getId(), void 0)
              else {
                const u = this.getFirstChildOfFirstChild(i, l)
                u && i.setGroupValue(r.getId(), u.key)
              }
          })
        })
    }
    getFirstChildOfFirstChild(e, t) {
      let i = e
      for (; i; ) {
        const s = i.parent
        if (s && i.firstChild) {
          if (s.rowGroupColumn === t) return s
        } else return null
        i = s
      }
      return null
    }
  },
  F1 = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'sortStage')
    }
    wireBeans(e) {
      ;(this.sortService = e.sortService),
        (this.sortController = e.sortController)
    }
    execute(e) {
      const t = this.sortController.getSortOptions(),
        i = ue(t) && t.length > 0,
        s = i && ue(e.rowNodeTransactions) && this.gos.get('deltaSort'),
        n = t.some((r) =>
          cs(this.gos)
            ? r.column.isPrimary() && r.column.isRowGroupActive()
            : !!r.column.getColDef().showRowGroup,
        )
      this.sortService.sort(t, i, s, e.rowNodeTransactions, e.changedPath, n)
    }
  },
  Md = '32.3.3',
  cC = {
    version: Md,
    moduleName: '@ag-grid-community/client-side-row-model-core',
    rowModel: 'clientSide',
    beans: [l1, w1, F1, y1, R1, b1],
  },
  E1 = {
    version: Md,
    moduleName: '@ag-grid-community/client-side-row-model-api',
    beans: [lC],
    apiFunctions: {
      onGroupExpandedOrCollapsed: c1,
      refreshClientSideRowModel: u1,
      isRowDataEmpty: d1,
      forEachLeafNode: h1,
      forEachNodeAfterFilter: g1,
      forEachNodeAfterFilterAndSort: f1,
      resetRowHeights: p1,
      applyTransaction: m1,
      applyTransactionAsync: v1,
      flushAsyncTransactions: C1,
      getBestCostNodeSelection: S1,
    },
    dependantModules: [cC, s1],
  },
  P1 = {
    version: Md,
    moduleName: '@ag-grid-community/client-side-row-model',
    dependantModules: [cC, E1],
  },
  x1 = class extends X {
    setBeans(e) {
      this.beans = e
    }
    getFileName(e) {
      const t = this.getDefaultFileExtension()
      return (
        (e == null || !e.length) && (e = this.getDefaultFileName()),
        e.indexOf('.') === -1 ? `${e}.${t}` : e
      )
    }
    getData(e) {
      const t = this.createSerializingSession(e)
      return this.beans.gridSerializer.serialize(t, e)
    }
    getDefaultFileName() {
      return `export.${this.getDefaultFileExtension()}`
    }
  },
  D1 = class {
    constructor(e) {
      this.groupColumns = []
      const {
        columnModel: t,
        funcColsService: i,
        columnNameService: s,
        valueService: n,
        gos: r,
        processCellCallback: o,
        processHeaderCallback: a,
        processGroupHeaderCallback: l,
        processRowGroupCallback: c,
      } = e
      ;(this.columnModel = t),
        (this.funcColsService = i),
        (this.columnNameService = s),
        (this.valueService = n),
        (this.gos = r),
        (this.processCellCallback = o),
        (this.processHeaderCallback = a),
        (this.processGroupHeaderCallback = l),
        (this.processRowGroupCallback = c)
    }
    prepare(e) {
      this.groupColumns = e.filter((t) => !!t.getColDef().showRowGroup)
    }
    extractHeaderValue(e) {
      return this.getHeaderName(this.processHeaderCallback, e) ?? ''
    }
    extractRowCellValue(e, t, i, s, n) {
      const o =
        (!this.gos.get('groupHideOpenParents') || n.footer) &&
        this.shouldRenderGroupSummaryCell(n, e, t)
          ? this.createValueForGroupNode(e, n)
          : this.valueService.getValue(e, n)
      return this.processCell({
        accumulatedRowIndex: i,
        rowNode: n,
        column: e,
        value: o,
        processCellCallback: this.processCellCallback,
        type: s,
      })
    }
    shouldRenderGroupSummaryCell(e, t, i) {
      var o
      if (!(e && e.group)) return !1
      if (this.groupColumns.indexOf(t) !== -1) {
        const a = (o = e.groupData) == null ? void 0 : o[t.getId()],
          l = this.gos.get('suppressGroupMaintainValueType')
        if (
          (l && a != null) ||
          (!l && a !== void 0) ||
          (ms(this.gos) && e.group)
        )
          return !0
        if (e.footer && e.level === -1) {
          const c = t.getColDef()
          return (
            c == null ||
            c.showRowGroup === !0 ||
            c.showRowGroup ===
              this.funcColsService.getRowGroupColumns()[0].getId()
          )
        }
      }
      const r = pl(this.gos, this.columnModel.isPivotMode())
      return i === 0 && r
    }
    getHeaderName(e, t) {
      return e
        ? e(this.gos.addGridCommonParams({ column: t }))
        : this.columnNameService.getDisplayNameForColumn(t, 'csv', !0)
    }
    createValueForGroupNode(e, t) {
      if (this.processRowGroupCallback)
        return this.processRowGroupCallback(
          this.gos.addGridCommonParams({ column: e, node: t }),
        )
      const i = this.gos.get('treeData'),
        s = this.gos.get('suppressGroupMaintainValueType'),
        n = (l) => {
          var u
          if (i || s) return l.key
          const c = (u = l.groupData) == null ? void 0 : u[e.getId()]
          return !c ||
            !l.rowGroupColumn ||
            l.rowGroupColumn.getColDef().useValueFormatterForExport === !1
            ? c
            : (this.valueService.formatValue(l.rowGroupColumn, l, c) ?? c)
        },
        r = t.footer,
        o = [n(t)]
      if (!bm(this.gos)) for (; t.parent; ) (t = t.parent), o.push(n(t))
      const a = o.reverse().join(' -> ')
      return r ? `Total ${a}` : a
    }
    processCell(e) {
      const {
        accumulatedRowIndex: t,
        rowNode: i,
        column: s,
        value: n,
        processCellCallback: r,
        type: o,
      } = e
      return r
        ? {
            value:
              r(
                this.gos.addGridCommonParams({
                  accumulatedRowIndex: t,
                  column: s,
                  node: i,
                  value: n,
                  type: o,
                  parseValue: (a) =>
                    this.valueService.parseValue(
                      s,
                      i,
                      a,
                      this.valueService.getValue(s, i),
                    ),
                  formatValue: (a) =>
                    this.valueService.formatValue(s, i, a) ?? a,
                }),
              ) ?? '',
          }
        : s.getColDef().useValueFormatterForExport !== !1
          ? {
              value: n ?? '',
              valueFormatted: this.valueService.formatValue(s, i, n),
            }
          : { value: n ?? '' }
    }
  },
  M1 = class {
    static download(e, t) {
      const i = document.defaultView || window
      if (!i) {
        te('There is no `window` associated with the current `document`')
        return
      }
      const s = document.createElement('a'),
        n = i.URL.createObjectURL(t)
      s.setAttribute('href', n),
        s.setAttribute('download', e),
        (s.style.display = 'none'),
        document.body.appendChild(s),
        s.dispatchEvent(
          new MouseEvent('click', { bubbles: !1, cancelable: !0, view: i }),
        ),
        document.body.removeChild(s),
        i.setTimeout(() => {
          i.URL.revokeObjectURL(n)
        }, 0)
    }
  },
  Ng = `\r
`,
  I1 = class extends D1 {
    constructor(e) {
      super(e), (this.isFirstLine = !0), (this.result = '')
      const { suppressQuotes: t, columnSeparator: i } = e
      ;(this.suppressQuotes = t), (this.columnSeparator = i)
    }
    addCustomContent(e) {
      e &&
        (typeof e == 'string'
          ? (/^\s*\n/.test(e) || this.beginNewLine(),
            (e = e.replace(/\r?\n/g, Ng)),
            (this.result += e))
          : e.forEach((t) => {
              this.beginNewLine(),
                t.forEach((i, s) => {
                  s !== 0 && (this.result += this.columnSeparator),
                    (this.result += this.putInQuotes(i.data.value || '')),
                    i.mergeAcross && this.appendEmptyCells(i.mergeAcross)
                })
            }))
    }
    onNewHeaderGroupingRow() {
      return (
        this.beginNewLine(),
        { onColumn: this.onNewHeaderGroupingRowColumn.bind(this) }
      )
    }
    onNewHeaderGroupingRowColumn(e, t, i, s) {
      i != 0 && (this.result += this.columnSeparator),
        (this.result += this.putInQuotes(t)),
        this.appendEmptyCells(s)
    }
    appendEmptyCells(e) {
      for (let t = 1; t <= e; t++)
        this.result += this.columnSeparator + this.putInQuotes('')
    }
    onNewHeaderRow() {
      return (
        this.beginNewLine(), { onColumn: this.onNewHeaderRowColumn.bind(this) }
      )
    }
    onNewHeaderRowColumn(e, t) {
      t != 0 && (this.result += this.columnSeparator),
        (this.result += this.putInQuotes(this.extractHeaderValue(e)))
    }
    onNewBodyRow() {
      return (
        this.beginNewLine(), { onColumn: this.onNewBodyRowColumn.bind(this) }
      )
    }
    onNewBodyRowColumn(e, t, i) {
      t != 0 && (this.result += this.columnSeparator)
      const s = this.extractRowCellValue(e, t, t, 'csv', i)
      this.result += this.putInQuotes(s.valueFormatted ?? s.value)
    }
    putInQuotes(e) {
      if (this.suppressQuotes) return e
      if (e == null) return '""'
      let t
      return (
        typeof e == 'string'
          ? (t = e)
          : typeof e.toString == 'function'
            ? (t = e.toString())
            : (te('unknown value type during csv conversion'), (t = '')),
        '"' + t.replace(/"/g, '""') + '"'
      )
    }
    parse() {
      return this.result
    }
    beginNewLine() {
      this.isFirstLine || (this.result += Ng), (this.isFirstLine = !1)
    }
  },
  T1 = class extends x1 {
    constructor() {
      super(...arguments), (this.beanName = 'csvCreator')
    }
    wireBeans(e) {
      ;(this.columnModel = e.columnModel),
        (this.columnNameService = e.columnNameService),
        (this.funcColsService = e.funcColsService),
        (this.valueService = e.valueService),
        (this.gridSerializer = e.gridSerializer)
    }
    postConstruct() {
      this.setBeans({ gridSerializer: this.gridSerializer, gos: this.gos })
    }
    getMergedParams(e) {
      const t = this.gos.get('defaultCsvExportParams')
      return Object.assign({}, t, e)
    }
    export(e) {
      if (this.isExportSuppressed()) {
        te('Export cancelled. Export is not allowed as per your configuration.')
        return
      }
      const t = this.getMergedParams(e),
        i = this.getData(t),
        s = new Blob(['\uFEFF', i], { type: 'text/plain' }),
        n =
          typeof t.fileName == 'function'
            ? t.fileName(this.gos.getGridCommonParams())
            : t.fileName
      M1.download(this.getFileName(n), s)
    }
    exportDataAsCsv(e) {
      this.export(e)
    }
    getDataAsCsv(e, t = !1) {
      const i = t ? Object.assign({}, e) : this.getMergedParams(e)
      return this.getData(i)
    }
    getDefaultFileExtension() {
      return 'csv'
    }
    createSerializingSession(e) {
      const {
          columnModel: t,
          columnNameService: i,
          funcColsService: s,
          valueService: n,
          gos: r,
        } = this,
        {
          processCellCallback: o,
          processHeaderCallback: a,
          processGroupHeaderCallback: l,
          processRowGroupCallback: c,
          suppressQuotes: u,
          columnSeparator: h,
        } = e
      return new I1({
        columnModel: t,
        columnNameService: i,
        funcColsService: s,
        valueService: n,
        gos: r,
        processCellCallback: o || void 0,
        processHeaderCallback: a || void 0,
        processGroupHeaderCallback: l || void 0,
        processRowGroupCallback: c || void 0,
        suppressQuotes: u || !1,
        columnSeparator: h || ',',
      })
    }
    isExportSuppressed() {
      return this.gos.get('suppressCsvExport')
    }
  }
function A1(e, t) {
  var i
  return (i = e.csvCreator) == null ? void 0 : i.getDataAsCsv(t)
}
function O1(e, t) {
  var i
  ;(i = e.csvCreator) == null || i.exportDataAsCsv(t)
}
var L1 = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'gridSerializer')
    }
    wireBeans(e) {
      ;(this.visibleColsService = e.visibleColsService),
        (this.columnModel = e.columnModel),
        (this.columnNameService = e.columnNameService),
        (this.rowModel = e.rowModel),
        (this.pinnedRowModel = e.pinnedRowModel),
        (this.selectionService = e.selectionService),
        (this.rowNodeSorter = e.rowNodeSorter),
        (this.sortController = e.sortController)
    }
    serialize(e, t = {}) {
      const { allColumns: i, columnKeys: s, skipRowGroups: n } = t,
        r = this.getColumnsToExport(i, n, s)
      return ux(
        this.prepareSession(r),
        this.prependContent(t),
        this.exportColumnGroups(t, r),
        this.exportHeaders(t, r),
        this.processPinnedTopRows(t, r),
        this.processRows(t, r),
        this.processPinnedBottomRows(t, r),
        this.appendContent(t),
      )(e).parse()
    }
    processRow(e, t, i, s) {
      var C
      const n = t.shouldRowBeSkipped || (() => !1),
        r = this.gos.get('groupRemoveSingleChildren'),
        o = this.gos.get('groupRemoveLowestSingleChildren'),
        l = t.rowPositions != null || !!t.onlySelected,
        c = this.gos.get('groupHideOpenParents') && !l,
        u = this.columnModel.isPivotMode() ? s.leafGroup : !s.group,
        h = !!s.footer,
        g = o && s.leafGroup,
        f =
          s.allChildrenCount === 1 &&
          ((C = s.childrenAfterGroup) == null ? void 0 : C.length) === 1 &&
          (r || g)
      if (
        (!u && !h && (t.skipRowGroups || f || c)) ||
        (t.onlySelected && !s.isSelected()) ||
        (t.skipPinnedTop && s.rowPinned === 'top') ||
        (t.skipPinnedBottom && s.rowPinned === 'bottom') ||
        (s.level === -1 && !u && !h) ||
        n(this.gos.addGridCommonParams({ node: s }))
      )
        return
      const m = e.onNewBodyRow(s)
      if (
        (i.forEach((w, S) => {
          m.onColumn(w, S, s)
        }),
        t.getCustomContentBelowRow)
      ) {
        const w = t.getCustomContentBelowRow(
          this.gos.addGridCommonParams({ node: s }),
        )
        w && e.addCustomContent(w)
      }
    }
    appendContent(e) {
      return (t) => {
        const i = e.appendContent
        return i && t.addCustomContent(i), t
      }
    }
    prependContent(e) {
      return (t) => {
        const i = e.prependContent
        return i && t.addCustomContent(i), t
      }
    }
    prepareSession(e) {
      return (t) => (t.prepare(e), t)
    }
    exportColumnGroups(e, t) {
      return (i) => {
        if (!e.skipColumnGroupHeaders) {
          const s = new Lm(),
            n = this.visibleColsService.createGroups({
              columns: t,
              idCreator: s,
              pinned: null,
              isStandaloneStructure: !0,
            })
          this.recursivelyAddHeaderGroups(n, i, e.processGroupHeaderCallback)
        }
        return i
      }
    }
    exportHeaders(e, t) {
      return (i) => {
        if (!e.skipColumnHeaders) {
          const s = i.onNewHeaderRow()
          t.forEach((n, r) => {
            s.onColumn(n, r, void 0)
          })
        }
        return i
      }
    }
    processPinnedTopRows(e, t) {
      return (i) => {
        const s = this.processRow.bind(this, i, e, t)
        return (
          e.rowPositions
            ? e.rowPositions
                .filter((n) => n.rowPinned === 'top')
                .sort((n, r) => n.rowIndex - r.rowIndex)
                .map((n) => this.pinnedRowModel.getPinnedTopRow(n.rowIndex))
                .forEach(s)
            : this.pinnedRowModel.forEachPinnedRow('top', s),
          i
        )
      }
    }
    processRows(e, t) {
      return (i) => {
        const s = this.rowModel,
          n = Pt(this.gos),
          r = ms(this.gos),
          o = !n && e.onlySelected,
          a = this.processRow.bind(this, i, e, t),
          { exportedRows: l = 'filteredAndSorted' } = e
        if (e.rowPositions)
          e.rowPositions
            .filter((c) => c.rowPinned == null)
            .sort((c, u) => c.rowIndex - u.rowIndex)
            .map((c) => s.getRow(c.rowIndex))
            .forEach(a)
        else if (this.columnModel.isPivotMode())
          n
            ? s.forEachPivotNode(a, !0)
            : r
              ? s.forEachNodeAfterFilterAndSort(a, !0)
              : s.forEachNode(a)
        else if (e.onlySelectedAllPages || o) {
          const c = this.selectionService.getSelectedNodes()
          this.replicateSortedOrder(c), c.forEach(a)
        } else
          l === 'all'
            ? s.forEachNode(a)
            : n || r
              ? s.forEachNodeAfterFilterAndSort(a, !0)
              : s.forEachNode(a)
        return i
      }
    }
    replicateSortedOrder(e) {
      const t = this.sortController.getSortOptions(),
        i = (s, n) => {
          var r, o
          return s.rowIndex != null && n.rowIndex != null
            ? s.rowIndex - n.rowIndex
            : s.level === n.level
              ? ((r = s.parent) == null ? void 0 : r.id) ===
                ((o = n.parent) == null ? void 0 : o.id)
                ? this.rowNodeSorter.compareRowNodes(
                    t,
                    { rowNode: s, currentPos: s.rowIndex ?? -1 },
                    { rowNode: n, currentPos: n.rowIndex ?? -1 },
                  )
                : i(s.parent, n.parent)
              : s.level > n.level
                ? i(s.parent, n)
                : i(s, n.parent)
        }
      e.sort(i)
    }
    processPinnedBottomRows(e, t) {
      return (i) => {
        const s = this.processRow.bind(this, i, e, t)
        return (
          e.rowPositions
            ? e.rowPositions
                .filter((n) => n.rowPinned === 'bottom')
                .sort((n, r) => n.rowIndex - r.rowIndex)
                .map((n) => this.pinnedRowModel.getPinnedBottomRow(n.rowIndex))
                .forEach(s)
            : this.pinnedRowModel.forEachPinnedRow('bottom', s),
          i
        )
      }
    }
    getColumnsToExport(e = !1, t = !1, i) {
      const s = this.columnModel.isPivotMode()
      if (i && i.length) return this.columnModel.getColsForKeys(i)
      const n = this.gos.get('treeData')
      let r = []
      return (
        e && !s
          ? (r = this.columnModel.getCols())
          : (r = this.visibleColsService.getAllCols()),
        t && !n && (r = r.filter((o) => Yc(o) || Lo(o))),
        r
      )
    }
    recursivelyAddHeaderGroups(e, t, i) {
      const s = []
      e.forEach((n) => {
        const r = n
        r.getChildren && r.getChildren().forEach((o) => s.push(o))
      }),
        e.length > 0 && _t(e[0]) && this.doAddHeaderHeader(t, e, i),
        s && s.length > 0 && this.recursivelyAddHeaderGroups(s, t, i)
    }
    doAddHeaderHeader(e, t, i) {
      const s = e.onNewHeaderGroupingRow()
      let n = 0
      t.forEach((r) => {
        const o = r
        let a
        i
          ? (a = i(this.gos.addGridCommonParams({ columnGroup: o })))
          : (a = this.columnNameService.getDisplayNameForColumnGroup(
              o,
              'header',
            ))
        const l = o.getLeafColumns().reduce((c, u, h, g) => {
          let f = rt(c)
          return (
            u.getColumnGroupShow() === 'open'
              ? (!f || f[1] != null) && ((f = [h]), c.push(f))
              : f && f[1] == null && (f[1] = h - 1),
            h === g.length - 1 && f && f[1] == null && (f[1] = h),
            c
          )
        }, [])
        s.onColumn(o, a || '', n++, o.getLeafColumns().length - 1, l)
      })
    }
  },
  Id = '32.3.3',
  uC = {
    version: Id,
    moduleName: '@ag-grid-community/csv-export-core',
    beans: [T1, L1],
  },
  k1 = {
    version: Id,
    moduleName: '@ag-grid-community/csv-export-api',
    apiFunctions: { getDataAsCsv: A1, exportDataAsCsv: O1 },
    dependantModules: [uC],
  },
  H1 = {
    version: Id,
    moduleName: '@ag-grid-community/csv-export',
    dependantModules: [uC, k1],
  },
  N1 = class extends VA {
    wireBeans(e) {
      this.beans = e
    }
    constructor(e, t, i) {
      super(e),
        (this.parentCache = t),
        (this.params = i),
        (this.startRow = e * i.blockSize),
        (this.endRow = this.startRow + i.blockSize)
    }
    postConstruct() {
      this.createRowNodes()
    }
    getBlockStateJson() {
      return {
        id: '' + this.getId(),
        state: {
          blockNumber: this.getId(),
          startRow: this.getStartRow(),
          endRow: this.getEndRow(),
          pageStatus: this.getState(),
        },
      }
    }
    setDataAndId(e, t, i) {
      ue(t) ? e.setDataAndId(t, i.toString()) : e.setDataAndId(void 0, void 0)
    }
    loadFromDatasource() {
      const e = this.createLoadParams()
      if (ot(this.params.datasource.getRows)) {
        te('datasource is missing getRows method')
        return
      }
      window.setTimeout(() => {
        this.params.datasource.getRows(e)
      }, 0)
    }
    processServerFail() {}
    createLoadParams() {
      return {
        startRow: this.getStartRow(),
        endRow: this.getEndRow(),
        successCallback: this.pageLoaded.bind(this, this.getVersion()),
        failCallback: this.pageLoadFailed.bind(this, this.getVersion()),
        sortModel: this.params.sortModel,
        filterModel: this.params.filterModel,
        context: this.gos.getGridCommonParams().context,
      }
    }
    forEachNode(e, t, i) {
      this.rowNodes.forEach((s, n) => {
        this.startRow + n < i && e(s, t.next())
      })
    }
    getLastAccessed() {
      return this.lastAccessed
    }
    getRow(e, t = !1) {
      t || (this.lastAccessed = this.params.lastAccessedSequence.next())
      const i = e - this.startRow
      return this.rowNodes[i]
    }
    getStartRow() {
      return this.startRow
    }
    getEndRow() {
      return this.endRow
    }
    createRowNodes() {
      this.rowNodes = []
      for (let e = 0; e < this.params.blockSize; e++) {
        const t = this.startRow + e,
          i = new Ls(this.beans)
        i.setRowHeight(this.params.rowHeight),
          (i.uiLevel = 0),
          i.setRowIndex(t),
          i.setRowTop(this.params.rowHeight * t),
          this.rowNodes.push(i)
      }
    }
    processServerResult(e) {
      this.rowNodes.forEach((i, s) => {
        const n = e.rowData ? e.rowData[s] : void 0
        !i.id &&
          i.alreadyRendered &&
          n &&
          ((this.rowNodes[s] = new Ls(this.beans)),
          this.rowNodes[s].setRowIndex(i.rowIndex),
          this.rowNodes[s].setRowTop(i.rowTop),
          this.rowNodes[s].setRowHeight(i.rowHeight),
          i.clearRowTopAndRowIndex()),
          this.setDataAndId(this.rowNodes[s], n, this.startRow + s)
      })
      const t = e.rowCount != null && e.rowCount >= 0 ? e.rowCount : void 0
      this.parentCache.pageLoaded(this, t)
    }
    destroy() {
      this.rowNodes.forEach((e) => {
        e.clearRowTopAndRowIndex()
      }),
        super.destroy()
    }
  },
  G1 = 2,
  B1 = class extends X {
    constructor(e) {
      super(),
        (this.lastRowIndexKnown = !1),
        (this.blocks = {}),
        (this.blockCount = 0),
        (this.rowCount = e.initialRowCount),
        (this.params = e)
    }
    wireBeans(e) {
      ;(this.rowRenderer = e.rowRenderer), (this.focusService = e.focusService)
    }
    getRow(e, t = !1) {
      const i = Math.floor(e / this.params.blockSize)
      let s = this.blocks[i]
      if (!s) {
        if (t) return
        s = this.createBlock(i)
      }
      return s.getRow(e)
    }
    createBlock(e) {
      const t = this.createBean(new N1(e, this, this.params))
      return (
        (this.blocks[t.getId()] = t),
        this.blockCount++,
        this.purgeBlocksIfNeeded(t),
        this.params.rowNodeBlockLoader.addBlock(t),
        t
      )
    }
    refreshCache() {
      if (this.blockCount == 0) {
        this.purgeCache()
        return
      }
      this.getBlocksInOrder().forEach((t) => t.setStateWaitingToLoad()),
        this.params.rowNodeBlockLoader.checkBlockToLoad()
    }
    destroy() {
      this.getBlocksInOrder().forEach((e) => this.destroyBlock(e)),
        super.destroy()
    }
    getRowCount() {
      return this.rowCount
    }
    isLastRowIndexKnown() {
      return this.lastRowIndexKnown
    }
    pageLoaded(e, t) {
      this.isAlive() &&
        (this.gos.get('debug') &&
          Xi(
            `InfiniteCache - onPageLoaded: page = ${e.getId()}, lastRow = ${t}`,
          ),
        this.checkRowCount(e, t),
        this.onCacheUpdated())
    }
    purgeBlocksIfNeeded(e) {
      const t = this.getBlocksInOrder().filter((o) => o != e),
        i = (o, a) => a.getLastAccessed() - o.getLastAccessed()
      t.sort(i)
      const s = this.params.maxBlocksInCache > 0,
        n = s ? this.params.maxBlocksInCache - 1 : null,
        r = G1 - 1
      t.forEach((o, a) => {
        const l = o.getState() === 'needsLoading' && a >= r,
          c = s ? a >= n : !1
        if (l || c) {
          if (this.isBlockCurrentlyDisplayed(o) || this.isBlockFocused(o))
            return
          this.removeBlockFromCache(o)
        }
      })
    }
    isBlockFocused(e) {
      const t = this.focusService.getFocusCellToUseAfterRefresh()
      if (!t || t.rowPinned != null) return !1
      const i = e.getStartRow(),
        s = e.getEndRow()
      return t.rowIndex >= i && t.rowIndex < s
    }
    isBlockCurrentlyDisplayed(e) {
      const t = e.getStartRow(),
        i = e.getEndRow() - 1
      return this.rowRenderer.isRangeInRenderedViewport(t, i)
    }
    removeBlockFromCache(e) {
      e && this.destroyBlock(e)
    }
    checkRowCount(e, t) {
      if (typeof t == 'number' && t >= 0)
        (this.rowCount = t), (this.lastRowIndexKnown = !0)
      else if (!this.lastRowIndexKnown) {
        const s =
          (e.getId() + 1) * this.params.blockSize + this.params.overflowSize
        this.rowCount < s && (this.rowCount = s)
      }
    }
    setRowCount(e, t) {
      ;(this.rowCount = e),
        ue(t) && (this.lastRowIndexKnown = t),
        this.lastRowIndexKnown ||
          (this.rowCount % this.params.blockSize === 0 && this.rowCount++),
        this.onCacheUpdated()
    }
    forEachNodeDeep(e) {
      const t = new vr()
      this.getBlocksInOrder().forEach((i) => i.forEachNode(e, t, this.rowCount))
    }
    getBlocksInOrder() {
      const e = (i, s) => i.getId() - s.getId()
      return qc(this.blocks).sort(e)
    }
    destroyBlock(e) {
      delete this.blocks[e.getId()],
        this.destroyBean(e),
        this.blockCount--,
        this.params.rowNodeBlockLoader.removeBlock(e)
    }
    onCacheUpdated() {
      this.isAlive() &&
        (this.destroyAllBlocksPastVirtualRowCount(),
        this.eventService.dispatchEvent({ type: 'storeUpdated' }))
    }
    destroyAllBlocksPastVirtualRowCount() {
      const e = []
      this.getBlocksInOrder().forEach((t) => {
        t.getId() * this.params.blockSize >= this.rowCount && e.push(t)
      }),
        e.length > 0 && e.forEach((t) => this.destroyBlock(t))
    }
    purgeCache() {
      this.getBlocksInOrder().forEach((e) => this.removeBlockFromCache(e)),
        (this.lastRowIndexKnown = !1),
        this.rowCount === 0 && (this.rowCount = this.params.initialRowCount),
        this.onCacheUpdated()
    }
    getRowNodesInRange(e, t) {
      const i = []
      let s = -1,
        n = !1
      const r = new vr()
      let o = !1
      return (
        this.getBlocksInOrder().forEach((l) => {
          if (!o) {
            if (n && s + 1 !== l.getId()) {
              o = !0
              return
            }
            ;(s = l.getId()),
              l.forEachNode(
                (c) => {
                  const u = c === e || c === t
                  ;(n || u) && i.push(c), u && (n = !n)
                },
                r,
                this.rowCount,
              )
          }
        }),
        o || n ? [] : i
      )
    }
  },
  V1 = class extends X {
    constructor() {
      super(...arguments), (this.beanName = 'rowModel')
    }
    wireBeans(e) {
      ;(this.filterManager = e.filterManager),
        (this.sortController = e.sortController),
        (this.selectionService = e.selectionService),
        (this.rowRenderer = e.rowRenderer),
        (this.rowNodeBlockLoader = e.rowNodeBlockLoader)
    }
    getRowBounds(e) {
      return { rowHeight: this.rowHeight, rowTop: this.rowHeight * e }
    }
    ensureRowHeightsValid() {
      return !1
    }
    postConstruct() {
      this.gos.get('rowModelType') === 'infinite' &&
        ((this.rowHeight = In(this.gos)),
        this.addEventListeners(),
        this.addDestroyFunc(() => this.destroyCache()),
        this.verifyProps())
    }
    verifyProps() {
      this.gos.exists('initialGroupOrderComparator') &&
        te(
          'initialGroupOrderComparator cannot be used with Infinite Row Model as sorting is done on the server side',
        )
    }
    start() {
      this.setDatasource(this.gos.get('datasource'))
    }
    destroy() {
      this.destroyDatasource(), super.destroy()
    }
    destroyDatasource() {
      this.datasource &&
        (this.destroyBean(this.datasource),
        this.rowRenderer.datasourceChanged(),
        (this.datasource = null))
    }
    addEventListeners() {
      this.addManagedEventListeners({
        filterChanged: this.onFilterChanged.bind(this),
        sortChanged: this.onSortChanged.bind(this),
        newColumnsLoaded: this.onColumnEverything.bind(this),
        storeUpdated: this.onCacheUpdated.bind(this),
      }),
        this.addManagedPropertyListener('datasource', () =>
          this.setDatasource(this.gos.get('datasource')),
        ),
        this.addManagedPropertyListener('cacheBlockSize', () =>
          this.resetCache(),
        ),
        this.addManagedPropertyListener('rowHeight', () => {
          ;(this.rowHeight = In(this.gos)),
            (this.cacheParams.rowHeight = this.rowHeight),
            this.updateRowHeights()
        })
    }
    onFilterChanged() {
      this.reset()
    }
    onSortChanged() {
      this.reset()
    }
    onColumnEverything() {
      let e
      this.cacheParams ? (e = this.isSortModelDifferent()) : (e = !0),
        e && this.reset()
    }
    isSortModelDifferent() {
      return !po(this.cacheParams.sortModel, this.sortController.getSortModel())
    }
    getType() {
      return 'infinite'
    }
    setDatasource(e) {
      this.destroyDatasource(), (this.datasource = e), e && this.reset()
    }
    isEmpty() {
      return !this.infiniteCache
    }
    isRowsToRender() {
      return !!this.infiniteCache
    }
    getNodesInRangeForSelection(e, t) {
      return this.infiniteCache
        ? this.infiniteCache.getRowNodesInRange(e, t)
        : []
    }
    reset() {
      if (!this.datasource) return
      Mr(this.gos) != null || this.selectionService.reset('rowDataChanged'),
        this.resetCache()
    }
    dispatchModelUpdatedEvent() {
      this.eventService.dispatchEvent({
        type: 'modelUpdated',
        newPage: !1,
        newPageSize: !1,
        newData: !1,
        keepRenderedRows: !0,
        animate: !1,
      })
    }
    resetCache() {
      var e
      this.destroyCache(),
        (this.cacheParams = {
          datasource: this.datasource,
          filterModel:
            ((e = this.filterManager) == null ? void 0 : e.getFilterModel()) ??
            {},
          sortModel: this.sortController.getSortModel(),
          rowNodeBlockLoader: this.rowNodeBlockLoader,
          initialRowCount: this.gos.get('infiniteInitialRowCount'),
          maxBlocksInCache: this.gos.get('maxBlocksInCache'),
          rowHeight: In(this.gos),
          overflowSize: this.gos.get('cacheOverflowSize'),
          blockSize: this.gos.get('cacheBlockSize'),
          lastAccessedSequence: new vr(),
        }),
        (this.infiniteCache = this.createBean(new B1(this.cacheParams))),
        this.eventService.dispatchEventOnce({ type: 'rowCountReady' }),
        this.dispatchModelUpdatedEvent()
    }
    updateRowHeights() {
      this.forEachNode((e) => {
        e.setRowHeight(this.rowHeight), e.setRowTop(this.rowHeight * e.rowIndex)
      }),
        this.dispatchModelUpdatedEvent()
    }
    destroyCache() {
      this.infiniteCache &&
        (this.infiniteCache = this.destroyBean(this.infiniteCache))
    }
    onCacheUpdated() {
      this.dispatchModelUpdatedEvent()
    }
    getRow(e) {
      if (this.infiniteCache && !(e >= this.infiniteCache.getRowCount()))
        return this.infiniteCache.getRow(e)
    }
    getRowNode(e) {
      let t
      return (
        this.forEachNode((i) => {
          i.id === e && (t = i)
        }),
        t
      )
    }
    forEachNode(e) {
      this.infiniteCache && this.infiniteCache.forEachNodeDeep(e)
    }
    getTopLevelRowCount() {
      return this.getRowCount()
    }
    getTopLevelRowDisplayedIndex(e) {
      return e
    }
    getRowIndexAtPixel(e) {
      if (this.rowHeight !== 0) {
        const t = Math.floor(e / this.rowHeight),
          i = this.getRowCount() - 1
        return t > i ? i : t
      }
      return 0
    }
    getRowCount() {
      return this.infiniteCache ? this.infiniteCache.getRowCount() : 0
    }
    isRowPresent(e) {
      return !!this.getRowNode(e.id)
    }
    refreshCache() {
      this.infiniteCache && this.infiniteCache.refreshCache()
    }
    purgeCache() {
      this.infiniteCache && this.infiniteCache.purgeCache()
    }
    isLastRowIndexKnown() {
      return this.infiniteCache ? this.infiniteCache.isLastRowIndexKnown() : !1
    }
    setRowCount(e, t) {
      this.infiniteCache && this.infiniteCache.setRowCount(e, t)
    }
  }
function _1(e) {
  var t, i
  ;(i =
    (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) ==
    null || i.refreshCache()
}
function W1(e) {
  var t, i
  ;(i =
    (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) ==
    null || i.purgeCache()
}
function $1(e) {
  var t, i
  return (i =
    (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) ==
    null
    ? void 0
    : i.getRowCount()
}
var Td = '32.3.3',
  dC = {
    version: Td,
    moduleName: '@ag-grid-community/infinite-row-model-core',
    rowModel: 'infinite',
    beans: [V1],
    dependantModules: [WA],
  },
  z1 = {
    version: Td,
    moduleName: '@ag-grid-community/infinite-row-model-api',
    beans: [lC],
    apiFunctions: {
      refreshInfiniteCache: _1,
      purgeInfiniteCache: W1,
      getInfiniteRowCount: $1,
    },
    dependantModules: [dC, n1],
  },
  U1 = {
    version: Td,
    moduleName: '@ag-grid-community/infinite-row-model',
    dependantModules: [dC, z1],
  }
us.__registerModules([iC, P1, U1, H1], !1, void 0)
var mi = $.createContext({}),
  Bo = (e, t, i, s) => {
    if (!e || e.componentFromFramework || t.isDestroyed()) return
    const r = e.newAgStackInstance()
    if (r == null) return
    let o,
      a,
      l = !1
    return (
      r.then((c) => {
        if (l) {
          t.destroyBean(c)
          return
        }
        ;(o = c), (a = o.getGui()), i.appendChild(a), Gg(s, o)
      }),
      () => {
        var c
        ;(l = !0),
          o &&
            ((c = a == null ? void 0 : a.parentElement) == null ||
              c.removeChild(a),
            t.destroyBean(o),
            s && Gg(s, void 0))
      }
    )
  },
  Gg = (e, t) => {
    if (e)
      if (e instanceof Function) e(t)
      else {
        const i = e
        i.current = t
      }
  },
  qi = (...e) => e.filter((i) => i != null && i !== '').join(' '),
  _i = class hC {
    constructor(...t) {
      ;(this.classesMap = {}),
        t.forEach((i) => {
          this.classesMap[i] = !0
        })
    }
    setClass(t, i) {
      if (!!this.classesMap[t] == i) return this
      const n = new hC()
      return (n.classesMap = { ...this.classesMap }), (n.classesMap[t] = i), n
    }
    toString() {
      return Object.keys(this.classesMap)
        .filter((i) => this.classesMap[i])
        .join(' ')
    }
  },
  Lr = (e) => {
    const t = () => typeof Symbol == 'function' && Symbol.for,
      i = () => (t() ? Symbol.for('react.memo') : 60115)
    return (
      (typeof e == 'function' &&
        !(e.prototype && e.prototype.isReactComponent)) ||
      (typeof e == 'object' && e.$$typeof === i())
    )
  },
  qg,
  cu = (qg = $.version) == null ? void 0 : qg.split('.')[0],
  j1 = cu === '16' || cu === '17'
function Y1() {
  return cu === '19'
}
var pa = !1
function K1(e) {
  return pa || setTimeout(() => (pa = !1), 0), (pa = !0), e()
}
var Ad = (e, t) => {
  !j1 && e && !pa ? $S.flushSync(t) : t()
}
function Od(e, t, i) {
  if (t == null || e == null) return t
  if (e === t || (t.length === 0 && e.length === 0)) return e
  if (i || (e.length === 0 && t.length > 0) || (e.length > 0 && t.length === 0))
    return t
  const s = [],
    n = [],
    r = new Map(),
    o = new Map()
  for (let a = 0; a < t.length; a++) {
    const l = t[a]
    o.set(l.instanceId, l)
  }
  for (let a = 0; a < e.length; a++) {
    const l = e[a]
    r.set(l.instanceId, l), o.has(l.instanceId) && s.push(l)
  }
  for (let a = 0; a < t.length; a++) {
    const l = t[a],
      c = l.instanceId
    r.has(c) || n.push(l)
  }
  return s.length === e.length && n.length === 0
    ? e
    : s.length === 0 && n.length === t.length
      ? t
      : s.length === 0
        ? n
        : n.length === 0
          ? s
          : [...s, ...n]
}
var gC = d.forwardRef((e, t) => {
    var k
    const { ctrlsFactory: i, context: s } = d.useContext(mi),
      n = d.useRef(null),
      r = d.useRef(null),
      o = d.useRef(null),
      a = d.useRef(null),
      l = d.useRef(null),
      c = d.useRef(),
      [u, h] = d.useState(),
      [g, f] = d.useState(),
      [p, v] = d.useState(),
      [m, C] = d.useState(() => new _i()),
      [w, S] = d.useState(() => new _i('ag-hidden')),
      [y, F] = d.useState(() => new _i('ag-hidden')),
      [R, b] = d.useState(() => new _i('ag-invisible'))
    d.useImperativeHandle(t, () => ({
      refresh() {
        return !1
      },
    })),
      d.useLayoutEffect(() => Bo(u, s, r.current), [u])
    const x = d.useCallback((E) => {
        if (((n.current = E), !E)) {
          c.current = s.destroyBean(c.current)
          return
        }
        const N = {
            setInnerRenderer: (G, H) => {
              h(G), v(H)
            },
            setChildCount: (G) => f(G),
            addOrRemoveCssClass: (G, H) => C((_) => _.setClass(G, H)),
            setContractedDisplayed: (G) =>
              F((H) => H.setClass('ag-hidden', !G)),
            setExpandedDisplayed: (G) => S((H) => H.setClass('ag-hidden', !G)),
            setCheckboxVisible: (G) => b((H) => H.setClass('ag-invisible', !G)),
          },
          T = i.getInstance('groupCellRendererCtrl')
        T &&
          ((c.current = s.createBean(T)),
          c.current.init(N, E, o.current, a.current, l.current, gC, e))
      }, []),
      D = d.useMemo(() => `ag-cell-wrapper ${m.toString()}`, [m]),
      O = d.useMemo(() => `ag-group-expanded ${w.toString()}`, [w]),
      M = d.useMemo(() => `ag-group-contracted ${y.toString()}`, [y]),
      L = d.useMemo(() => `ag-group-checkbox ${R.toString()}`, [R]),
      V = u && u.componentFromFramework,
      A = V ? u.componentClass : void 0,
      I = u == null && p != null,
      P = hs(p, !0)
    return $.createElement(
      'span',
      {
        className: D,
        ref: x,
        ...(e.colDef
          ? {}
          : { role: (k = c.current) == null ? void 0 : k.getCellAriaRole() }),
      },
      $.createElement('span', { className: O, ref: a }),
      $.createElement('span', { className: M, ref: l }),
      $.createElement('span', { className: L, ref: o }),
      $.createElement(
        'span',
        { className: 'ag-group-value', ref: r },
        I && $.createElement($.Fragment, null, P),
        V && $.createElement(A, { ...u.params }),
      ),
      $.createElement('span', { className: 'ag-group-child-count' }, g),
    )
  }),
  Bg = gC,
  Ld = d.createContext({ setMethods: () => {} }),
  q1 = (e) => {
    const {
        initialProps: t,
        addUpdateCallback: i,
        CustomComponentClass: s,
        setMethods: n,
      } = e,
      [{ key: r, ...o }, a] = d.useState(t)
    return (
      d.useEffect(() => {
        i((l) => a(l))
      }, []),
      $.createElement(
        Ld.Provider,
        { value: { setMethods: n } },
        $.createElement(s, { key: r, ...o }),
      )
    )
  },
  Q1 = d.memo(q1),
  X1 = 0
function Vg() {
  return `agPortalKey_${++X1}`
}
var fC = class {
  constructor(e, t, i, s) {
    ;(this.portal = null),
      (this.oldPortal = null),
      (this.reactComponent = e),
      (this.portalManager = t),
      (this.componentType = i),
      (this.suppressFallbackMethods = !!s),
      (this.statelessComponent = this.isStateless(this.reactComponent)),
      (this.key = Vg()),
      (this.portalKey = Vg()),
      (this.instanceCreated = this.isStatelessComponent()
        ? Nt.resolve(!1)
        : new Nt((n) => {
            this.resolveInstanceCreated = n
          }))
  }
  getGui() {
    return this.eParentElement
  }
  getRootElement() {
    return this.eParentElement.firstChild
  }
  destroy() {
    this.componentInstance &&
      typeof this.componentInstance.destroy == 'function' &&
      this.componentInstance.destroy()
    const e = this.portal
    e && this.portalManager.destroyPortal(e)
  }
  createParentElement(e) {
    const t = this.portalManager.getComponentWrappingElement(),
      i = document.createElement(t || 'div')
    return i.classList.add('ag-react-container'), (e.reactContainer = i), i
  }
  addParentContainerStyleAndClasses() {
    this.componentInstance &&
      (this.componentInstance.getReactContainerStyle &&
        this.componentInstance.getReactContainerStyle() &&
        (te(
          'Since v31.1 "getReactContainerStyle" is deprecated. Apply styling directly to ".ag-react-container" if needed.',
        ),
        Object.assign(
          this.eParentElement.style,
          this.componentInstance.getReactContainerStyle(),
        )),
      this.componentInstance.getReactContainerClasses &&
        this.componentInstance.getReactContainerClasses() &&
        (te(
          'Since v31.1 "getReactContainerClasses" is deprecated. Apply styling directly to ".ag-react-container" if needed.',
        ),
        this.componentInstance
          .getReactContainerClasses()
          .forEach((t) => this.eParentElement.classList.add(t))))
  }
  statelessComponentRendered() {
    return (
      this.eParentElement.childElementCount > 0 ||
      this.eParentElement.childNodes.length > 0
    )
  }
  getFrameworkComponentInstance() {
    return this.componentInstance
  }
  isStatelessComponent() {
    return this.statelessComponent
  }
  getReactComponentName() {
    return this.reactComponent.name
  }
  getMemoType() {
    return this.hasSymbol() ? Symbol.for('react.memo') : 60115
  }
  hasSymbol() {
    return typeof Symbol == 'function' && Symbol.for
  }
  isStateless(e) {
    return (
      (typeof e == 'function' &&
        !(e.prototype && e.prototype.isReactComponent)) ||
      (typeof e == 'object' && e.$$typeof === this.getMemoType())
    )
  }
  hasMethod(e) {
    const t = this.getFrameworkComponentInstance()
    return (!!t && t[e] != null) || this.fallbackMethodAvailable(e)
  }
  callMethod(e, t) {
    const i = this.getFrameworkComponentInstance()
    if (this.isStatelessComponent())
      return this.fallbackMethod(e, t && t[0] ? t[0] : {})
    if (!i) {
      setTimeout(() => this.callMethod(e, t))
      return
    }
    const s = i[e]
    if (s) return s.apply(i, t)
    if (this.fallbackMethodAvailable(e))
      return this.fallbackMethod(e, t && t[0] ? t[0] : {})
  }
  addMethod(e, t) {
    this[e] = t
  }
  init(e) {
    return (
      (this.eParentElement = this.createParentElement(e)),
      this.createOrUpdatePortal(e),
      new Nt((t) => this.createReactComponent(t))
    )
  }
  createOrUpdatePortal(e) {
    this.isStatelessComponent() ||
      ((this.ref = (t) => {
        var i
        ;(this.componentInstance = t),
          this.addParentContainerStyleAndClasses(),
          (i = this.resolveInstanceCreated) == null || i.call(this, !0),
          (this.resolveInstanceCreated = void 0)
      }),
      (e.ref = this.ref)),
      (this.reactElement = this.createElement(this.reactComponent, {
        ...e,
        key: this.key,
      })),
      (this.portal = ya.createPortal(
        this.reactElement,
        this.eParentElement,
        this.portalKey,
      ))
  }
  createElement(e, t) {
    return d.createElement(e, t)
  }
  createReactComponent(e) {
    this.portalManager.mountReactPortal(this.portal, this, e)
  }
  rendered() {
    return (
      (this.isStatelessComponent() && this.statelessComponentRendered()) ||
      !!(!this.isStatelessComponent() && this.getFrameworkComponentInstance())
    )
  }
  refreshComponent(e) {
    ;(this.oldPortal = this.portal),
      this.createOrUpdatePortal(e),
      this.portalManager.updateReactPortal(this.oldPortal, this.portal)
  }
  fallbackMethod(e, t) {
    const i = this[`${e}Component`]
    if (!this.suppressFallbackMethods && i) return i.bind(this)(t)
  }
  fallbackMethodAvailable(e) {
    return this.suppressFallbackMethods ? !1 : !!this[`${e}Component`]
  }
}
function kd(e, t, i) {
  e.forEach((s) => {
    const n = t[s]
    n && (i[s] = n)
  })
}
var Cs = class extends fC {
    constructor() {
      super(...arguments),
        (this.awaitUpdateCallback = new Nt((e) => {
          this.resolveUpdateCallback = e
        })),
        (this.wrapperComponent = Q1)
    }
    init(e) {
      return (this.sourceParams = e), super.init(this.getProps())
    }
    addMethod() {}
    getInstance() {
      return this.instanceCreated.then(() => this.componentInstance)
    }
    getFrameworkComponentInstance() {
      return this
    }
    createElement(e, t) {
      return super.createElement(this.wrapperComponent, {
        initialProps: t,
        CustomComponentClass: e,
        setMethods: (i) => this.setMethods(i),
        addUpdateCallback: (i) => {
          ;(this.updateCallback = () => (
            i(this.getProps()),
            new Nt((s) => {
              setTimeout(() => {
                s()
              })
            })
          )),
            this.resolveUpdateCallback()
        },
      })
    }
    setMethods(e) {
      ;(this.providedMethods = e),
        kd(this.getOptionalMethods(), this.providedMethods, this)
    }
    getOptionalMethods() {
      return []
    }
    getProps() {
      return { ...this.sourceParams, key: this.key, ref: this.ref }
    }
    refreshProps() {
      return this.updateCallback
        ? this.updateCallback()
        : new Nt((e) =>
            this.awaitUpdateCallback.then(() => {
              this.updateCallback().then(() => e())
            }),
          )
    }
  },
  J1 = class extends Cs {
    refresh(e) {
      return (this.sourceParams = e), this.refreshProps(), !0
    }
  },
  Z1 = class extends Cs {
    constructor() {
      super(...arguments),
        (this.date = null),
        (this.onDateChange = (e) => this.updateDate(e))
    }
    getDate() {
      return this.date
    }
    setDate(e) {
      ;(this.date = e), this.refreshProps()
    }
    refresh(e) {
      ;(this.sourceParams = e), this.refreshProps()
    }
    getOptionalMethods() {
      return [
        'afterGuiAttached',
        'setInputPlaceholder',
        'setInputAriaLabel',
        'setDisabled',
      ]
    }
    updateDate(e) {
      this.setDate(e), this.sourceParams.onDateChanged()
    }
    getProps() {
      const e = super.getProps()
      return (
        (e.date = this.date),
        (e.onDateChange = this.onDateChange),
        delete e.onDateChanged,
        e
      )
    }
  },
  eN = class extends Cs {
    constructor() {
      super(...arguments),
        (this.label = ''),
        (this.icon = null),
        (this.shake = !1)
    }
    setIcon(e, t) {
      ;(this.icon = e), (this.shake = t), this.refreshProps()
    }
    setLabel(e) {
      ;(this.label = e), this.refreshProps()
    }
    getProps() {
      const e = super.getProps(),
        { label: t, icon: i, shake: s } = this
      return (e.label = t), (e.icon = i), (e.shake = s), e
    }
  },
  tN = class extends Cs {
    constructor() {
      super(...arguments),
        (this.model = null),
        (this.onModelChange = (e) => this.updateModel(e)),
        (this.onUiChange = () => this.sourceParams.filterChangedCallback()),
        (this.expectingNewMethods = !0),
        (this.hasBeenActive = !1)
    }
    isFilterActive() {
      return this.model != null
    }
    doesFilterPass(e) {
      return this.providedMethods.doesFilterPass(e)
    }
    getModel() {
      return this.model
    }
    setModel(e) {
      return (
        (this.expectingNewMethods = !0),
        (this.model = e),
        this.hasBeenActive || (this.hasBeenActive = this.isFilterActive()),
        this.refreshProps()
      )
    }
    refresh(e) {
      return (this.sourceParams = e), this.refreshProps(), !0
    }
    getOptionalMethods() {
      return [
        'afterGuiAttached',
        'afterGuiDetached',
        'onNewRowsLoaded',
        'getModelAsString',
        'onAnyFilterChanged',
      ]
    }
    setMethods(e) {
      var t
      this.expectingNewMethods === !1 &&
        this.hasBeenActive &&
        ((t = this.providedMethods) == null ? void 0 : t.doesFilterPass) !==
          (e == null ? void 0 : e.doesFilterPass) &&
        setTimeout(() => {
          this.sourceParams.filterChangedCallback()
        }),
        (this.expectingNewMethods = !1),
        super.setMethods(e)
    }
    updateModel(e) {
      this.setModel(e).then(() => this.sourceParams.filterChangedCallback())
    }
    getProps() {
      const e = super.getProps()
      return (
        (e.model = this.model),
        (e.onModelChange = this.onModelChange),
        (e.onUiChange = this.onUiChange),
        delete e.filterChangedCallback,
        delete e.filterModifiedCallback,
        delete e.valueGetter,
        e
      )
    }
  }
function pC(e, t) {
  e.parentFilterInstance((i) => {
    ;(i.setModel(t) || Nt.resolve()).then(() => {
      e.filterParams.filterChangedCallback()
    })
  })
}
var iN = class {
    constructor(e, t) {
      ;(this.floatingFilterParams = e),
        (this.refreshProps = t),
        (this.model = null),
        (this.onModelChange = (i) => this.updateModel(i))
    }
    getProps() {
      return {
        ...this.floatingFilterParams,
        model: this.model,
        onModelChange: this.onModelChange,
      }
    }
    onParentModelChanged(e) {
      ;(this.model = e), this.refreshProps()
    }
    refresh(e) {
      ;(this.floatingFilterParams = e), this.refreshProps()
    }
    setMethods(e) {
      kd(this.getOptionalMethods(), e, this)
    }
    getOptionalMethods() {
      return ['afterGuiAttached']
    }
    updateModel(e) {
      ;(this.model = e), this.refreshProps(), pC(this.floatingFilterParams, e)
    }
  },
  sN = class extends Cs {
    constructor() {
      super(...arguments),
        (this.model = null),
        (this.onModelChange = (e) => this.updateModel(e))
    }
    onParentModelChanged(e) {
      ;(this.model = e), this.refreshProps()
    }
    refresh(e) {
      ;(this.sourceParams = e), this.refreshProps()
    }
    getOptionalMethods() {
      return ['afterGuiAttached']
    }
    updateModel(e) {
      ;(this.model = e), this.refreshProps(), pC(this.sourceParams, e)
    }
    getProps() {
      const e = super.getProps()
      return (e.model = this.model), (e.onModelChange = this.onModelChange), e
    }
  },
  nN = class extends Cs {
    refresh(e) {
      ;(this.sourceParams = e), this.refreshProps()
    }
  },
  rN = class extends Cs {
    constructor() {
      super(...arguments),
        (this.active = !1),
        (this.expanded = !1),
        (this.onActiveChange = (e) => this.updateActive(e))
    }
    setActive(e) {
      this.awaitSetActive(e)
    }
    setExpanded(e) {
      ;(this.expanded = e), this.refreshProps()
    }
    getOptionalMethods() {
      return ['select', 'configureDefaults']
    }
    awaitSetActive(e) {
      return (this.active = e), this.refreshProps()
    }
    updateActive(e) {
      const t = this.awaitSetActive(e)
      e && t.then(() => this.sourceParams.onItemActivated())
    }
    getProps() {
      const e = super.getProps()
      return (
        (e.active = this.active),
        (e.expanded = this.expanded),
        (e.onActiveChange = this.onActiveChange),
        delete e.onItemActivated,
        e
      )
    }
  },
  oN = class extends Cs {
    refresh(e) {
      ;(this.sourceParams = e), this.refreshProps()
    }
  },
  aN = class extends Cs {
    refresh(e) {
      return (this.sourceParams = e), this.refreshProps(), !0
    }
  },
  lN = class extends Cs {
    constructor() {
      super(...arguments), (this.onStateChange = (e) => this.updateState(e))
    }
    refresh(e) {
      return (this.sourceParams = e), this.refreshProps(), !0
    }
    getState() {
      return this.state
    }
    updateState(e) {
      ;(this.state = e), this.refreshProps(), this.sourceParams.onStateUpdated()
    }
    getProps() {
      const e = super.getProps()
      return (e.state = this.state), (e.onStateChange = this.onStateChange), e
    }
  }
function Hd() {
  te(
    'As of v32, using custom components with `reactiveCustomComponents = false` is deprecated.',
  )
}
var cN = 1e3,
  uN = class {
    constructor(e, t, i) {
      ;(this.destroyed = !1),
        (this.portals = []),
        (this.hasPendingPortalUpdate = !1),
        (this.wrappingElement = t || 'div'),
        (this.refresher = e),
        (this.maxComponentCreationTimeMs = i || cN)
    }
    getPortals() {
      return this.portals
    }
    destroy() {
      this.destroyed = !0
    }
    destroyPortal(e) {
      ;(this.portals = this.portals.filter((t) => t !== e)), this.batchUpdate()
    }
    getComponentWrappingElement() {
      return this.wrappingElement
    }
    mountReactPortal(e, t, i) {
      ;(this.portals = [...this.portals, e]),
        this.waitForInstance(t, i),
        this.batchUpdate()
    }
    updateReactPortal(e, t) {
      ;(this.portals[this.portals.indexOf(e)] = t), this.batchUpdate()
    }
    batchUpdate() {
      this.hasPendingPortalUpdate ||
        (setTimeout(() => {
          this.destroyed ||
            (this.refresher(), (this.hasPendingPortalUpdate = !1))
        }),
        (this.hasPendingPortalUpdate = !0))
    }
    waitForInstance(e, t, i = Date.now()) {
      if (this.destroyed) {
        t(null)
        return
      }
      if (e.rendered()) t(e)
      else {
        if (
          Date.now() - i >= this.maxComponentCreationTimeMs &&
          !this.hasPendingPortalUpdate
        )
          return
        window.setTimeout(() => {
          this.waitForInstance(e, t, i)
        })
      }
    }
  },
  dN = ({ ctrl: e }) => {
    const t = e.isAlive(),
      { context: i } = d.useContext(mi),
      s = t ? e.getColId() : void 0,
      [n, r] = d.useState(),
      o = d.useRef(),
      a = d.useRef(null),
      l = d.useRef(null),
      c = d.useRef(null),
      u = d.useRef(),
      h = d.useRef()
    t && !h.current && (h.current = new Ho(() => a.current))
    const g = d.useCallback((m) => {
      var S
      if (
        ((a.current = m),
        (o.current = m ? i.createBean(new Ir()) : i.destroyBean(o.current)),
        !m || !t)
      )
        return
      const C = {
        setWidth: (y) => {
          a.current && (a.current.style.width = y)
        },
        addOrRemoveCssClass: (y, F) => h.current.addOrRemoveCssClass(y, F),
        setAriaSort: (y) => {
          a.current && (y ? uD(a.current, y) : dD(a.current))
        },
        setUserCompDetails: (y) => r(y),
        getUserCompInstance: () => u.current || void 0,
      }
      e.setComp(C, m, l.current, c.current, o.current)
      const w = e.getSelectAllGui()
      ;(S = l.current) == null || S.insertAdjacentElement('afterend', w),
        o.current.addDestroyFunc(() => w.remove())
    }, [])
    d.useLayoutEffect(() => Bo(n, i, c.current, u), [n]),
      d.useEffect(() => {
        e.setDragSource(a.current)
      }, [n])
    const f = d.useMemo(
        () =>
          !!(
            (n == null ? void 0 : n.componentFromFramework) &&
            Lr(n.componentClass)
          ),
        [n],
      ),
      p = n && n.componentFromFramework,
      v = n && n.componentClass
    return $.createElement(
      'div',
      {
        ref: g,
        className: 'ag-header-cell',
        'col-id': s,
        role: 'columnheader',
      },
      $.createElement('div', {
        ref: l,
        className: 'ag-header-cell-resize',
        role: 'presentation',
      }),
      $.createElement(
        'div',
        {
          ref: c,
          className: 'ag-header-cell-comp-wrapper',
          role: 'presentation',
        },
        p && f && $.createElement(v, { ...n.params }),
        p && !f && $.createElement(v, { ...n.params, ref: u }),
      ),
    )
  },
  hN = d.memo(dN),
  gN = ({ ctrl: e }) => {
    const { context: t, gos: i } = d.useContext(mi),
      [s, n] = d.useState(() => new _i('ag-header-cell', 'ag-floating-filter')),
      [r, o] = d.useState(() => new _i()),
      [a, l] = d.useState(
        () => new _i('ag-floating-filter-button', 'ag-hidden'),
      ),
      [c, u] = d.useState('false'),
      [h, g] = d.useState(),
      [, f] = d.useState(1),
      p = d.useRef(),
      v = d.useRef(null),
      m = d.useRef(null),
      C = d.useRef(null),
      w = d.useRef(null),
      S = d.useRef(),
      y = d.useRef(),
      F = (P) => {
        P != null && S.current && S.current(P)
      },
      R = d.useCallback((P) => {
        if (
          ((v.current = P),
          (p.current = P ? t.createBean(new Ir()) : t.destroyBean(p.current)),
          !P)
        )
          return
        y.current = new Nt((E) => {
          S.current = E
        })
        const k = {
          addOrRemoveCssClass: (E, N) => n((T) => T.setClass(E, N)),
          addOrRemoveBodyCssClass: (E, N) => o((T) => T.setClass(E, N)),
          setButtonWrapperDisplayed: (E) => {
            l((N) => N.setClass('ag-hidden', !E)), u(E ? 'false' : 'true')
          },
          setWidth: (E) => {
            v.current && (v.current.style.width = E)
          },
          setCompDetails: (E) => g(E),
          getFloatingFilterComp: () => (y.current ? y.current : null),
          setMenuIcon: (E) => {
            var N
            return (N = w.current) == null ? void 0 : N.appendChild(E)
          },
        }
        e.setComp(k, P, w.current, m.current, p.current)
      }, [])
    d.useLayoutEffect(() => Bo(h, t, m.current, F), [h])
    const b = d.useMemo(() => s.toString(), [s]),
      x = d.useMemo(() => r.toString(), [r]),
      D = d.useMemo(() => a.toString(), [a]),
      O = d.useMemo(
        () => !!(h && h.componentFromFramework && Lr(h.componentClass)),
        [h],
      ),
      M = d.useMemo(() => i.get('reactiveCustomComponents'), []),
      L = d.useMemo(() => {
        if (h)
          if (M) {
            const P = new iN(h.params, () => f((k) => k + 1))
            return F(P), P
          } else h.componentFromFramework && Hd()
      }, [h]),
      V = L == null ? void 0 : L.getProps(),
      A = h && h.componentFromFramework,
      I = h && h.componentClass
    return $.createElement(
      'div',
      { ref: R, className: b, role: 'gridcell' },
      $.createElement(
        'div',
        { ref: m, className: x, role: 'presentation' },
        A && !M && $.createElement(I, { ...h.params, ref: O ? () => {} : F }),
        A &&
          M &&
          $.createElement(
            Ld.Provider,
            { value: { setMethods: (P) => L.setMethods(P) } },
            $.createElement(I, { ...V }),
          ),
      ),
      $.createElement(
        'div',
        { ref: C, 'aria-hidden': c, className: D, role: 'presentation' },
        $.createElement('button', {
          ref: w,
          type: 'button',
          className: 'ag-button ag-floating-filter-button-button',
          tabIndex: -1,
        }),
      ),
    )
  },
  fN = d.memo(gN),
  pN = ({ ctrl: e }) => {
    const { context: t } = d.useContext(mi),
      [i, s] = d.useState(() => new _i()),
      [n, r] = d.useState(() => new _i()),
      [o, a] = d.useState('false'),
      [l, c] = d.useState(),
      [u, h] = d.useState(),
      g = d.useMemo(() => e.getColId(), []),
      f = d.useRef(),
      p = d.useRef(null),
      v = d.useRef(null),
      m = d.useRef(null),
      C = d.useRef(),
      w = d.useCallback((x) => {
        if (
          ((p.current = x),
          (f.current = x ? t.createBean(new Ir()) : t.destroyBean(f.current)),
          !x)
        )
          return
        const D = {
          setWidth: (O) => {
            p.current && (p.current.style.width = O)
          },
          addOrRemoveCssClass: (O, M) => s((L) => L.setClass(O, M)),
          setHeaderWrapperHidden: (O) => {
            const M = m.current
            M &&
              (O
                ? M.style.setProperty('display', 'none')
                : M.style.removeProperty('display'))
          },
          setHeaderWrapperMaxHeight: (O) => {
            const M = m.current
            M &&
              (O != null
                ? M.style.setProperty('max-height', `${O}px`)
                : M.style.removeProperty('max-height'),
              M.classList.toggle(
                'ag-header-cell-comp-wrapper-limited-height',
                O != null,
              ))
          },
          setUserCompDetails: (O) => h(O),
          setResizableDisplayed: (O) => {
            r((M) => M.setClass('ag-hidden', !O)), a(O ? 'false' : 'true')
          },
          setAriaExpanded: (O) => c(O),
          getUserCompInstance: () => C.current || void 0,
        }
        e.setComp(D, x, v.current, m.current, f.current)
      }, [])
    d.useLayoutEffect(() => Bo(u, t, m.current), [u]),
      d.useEffect(() => {
        p.current && e.setDragSource(p.current)
      }, [u])
    const S = d.useMemo(
        () =>
          !!(
            (u == null ? void 0 : u.componentFromFramework) &&
            Lr(u.componentClass)
          ),
        [u],
      ),
      y = d.useMemo(() => 'ag-header-group-cell ' + i.toString(), [i]),
      F = d.useMemo(() => 'ag-header-cell-resize ' + n.toString(), [n]),
      R = u && u.componentFromFramework,
      b = u && u.componentClass
    return $.createElement(
      'div',
      {
        ref: w,
        className: y,
        'col-id': g,
        role: 'columnheader',
        'aria-expanded': l,
      },
      $.createElement(
        'div',
        {
          ref: m,
          className: 'ag-header-cell-comp-wrapper',
          role: 'presentation',
        },
        R && S && $.createElement(b, { ...u.params }),
        R && !S && $.createElement(b, { ...u.params, ref: C }),
      ),
      $.createElement('div', { ref: v, 'aria-hidden': o, className: F }),
    )
  },
  mN = d.memo(pN),
  vN = ({ ctrl: e }) => {
    const { context: t } = d.useContext(mi),
      { topOffset: i, rowHeight: s } = d.useMemo(() => e.getTopAndHeight(), []),
      n = e.getAriaRowIndex(),
      r = e.getHeaderRowClass(),
      [o, a] = d.useState(() => s + 'px'),
      [l, c] = d.useState(() => i + 'px'),
      u = d.useRef(null),
      h = d.useRef(null),
      [g, f] = d.useState(() => e.getHeaderCtrls()),
      p = d.useRef(),
      v = d.useRef(null),
      m = d.useCallback((S) => {
        if (
          ((v.current = S),
          (p.current = S ? t.createBean(new Ir()) : t.destroyBean(p.current)),
          !S)
        )
          return
        const y = {
          setHeight: (F) => a(F),
          setTop: (F) => c(F),
          setHeaderCtrls: (F, R, b) => {
            ;(h.current = u.current), (u.current = F)
            const x = Od(h.current, F, R)
            x !== h.current && Ad(b, () => f(x))
          },
          setWidth: (F) => {
            v.current && (v.current.style.width = F)
          },
        }
        e.setComp(y, p.current, !1)
      }, []),
      C = d.useMemo(() => ({ height: o, top: l }), [o, l]),
      w = d.useCallback((S) => {
        switch (e.getType()) {
          case nu.COLUMN_GROUP:
            return $.createElement(mN, { ctrl: S, key: S.instanceId })
          case nu.FLOATING_FILTER:
            return $.createElement(fN, { ctrl: S, key: S.instanceId })
          default:
            return $.createElement(hN, { ctrl: S, key: S.instanceId })
        }
      }, [])
    return $.createElement(
      'div',
      { ref: m, className: r, role: 'row', style: C, 'aria-rowindex': n },
      g.map(w),
    )
  },
  CN = d.memo(vN),
  SN = ({ pinned: e }) => {
    const [t, i] = d.useState(!0),
      [s, n] = d.useState([]),
      { context: r } = d.useContext(mi),
      o = d.useRef(null),
      a = d.useRef(null),
      l = d.useRef(),
      c = e === 'left',
      u = e === 'right',
      h = !c && !u,
      g = d.useCallback((v) => {
        if (
          ((o.current = v),
          (l.current = v ? r.createBean(new jI(e)) : r.destroyBean(l.current)),
          !v)
        )
          return
        const m = {
          setDisplayed: i,
          setCtrls: (C) => n(C),
          setCenterWidth: (C) => {
            a.current && (a.current.style.width = C)
          },
          setViewportScrollLeft: (C) => {
            o.current && (o.current.scrollLeft = C)
          },
          setPinnedContainerWidth: (C) => {
            o.current &&
              ((o.current.style.width = C),
              (o.current.style.minWidth = C),
              (o.current.style.maxWidth = C))
          },
        }
        l.current.setComp(m, o.current)
      }, []),
      f = t ? '' : 'ag-hidden',
      p = () =>
        s.map((v) => $.createElement(CN, { ctrl: v, key: v.instanceId }))
    return $.createElement(
      $.Fragment,
      null,
      c &&
        $.createElement(
          'div',
          {
            ref: g,
            className: 'ag-pinned-left-header ' + f,
            'aria-hidden': !t,
            role: 'rowgroup',
          },
          p(),
        ),
      u &&
        $.createElement(
          'div',
          {
            ref: g,
            className: 'ag-pinned-right-header ' + f,
            'aria-hidden': !t,
            role: 'rowgroup',
          },
          p(),
        ),
      h &&
        $.createElement(
          'div',
          {
            ref: g,
            className: 'ag-header-viewport ' + f,
            role: 'presentation',
          },
          $.createElement(
            'div',
            { ref: a, className: 'ag-header-container', role: 'rowgroup' },
            p(),
          ),
        ),
    )
  },
  wc = d.memo(SN),
  wN = () => {
    const [e, t] = d.useState(() => new _i()),
      [i, s] = d.useState(),
      { context: n } = d.useContext(mi),
      r = d.useRef(null),
      o = d.useRef(),
      a = d.useCallback((u) => {
        if (
          ((r.current = u),
          (o.current = u ? n.createBean(new MI()) : n.destroyBean(o.current)),
          !u)
        )
          return
        const h = {
          addOrRemoveCssClass: (g, f) => t((p) => p.setClass(g, f)),
          setHeightAndMinHeight: (g) => s(g),
        }
        o.current.setComp(h, u, u)
      }, []),
      l = d.useMemo(() => 'ag-header ' + e.toString(), [e]),
      c = d.useMemo(() => ({ height: i, minHeight: i }), [i])
    return $.createElement(
      'div',
      { ref: a, className: l, style: c, role: 'presentation' },
      $.createElement(wc, { pinned: 'left' }),
      $.createElement(wc, { pinned: null }),
      $.createElement(wc, { pinned: 'right' }),
    )
  },
  yN = d.memo(wN),
  bN = (e, t) => {
    d.useEffect(() => {
      const i = t.current
      if (i) {
        const s = i.parentElement
        if (s) {
          const n = document.createComment(e)
          return (
            s.insertBefore(n, i),
            () => {
              s.removeChild(n)
            }
          )
        }
      }
    }, [e])
  },
  Fn = bN,
  RN = class {
    constructor(e, t) {
      ;(this.cellEditorParams = e),
        (this.refreshProps = t),
        (this.instanceCreated = new Nt((i) => {
          this.resolveInstanceCreated = i
        })),
        (this.onValueChange = (i) => this.updateValue(i)),
        (this.value = e.value)
    }
    getProps() {
      return {
        ...this.cellEditorParams,
        initialValue: this.cellEditorParams.value,
        value: this.value,
        onValueChange: this.onValueChange,
      }
    }
    getValue() {
      return this.value
    }
    refresh(e) {
      ;(this.cellEditorParams = e), this.refreshProps()
    }
    setMethods(e) {
      kd(this.getOptionalMethods(), e, this)
    }
    getInstance() {
      return this.instanceCreated.then(() => this.componentInstance)
    }
    setRef(e) {
      var t
      ;(this.componentInstance = e),
        (t = this.resolveInstanceCreated) == null || t.call(this),
        (this.resolveInstanceCreated = void 0)
    }
    getOptionalMethods() {
      return [
        'isCancelBeforeStart',
        'isCancelAfterEnd',
        'focusIn',
        'focusOut',
        'afterGuiAttached',
      ]
    }
    updateValue(e) {
      ;(this.value = e), this.refreshProps()
    }
  },
  FN = (e) => {
    const t = d.useRef(e),
      i = d.useRef(),
      s = d.useRef(!1),
      n = d.useRef(!1),
      [, r] = d.useState(0)
    s.current && (n.current = !0),
      d.useEffect(
        () => (
          s.current || ((i.current = t.current()), (s.current = !0)),
          r((o) => o + 1),
          () => {
            var o
            n.current && ((o = i.current) == null || o.call(i))
          }
        ),
        [],
      )
  },
  EN = (e) => {
    const [t, i] = d.useState(),
      {
        context: s,
        popupService: n,
        localeService: r,
        gos: o,
        editService: a,
      } = d.useContext(mi)
    return (
      FN(() => {
        var y, F
        const { editDetails: l, cellCtrl: c, eParentCell: u } = e,
          { compDetails: h } = l,
          g = o.get('stopEditingWhenCellsLoseFocus'),
          f = s.createBean(a.createPopupEditorWrapper(h.params)),
          p = f.getGui()
        if (e.jsChildComp) {
          const R = e.jsChildComp.getGui()
          R && p.appendChild(R)
        }
        const v = {
            column: c.getColumn(),
            rowNode: c.getRowNode(),
            type: 'popupCellEditor',
            eventSource: u,
            ePopup: p,
            position: l.popupPosition,
            keepWithinBounds: !0,
          },
          m = n.positionPopupByComponent.bind(n, v),
          C = r.getLocaleTextFunc(),
          w = n.addPopup({
            modal: g,
            eChild: p,
            closeOnEsc: !0,
            closedCallback: () => {
              c.onPopupEditorClosed()
            },
            anchorToElement: u,
            positionCallback: m,
            ariaLabel: C('ariaLabelCellEditor', 'Cell Editor'),
          }),
          S = w ? w.hideFunc : void 0
        return (
          i(f),
          (F = (y = e.jsChildComp) == null ? void 0 : y.afterGuiAttached) ==
            null || F.call(y),
          () => {
            S == null || S(), s.destroyBean(f)
          }
        )
      }),
      $.createElement(
        $.Fragment,
        null,
        t && e.wrappedContent && ya.createPortal(e.wrappedContent, t.getGui()),
      )
    )
  },
  _g = d.memo(EN),
  PN = (e, t, i, s, n, r) => {
    const { context: o } = d.useContext(mi),
      a = d.useCallback(() => {
        const l = n.current
        if (!l) return
        const c = l.getGui()
        c && c.parentElement && c.parentElement.removeChild(c),
          o.destroyBean(l),
          (n.current = void 0)
      }, [])
    d.useEffect(() => {
      const l = e != null,
        c =
          (e == null ? void 0 : e.compDetails) &&
          !e.compDetails.componentFromFramework,
        u = t && i == null
      if (!(l && c && !u)) {
        a()
        return
      }
      const g = e.compDetails
      if (n.current) {
        const p = n.current,
          m = p.refresh != null && e.force == !1 ? p.refresh(g.params) : !1
        if (m === !0 || m === void 0) return
        a()
      }
      const f = g.newAgStackInstance()
      f != null &&
        f.then((p) => {
          if (!p) return
          const v = p.getGui()
          if (!v) return
          ;(t ? i : r.current).appendChild(v), (n.current = p)
        })
    }, [e, t, s]),
      d.useEffect(() => a, [])
  },
  xN = PN,
  DN = (e, t, i) => {
    const { compProxy: s } = e
    i(s)
    const n = s.getProps(),
      r = Lr(t)
    return $.createElement(
      Ld.Provider,
      { value: { setMethods: (o) => s.setMethods(o) } },
      r
        ? $.createElement(t, { ...n })
        : $.createElement(t, { ...n, ref: (o) => s.setRef(o) }),
    )
  },
  Wg = (e, t, i) => {
    const s = e.compProxy
    return $.createElement(
      $.Fragment,
      null,
      s ? DN(e, t, i) : $.createElement(t, { ...e.compDetails.params, ref: i }),
    )
  },
  MN = (e, t, i, s, n) => {
    const r = e.compDetails,
      o = r.componentClass,
      a = r.componentFromFramework && !e.popup,
      l = r.componentFromFramework && e.popup,
      c = !r.componentFromFramework && e.popup
    return $.createElement(
      $.Fragment,
      null,
      a && Wg(e, o, t),
      l &&
        $.createElement(_g, {
          editDetails: e,
          cellCtrl: s,
          eParentCell: i,
          wrappedContent: Wg(e, o, t),
        }),
      c &&
        n &&
        $.createElement(_g, {
          editDetails: e,
          cellCtrl: s,
          eParentCell: i,
          jsChildComp: n,
        }),
    )
  },
  IN = (e, t, i, s, n, r, o) => {
    const { compDetails: a, value: l } = e,
      c = !a,
      u = a && a.componentFromFramework,
      h = a && a.componentClass,
      g = l != null && l.toString ? l.toString() : l,
      f = () =>
        $.createElement(
          $.Fragment,
          null,
          c && $.createElement($.Fragment, null, g),
          u && !r && $.createElement(h, { ...a.params, key: t, ref: s }),
          u && r && $.createElement(h, { ...a.params, key: t }),
        )
    return $.createElement(
      $.Fragment,
      null,
      n
        ? $.createElement(
            'span',
            {
              role: 'presentation',
              id: `cell-${i}`,
              className: 'ag-cell-value',
              ref: o,
            },
            f(),
          )
        : f(),
    )
  },
  TN = ({ cellCtrl: e, printLayout: t, editingRow: i }) => {
    const { context: s } = d.useContext(mi),
      { colIdSanitised: n, instanceId: r } = e,
      o = d.useRef(),
      [a, l] = d.useState(() =>
        e.isCellRenderer()
          ? void 0
          : { compDetails: void 0, value: e.getValueToDisplay(), force: !1 },
      ),
      [c, u] = d.useState(),
      [h, g] = d.useState(1),
      [f, p] = d.useState(),
      [v, m] = d.useState(!1),
      [C, w] = d.useState(!1),
      [S, y] = d.useState(!1),
      [F, R] = d.useState(),
      b = d.useMemo(() => e.isForceWrapper(), [e]),
      x = d.useMemo(() => e.getCellAriaRole(), [e]),
      D = d.useRef(null),
      O = d.useRef(null),
      M = d.useRef(),
      L = d.useRef(),
      V = d.useRef(),
      A = d.useRef([]),
      I = d.useRef(),
      [P, k] = d.useState(0),
      E = d.useCallback((ie) => {
        ;(I.current = ie), k((U) => U + 1)
      }, []),
      N = a != null && (v || S || C),
      T = b || N,
      G = d.useCallback(
        (ie) => {
          if (((L.current = ie), ie)) {
            const U = ie.isCancelBeforeStart && ie.isCancelBeforeStart()
            setTimeout(() => {
              U ? (e.stopEditing(!0), e.focusCell(!0)) : e.cellEditorAttached()
            })
          }
        },
        [e],
      ),
      H = d.useRef()
    H.current || (H.current = new Ho(() => D.current)),
      xN(a, T, I.current, P, M, D)
    const _ = d.useRef()
    d.useLayoutEffect(() => {
      var q
      const ie = _.current,
        U = a
      if (
        ((_.current = a),
        ie == null ||
          ie.compDetails == null ||
          U == null ||
          U.compDetails == null)
      )
        return
      const W = ie.compDetails,
        j = U.compDetails
      if (
        W.componentClass != j.componentClass ||
        ((q = O.current) == null ? void 0 : q.refresh) == null
      )
        return
      O.current.refresh(j.params) != !0 && g((ne) => ne + 1)
    }, [a]),
      d.useLayoutEffect(() => {
        if (!(c && !c.compDetails.componentFromFramework)) return
        const U = c.compDetails,
          W = c.popup === !0,
          j = U.newAgStackInstance()
        return (
          j.then((K) => {
            if (!K) return
            const q = K.getGui()
            if ((G(K), !W)) {
              const ne = (b ? V : D).current
              ne == null || ne.appendChild(q),
                K.afterGuiAttached && K.afterGuiAttached()
            }
            R(K)
          }),
          () => {
            j.then((K) => {
              var ne
              const q = K.getGui()
              s.destroyBean(K),
                G(void 0),
                R(void 0),
                (ne = q == null ? void 0 : q.parentElement) == null ||
                  ne.removeChild(q)
            })
          }
        )
      }, [c])
    const B = d.useCallback(
        (ie) => {
          if (((V.current = ie), !ie)) {
            A.current.forEach((W) => W()), (A.current = [])
            return
          }
          const U = (W) => {
            if (W) {
              const j = W.getGui()
              ie.insertAdjacentElement('afterbegin', j),
                A.current.push(() => {
                  s.destroyBean(W), Bn(j)
                })
            }
            return W
          }
          if (v) {
            const W = e.createSelectionCheckbox()
            U(W)
          }
          S && U(e.createDndSource()), C && U(e.createRowDragComp())
        },
        [e, s, S, C, v],
      ),
      z = d.useCallback((ie) => {
        if (
          ((D.current = ie),
          (o.current = ie ? s.createBean(new Ir()) : s.destroyBean(o.current)),
          !ie || !e)
        )
          return
        const U = {
            addOrRemoveCssClass: (j, K) => H.current.addOrRemoveCssClass(j, K),
            setUserStyles: (j) => p(j),
            getFocusableElement: () => D.current,
            setIncludeSelection: (j) => m(j),
            setIncludeRowDrag: (j) => w(j),
            setIncludeDndSource: (j) => y(j),
            getCellEditor: () => L.current || null,
            getCellRenderer: () => O.current ?? M.current,
            getParentOfValue: () => I.current ?? V.current ?? D.current,
            setRenderDetails: (j, K, q) => {
              l((ne) =>
                (ne == null ? void 0 : ne.compDetails) !== j ||
                (ne == null ? void 0 : ne.value) !== K ||
                (ne == null ? void 0 : ne.force) !== q
                  ? { value: K, compDetails: j, force: q }
                  : ne,
              )
            },
            setEditDetails: (j, K, q, ne) => {
              if (j) {
                let oe
                ne
                  ? (oe = new RN(j.params, () => g((le) => le + 1)))
                  : j.componentFromFramework && Hd(),
                  u({
                    compDetails: j,
                    popup: K,
                    popupPosition: q,
                    compProxy: oe,
                  }),
                  K || l(void 0)
              } else
                u((oe) => {
                  oe != null && oe.compProxy && (L.current = void 0)
                })
            },
          },
          W = V.current || void 0
        e.setComp(U, ie, W, t, i, o.current)
      }, []),
      Q = d.useMemo(() => {
        var U
        return !!(
          ((U = a == null ? void 0 : a.compDetails) == null
            ? void 0
            : U.componentFromFramework) && Lr(a.compDetails.componentClass)
        )
      }, [a])
    d.useLayoutEffect(() => {
      var ie
      D.current &&
        (H.current.addOrRemoveCssClass('ag-cell-value', !T),
        H.current.addOrRemoveCssClass(
          'ag-cell-inline-editing',
          !!c && !c.popup,
        ),
        H.current.addOrRemoveCssClass(
          'ag-cell-popup-editing',
          !!c && !!c.popup,
        ),
        H.current.addOrRemoveCssClass(
          'ag-cell-not-inline-editing',
          !c || !!c.popup,
        ),
        (ie = e.getRowCtrl()) == null || ie.setInlineEditingCss(),
        e.shouldRestoreFocus() &&
          !e.isEditing() &&
          D.current.focus({ preventScroll: !0 }))
    })
    const J = () =>
        $.createElement(
          $.Fragment,
          null,
          a != null && IN(a, h, r, O, T, Q, E),
          c != null && MN(c, G, D.current, e, F),
        ),
      se = d.useCallback(() => e.onFocusOut(), [])
    return $.createElement(
      'div',
      { ref: z, style: f, role: x, 'col-id': n, onBlur: se },
      T
        ? $.createElement(
            'div',
            { className: 'ag-cell-wrapper', role: 'presentation', ref: B },
            J(),
          )
        : J(),
    )
  },
  AN = d.memo(TN),
  ON = ({ rowCtrl: e, containerType: t }) => {
    const { context: i, gos: s } = d.useContext(mi),
      n = d.useRef(),
      r = d.useRef(e.getDomOrder()),
      o = e.isFullWidth(),
      a = e.getRowNode().displayed,
      [l, c] = d.useState(() => (a ? e.getRowIndex() : null)),
      [u, h] = d.useState(() => e.getRowId()),
      [g, f] = d.useState(() => e.getBusinessKey()),
      [p, v] = d.useState(() => e.getRowStyles()),
      m = d.useRef(null),
      C = d.useRef(null),
      [w, S] = d.useState(() => null),
      [y, F] = d.useState(),
      [R, b] = d.useState(() => (a ? e.getInitialRowTop(t) : void 0)),
      [x, D] = d.useState(() => (a ? e.getInitialTransform(t) : void 0)),
      O = d.useRef(null),
      M = d.useRef(),
      L = d.useRef(!1),
      [V, A] = d.useState(0)
    d.useEffect(() => {
      var z
      if (L.current || !y || V > 10) return
      const B = (z = O.current) == null ? void 0 : z.firstChild
      B ? (e.setupDetailRowAutoHeight(B), (L.current = !0)) : A((Q) => Q + 1)
    }, [y, V])
    const I = d.useRef()
    I.current || (I.current = new Ho(() => O.current))
    const P = d.useCallback((B) => {
      if (
        ((O.current = B),
        (n.current = B ? i.createBean(new Ir()) : i.destroyBean(n.current)),
        !B)
      ) {
        e.unsetComp(t)
        return
      }
      if (!e.isAlive()) return
      const z = {
        setTop: b,
        setTransform: D,
        addOrRemoveCssClass: (Q, J) => I.current.addOrRemoveCssClass(Q, J),
        setDomOrder: (Q) => (r.current = Q),
        setRowIndex: c,
        setRowId: h,
        setRowBusinessKey: f,
        setUserStyles: v,
        setCellCtrls: (Q, J) => {
          ;(C.current = m.current), (m.current = Q)
          const se = Od(C.current, Q, r.current)
          se !== C.current && Ad(J, () => S(se))
        },
        showFullWidth: (Q) => F(Q),
        getFullWidthCellRenderer: () => M.current,
        refreshFullWidth: (Q) =>
          G.current
            ? (F((J) => ({ ...J, params: Q() })), !0)
            : !M.current || !M.current.refresh
              ? !1
              : M.current.refresh(Q()),
      }
      e.setComp(z, B, t, n.current)
    }, [])
    d.useLayoutEffect(() => Bo(y, i, O.current, M), [y])
    const k = d.useMemo(() => {
        const B = { top: R, transform: x }
        return Object.assign(B, p), B
      }, [R, x, p]),
      E = o && (y == null ? void 0 : y.componentFromFramework),
      N = !o && w != null,
      T = d.useMemo(
        () =>
          !!(
            (y == null ? void 0 : y.componentFromFramework) &&
            Lr(y.componentClass)
          ),
        [y],
      ),
      G = d.useRef(!1)
    d.useEffect(() => {
      G.current = T && !!y && !!s.get('reactiveCustomComponents')
    }, [T, y])
    const H = () =>
        w == null
          ? void 0
          : w.map((B) =>
              $.createElement(AN, {
                cellCtrl: B,
                editingRow: e.isEditing(),
                printLayout: e.isPrintLayout(),
                key: B.instanceId,
              }),
            ),
      _ = () => {
        const B = y.componentClass
        return $.createElement(
          $.Fragment,
          null,
          T
            ? $.createElement(B, { ...y.params })
            : $.createElement(B, { ...y.params, ref: M }),
        )
      }
    return $.createElement(
      'div',
      {
        ref: P,
        role: 'row',
        style: k,
        'row-index': l,
        'row-id': u,
        'row-business-key': g,
      },
      N && H(),
      E && _(),
    )
  },
  LN = d.memo(ON),
  kN = ({ name: e }) => {
    const { context: t } = d.useContext(mi),
      i = d.useMemo(() => nr(e), [e]),
      s = d.useRef(null),
      n = d.useRef(null),
      r = d.useRef([]),
      o = d.useRef([]),
      [a, l] = d.useState(() => []),
      c = d.useRef(!1),
      u = d.useRef(),
      h = d.useMemo(() => qi(i.viewport), [i]),
      g = d.useMemo(() => qi(i.container), [i]),
      f = i.type === 'center',
      p = f ? s : n
    Fn(' AG Row Container ' + e + ' ', p)
    const v = d.useCallback(
        () => (f ? s.current != null && n.current != null : n.current != null),
        [],
      ),
      m = d.useCallback(
        () => (f ? s.current == null && n.current == null : n.current == null),
        [],
      ),
      C = d.useCallback(() => {
        if ((m() && (u.current = t.destroyBean(u.current)), v())) {
          const F = (b) => {
              const x = Od(o.current, r.current, c.current)
              x !== o.current && ((o.current = x), Ad(b, () => l(x)))
            },
            R = {
              setHorizontalScroll: (b) => {
                s.current && (s.current.scrollLeft = b)
              },
              setViewportHeight: (b) => {
                s.current && (s.current.style.height = b)
              },
              setRowCtrls: ({ rowCtrls: b, useFlushSync: x }) => {
                const D = !!x && r.current.length > 0 && b.length > 0
                ;(r.current = b), F(D)
              },
              setDomOrder: (b) => {
                c.current != b && ((c.current = b), F(!1))
              },
              setContainerWidth: (b) => {
                n.current && (n.current.style.width = b)
              },
              setOffsetTop: (b) => {
                n.current && (n.current.style.transform = `translateY(${b})`)
              },
            }
          ;(u.current = t.createBean(new GT(e))),
            u.current.setComp(R, n.current, s.current)
        }
      }, [v, m]),
      w = d.useCallback(
        (F) => {
          ;(n.current = F), C()
        },
        [C],
      ),
      S = d.useCallback(
        (F) => {
          ;(s.current = F), C()
        },
        [C],
      ),
      y = () =>
        $.createElement(
          'div',
          { className: g, ref: w, role: 'rowgroup' },
          a.map((F) =>
            $.createElement(LN, {
              rowCtrl: F,
              containerType: i.type,
              key: F.instanceId,
            }),
          ),
        )
    return $.createElement(
      $.Fragment,
      null,
      f
        ? $.createElement(
            'div',
            { className: h, ref: S, role: 'presentation' },
            y(),
          )
        : y(),
    )
  },
  HN = d.memo(kN),
  NN = () => {
    const { context: e, resizeObserverService: t } = d.useContext(mi),
      [i, s] = d.useState(''),
      [n, r] = d.useState(0),
      [o, a] = d.useState(0),
      [l, c] = d.useState('0px'),
      [u, h] = d.useState('0px'),
      [g, f] = d.useState('100%'),
      [p, v] = d.useState('0px'),
      [m, C] = d.useState('0px'),
      [w, S] = d.useState('100%'),
      [y, F] = d.useState(''),
      [R, b] = d.useState(''),
      [x, D] = d.useState(null),
      [O, M] = d.useState(''),
      [L, V] = d.useState(null),
      [A, I] = d.useState('ag-layout-normal'),
      P = d.useRef()
    P.current || (P.current = new Ho(() => k.current))
    const k = d.useRef(null),
      E = d.useRef(null),
      N = d.useRef(null),
      T = d.useRef(null),
      G = d.useRef(null),
      H = d.useRef(null),
      _ = d.useRef(null),
      B = d.useRef([]),
      z = d.useRef([])
    Fn(' AG Grid Body ', k),
      Fn(' AG Pinned Top ', E),
      Fn(' AG Sticky Top ', N),
      Fn(' AG Middle ', H),
      Fn(' AG Pinned Bottom ', _)
    const Q = d.useCallback((Me) => {
        if (((k.current = Me), !Me)) {
          ;(B.current = e.destroyBeans(B.current)),
            z.current.forEach((Se) => Se()),
            (z.current = [])
          return
        }
        if (!e) return
        const He = (Se, we) => {
            Se.appendChild(we), z.current.push(() => Se.removeChild(we))
          },
          $e = (Se) => {
            const we = e.createBean(new Se())
            return B.current.push(we), we
          },
          Fe = (Se, we, ze) => {
            He(Se, document.createComment(ze)), He(Se, $e(we).getGui())
          }
        Fe(Me, KI, ' AG Fake Horizontal Scroll '),
          Fe(Me, YI, ' AG Overlay Wrapper '),
          G.current && Fe(G.current, qI, ' AG Fake Vertical Scroll ')
        const ve = {
            setRowAnimationCssOnBodyViewport: s,
            setColumnCount: (Se) => {
              k.current && lD(k.current, Se)
            },
            setRowCount: (Se) => {
              k.current && oD(k.current, Se)
            },
            setTopHeight: r,
            setBottomHeight: a,
            setStickyTopHeight: c,
            setStickyTopTop: h,
            setStickyTopWidth: f,
            setTopDisplay: F,
            setBottomDisplay: b,
            setColumnMovingCss: (Se, we) =>
              P.current.addOrRemoveCssClass(Se, we),
            updateLayoutClasses: I,
            setAlwaysVerticalScrollClass: D,
            setPinnedTopBottomOverflowY: M,
            setCellSelectableCss: (Se, we) => V(we ? Se : null),
            setBodyViewportWidth: (Se) => {
              H.current && (H.current.style.width = Se)
            },
            registerBodyViewportResizeListener: (Se) => {
              if (H.current) {
                const we = t.observeResize(H.current, Se)
                z.current.push(() => we())
              }
            },
            setStickyBottomHeight: v,
            setStickyBottomBottom: C,
            setStickyBottomWidth: S,
          },
          Be = e.createBean(new WT())
        B.current.push(Be),
          Be.setComp(
            ve,
            Me,
            H.current,
            E.current,
            _.current,
            N.current,
            T.current,
          )
      }, []),
      J = d.useMemo(() => qi('ag-root', 'ag-unselectable', A), [A]),
      se = d.useMemo(() => qi('ag-body-viewport', i, A, x, L), [i, A, x, L]),
      ie = d.useMemo(() => qi('ag-body', A), [A]),
      U = d.useMemo(() => qi('ag-floating-top', L), [L]),
      W = d.useMemo(() => qi('ag-sticky-top', L), [L]),
      j = d.useMemo(
        () => qi('ag-sticky-bottom', p === '0px' ? 'ag-hidden' : null, L),
        [L, p],
      ),
      K = d.useMemo(() => qi('ag-floating-bottom', L), [L]),
      q = d.useMemo(
        () => ({ height: n, minHeight: n, display: y, overflowY: O }),
        [n, y, O],
      ),
      ne = d.useMemo(() => ({ height: l, top: u, width: g }), [l, u, g]),
      oe = d.useMemo(() => ({ height: p, bottom: m, width: w }), [p, m, w]),
      le = d.useMemo(
        () => ({ height: o, minHeight: o, display: R, overflowY: O }),
        [o, R, O],
      ),
      me = (Me) => $.createElement(HN, { name: Me, key: `${Me}-container` }),
      ye = ({ section: Me, children: He, className: $e, style: Fe }) =>
        $.createElement(
          'div',
          { ref: Me, className: $e, role: 'presentation', style: Fe },
          He.map(me),
        )
    return $.createElement(
      'div',
      { ref: Q, className: J, role: 'treegrid' },
      $.createElement(yN, null),
      ye({
        section: E,
        className: U,
        style: q,
        children: ['topLeft', 'topCenter', 'topRight', 'topFullWidth'],
      }),
      $.createElement(
        'div',
        { className: ie, ref: G, role: 'presentation' },
        ye({
          section: H,
          className: se,
          children: ['left', 'center', 'right', 'fullWidth'],
        }),
      ),
      ye({
        section: N,
        className: W,
        style: ne,
        children: [
          'stickyTopLeft',
          'stickyTopCenter',
          'stickyTopRight',
          'stickyTopFullWidth',
        ],
      }),
      ye({
        section: T,
        className: j,
        style: oe,
        children: [
          'stickyBottomLeft',
          'stickyBottomCenter',
          'stickyBottomRight',
          'stickyBottomFullWidth',
        ],
      }),
      ye({
        section: _,
        className: K,
        style: le,
        children: [
          'bottomLeft',
          'bottomCenter',
          'bottomRight',
          'bottomFullWidth',
        ],
      }),
    )
  },
  GN = d.memo(NN),
  BN = (e, t) => {
    const {
        children: i,
        eFocusableElement: s,
        onTabKeyDown: n,
        gridCtrl: r,
        forceFocusOutWhenTabGuardsAreEmpty: o,
      } = e,
      { context: a } = d.useContext(mi),
      l = d.useRef(null),
      c = d.useRef(null),
      u = d.useRef(),
      h = (m) => {
        const C = m == null ? void 0 : parseInt(m, 10).toString()
        ;[l, c].forEach((w) => {
          var S, y
          C === void 0
            ? (S = w.current) == null || S.removeAttribute('tabindex')
            : (y = w.current) == null || y.setAttribute('tabindex', C)
        })
      }
    d.useImperativeHandle(t, () => ({
      forceFocusOutOfContainer(m) {
        var C
        ;(C = u.current) == null || C.forceFocusOutOfContainer(m)
      },
    }))
    const g = d.useCallback(() => {
        const m = l.current,
          C = c.current
        if (!m && !C) {
          u.current = a.destroyBean(u.current)
          return
        }
        if (m && C) {
          const w = { setTabIndex: h }
          u.current = a.createBean(
            new Yv({
              comp: w,
              eTopGuard: m,
              eBottomGuard: C,
              eFocusableElement: s,
              onTabKeyDown: n,
              forceFocusOutWhenTabGuardsAreEmpty: o,
              focusInnerElement: (S) => r.focusInnerElement(S),
            }),
          )
        }
      }, []),
      f = d.useCallback(
        (m) => {
          ;(l.current = m), g()
        },
        [g],
      ),
      p = d.useCallback(
        (m) => {
          ;(c.current = m), g()
        },
        [g],
      ),
      v = (m) => {
        const C = m === 'top' ? ga.TAB_GUARD_TOP : ga.TAB_GUARD_BOTTOM
        return $.createElement('div', {
          className: `${ga.TAB_GUARD} ${C}`,
          role: 'presentation',
          ref: m === 'top' ? f : p,
        })
      }
    return $.createElement($.Fragment, null, v('top'), i, v('bottom'))
  },
  VN = d.forwardRef(BN),
  _N = d.memo(VN),
  WN = ({ context: e }) => {
    const [t, i] = d.useState(''),
      [s, n] = d.useState(''),
      [r, o] = d.useState(''),
      [a, l] = d.useState(null),
      [c, u] = d.useState(null),
      [h, g] = d.useState(!1),
      [f, p] = d.useState(),
      v = d.useRef(),
      m = d.useRef(null),
      C = d.useRef(),
      [w, S] = d.useState(null),
      y = d.useRef(() => {}),
      F = d.useRef(),
      R = d.useRef([]),
      b = d.useCallback(() => {}, []),
      x = d.useMemo(() => (e.isDestroyed() ? null : e.getBeans()), [e])
    Fn(' AG Grid ', m)
    const D = d.useCallback((A) => {
      if (
        ((m.current = A),
        (v.current = A ? e.createBean(new yO()) : e.destroyBean(v.current)),
        !A || e.isDestroyed())
      )
        return
      const I = v.current
      y.current = I.focusInnerElement.bind(I)
      const P = {
        destroyGridUi: () => {},
        setRtlClass: i,
        setGridThemeClass: n,
        forceFocusOutOfContainer: (k) => {
          var E, N
          if (!k && (E = F.current) != null && E.isDisplayed()) {
            F.current.forceFocusOutOfContainer(k)
            return
          }
          ;(N = C.current) == null || N.forceFocusOutOfContainer(k)
        },
        updateLayoutClasses: o,
        getFocusableContainers: () => {
          var N
          const k = [],
            E = (N = m.current) == null ? void 0 : N.querySelector('.ag-root')
          return (
            E && k.push({ getGui: () => E }),
            R.current.forEach((T) => {
              T.isDisplayed() && k.push(T)
            }),
            k
          )
        },
        setCursor: l,
        setUserSelect: u,
      }
      I.setComp(P, A, A), g(!0)
    }, [])
    d.useEffect(() => {
      const A = v.current,
        I = m.current
      if (!f || !x || !A || !w || !I) return
      const P = [],
        {
          watermarkSelector: k,
          paginationSelector: E,
          sideBarSelector: N,
          statusBarSelector: T,
          gridHeaderDropZonesSelector: G,
        } = A.getOptionalSelectors(),
        H = []
      if (G) {
        const B = e.createBean(new G.component()),
          z = B.getGui()
        I.insertAdjacentElement('afterbegin', z), H.push(z), P.push(B)
      }
      if (N) {
        const B = e.createBean(new N.component()),
          z = B.getGui(),
          Q = w.querySelector('.ag-tab-guard-bottom')
        Q && (Q.insertAdjacentElement('beforebegin', z), H.push(z)),
          P.push(B),
          R.current.push(B)
      }
      const _ = (B) => {
        const z = e.createBean(new B()),
          Q = z.getGui()
        return I.insertAdjacentElement('beforeend', Q), H.push(Q), P.push(z), z
      }
      if ((T && _(T.component), E)) {
        const B = _(E.component)
        ;(F.current = B), R.current.push(B)
      }
      return (
        k && _(k.component),
        () => {
          e.destroyBeans(P),
            H.forEach((B) => {
              var z
              ;(z = B.parentElement) == null || z.removeChild(B)
            })
        }
      )
    }, [f, w, x])
    const O = d.useMemo(() => qi('ag-root-wrapper', t, s, r), [t, s, r]),
      M = d.useMemo(
        () => qi('ag-root-wrapper-body', 'ag-focus-managed', r),
        [r],
      ),
      L = d.useMemo(
        () => ({
          userSelect: c ?? '',
          WebkitUserSelect: c ?? '',
          cursor: a ?? '',
        }),
        [c, a],
      ),
      V = d.useCallback((A) => {
        ;(C.current = A), p(A !== null)
      }, [])
    return $.createElement(
      'div',
      { ref: D, className: O, style: L, role: 'presentation' },
      $.createElement(
        'div',
        { className: M, ref: S, role: 'presentation' },
        h &&
          w &&
          x &&
          $.createElement(
            mi.Provider,
            { value: x },
            $.createElement(
              _N,
              {
                ref: V,
                eFocusableElement: w,
                onTabKeyDown: b,
                gridCtrl: v.current,
                forceFocusOutWhenTabGuardsAreEmpty: !0,
              },
              $.createElement(GN, null),
            ),
          ),
      ),
    )
  },
  $N = d.memo(WN),
  zN = class extends X {
    wireBeans(e) {
      this.ctrlsService = e.ctrlsService
    }
    areHeaderCellsRendered() {
      return this.ctrlsService
        .getHeaderRowContainerCtrls()
        .every((e) => e.getAllCtrls().every((t) => t.areCellsRendered()))
    }
  },
  mC = (e) => {
    var m
    const t = d.useRef(),
      i = d.useRef(null),
      s = d.useRef(null),
      n = d.useRef([]),
      r = d.useRef([]),
      o = d.useRef(e),
      a = d.useRef(),
      l = d.useRef(),
      c = d.useRef(!1),
      [u, h] = d.useState(void 0),
      [, g] = d.useState(0),
      f = d.useCallback((C) => {
        if (((i.current = C), !C)) {
          n.current.forEach((M) => M()), (n.current.length = 0)
          return
        }
        const w = e.modules || []
        s.current ||
          ((s.current = new uN(
            () => g((M) => M + 1),
            e.componentWrappingElement,
            e.maxComponentCreationTimeMs,
          )),
          n.current.push(() => {
            var M
            ;(M = s.current) == null || M.destroy(), (s.current = null)
          }))
        const S = Xx(e.gridOptions, e),
          y = () => {
            if (c.current) {
              const M = () => {
                var V
                return (V = a.current) != null && V.shouldQueueUpdates()
                  ? void 0
                  : r.current.shift()
              }
              let L = M()
              for (; L; ) L(), (L = M())
            }
          },
          F = new KN(y)
        a.current = F
        const R = new zN(),
          b = {
            providedBeanInstances: {
              frameworkComponentWrapper: new jN(
                s.current,
                S.reactiveCustomComponents ??
                  KH('reactiveCustomComponents') ??
                  !0,
              ),
              renderStatusService: R,
            },
            modules: w,
            frameworkOverrides: F,
          },
          x = (M) => {
            h(M),
              M.createBean(R),
              n.current.push(() => {
                M.destroy()
              }),
              M.getBean('ctrlsService').whenReady(
                {
                  addDestroyFunc: (L) => {
                    n.current.push(L)
                  },
                },
                () => {
                  var V
                  if (M.isDestroyed()) return
                  const L = t.current
                  L && ((V = e.setGridApi) == null || V.call(e, L))
                },
              )
          },
          D = (M) => {
            M.getBean('ctrlsService').whenReady(
              {
                addDestroyFunc: (L) => {
                  n.current.push(L)
                },
              },
              () => {
                r.current.forEach((L) => L()),
                  (r.current.length = 0),
                  (c.current = !0)
              },
            )
          },
          O = new QH()
        S.gridId ?? (S.gridId = l.current),
          (t.current = O.create(C, S, x, D, b)),
          n.current.push(() => {
            t.current = void 0
          }),
          t.current && (l.current = t.current.getGridId())
      }, []),
      p = d.useMemo(
        () => ({ height: '100%', ...(e.containerStyle || {}) }),
        [e.containerStyle],
      ),
      v = d.useCallback((C) => {
        var w
        c.current && !((w = a.current) != null && w.shouldQueueUpdates())
          ? C()
          : r.current.push(C)
      }, [])
    return (
      d.useEffect(() => {
        const C = UN(o.current, e)
        ;(o.current = e),
          v(() => {
            t.current && Jx(C, t.current)
          })
      }, [e]),
      $.createElement(
        'div',
        { style: p, className: e.className, ref: f },
        u && !u.isDestroyed() ? $.createElement($N, { context: u }) : null,
        ((m = s.current) == null ? void 0 : m.getPortals()) ?? null,
      )
    )
  }
function UN(e, t) {
  const i = {}
  return (
    Object.keys(t).forEach((s) => {
      const n = t[s]
      e[s] !== n && (i[s] = n)
    }),
    i
  )
}
var jN = class extends r1 {
    constructor(e, t) {
      super(), (this.parent = e), (this.reactiveCustomComponents = t)
    }
    createWrapper(e, t) {
      if (this.reactiveCustomComponents) {
        const n = ((r) => {
          switch (r) {
            case 'filter':
              return tN
            case 'floatingFilterComponent':
              return sN
            case 'dateComponent':
              return Z1
            case 'dragAndDropImageComponent':
              return eN
            case 'loadingOverlayComponent':
              return nN
            case 'noRowsOverlayComponent':
              return oN
            case 'statusPanel':
              return aN
            case 'toolPanel':
              return lN
            case 'menuItem':
              return rN
            case 'cellRenderer':
              return J1
          }
        })(t.propertyName)
        if (n) return new n(e, this.parent, t)
      } else
        switch (t.propertyName) {
          case 'filter':
          case 'floatingFilterComponent':
          case 'dateComponent':
          case 'dragAndDropImageComponent':
          case 'loadingOverlayComponent':
          case 'noRowsOverlayComponent':
          case 'statusPanel':
          case 'toolPanel':
          case 'menuItem':
          case 'cellRenderer':
            Hd()
            break
        }
      const i = !t.cellRenderer && t.propertyName !== 'toolPanel'
      return new fC(e, this.parent, t, i)
    }
  },
  YN = d.forwardRef((e, t) => {
    const {
        ctrlsFactory: i,
        context: s,
        gos: n,
        resizeObserverService: r,
        rowModel: o,
      } = d.useContext(mi),
      [a, l] = d.useState(() => new _i()),
      [c, u] = d.useState(() => new _i()),
      [h, g] = d.useState(),
      [f, p] = d.useState(),
      v = d.useRef(),
      m = d.useRef(null),
      C = d.useRef(),
      w = d.useMemo(
        () => us.__getGridRegisteredModules(e.api.getGridId()),
        [e],
      ),
      S = d.useMemo(() => a.toString() + ' ag-details-row', [a]),
      y = d.useMemo(() => c.toString() + ' ag-details-grid', [c])
    t &&
      d.useImperativeHandle(t, () => ({
        refresh() {
          var b
          return ((b = v.current) == null ? void 0 : b.refresh()) ?? !1
        },
      })),
      e.template &&
        te(
          'detailCellRendererParams.template is not supported by AG Grid React. To change the template, provide a Custom Detail Cell Renderer. See https://ag-grid.com/react-data-grid/master-detail-custom-detail/',
        )
    const F = d.useCallback((b) => {
        var O
        if (((m.current = b), !b)) {
          ;(v.current = s.destroyBean(v.current)),
            (O = C.current) == null || O.call(C)
          return
        }
        const x = {
            addOrRemoveCssClass: (M, L) => l((V) => V.setClass(M, L)),
            addOrRemoveDetailGridCssClass: (M, L) => u((V) => V.setClass(M, L)),
            setDetailGrid: (M) => g(M),
            setRowData: (M) => p(M),
            getGui: () => m.current,
          },
          D = i.getInstance('detailCellRenderer')
        if (
          D &&
          (s.createBean(D),
          D.init(x, e),
          (v.current = D),
          n.get('detailRowAutoHeight'))
        ) {
          const M = () => {
            if (m.current == null) return
            const L = m.current.clientHeight
            L != null &&
              L > 0 &&
              setTimeout(() => {
                e.node.setRowHeight(L),
                  (Pt(n) || ms(n)) && o.onRowHeightChanged()
              }, 0)
          }
          ;(C.current = r.observeResize(b, M)), M()
        }
      }, []),
      R = d.useCallback((b) => {
        var x
        ;(x = v.current) == null || x.registerDetailWithMaster(b)
      }, [])
    return $.createElement(
      'div',
      { className: S, ref: F },
      h &&
        $.createElement(mC, {
          className: y,
          ...h,
          modules: w,
          rowData: f,
          setGridApi: R,
        }),
    )
  }),
  KN = class extends Kv {
    constructor(e) {
      super('react'),
        (this.processQueuedUpdates = e),
        (this.queueUpdates = !1),
        (this.frameworkComponents = {
          agGroupCellRenderer: Bg,
          agGroupRowRenderer: Bg,
          agDetailCellRenderer: YN,
        }),
        (this.wrapIncoming = (t, i) => (i === 'ensureVisible' ? K1(t) : t())),
        (this.renderingEngine = 'react')
    }
    frameworkComponent(e) {
      return this.frameworkComponents[e]
    }
    isFrameworkComponent(e) {
      if (!e) return !1
      const t = e.prototype
      return !(t && 'getGui' in t)
    }
    getLockOnRefresh() {
      this.queueUpdates = !0
    }
    releaseLockOnRefresh() {
      ;(this.queueUpdates = !1), this.processQueuedUpdates()
    }
    shouldQueueUpdates() {
      return this.queueUpdates
    }
    runWhenReadyAsync() {
      return Y1()
    }
  },
  qN = class extends d.Component {
    constructor() {
      super(...arguments),
        (this.apiListeners = []),
        (this.setGridApi = (e) => {
          ;(this.api = e), this.apiListeners.forEach((t) => t(e))
        })
    }
    registerApiListener(e) {
      this.apiListeners.push(e)
    }
    componentWillUnmount() {
      this.apiListeners.length = 0
    }
    render() {
      return $.createElement(mC, { ...this.props, setGridApi: this.setGridApi })
    }
  } //! moment.js
//! version : 2.30.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var vC
function Re() {
  return vC.apply(null, arguments)
}
function QN(e) {
  vC = e
}
function ts(e) {
  return (
    e instanceof Array || Object.prototype.toString.call(e) === '[object Array]'
  )
}
function Ln(e) {
  return e != null && Object.prototype.toString.call(e) === '[object Object]'
}
function gt(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t)
}
function Nd(e) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(e).length === 0
  var t
  for (t in e) if (gt(e, t)) return !1
  return !0
}
function xi(e) {
  return e === void 0
}
function Ws(e) {
  return (
    typeof e == 'number' ||
    Object.prototype.toString.call(e) === '[object Number]'
  )
}
function Vo(e) {
  return (
    e instanceof Date || Object.prototype.toString.call(e) === '[object Date]'
  )
}
function CC(e, t) {
  var i = [],
    s,
    n = e.length
  for (s = 0; s < n; ++s) i.push(t(e[s], s))
  return i
}
function sn(e, t) {
  for (var i in t) gt(t, i) && (e[i] = t[i])
  return (
    gt(t, 'toString') && (e.toString = t.toString),
    gt(t, 'valueOf') && (e.valueOf = t.valueOf),
    e
  )
}
function Ss(e, t, i, s) {
  return _C(e, t, i, s, !0).utc()
}
function XN() {
  return {
    empty: !1,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: !1,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: !1,
    userInvalidated: !1,
    iso: !1,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: !1,
    weekdayMismatch: !1,
  }
}
function Ze(e) {
  return e._pf == null && (e._pf = XN()), e._pf
}
var uu
Array.prototype.some
  ? (uu = Array.prototype.some)
  : (uu = function (e) {
      var t = Object(this),
        i = t.length >>> 0,
        s
      for (s = 0; s < i; s++) if (s in t && e.call(this, t[s], s, t)) return !0
      return !1
    })
function Gd(e) {
  var t = null,
    i = !1,
    s = e._d && !isNaN(e._d.getTime())
  if (
    (s &&
      ((t = Ze(e)),
      (i = uu.call(t.parsedDateParts, function (n) {
        return n != null
      })),
      (s =
        t.overflow < 0 &&
        !t.empty &&
        !t.invalidEra &&
        !t.invalidMonth &&
        !t.invalidWeekday &&
        !t.weekdayMismatch &&
        !t.nullInput &&
        !t.invalidFormat &&
        !t.userInvalidated &&
        (!t.meridiem || (t.meridiem && i))),
      e._strict &&
        (s =
          s &&
          t.charsLeftOver === 0 &&
          t.unusedTokens.length === 0 &&
          t.bigHour === void 0)),
    Object.isFrozen == null || !Object.isFrozen(e))
  )
    e._isValid = s
  else return s
  return e._isValid
}
function bl(e) {
  var t = Ss(NaN)
  return e != null ? sn(Ze(t), e) : (Ze(t).userInvalidated = !0), t
}
var $g = (Re.momentProperties = []),
  yc = !1
function Bd(e, t) {
  var i,
    s,
    n,
    r = $g.length
  if (
    (xi(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject),
    xi(t._i) || (e._i = t._i),
    xi(t._f) || (e._f = t._f),
    xi(t._l) || (e._l = t._l),
    xi(t._strict) || (e._strict = t._strict),
    xi(t._tzm) || (e._tzm = t._tzm),
    xi(t._isUTC) || (e._isUTC = t._isUTC),
    xi(t._offset) || (e._offset = t._offset),
    xi(t._pf) || (e._pf = Ze(t)),
    xi(t._locale) || (e._locale = t._locale),
    r > 0)
  )
    for (i = 0; i < r; i++) (s = $g[i]), (n = t[s]), xi(n) || (e[s] = n)
  return e
}
function _o(e) {
  Bd(this, e),
    (this._d = new Date(e._d != null ? e._d.getTime() : NaN)),
    this.isValid() || (this._d = new Date(NaN)),
    yc === !1 && ((yc = !0), Re.updateOffset(this), (yc = !1))
}
function is(e) {
  return e instanceof _o || (e != null && e._isAMomentObject != null)
}
function SC(e) {
  Re.suppressDeprecationWarnings === !1 &&
    typeof console < 'u' &&
    console.warn &&
    console.warn('Deprecation warning: ' + e)
}
function Ui(e, t) {
  var i = !0
  return sn(function () {
    if ((Re.deprecationHandler != null && Re.deprecationHandler(null, e), i)) {
      var s = [],
        n,
        r,
        o,
        a = arguments.length
      for (r = 0; r < a; r++) {
        if (((n = ''), typeof arguments[r] == 'object')) {
          n +=
            `
[` +
            r +
            '] '
          for (o in arguments[0])
            gt(arguments[0], o) && (n += o + ': ' + arguments[0][o] + ', ')
          n = n.slice(0, -2)
        } else n = arguments[r]
        s.push(n)
      }
      SC(
        e +
          `
Arguments: ` +
          Array.prototype.slice.call(s).join('') +
          `
` +
          new Error().stack,
      ),
        (i = !1)
    }
    return t.apply(this, arguments)
  }, t)
}
var zg = {}
function wC(e, t) {
  Re.deprecationHandler != null && Re.deprecationHandler(e, t),
    zg[e] || (SC(t), (zg[e] = !0))
}
Re.suppressDeprecationWarnings = !1
Re.deprecationHandler = null
function ws(e) {
  return (
    (typeof Function < 'u' && e instanceof Function) ||
    Object.prototype.toString.call(e) === '[object Function]'
  )
}
function JN(e) {
  var t, i
  for (i in e)
    gt(e, i) && ((t = e[i]), ws(t) ? (this[i] = t) : (this['_' + i] = t))
  ;(this._config = e),
    (this._dayOfMonthOrdinalParseLenient = new RegExp(
      (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
        '|' +
        /\d{1,2}/.source,
    ))
}
function du(e, t) {
  var i = sn({}, e),
    s
  for (s in t)
    gt(t, s) &&
      (Ln(e[s]) && Ln(t[s])
        ? ((i[s] = {}), sn(i[s], e[s]), sn(i[s], t[s]))
        : t[s] != null
          ? (i[s] = t[s])
          : delete i[s])
  for (s in e) gt(e, s) && !gt(t, s) && Ln(e[s]) && (i[s] = sn({}, i[s]))
  return i
}
function Vd(e) {
  e != null && this.set(e)
}
var hu
Object.keys
  ? (hu = Object.keys)
  : (hu = function (e) {
      var t,
        i = []
      for (t in e) gt(e, t) && i.push(t)
      return i
    })
var ZN = {
  sameDay: '[Today at] LT',
  nextDay: '[Tomorrow at] LT',
  nextWeek: 'dddd [at] LT',
  lastDay: '[Yesterday at] LT',
  lastWeek: '[Last] dddd [at] LT',
  sameElse: 'L',
}
function eG(e, t, i) {
  var s = this._calendar[e] || this._calendar.sameElse
  return ws(s) ? s.call(t, i) : s
}
function ps(e, t, i) {
  var s = '' + Math.abs(e),
    n = t - s.length,
    r = e >= 0
  return (
    (r ? (i ? '+' : '') : '-') +
    Math.pow(10, Math.max(0, n)).toString().substr(1) +
    s
  )
}
var _d =
    /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
  oa = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
  bc = {},
  cr = {}
function Ve(e, t, i, s) {
  var n = s
  typeof s == 'string' &&
    (n = function () {
      return this[s]()
    }),
    e && (cr[e] = n),
    t &&
      (cr[t[0]] = function () {
        return ps(n.apply(this, arguments), t[1], t[2])
      }),
    i &&
      (cr[i] = function () {
        return this.localeData().ordinal(n.apply(this, arguments), e)
      })
}
function tG(e) {
  return e.match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, '') : e.replace(/\\/g, '')
}
function iG(e) {
  var t = e.match(_d),
    i,
    s
  for (i = 0, s = t.length; i < s; i++)
    cr[t[i]] ? (t[i] = cr[t[i]]) : (t[i] = tG(t[i]))
  return function (n) {
    var r = '',
      o
    for (o = 0; o < s; o++) r += ws(t[o]) ? t[o].call(n, e) : t[o]
    return r
  }
}
function ma(e, t) {
  return e.isValid()
    ? ((t = yC(t, e.localeData())), (bc[t] = bc[t] || iG(t)), bc[t](e))
    : e.localeData().invalidDate()
}
function yC(e, t) {
  var i = 5
  function s(n) {
    return t.longDateFormat(n) || n
  }
  for (oa.lastIndex = 0; i >= 0 && oa.test(e); )
    (e = e.replace(oa, s)), (oa.lastIndex = 0), (i -= 1)
  return e
}
var sG = {
  LTS: 'h:mm:ss A',
  LT: 'h:mm A',
  L: 'MM/DD/YYYY',
  LL: 'MMMM D, YYYY',
  LLL: 'MMMM D, YYYY h:mm A',
  LLLL: 'dddd, MMMM D, YYYY h:mm A',
}
function nG(e) {
  var t = this._longDateFormat[e],
    i = this._longDateFormat[e.toUpperCase()]
  return t || !i
    ? t
    : ((this._longDateFormat[e] = i
        .match(_d)
        .map(function (s) {
          return s === 'MMMM' || s === 'MM' || s === 'DD' || s === 'dddd'
            ? s.slice(1)
            : s
        })
        .join('')),
      this._longDateFormat[e])
}
var rG = 'Invalid date'
function oG() {
  return this._invalidDate
}
var aG = '%d',
  lG = /\d{1,2}/
function cG(e) {
  return this._ordinal.replace('%d', e)
}
var uG = {
  future: 'in %s',
  past: '%s ago',
  s: 'a few seconds',
  ss: '%d seconds',
  m: 'a minute',
  mm: '%d minutes',
  h: 'an hour',
  hh: '%d hours',
  d: 'a day',
  dd: '%d days',
  w: 'a week',
  ww: '%d weeks',
  M: 'a month',
  MM: '%d months',
  y: 'a year',
  yy: '%d years',
}
function dG(e, t, i, s) {
  var n = this._relativeTime[i]
  return ws(n) ? n(e, t, i, s) : n.replace(/%d/i, e)
}
function hG(e, t) {
  var i = this._relativeTime[e > 0 ? 'future' : 'past']
  return ws(i) ? i(t) : i.replace(/%s/i, t)
}
var Ug = {
  D: 'date',
  dates: 'date',
  date: 'date',
  d: 'day',
  days: 'day',
  day: 'day',
  e: 'weekday',
  weekdays: 'weekday',
  weekday: 'weekday',
  E: 'isoWeekday',
  isoweekdays: 'isoWeekday',
  isoweekday: 'isoWeekday',
  DDD: 'dayOfYear',
  dayofyears: 'dayOfYear',
  dayofyear: 'dayOfYear',
  h: 'hour',
  hours: 'hour',
  hour: 'hour',
  ms: 'millisecond',
  milliseconds: 'millisecond',
  millisecond: 'millisecond',
  m: 'minute',
  minutes: 'minute',
  minute: 'minute',
  M: 'month',
  months: 'month',
  month: 'month',
  Q: 'quarter',
  quarters: 'quarter',
  quarter: 'quarter',
  s: 'second',
  seconds: 'second',
  second: 'second',
  gg: 'weekYear',
  weekyears: 'weekYear',
  weekyear: 'weekYear',
  GG: 'isoWeekYear',
  isoweekyears: 'isoWeekYear',
  isoweekyear: 'isoWeekYear',
  w: 'week',
  weeks: 'week',
  week: 'week',
  W: 'isoWeek',
  isoweeks: 'isoWeek',
  isoweek: 'isoWeek',
  y: 'year',
  years: 'year',
  year: 'year',
}
function ji(e) {
  return typeof e == 'string' ? Ug[e] || Ug[e.toLowerCase()] : void 0
}
function Wd(e) {
  var t = {},
    i,
    s
  for (s in e) gt(e, s) && ((i = ji(s)), i && (t[i] = e[s]))
  return t
}
var gG = {
  date: 9,
  day: 11,
  weekday: 11,
  isoWeekday: 11,
  dayOfYear: 4,
  hour: 13,
  millisecond: 16,
  minute: 14,
  month: 8,
  quarter: 7,
  second: 15,
  weekYear: 1,
  isoWeekYear: 1,
  week: 5,
  isoWeek: 5,
  year: 1,
}
function fG(e) {
  var t = [],
    i
  for (i in e) gt(e, i) && t.push({ unit: i, priority: gG[i] })
  return (
    t.sort(function (s, n) {
      return s.priority - n.priority
    }),
    t
  )
}
var bC = /\d/,
  Gi = /\d\d/,
  RC = /\d{3}/,
  $d = /\d{4}/,
  Rl = /[+-]?\d{6}/,
  Dt = /\d\d?/,
  FC = /\d\d\d\d?/,
  EC = /\d\d\d\d\d\d?/,
  Fl = /\d{1,3}/,
  zd = /\d{1,4}/,
  El = /[+-]?\d{1,6}/,
  kr = /\d+/,
  Pl = /[+-]?\d+/,
  pG = /Z|[+-]\d\d:?\d\d/gi,
  xl = /Z|[+-]\d\d(?::?\d\d)?/gi,
  mG = /[+-]?\d+(\.\d{1,3})?/,
  Wo =
    /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
  Hr = /^[1-9]\d?/,
  Ud = /^([1-9]\d|\d)/,
  za
za = {}
function Pe(e, t, i) {
  za[e] = ws(t)
    ? t
    : function (s, n) {
        return s && i ? i : t
      }
}
function vG(e, t) {
  return gt(za, e) ? za[e](t._strict, t._locale) : new RegExp(CG(e))
}
function CG(e) {
  return ks(
    e
      .replace('\\', '')
      .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (t, i, s, n, r) {
        return i || s || n || r
      }),
  )
}
function ks(e) {
  return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')
}
function Vi(e) {
  return e < 0 ? Math.ceil(e) || 0 : Math.floor(e)
}
function lt(e) {
  var t = +e,
    i = 0
  return t !== 0 && isFinite(t) && (i = Vi(t)), i
}
var gu = {}
function wt(e, t) {
  var i,
    s = t,
    n
  for (
    typeof e == 'string' && (e = [e]),
      Ws(t) &&
        (s = function (r, o) {
          o[t] = lt(r)
        }),
      n = e.length,
      i = 0;
    i < n;
    i++
  )
    gu[e[i]] = s
}
function $o(e, t) {
  wt(e, function (i, s, n, r) {
    ;(n._w = n._w || {}), t(i, n._w, n, r)
  })
}
function SG(e, t, i) {
  t != null && gt(gu, e) && gu[e](t, i._a, i, e)
}
function Dl(e) {
  return (e % 4 === 0 && e % 100 !== 0) || e % 400 === 0
}
var pi = 0,
  Ms = 1,
  ds = 2,
  Xt = 3,
  Ji = 4,
  Is = 5,
  xn = 6,
  wG = 7,
  yG = 8
Ve('Y', 0, 0, function () {
  var e = this.year()
  return e <= 9999 ? ps(e, 4) : '+' + e
})
Ve(0, ['YY', 2], 0, function () {
  return this.year() % 100
})
Ve(0, ['YYYY', 4], 0, 'year')
Ve(0, ['YYYYY', 5], 0, 'year')
Ve(0, ['YYYYYY', 6, !0], 0, 'year')
Pe('Y', Pl)
Pe('YY', Dt, Gi)
Pe('YYYY', zd, $d)
Pe('YYYYY', El, Rl)
Pe('YYYYYY', El, Rl)
wt(['YYYYY', 'YYYYYY'], pi)
wt('YYYY', function (e, t) {
  t[pi] = e.length === 2 ? Re.parseTwoDigitYear(e) : lt(e)
})
wt('YY', function (e, t) {
  t[pi] = Re.parseTwoDigitYear(e)
})
wt('Y', function (e, t) {
  t[pi] = parseInt(e, 10)
})
function uo(e) {
  return Dl(e) ? 366 : 365
}
Re.parseTwoDigitYear = function (e) {
  return lt(e) + (lt(e) > 68 ? 1900 : 2e3)
}
var PC = Nr('FullYear', !0)
function bG() {
  return Dl(this.year())
}
function Nr(e, t) {
  return function (i) {
    return i != null
      ? (xC(this, e, i), Re.updateOffset(this, t), this)
      : Ro(this, e)
  }
}
function Ro(e, t) {
  if (!e.isValid()) return NaN
  var i = e._d,
    s = e._isUTC
  switch (t) {
    case 'Milliseconds':
      return s ? i.getUTCMilliseconds() : i.getMilliseconds()
    case 'Seconds':
      return s ? i.getUTCSeconds() : i.getSeconds()
    case 'Minutes':
      return s ? i.getUTCMinutes() : i.getMinutes()
    case 'Hours':
      return s ? i.getUTCHours() : i.getHours()
    case 'Date':
      return s ? i.getUTCDate() : i.getDate()
    case 'Day':
      return s ? i.getUTCDay() : i.getDay()
    case 'Month':
      return s ? i.getUTCMonth() : i.getMonth()
    case 'FullYear':
      return s ? i.getUTCFullYear() : i.getFullYear()
    default:
      return NaN
  }
}
function xC(e, t, i) {
  var s, n, r, o, a
  if (!(!e.isValid() || isNaN(i))) {
    switch (((s = e._d), (n = e._isUTC), t)) {
      case 'Milliseconds':
        return void (n ? s.setUTCMilliseconds(i) : s.setMilliseconds(i))
      case 'Seconds':
        return void (n ? s.setUTCSeconds(i) : s.setSeconds(i))
      case 'Minutes':
        return void (n ? s.setUTCMinutes(i) : s.setMinutes(i))
      case 'Hours':
        return void (n ? s.setUTCHours(i) : s.setHours(i))
      case 'Date':
        return void (n ? s.setUTCDate(i) : s.setDate(i))
      case 'FullYear':
        break
      default:
        return
    }
    ;(r = i),
      (o = e.month()),
      (a = e.date()),
      (a = a === 29 && o === 1 && !Dl(r) ? 28 : a),
      n ? s.setUTCFullYear(r, o, a) : s.setFullYear(r, o, a)
  }
}
function RG(e) {
  return (e = ji(e)), ws(this[e]) ? this[e]() : this
}
function FG(e, t) {
  if (typeof e == 'object') {
    e = Wd(e)
    var i = fG(e),
      s,
      n = i.length
    for (s = 0; s < n; s++) this[i[s].unit](e[i[s].unit])
  } else if (((e = ji(e)), ws(this[e]))) return this[e](t)
  return this
}
function EG(e, t) {
  return ((e % t) + t) % t
}
var Vt
Array.prototype.indexOf
  ? (Vt = Array.prototype.indexOf)
  : (Vt = function (e) {
      var t
      for (t = 0; t < this.length; ++t) if (this[t] === e) return t
      return -1
    })
function jd(e, t) {
  if (isNaN(e) || isNaN(t)) return NaN
  var i = EG(t, 12)
  return (e += (t - i) / 12), i === 1 ? (Dl(e) ? 29 : 28) : 31 - ((i % 7) % 2)
}
Ve('M', ['MM', 2], 'Mo', function () {
  return this.month() + 1
})
Ve('MMM', 0, 0, function (e) {
  return this.localeData().monthsShort(this, e)
})
Ve('MMMM', 0, 0, function (e) {
  return this.localeData().months(this, e)
})
Pe('M', Dt, Hr)
Pe('MM', Dt, Gi)
Pe('MMM', function (e, t) {
  return t.monthsShortRegex(e)
})
Pe('MMMM', function (e, t) {
  return t.monthsRegex(e)
})
wt(['M', 'MM'], function (e, t) {
  t[Ms] = lt(e) - 1
})
wt(['MMM', 'MMMM'], function (e, t, i, s) {
  var n = i._locale.monthsParse(e, s, i._strict)
  n != null ? (t[Ms] = n) : (Ze(i).invalidMonth = e)
})
var PG =
    'January_February_March_April_May_June_July_August_September_October_November_December'.split(
      '_',
    ),
  DC = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
  MC = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
  xG = Wo,
  DG = Wo
function MG(e, t) {
  return e
    ? ts(this._months)
      ? this._months[e.month()]
      : this._months[
          (this._months.isFormat || MC).test(t) ? 'format' : 'standalone'
        ][e.month()]
    : ts(this._months)
      ? this._months
      : this._months.standalone
}
function IG(e, t) {
  return e
    ? ts(this._monthsShort)
      ? this._monthsShort[e.month()]
      : this._monthsShort[MC.test(t) ? 'format' : 'standalone'][e.month()]
    : ts(this._monthsShort)
      ? this._monthsShort
      : this._monthsShort.standalone
}
function TG(e, t, i) {
  var s,
    n,
    r,
    o = e.toLocaleLowerCase()
  if (!this._monthsParse)
    for (
      this._monthsParse = [],
        this._longMonthsParse = [],
        this._shortMonthsParse = [],
        s = 0;
      s < 12;
      ++s
    )
      (r = Ss([2e3, s])),
        (this._shortMonthsParse[s] = this.monthsShort(
          r,
          '',
        ).toLocaleLowerCase()),
        (this._longMonthsParse[s] = this.months(r, '').toLocaleLowerCase())
  return i
    ? t === 'MMM'
      ? ((n = Vt.call(this._shortMonthsParse, o)), n !== -1 ? n : null)
      : ((n = Vt.call(this._longMonthsParse, o)), n !== -1 ? n : null)
    : t === 'MMM'
      ? ((n = Vt.call(this._shortMonthsParse, o)),
        n !== -1
          ? n
          : ((n = Vt.call(this._longMonthsParse, o)), n !== -1 ? n : null))
      : ((n = Vt.call(this._longMonthsParse, o)),
        n !== -1
          ? n
          : ((n = Vt.call(this._shortMonthsParse, o)), n !== -1 ? n : null))
}
function AG(e, t, i) {
  var s, n, r
  if (this._monthsParseExact) return TG.call(this, e, t, i)
  for (
    this._monthsParse ||
      ((this._monthsParse = []),
      (this._longMonthsParse = []),
      (this._shortMonthsParse = [])),
      s = 0;
    s < 12;
    s++
  ) {
    if (
      ((n = Ss([2e3, s])),
      i &&
        !this._longMonthsParse[s] &&
        ((this._longMonthsParse[s] = new RegExp(
          '^' + this.months(n, '').replace('.', '') + '$',
          'i',
        )),
        (this._shortMonthsParse[s] = new RegExp(
          '^' + this.monthsShort(n, '').replace('.', '') + '$',
          'i',
        ))),
      !i &&
        !this._monthsParse[s] &&
        ((r = '^' + this.months(n, '') + '|^' + this.monthsShort(n, '')),
        (this._monthsParse[s] = new RegExp(r.replace('.', ''), 'i'))),
      i && t === 'MMMM' && this._longMonthsParse[s].test(e))
    )
      return s
    if (i && t === 'MMM' && this._shortMonthsParse[s].test(e)) return s
    if (!i && this._monthsParse[s].test(e)) return s
  }
}
function IC(e, t) {
  if (!e.isValid()) return e
  if (typeof t == 'string') {
    if (/^\d+$/.test(t)) t = lt(t)
    else if (((t = e.localeData().monthsParse(t)), !Ws(t))) return e
  }
  var i = t,
    s = e.date()
  return (
    (s = s < 29 ? s : Math.min(s, jd(e.year(), i))),
    e._isUTC ? e._d.setUTCMonth(i, s) : e._d.setMonth(i, s),
    e
  )
}
function TC(e) {
  return e != null
    ? (IC(this, e), Re.updateOffset(this, !0), this)
    : Ro(this, 'Month')
}
function OG() {
  return jd(this.year(), this.month())
}
function LG(e) {
  return this._monthsParseExact
    ? (gt(this, '_monthsRegex') || AC.call(this),
      e ? this._monthsShortStrictRegex : this._monthsShortRegex)
    : (gt(this, '_monthsShortRegex') || (this._monthsShortRegex = xG),
      this._monthsShortStrictRegex && e
        ? this._monthsShortStrictRegex
        : this._monthsShortRegex)
}
function kG(e) {
  return this._monthsParseExact
    ? (gt(this, '_monthsRegex') || AC.call(this),
      e ? this._monthsStrictRegex : this._monthsRegex)
    : (gt(this, '_monthsRegex') || (this._monthsRegex = DG),
      this._monthsStrictRegex && e
        ? this._monthsStrictRegex
        : this._monthsRegex)
}
function AC() {
  function e(l, c) {
    return c.length - l.length
  }
  var t = [],
    i = [],
    s = [],
    n,
    r,
    o,
    a
  for (n = 0; n < 12; n++)
    (r = Ss([2e3, n])),
      (o = ks(this.monthsShort(r, ''))),
      (a = ks(this.months(r, ''))),
      t.push(o),
      i.push(a),
      s.push(a),
      s.push(o)
  t.sort(e),
    i.sort(e),
    s.sort(e),
    (this._monthsRegex = new RegExp('^(' + s.join('|') + ')', 'i')),
    (this._monthsShortRegex = this._monthsRegex),
    (this._monthsStrictRegex = new RegExp('^(' + i.join('|') + ')', 'i')),
    (this._monthsShortStrictRegex = new RegExp('^(' + t.join('|') + ')', 'i'))
}
function HG(e, t, i, s, n, r, o) {
  var a
  return (
    e < 100 && e >= 0
      ? ((a = new Date(e + 400, t, i, s, n, r, o)),
        isFinite(a.getFullYear()) && a.setFullYear(e))
      : (a = new Date(e, t, i, s, n, r, o)),
    a
  )
}
function Fo(e) {
  var t, i
  return (
    e < 100 && e >= 0
      ? ((i = Array.prototype.slice.call(arguments)),
        (i[0] = e + 400),
        (t = new Date(Date.UTC.apply(null, i))),
        isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e))
      : (t = new Date(Date.UTC.apply(null, arguments))),
    t
  )
}
function Ua(e, t, i) {
  var s = 7 + t - i,
    n = (7 + Fo(e, 0, s).getUTCDay() - t) % 7
  return -n + s - 1
}
function OC(e, t, i, s, n) {
  var r = (7 + i - s) % 7,
    o = Ua(e, s, n),
    a = 1 + 7 * (t - 1) + r + o,
    l,
    c
  return (
    a <= 0
      ? ((l = e - 1), (c = uo(l) + a))
      : a > uo(e)
        ? ((l = e + 1), (c = a - uo(e)))
        : ((l = e), (c = a)),
    { year: l, dayOfYear: c }
  )
}
function Eo(e, t, i) {
  var s = Ua(e.year(), t, i),
    n = Math.floor((e.dayOfYear() - s - 1) / 7) + 1,
    r,
    o
  return (
    n < 1
      ? ((o = e.year() - 1), (r = n + Hs(o, t, i)))
      : n > Hs(e.year(), t, i)
        ? ((r = n - Hs(e.year(), t, i)), (o = e.year() + 1))
        : ((o = e.year()), (r = n)),
    { week: r, year: o }
  )
}
function Hs(e, t, i) {
  var s = Ua(e, t, i),
    n = Ua(e + 1, t, i)
  return (uo(e) - s + n) / 7
}
Ve('w', ['ww', 2], 'wo', 'week')
Ve('W', ['WW', 2], 'Wo', 'isoWeek')
Pe('w', Dt, Hr)
Pe('ww', Dt, Gi)
Pe('W', Dt, Hr)
Pe('WW', Dt, Gi)
$o(['w', 'ww', 'W', 'WW'], function (e, t, i, s) {
  t[s.substr(0, 1)] = lt(e)
})
function NG(e) {
  return Eo(e, this._week.dow, this._week.doy).week
}
var GG = { dow: 0, doy: 6 }
function BG() {
  return this._week.dow
}
function VG() {
  return this._week.doy
}
function _G(e) {
  var t = this.localeData().week(this)
  return e == null ? t : this.add((e - t) * 7, 'd')
}
function WG(e) {
  var t = Eo(this, 1, 4).week
  return e == null ? t : this.add((e - t) * 7, 'd')
}
Ve('d', 0, 'do', 'day')
Ve('dd', 0, 0, function (e) {
  return this.localeData().weekdaysMin(this, e)
})
Ve('ddd', 0, 0, function (e) {
  return this.localeData().weekdaysShort(this, e)
})
Ve('dddd', 0, 0, function (e) {
  return this.localeData().weekdays(this, e)
})
Ve('e', 0, 0, 'weekday')
Ve('E', 0, 0, 'isoWeekday')
Pe('d', Dt)
Pe('e', Dt)
Pe('E', Dt)
Pe('dd', function (e, t) {
  return t.weekdaysMinRegex(e)
})
Pe('ddd', function (e, t) {
  return t.weekdaysShortRegex(e)
})
Pe('dddd', function (e, t) {
  return t.weekdaysRegex(e)
})
$o(['dd', 'ddd', 'dddd'], function (e, t, i, s) {
  var n = i._locale.weekdaysParse(e, s, i._strict)
  n != null ? (t.d = n) : (Ze(i).invalidWeekday = e)
})
$o(['d', 'e', 'E'], function (e, t, i, s) {
  t[s] = lt(e)
})
function $G(e, t) {
  return typeof e != 'string'
    ? e
    : isNaN(e)
      ? ((e = t.weekdaysParse(e)), typeof e == 'number' ? e : null)
      : parseInt(e, 10)
}
function zG(e, t) {
  return typeof e == 'string'
    ? t.weekdaysParse(e) % 7 || 7
    : isNaN(e)
      ? null
      : e
}
function Yd(e, t) {
  return e.slice(t, 7).concat(e.slice(0, t))
}
var UG = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
  LC = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
  jG = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
  YG = Wo,
  KG = Wo,
  qG = Wo
function QG(e, t) {
  var i = ts(this._weekdays)
    ? this._weekdays
    : this._weekdays[
        e && e !== !0 && this._weekdays.isFormat.test(t)
          ? 'format'
          : 'standalone'
      ]
  return e === !0 ? Yd(i, this._week.dow) : e ? i[e.day()] : i
}
function XG(e) {
  return e === !0
    ? Yd(this._weekdaysShort, this._week.dow)
    : e
      ? this._weekdaysShort[e.day()]
      : this._weekdaysShort
}
function JG(e) {
  return e === !0
    ? Yd(this._weekdaysMin, this._week.dow)
    : e
      ? this._weekdaysMin[e.day()]
      : this._weekdaysMin
}
function ZG(e, t, i) {
  var s,
    n,
    r,
    o = e.toLocaleLowerCase()
  if (!this._weekdaysParse)
    for (
      this._weekdaysParse = [],
        this._shortWeekdaysParse = [],
        this._minWeekdaysParse = [],
        s = 0;
      s < 7;
      ++s
    )
      (r = Ss([2e3, 1]).day(s)),
        (this._minWeekdaysParse[s] = this.weekdaysMin(
          r,
          '',
        ).toLocaleLowerCase()),
        (this._shortWeekdaysParse[s] = this.weekdaysShort(
          r,
          '',
        ).toLocaleLowerCase()),
        (this._weekdaysParse[s] = this.weekdays(r, '').toLocaleLowerCase())
  return i
    ? t === 'dddd'
      ? ((n = Vt.call(this._weekdaysParse, o)), n !== -1 ? n : null)
      : t === 'ddd'
        ? ((n = Vt.call(this._shortWeekdaysParse, o)), n !== -1 ? n : null)
        : ((n = Vt.call(this._minWeekdaysParse, o)), n !== -1 ? n : null)
    : t === 'dddd'
      ? ((n = Vt.call(this._weekdaysParse, o)),
        n !== -1 || ((n = Vt.call(this._shortWeekdaysParse, o)), n !== -1)
          ? n
          : ((n = Vt.call(this._minWeekdaysParse, o)), n !== -1 ? n : null))
      : t === 'ddd'
        ? ((n = Vt.call(this._shortWeekdaysParse, o)),
          n !== -1 || ((n = Vt.call(this._weekdaysParse, o)), n !== -1)
            ? n
            : ((n = Vt.call(this._minWeekdaysParse, o)), n !== -1 ? n : null))
        : ((n = Vt.call(this._minWeekdaysParse, o)),
          n !== -1 || ((n = Vt.call(this._weekdaysParse, o)), n !== -1)
            ? n
            : ((n = Vt.call(this._shortWeekdaysParse, o)), n !== -1 ? n : null))
}
function eB(e, t, i) {
  var s, n, r
  if (this._weekdaysParseExact) return ZG.call(this, e, t, i)
  for (
    this._weekdaysParse ||
      ((this._weekdaysParse = []),
      (this._minWeekdaysParse = []),
      (this._shortWeekdaysParse = []),
      (this._fullWeekdaysParse = [])),
      s = 0;
    s < 7;
    s++
  ) {
    if (
      ((n = Ss([2e3, 1]).day(s)),
      i &&
        !this._fullWeekdaysParse[s] &&
        ((this._fullWeekdaysParse[s] = new RegExp(
          '^' + this.weekdays(n, '').replace('.', '\\.?') + '$',
          'i',
        )),
        (this._shortWeekdaysParse[s] = new RegExp(
          '^' + this.weekdaysShort(n, '').replace('.', '\\.?') + '$',
          'i',
        )),
        (this._minWeekdaysParse[s] = new RegExp(
          '^' + this.weekdaysMin(n, '').replace('.', '\\.?') + '$',
          'i',
        ))),
      this._weekdaysParse[s] ||
        ((r =
          '^' +
          this.weekdays(n, '') +
          '|^' +
          this.weekdaysShort(n, '') +
          '|^' +
          this.weekdaysMin(n, '')),
        (this._weekdaysParse[s] = new RegExp(r.replace('.', ''), 'i'))),
      i && t === 'dddd' && this._fullWeekdaysParse[s].test(e))
    )
      return s
    if (i && t === 'ddd' && this._shortWeekdaysParse[s].test(e)) return s
    if (i && t === 'dd' && this._minWeekdaysParse[s].test(e)) return s
    if (!i && this._weekdaysParse[s].test(e)) return s
  }
}
function tB(e) {
  if (!this.isValid()) return e != null ? this : NaN
  var t = Ro(this, 'Day')
  return e != null ? ((e = $G(e, this.localeData())), this.add(e - t, 'd')) : t
}
function iB(e) {
  if (!this.isValid()) return e != null ? this : NaN
  var t = (this.day() + 7 - this.localeData()._week.dow) % 7
  return e == null ? t : this.add(e - t, 'd')
}
function sB(e) {
  if (!this.isValid()) return e != null ? this : NaN
  if (e != null) {
    var t = zG(e, this.localeData())
    return this.day(this.day() % 7 ? t : t - 7)
  } else return this.day() || 7
}
function nB(e) {
  return this._weekdaysParseExact
    ? (gt(this, '_weekdaysRegex') || Kd.call(this),
      e ? this._weekdaysStrictRegex : this._weekdaysRegex)
    : (gt(this, '_weekdaysRegex') || (this._weekdaysRegex = YG),
      this._weekdaysStrictRegex && e
        ? this._weekdaysStrictRegex
        : this._weekdaysRegex)
}
function rB(e) {
  return this._weekdaysParseExact
    ? (gt(this, '_weekdaysRegex') || Kd.call(this),
      e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
    : (gt(this, '_weekdaysShortRegex') || (this._weekdaysShortRegex = KG),
      this._weekdaysShortStrictRegex && e
        ? this._weekdaysShortStrictRegex
        : this._weekdaysShortRegex)
}
function oB(e) {
  return this._weekdaysParseExact
    ? (gt(this, '_weekdaysRegex') || Kd.call(this),
      e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
    : (gt(this, '_weekdaysMinRegex') || (this._weekdaysMinRegex = qG),
      this._weekdaysMinStrictRegex && e
        ? this._weekdaysMinStrictRegex
        : this._weekdaysMinRegex)
}
function Kd() {
  function e(u, h) {
    return h.length - u.length
  }
  var t = [],
    i = [],
    s = [],
    n = [],
    r,
    o,
    a,
    l,
    c
  for (r = 0; r < 7; r++)
    (o = Ss([2e3, 1]).day(r)),
      (a = ks(this.weekdaysMin(o, ''))),
      (l = ks(this.weekdaysShort(o, ''))),
      (c = ks(this.weekdays(o, ''))),
      t.push(a),
      i.push(l),
      s.push(c),
      n.push(a),
      n.push(l),
      n.push(c)
  t.sort(e),
    i.sort(e),
    s.sort(e),
    n.sort(e),
    (this._weekdaysRegex = new RegExp('^(' + n.join('|') + ')', 'i')),
    (this._weekdaysShortRegex = this._weekdaysRegex),
    (this._weekdaysMinRegex = this._weekdaysRegex),
    (this._weekdaysStrictRegex = new RegExp('^(' + s.join('|') + ')', 'i')),
    (this._weekdaysShortStrictRegex = new RegExp(
      '^(' + i.join('|') + ')',
      'i',
    )),
    (this._weekdaysMinStrictRegex = new RegExp('^(' + t.join('|') + ')', 'i'))
}
function qd() {
  return this.hours() % 12 || 12
}
function aB() {
  return this.hours() || 24
}
Ve('H', ['HH', 2], 0, 'hour')
Ve('h', ['hh', 2], 0, qd)
Ve('k', ['kk', 2], 0, aB)
Ve('hmm', 0, 0, function () {
  return '' + qd.apply(this) + ps(this.minutes(), 2)
})
Ve('hmmss', 0, 0, function () {
  return '' + qd.apply(this) + ps(this.minutes(), 2) + ps(this.seconds(), 2)
})
Ve('Hmm', 0, 0, function () {
  return '' + this.hours() + ps(this.minutes(), 2)
})
Ve('Hmmss', 0, 0, function () {
  return '' + this.hours() + ps(this.minutes(), 2) + ps(this.seconds(), 2)
})
function kC(e, t) {
  Ve(e, 0, 0, function () {
    return this.localeData().meridiem(this.hours(), this.minutes(), t)
  })
}
kC('a', !0)
kC('A', !1)
function HC(e, t) {
  return t._meridiemParse
}
Pe('a', HC)
Pe('A', HC)
Pe('H', Dt, Ud)
Pe('h', Dt, Hr)
Pe('k', Dt, Hr)
Pe('HH', Dt, Gi)
Pe('hh', Dt, Gi)
Pe('kk', Dt, Gi)
Pe('hmm', FC)
Pe('hmmss', EC)
Pe('Hmm', FC)
Pe('Hmmss', EC)
wt(['H', 'HH'], Xt)
wt(['k', 'kk'], function (e, t, i) {
  var s = lt(e)
  t[Xt] = s === 24 ? 0 : s
})
wt(['a', 'A'], function (e, t, i) {
  ;(i._isPm = i._locale.isPM(e)), (i._meridiem = e)
})
wt(['h', 'hh'], function (e, t, i) {
  ;(t[Xt] = lt(e)), (Ze(i).bigHour = !0)
})
wt('hmm', function (e, t, i) {
  var s = e.length - 2
  ;(t[Xt] = lt(e.substr(0, s))), (t[Ji] = lt(e.substr(s))), (Ze(i).bigHour = !0)
})
wt('hmmss', function (e, t, i) {
  var s = e.length - 4,
    n = e.length - 2
  ;(t[Xt] = lt(e.substr(0, s))),
    (t[Ji] = lt(e.substr(s, 2))),
    (t[Is] = lt(e.substr(n))),
    (Ze(i).bigHour = !0)
})
wt('Hmm', function (e, t, i) {
  var s = e.length - 2
  ;(t[Xt] = lt(e.substr(0, s))), (t[Ji] = lt(e.substr(s)))
})
wt('Hmmss', function (e, t, i) {
  var s = e.length - 4,
    n = e.length - 2
  ;(t[Xt] = lt(e.substr(0, s))),
    (t[Ji] = lt(e.substr(s, 2))),
    (t[Is] = lt(e.substr(n)))
})
function lB(e) {
  return (e + '').toLowerCase().charAt(0) === 'p'
}
var cB = /[ap]\.?m?\.?/i,
  uB = Nr('Hours', !0)
function dB(e, t, i) {
  return e > 11 ? (i ? 'pm' : 'PM') : i ? 'am' : 'AM'
}
var NC = {
    calendar: ZN,
    longDateFormat: sG,
    invalidDate: rG,
    ordinal: aG,
    dayOfMonthOrdinalParse: lG,
    relativeTime: uG,
    months: PG,
    monthsShort: DC,
    week: GG,
    weekdays: UG,
    weekdaysMin: jG,
    weekdaysShort: LC,
    meridiemParse: cB,
  },
  It = {},
  Xr = {},
  Po
function hB(e, t) {
  var i,
    s = Math.min(e.length, t.length)
  for (i = 0; i < s; i += 1) if (e[i] !== t[i]) return i
  return s
}
function jg(e) {
  return e && e.toLowerCase().replace('_', '-')
}
function gB(e) {
  for (var t = 0, i, s, n, r; t < e.length; ) {
    for (
      r = jg(e[t]).split('-'),
        i = r.length,
        s = jg(e[t + 1]),
        s = s ? s.split('-') : null;
      i > 0;

    ) {
      if (((n = Ml(r.slice(0, i).join('-'))), n)) return n
      if (s && s.length >= i && hB(r, s) >= i - 1) break
      i--
    }
    t++
  }
  return Po
}
function fB(e) {
  return !!(e && e.match('^[^/\\\\]*$'))
}
function Ml(e) {
  var t = null,
    i
  if (
    It[e] === void 0 &&
    typeof module < 'u' &&
    module &&
    module.exports &&
    fB(e)
  )
    try {
      ;(t = Po._abbr), (i = require), i('./locale/' + e), an(t)
    } catch {
      It[e] = null
    }
  return It[e]
}
function an(e, t) {
  var i
  return (
    e &&
      (xi(t) ? (i = Ys(e)) : (i = Qd(e, t)),
      i
        ? (Po = i)
        : typeof console < 'u' &&
          console.warn &&
          console.warn(
            'Locale ' + e + ' not found. Did you forget to load it?',
          )),
    Po._abbr
  )
}
function Qd(e, t) {
  if (t !== null) {
    var i,
      s = NC
    if (((t.abbr = e), It[e] != null))
      wC(
        'defineLocaleOverride',
        'use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.',
      ),
        (s = It[e]._config)
    else if (t.parentLocale != null)
      if (It[t.parentLocale] != null) s = It[t.parentLocale]._config
      else if (((i = Ml(t.parentLocale)), i != null)) s = i._config
      else
        return (
          Xr[t.parentLocale] || (Xr[t.parentLocale] = []),
          Xr[t.parentLocale].push({ name: e, config: t }),
          null
        )
    return (
      (It[e] = new Vd(du(s, t))),
      Xr[e] &&
        Xr[e].forEach(function (n) {
          Qd(n.name, n.config)
        }),
      an(e),
      It[e]
    )
  } else return delete It[e], null
}
function pB(e, t) {
  if (t != null) {
    var i,
      s,
      n = NC
    It[e] != null && It[e].parentLocale != null
      ? It[e].set(du(It[e]._config, t))
      : ((s = Ml(e)),
        s != null && (n = s._config),
        (t = du(n, t)),
        s == null && (t.abbr = e),
        (i = new Vd(t)),
        (i.parentLocale = It[e]),
        (It[e] = i)),
      an(e)
  } else
    It[e] != null &&
      (It[e].parentLocale != null
        ? ((It[e] = It[e].parentLocale), e === an() && an(e))
        : It[e] != null && delete It[e])
  return It[e]
}
function Ys(e) {
  var t
  if ((e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e))
    return Po
  if (!ts(e)) {
    if (((t = Ml(e)), t)) return t
    e = [e]
  }
  return gB(e)
}
function mB() {
  return hu(It)
}
function Xd(e) {
  var t,
    i = e._a
  return (
    i &&
      Ze(e).overflow === -2 &&
      ((t =
        i[Ms] < 0 || i[Ms] > 11
          ? Ms
          : i[ds] < 1 || i[ds] > jd(i[pi], i[Ms])
            ? ds
            : i[Xt] < 0 ||
                i[Xt] > 24 ||
                (i[Xt] === 24 && (i[Ji] !== 0 || i[Is] !== 0 || i[xn] !== 0))
              ? Xt
              : i[Ji] < 0 || i[Ji] > 59
                ? Ji
                : i[Is] < 0 || i[Is] > 59
                  ? Is
                  : i[xn] < 0 || i[xn] > 999
                    ? xn
                    : -1),
      Ze(e)._overflowDayOfYear && (t < pi || t > ds) && (t = ds),
      Ze(e)._overflowWeeks && t === -1 && (t = wG),
      Ze(e)._overflowWeekday && t === -1 && (t = yG),
      (Ze(e).overflow = t)),
    e
  )
}
var vB =
    /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
  CB =
    /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
  SB = /Z|[+-]\d\d(?::?\d\d)?/,
  aa = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, !1],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, !1],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, !1],
    ['YYYYDDD', /\d{7}/],
    ['YYYYMM', /\d{6}/, !1],
    ['YYYY', /\d{4}/, !1],
  ],
  Rc = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/],
  ],
  wB = /^\/?Date\((-?\d+)/i,
  yB =
    /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
  bB = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60,
  }
function GC(e) {
  var t,
    i,
    s = e._i,
    n = vB.exec(s) || CB.exec(s),
    r,
    o,
    a,
    l,
    c = aa.length,
    u = Rc.length
  if (n) {
    for (Ze(e).iso = !0, t = 0, i = c; t < i; t++)
      if (aa[t][1].exec(n[1])) {
        ;(o = aa[t][0]), (r = aa[t][2] !== !1)
        break
      }
    if (o == null) {
      e._isValid = !1
      return
    }
    if (n[3]) {
      for (t = 0, i = u; t < i; t++)
        if (Rc[t][1].exec(n[3])) {
          a = (n[2] || ' ') + Rc[t][0]
          break
        }
      if (a == null) {
        e._isValid = !1
        return
      }
    }
    if (!r && a != null) {
      e._isValid = !1
      return
    }
    if (n[4])
      if (SB.exec(n[4])) l = 'Z'
      else {
        e._isValid = !1
        return
      }
    ;(e._f = o + (a || '') + (l || '')), Zd(e)
  } else e._isValid = !1
}
function RB(e, t, i, s, n, r) {
  var o = [
    FB(e),
    DC.indexOf(t),
    parseInt(i, 10),
    parseInt(s, 10),
    parseInt(n, 10),
  ]
  return r && o.push(parseInt(r, 10)), o
}
function FB(e) {
  var t = parseInt(e, 10)
  return t <= 49 ? 2e3 + t : t <= 999 ? 1900 + t : t
}
function EB(e) {
  return e
    .replace(/\([^()]*\)|[\n\t]/g, ' ')
    .replace(/(\s\s+)/g, ' ')
    .replace(/^\s\s*/, '')
    .replace(/\s\s*$/, '')
}
function PB(e, t, i) {
  if (e) {
    var s = LC.indexOf(e),
      n = new Date(t[0], t[1], t[2]).getDay()
    if (s !== n) return (Ze(i).weekdayMismatch = !0), (i._isValid = !1), !1
  }
  return !0
}
function xB(e, t, i) {
  if (e) return bB[e]
  if (t) return 0
  var s = parseInt(i, 10),
    n = s % 100,
    r = (s - n) / 100
  return r * 60 + n
}
function BC(e) {
  var t = yB.exec(EB(e._i)),
    i
  if (t) {
    if (((i = RB(t[4], t[3], t[2], t[5], t[6], t[7])), !PB(t[1], i, e))) return
    ;(e._a = i),
      (e._tzm = xB(t[8], t[9], t[10])),
      (e._d = Fo.apply(null, e._a)),
      e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm),
      (Ze(e).rfc2822 = !0)
  } else e._isValid = !1
}
function DB(e) {
  var t = wB.exec(e._i)
  if (t !== null) {
    e._d = new Date(+t[1])
    return
  }
  if ((GC(e), e._isValid === !1)) delete e._isValid
  else return
  if ((BC(e), e._isValid === !1)) delete e._isValid
  else return
  e._strict ? (e._isValid = !1) : Re.createFromInputFallback(e)
}
Re.createFromInputFallback = Ui(
  'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
  function (e) {
    e._d = new Date(e._i + (e._useUTC ? ' UTC' : ''))
  },
)
function sr(e, t, i) {
  return e ?? t ?? i
}
function MB(e) {
  var t = new Date(Re.now())
  return e._useUTC
    ? [t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate()]
    : [t.getFullYear(), t.getMonth(), t.getDate()]
}
function Jd(e) {
  var t,
    i,
    s = [],
    n,
    r,
    o
  if (!e._d) {
    for (
      n = MB(e),
        e._w && e._a[ds] == null && e._a[Ms] == null && IB(e),
        e._dayOfYear != null &&
          ((o = sr(e._a[pi], n[pi])),
          (e._dayOfYear > uo(o) || e._dayOfYear === 0) &&
            (Ze(e)._overflowDayOfYear = !0),
          (i = Fo(o, 0, e._dayOfYear)),
          (e._a[Ms] = i.getUTCMonth()),
          (e._a[ds] = i.getUTCDate())),
        t = 0;
      t < 3 && e._a[t] == null;
      ++t
    )
      e._a[t] = s[t] = n[t]
    for (; t < 7; t++)
      e._a[t] = s[t] = e._a[t] == null ? (t === 2 ? 1 : 0) : e._a[t]
    e._a[Xt] === 24 &&
      e._a[Ji] === 0 &&
      e._a[Is] === 0 &&
      e._a[xn] === 0 &&
      ((e._nextDay = !0), (e._a[Xt] = 0)),
      (e._d = (e._useUTC ? Fo : HG).apply(null, s)),
      (r = e._useUTC ? e._d.getUTCDay() : e._d.getDay()),
      e._tzm != null && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm),
      e._nextDay && (e._a[Xt] = 24),
      e._w &&
        typeof e._w.d < 'u' &&
        e._w.d !== r &&
        (Ze(e).weekdayMismatch = !0)
  }
}
function IB(e) {
  var t, i, s, n, r, o, a, l, c
  ;(t = e._w),
    t.GG != null || t.W != null || t.E != null
      ? ((r = 1),
        (o = 4),
        (i = sr(t.GG, e._a[pi], Eo(xt(), 1, 4).year)),
        (s = sr(t.W, 1)),
        (n = sr(t.E, 1)),
        (n < 1 || n > 7) && (l = !0))
      : ((r = e._locale._week.dow),
        (o = e._locale._week.doy),
        (c = Eo(xt(), r, o)),
        (i = sr(t.gg, e._a[pi], c.year)),
        (s = sr(t.w, c.week)),
        t.d != null
          ? ((n = t.d), (n < 0 || n > 6) && (l = !0))
          : t.e != null
            ? ((n = t.e + r), (t.e < 0 || t.e > 6) && (l = !0))
            : (n = r)),
    s < 1 || s > Hs(i, r, o)
      ? (Ze(e)._overflowWeeks = !0)
      : l != null
        ? (Ze(e)._overflowWeekday = !0)
        : ((a = OC(i, s, n, r, o)),
          (e._a[pi] = a.year),
          (e._dayOfYear = a.dayOfYear))
}
Re.ISO_8601 = function () {}
Re.RFC_2822 = function () {}
function Zd(e) {
  if (e._f === Re.ISO_8601) {
    GC(e)
    return
  }
  if (e._f === Re.RFC_2822) {
    BC(e)
    return
  }
  ;(e._a = []), (Ze(e).empty = !0)
  var t = '' + e._i,
    i,
    s,
    n,
    r,
    o,
    a = t.length,
    l = 0,
    c,
    u
  for (n = yC(e._f, e._locale).match(_d) || [], u = n.length, i = 0; i < u; i++)
    (r = n[i]),
      (s = (t.match(vG(r, e)) || [])[0]),
      s &&
        ((o = t.substr(0, t.indexOf(s))),
        o.length > 0 && Ze(e).unusedInput.push(o),
        (t = t.slice(t.indexOf(s) + s.length)),
        (l += s.length)),
      cr[r]
        ? (s ? (Ze(e).empty = !1) : Ze(e).unusedTokens.push(r), SG(r, s, e))
        : e._strict && !s && Ze(e).unusedTokens.push(r)
  ;(Ze(e).charsLeftOver = a - l),
    t.length > 0 && Ze(e).unusedInput.push(t),
    e._a[Xt] <= 12 &&
      Ze(e).bigHour === !0 &&
      e._a[Xt] > 0 &&
      (Ze(e).bigHour = void 0),
    (Ze(e).parsedDateParts = e._a.slice(0)),
    (Ze(e).meridiem = e._meridiem),
    (e._a[Xt] = TB(e._locale, e._a[Xt], e._meridiem)),
    (c = Ze(e).era),
    c !== null && (e._a[pi] = e._locale.erasConvertYear(c, e._a[pi])),
    Jd(e),
    Xd(e)
}
function TB(e, t, i) {
  var s
  return i == null
    ? t
    : e.meridiemHour != null
      ? e.meridiemHour(t, i)
      : (e.isPM != null &&
          ((s = e.isPM(i)),
          s && t < 12 && (t += 12),
          !s && t === 12 && (t = 0)),
        t)
}
function AB(e) {
  var t,
    i,
    s,
    n,
    r,
    o,
    a = !1,
    l = e._f.length
  if (l === 0) {
    ;(Ze(e).invalidFormat = !0), (e._d = new Date(NaN))
    return
  }
  for (n = 0; n < l; n++)
    (r = 0),
      (o = !1),
      (t = Bd({}, e)),
      e._useUTC != null && (t._useUTC = e._useUTC),
      (t._f = e._f[n]),
      Zd(t),
      Gd(t) && (o = !0),
      (r += Ze(t).charsLeftOver),
      (r += Ze(t).unusedTokens.length * 10),
      (Ze(t).score = r),
      a
        ? r < s && ((s = r), (i = t))
        : (s == null || r < s || o) && ((s = r), (i = t), o && (a = !0))
  sn(e, i || t)
}
function OB(e) {
  if (!e._d) {
    var t = Wd(e._i),
      i = t.day === void 0 ? t.date : t.day
    ;(e._a = CC(
      [t.year, t.month, i, t.hour, t.minute, t.second, t.millisecond],
      function (s) {
        return s && parseInt(s, 10)
      },
    )),
      Jd(e)
  }
}
function LB(e) {
  var t = new _o(Xd(VC(e)))
  return t._nextDay && (t.add(1, 'd'), (t._nextDay = void 0)), t
}
function VC(e) {
  var t = e._i,
    i = e._f
  return (
    (e._locale = e._locale || Ys(e._l)),
    t === null || (i === void 0 && t === '')
      ? bl({ nullInput: !0 })
      : (typeof t == 'string' && (e._i = t = e._locale.preparse(t)),
        is(t)
          ? new _o(Xd(t))
          : (Vo(t) ? (e._d = t) : ts(i) ? AB(e) : i ? Zd(e) : kB(e),
            Gd(e) || (e._d = null),
            e))
  )
}
function kB(e) {
  var t = e._i
  xi(t)
    ? (e._d = new Date(Re.now()))
    : Vo(t)
      ? (e._d = new Date(t.valueOf()))
      : typeof t == 'string'
        ? DB(e)
        : ts(t)
          ? ((e._a = CC(t.slice(0), function (i) {
              return parseInt(i, 10)
            })),
            Jd(e))
          : Ln(t)
            ? OB(e)
            : Ws(t)
              ? (e._d = new Date(t))
              : Re.createFromInputFallback(e)
}
function _C(e, t, i, s, n) {
  var r = {}
  return (
    (t === !0 || t === !1) && ((s = t), (t = void 0)),
    (i === !0 || i === !1) && ((s = i), (i = void 0)),
    ((Ln(e) && Nd(e)) || (ts(e) && e.length === 0)) && (e = void 0),
    (r._isAMomentObject = !0),
    (r._useUTC = r._isUTC = n),
    (r._l = i),
    (r._i = e),
    (r._f = t),
    (r._strict = s),
    LB(r)
  )
}
function xt(e, t, i, s) {
  return _C(e, t, i, s, !1)
}
var HB = Ui(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
      var e = xt.apply(null, arguments)
      return this.isValid() && e.isValid() ? (e < this ? this : e) : bl()
    },
  ),
  NB = Ui(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
      var e = xt.apply(null, arguments)
      return this.isValid() && e.isValid() ? (e > this ? this : e) : bl()
    },
  )
function WC(e, t) {
  var i, s
  if ((t.length === 1 && ts(t[0]) && (t = t[0]), !t.length)) return xt()
  for (i = t[0], s = 1; s < t.length; ++s)
    (!t[s].isValid() || t[s][e](i)) && (i = t[s])
  return i
}
function GB() {
  var e = [].slice.call(arguments, 0)
  return WC('isBefore', e)
}
function BB() {
  var e = [].slice.call(arguments, 0)
  return WC('isAfter', e)
}
var VB = function () {
    return Date.now ? Date.now() : +new Date()
  },
  Jr = [
    'year',
    'quarter',
    'month',
    'week',
    'day',
    'hour',
    'minute',
    'second',
    'millisecond',
  ]
function _B(e) {
  var t,
    i = !1,
    s,
    n = Jr.length
  for (t in e)
    if (gt(e, t) && !(Vt.call(Jr, t) !== -1 && (e[t] == null || !isNaN(e[t]))))
      return !1
  for (s = 0; s < n; ++s)
    if (e[Jr[s]]) {
      if (i) return !1
      parseFloat(e[Jr[s]]) !== lt(e[Jr[s]]) && (i = !0)
    }
  return !0
}
function WB() {
  return this._isValid
}
function $B() {
  return rs(NaN)
}
function Il(e) {
  var t = Wd(e),
    i = t.year || 0,
    s = t.quarter || 0,
    n = t.month || 0,
    r = t.week || t.isoWeek || 0,
    o = t.day || 0,
    a = t.hour || 0,
    l = t.minute || 0,
    c = t.second || 0,
    u = t.millisecond || 0
  ;(this._isValid = _B(t)),
    (this._milliseconds = +u + c * 1e3 + l * 6e4 + a * 1e3 * 60 * 60),
    (this._days = +o + r * 7),
    (this._months = +n + s * 3 + i * 12),
    (this._data = {}),
    (this._locale = Ys()),
    this._bubble()
}
function va(e) {
  return e instanceof Il
}
function fu(e) {
  return e < 0 ? Math.round(-1 * e) * -1 : Math.round(e)
}
function zB(e, t, i) {
  var s = Math.min(e.length, t.length),
    n = Math.abs(e.length - t.length),
    r = 0,
    o
  for (o = 0; o < s; o++) lt(e[o]) !== lt(t[o]) && r++
  return r + n
}
function $C(e, t) {
  Ve(e, 0, 0, function () {
    var i = this.utcOffset(),
      s = '+'
    return (
      i < 0 && ((i = -i), (s = '-')),
      s + ps(~~(i / 60), 2) + t + ps(~~i % 60, 2)
    )
  })
}
$C('Z', ':')
$C('ZZ', '')
Pe('Z', xl)
Pe('ZZ', xl)
wt(['Z', 'ZZ'], function (e, t, i) {
  ;(i._useUTC = !0), (i._tzm = eh(xl, e))
})
var UB = /([\+\-]|\d\d)/gi
function eh(e, t) {
  var i = (t || '').match(e),
    s,
    n,
    r
  return i === null
    ? null
    : ((s = i[i.length - 1] || []),
      (n = (s + '').match(UB) || ['-', 0, 0]),
      (r = +(n[1] * 60) + lt(n[2])),
      r === 0 ? 0 : n[0] === '+' ? r : -r)
}
function th(e, t) {
  var i, s
  return t._isUTC
    ? ((i = t.clone()),
      (s = (is(e) || Vo(e) ? e.valueOf() : xt(e).valueOf()) - i.valueOf()),
      i._d.setTime(i._d.valueOf() + s),
      Re.updateOffset(i, !1),
      i)
    : xt(e).local()
}
function pu(e) {
  return -Math.round(e._d.getTimezoneOffset())
}
Re.updateOffset = function () {}
function jB(e, t, i) {
  var s = this._offset || 0,
    n
  if (!this.isValid()) return e != null ? this : NaN
  if (e != null) {
    if (typeof e == 'string') {
      if (((e = eh(xl, e)), e === null)) return this
    } else Math.abs(e) < 16 && !i && (e = e * 60)
    return (
      !this._isUTC && t && (n = pu(this)),
      (this._offset = e),
      (this._isUTC = !0),
      n != null && this.add(n, 'm'),
      s !== e &&
        (!t || this._changeInProgress
          ? jC(this, rs(e - s, 'm'), 1, !1)
          : this._changeInProgress ||
            ((this._changeInProgress = !0),
            Re.updateOffset(this, !0),
            (this._changeInProgress = null))),
      this
    )
  } else return this._isUTC ? s : pu(this)
}
function YB(e, t) {
  return e != null
    ? (typeof e != 'string' && (e = -e), this.utcOffset(e, t), this)
    : -this.utcOffset()
}
function KB(e) {
  return this.utcOffset(0, e)
}
function qB(e) {
  return (
    this._isUTC &&
      (this.utcOffset(0, e),
      (this._isUTC = !1),
      e && this.subtract(pu(this), 'm')),
    this
  )
}
function QB() {
  if (this._tzm != null) this.utcOffset(this._tzm, !1, !0)
  else if (typeof this._i == 'string') {
    var e = eh(pG, this._i)
    e != null ? this.utcOffset(e) : this.utcOffset(0, !0)
  }
  return this
}
function XB(e) {
  return this.isValid()
    ? ((e = e ? xt(e).utcOffset() : 0), (this.utcOffset() - e) % 60 === 0)
    : !1
}
function JB() {
  return (
    this.utcOffset() > this.clone().month(0).utcOffset() ||
    this.utcOffset() > this.clone().month(5).utcOffset()
  )
}
function ZB() {
  if (!xi(this._isDSTShifted)) return this._isDSTShifted
  var e = {},
    t
  return (
    Bd(e, this),
    (e = VC(e)),
    e._a
      ? ((t = e._isUTC ? Ss(e._a) : xt(e._a)),
        (this._isDSTShifted = this.isValid() && zB(e._a, t.toArray()) > 0))
      : (this._isDSTShifted = !1),
    this._isDSTShifted
  )
}
function eV() {
  return this.isValid() ? !this._isUTC : !1
}
function tV() {
  return this.isValid() ? this._isUTC : !1
}
function zC() {
  return this.isValid() ? this._isUTC && this._offset === 0 : !1
}
var iV = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
  sV =
    /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/
function rs(e, t) {
  var i = e,
    s = null,
    n,
    r,
    o
  return (
    va(e)
      ? (i = { ms: e._milliseconds, d: e._days, M: e._months })
      : Ws(e) || !isNaN(+e)
        ? ((i = {}), t ? (i[t] = +e) : (i.milliseconds = +e))
        : (s = iV.exec(e))
          ? ((n = s[1] === '-' ? -1 : 1),
            (i = {
              y: 0,
              d: lt(s[ds]) * n,
              h: lt(s[Xt]) * n,
              m: lt(s[Ji]) * n,
              s: lt(s[Is]) * n,
              ms: lt(fu(s[xn] * 1e3)) * n,
            }))
          : (s = sV.exec(e))
            ? ((n = s[1] === '-' ? -1 : 1),
              (i = {
                y: Cn(s[2], n),
                M: Cn(s[3], n),
                w: Cn(s[4], n),
                d: Cn(s[5], n),
                h: Cn(s[6], n),
                m: Cn(s[7], n),
                s: Cn(s[8], n),
              }))
            : i == null
              ? (i = {})
              : typeof i == 'object' &&
                ('from' in i || 'to' in i) &&
                ((o = nV(xt(i.from), xt(i.to))),
                (i = {}),
                (i.ms = o.milliseconds),
                (i.M = o.months)),
    (r = new Il(i)),
    va(e) && gt(e, '_locale') && (r._locale = e._locale),
    va(e) && gt(e, '_isValid') && (r._isValid = e._isValid),
    r
  )
}
rs.fn = Il.prototype
rs.invalid = $B
function Cn(e, t) {
  var i = e && parseFloat(e.replace(',', '.'))
  return (isNaN(i) ? 0 : i) * t
}
function Yg(e, t) {
  var i = {}
  return (
    (i.months = t.month() - e.month() + (t.year() - e.year()) * 12),
    e.clone().add(i.months, 'M').isAfter(t) && --i.months,
    (i.milliseconds = +t - +e.clone().add(i.months, 'M')),
    i
  )
}
function nV(e, t) {
  var i
  return e.isValid() && t.isValid()
    ? ((t = th(t, e)),
      e.isBefore(t)
        ? (i = Yg(e, t))
        : ((i = Yg(t, e)),
          (i.milliseconds = -i.milliseconds),
          (i.months = -i.months)),
      i)
    : { milliseconds: 0, months: 0 }
}
function UC(e, t) {
  return function (i, s) {
    var n, r
    return (
      s !== null &&
        !isNaN(+s) &&
        (wC(
          t,
          'moment().' +
            t +
            '(period, number) is deprecated. Please use moment().' +
            t +
            '(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.',
        ),
        (r = i),
        (i = s),
        (s = r)),
      (n = rs(i, s)),
      jC(this, n, e),
      this
    )
  }
}
function jC(e, t, i, s) {
  var n = t._milliseconds,
    r = fu(t._days),
    o = fu(t._months)
  e.isValid() &&
    ((s = s ?? !0),
    o && IC(e, Ro(e, 'Month') + o * i),
    r && xC(e, 'Date', Ro(e, 'Date') + r * i),
    n && e._d.setTime(e._d.valueOf() + n * i),
    s && Re.updateOffset(e, r || o))
}
var rV = UC(1, 'add'),
  oV = UC(-1, 'subtract')
function YC(e) {
  return typeof e == 'string' || e instanceof String
}
function aV(e) {
  return (
    is(e) ||
    Vo(e) ||
    YC(e) ||
    Ws(e) ||
    cV(e) ||
    lV(e) ||
    e === null ||
    e === void 0
  )
}
function lV(e) {
  var t = Ln(e) && !Nd(e),
    i = !1,
    s = [
      'years',
      'year',
      'y',
      'months',
      'month',
      'M',
      'days',
      'day',
      'd',
      'dates',
      'date',
      'D',
      'hours',
      'hour',
      'h',
      'minutes',
      'minute',
      'm',
      'seconds',
      'second',
      's',
      'milliseconds',
      'millisecond',
      'ms',
    ],
    n,
    r,
    o = s.length
  for (n = 0; n < o; n += 1) (r = s[n]), (i = i || gt(e, r))
  return t && i
}
function cV(e) {
  var t = ts(e),
    i = !1
  return (
    t &&
      (i =
        e.filter(function (s) {
          return !Ws(s) && YC(e)
        }).length === 0),
    t && i
  )
}
function uV(e) {
  var t = Ln(e) && !Nd(e),
    i = !1,
    s = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],
    n,
    r
  for (n = 0; n < s.length; n += 1) (r = s[n]), (i = i || gt(e, r))
  return t && i
}
function dV(e, t) {
  var i = e.diff(t, 'days', !0)
  return i < -6
    ? 'sameElse'
    : i < -1
      ? 'lastWeek'
      : i < 0
        ? 'lastDay'
        : i < 1
          ? 'sameDay'
          : i < 2
            ? 'nextDay'
            : i < 7
              ? 'nextWeek'
              : 'sameElse'
}
function hV(e, t) {
  arguments.length === 1 &&
    (arguments[0]
      ? aV(arguments[0])
        ? ((e = arguments[0]), (t = void 0))
        : uV(arguments[0]) && ((t = arguments[0]), (e = void 0))
      : ((e = void 0), (t = void 0)))
  var i = e || xt(),
    s = th(i, this).startOf('day'),
    n = Re.calendarFormat(this, s) || 'sameElse',
    r = t && (ws(t[n]) ? t[n].call(this, i) : t[n])
  return this.format(r || this.localeData().calendar(n, this, xt(i)))
}
function gV() {
  return new _o(this)
}
function fV(e, t) {
  var i = is(e) ? e : xt(e)
  return this.isValid() && i.isValid()
    ? ((t = ji(t) || 'millisecond'),
      t === 'millisecond'
        ? this.valueOf() > i.valueOf()
        : i.valueOf() < this.clone().startOf(t).valueOf())
    : !1
}
function pV(e, t) {
  var i = is(e) ? e : xt(e)
  return this.isValid() && i.isValid()
    ? ((t = ji(t) || 'millisecond'),
      t === 'millisecond'
        ? this.valueOf() < i.valueOf()
        : this.clone().endOf(t).valueOf() < i.valueOf())
    : !1
}
function mV(e, t, i, s) {
  var n = is(e) ? e : xt(e),
    r = is(t) ? t : xt(t)
  return this.isValid() && n.isValid() && r.isValid()
    ? ((s = s || '()'),
      (s[0] === '(' ? this.isAfter(n, i) : !this.isBefore(n, i)) &&
        (s[1] === ')' ? this.isBefore(r, i) : !this.isAfter(r, i)))
    : !1
}
function vV(e, t) {
  var i = is(e) ? e : xt(e),
    s
  return this.isValid() && i.isValid()
    ? ((t = ji(t) || 'millisecond'),
      t === 'millisecond'
        ? this.valueOf() === i.valueOf()
        : ((s = i.valueOf()),
          this.clone().startOf(t).valueOf() <= s &&
            s <= this.clone().endOf(t).valueOf()))
    : !1
}
function CV(e, t) {
  return this.isSame(e, t) || this.isAfter(e, t)
}
function SV(e, t) {
  return this.isSame(e, t) || this.isBefore(e, t)
}
function wV(e, t, i) {
  var s, n, r
  if (!this.isValid()) return NaN
  if (((s = th(e, this)), !s.isValid())) return NaN
  switch (((n = (s.utcOffset() - this.utcOffset()) * 6e4), (t = ji(t)), t)) {
    case 'year':
      r = Ca(this, s) / 12
      break
    case 'month':
      r = Ca(this, s)
      break
    case 'quarter':
      r = Ca(this, s) / 3
      break
    case 'second':
      r = (this - s) / 1e3
      break
    case 'minute':
      r = (this - s) / 6e4
      break
    case 'hour':
      r = (this - s) / 36e5
      break
    case 'day':
      r = (this - s - n) / 864e5
      break
    case 'week':
      r = (this - s - n) / 6048e5
      break
    default:
      r = this - s
  }
  return i ? r : Vi(r)
}
function Ca(e, t) {
  if (e.date() < t.date()) return -Ca(t, e)
  var i = (t.year() - e.year()) * 12 + (t.month() - e.month()),
    s = e.clone().add(i, 'months'),
    n,
    r
  return (
    t - s < 0
      ? ((n = e.clone().add(i - 1, 'months')), (r = (t - s) / (s - n)))
      : ((n = e.clone().add(i + 1, 'months')), (r = (t - s) / (n - s))),
    -(i + r) || 0
  )
}
Re.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ'
Re.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]'
function yV() {
  return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ')
}
function bV(e) {
  if (!this.isValid()) return null
  var t = e !== !0,
    i = t ? this.clone().utc() : this
  return i.year() < 0 || i.year() > 9999
    ? ma(
        i,
        t ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ',
      )
    : ws(Date.prototype.toISOString)
      ? t
        ? this.toDate().toISOString()
        : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3)
            .toISOString()
            .replace('Z', ma(i, 'Z'))
      : ma(i, t ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ')
}
function RV() {
  if (!this.isValid()) return 'moment.invalid(/* ' + this._i + ' */)'
  var e = 'moment',
    t = '',
    i,
    s,
    n,
    r
  return (
    this.isLocal() ||
      ((e = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone'),
      (t = 'Z')),
    (i = '[' + e + '("]'),
    (s = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY'),
    (n = '-MM-DD[T]HH:mm:ss.SSS'),
    (r = t + '[")]'),
    this.format(i + s + n + r)
  )
}
function FV(e) {
  e || (e = this.isUtc() ? Re.defaultFormatUtc : Re.defaultFormat)
  var t = ma(this, e)
  return this.localeData().postformat(t)
}
function EV(e, t) {
  return this.isValid() && ((is(e) && e.isValid()) || xt(e).isValid())
    ? rs({ to: this, from: e }).locale(this.locale()).humanize(!t)
    : this.localeData().invalidDate()
}
function PV(e) {
  return this.from(xt(), e)
}
function xV(e, t) {
  return this.isValid() && ((is(e) && e.isValid()) || xt(e).isValid())
    ? rs({ from: this, to: e }).locale(this.locale()).humanize(!t)
    : this.localeData().invalidDate()
}
function DV(e) {
  return this.to(xt(), e)
}
function KC(e) {
  var t
  return e === void 0
    ? this._locale._abbr
    : ((t = Ys(e)), t != null && (this._locale = t), this)
}
var qC = Ui(
  'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
  function (e) {
    return e === void 0 ? this.localeData() : this.locale(e)
  },
)
function QC() {
  return this._locale
}
var ja = 1e3,
  ur = 60 * ja,
  Ya = 60 * ur,
  XC = (365 * 400 + 97) * 24 * Ya
function dr(e, t) {
  return ((e % t) + t) % t
}
function JC(e, t, i) {
  return e < 100 && e >= 0
    ? new Date(e + 400, t, i) - XC
    : new Date(e, t, i).valueOf()
}
function ZC(e, t, i) {
  return e < 100 && e >= 0 ? Date.UTC(e + 400, t, i) - XC : Date.UTC(e, t, i)
}
function MV(e) {
  var t, i
  if (((e = ji(e)), e === void 0 || e === 'millisecond' || !this.isValid()))
    return this
  switch (((i = this._isUTC ? ZC : JC), e)) {
    case 'year':
      t = i(this.year(), 0, 1)
      break
    case 'quarter':
      t = i(this.year(), this.month() - (this.month() % 3), 1)
      break
    case 'month':
      t = i(this.year(), this.month(), 1)
      break
    case 'week':
      t = i(this.year(), this.month(), this.date() - this.weekday())
      break
    case 'isoWeek':
      t = i(this.year(), this.month(), this.date() - (this.isoWeekday() - 1))
      break
    case 'day':
    case 'date':
      t = i(this.year(), this.month(), this.date())
      break
    case 'hour':
      ;(t = this._d.valueOf()),
        (t -= dr(t + (this._isUTC ? 0 : this.utcOffset() * ur), Ya))
      break
    case 'minute':
      ;(t = this._d.valueOf()), (t -= dr(t, ur))
      break
    case 'second':
      ;(t = this._d.valueOf()), (t -= dr(t, ja))
      break
  }
  return this._d.setTime(t), Re.updateOffset(this, !0), this
}
function IV(e) {
  var t, i
  if (((e = ji(e)), e === void 0 || e === 'millisecond' || !this.isValid()))
    return this
  switch (((i = this._isUTC ? ZC : JC), e)) {
    case 'year':
      t = i(this.year() + 1, 0, 1) - 1
      break
    case 'quarter':
      t = i(this.year(), this.month() - (this.month() % 3) + 3, 1) - 1
      break
    case 'month':
      t = i(this.year(), this.month() + 1, 1) - 1
      break
    case 'week':
      t = i(this.year(), this.month(), this.date() - this.weekday() + 7) - 1
      break
    case 'isoWeek':
      t =
        i(
          this.year(),
          this.month(),
          this.date() - (this.isoWeekday() - 1) + 7,
        ) - 1
      break
    case 'day':
    case 'date':
      t = i(this.year(), this.month(), this.date() + 1) - 1
      break
    case 'hour':
      ;(t = this._d.valueOf()),
        (t += Ya - dr(t + (this._isUTC ? 0 : this.utcOffset() * ur), Ya) - 1)
      break
    case 'minute':
      ;(t = this._d.valueOf()), (t += ur - dr(t, ur) - 1)
      break
    case 'second':
      ;(t = this._d.valueOf()), (t += ja - dr(t, ja) - 1)
      break
  }
  return this._d.setTime(t), Re.updateOffset(this, !0), this
}
function TV() {
  return this._d.valueOf() - (this._offset || 0) * 6e4
}
function AV() {
  return Math.floor(this.valueOf() / 1e3)
}
function OV() {
  return new Date(this.valueOf())
}
function LV() {
  var e = this
  return [
    e.year(),
    e.month(),
    e.date(),
    e.hour(),
    e.minute(),
    e.second(),
    e.millisecond(),
  ]
}
function kV() {
  var e = this
  return {
    years: e.year(),
    months: e.month(),
    date: e.date(),
    hours: e.hours(),
    minutes: e.minutes(),
    seconds: e.seconds(),
    milliseconds: e.milliseconds(),
  }
}
function HV() {
  return this.isValid() ? this.toISOString() : null
}
function NV() {
  return Gd(this)
}
function GV() {
  return sn({}, Ze(this))
}
function BV() {
  return Ze(this).overflow
}
function VV() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict,
  }
}
Ve('N', 0, 0, 'eraAbbr')
Ve('NN', 0, 0, 'eraAbbr')
Ve('NNN', 0, 0, 'eraAbbr')
Ve('NNNN', 0, 0, 'eraName')
Ve('NNNNN', 0, 0, 'eraNarrow')
Ve('y', ['y', 1], 'yo', 'eraYear')
Ve('y', ['yy', 2], 0, 'eraYear')
Ve('y', ['yyy', 3], 0, 'eraYear')
Ve('y', ['yyyy', 4], 0, 'eraYear')
Pe('N', ih)
Pe('NN', ih)
Pe('NNN', ih)
Pe('NNNN', XV)
Pe('NNNNN', JV)
wt(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (e, t, i, s) {
  var n = i._locale.erasParse(e, s, i._strict)
  n ? (Ze(i).era = n) : (Ze(i).invalidEra = e)
})
Pe('y', kr)
Pe('yy', kr)
Pe('yyy', kr)
Pe('yyyy', kr)
Pe('yo', ZV)
wt(['y', 'yy', 'yyy', 'yyyy'], pi)
wt(['yo'], function (e, t, i, s) {
  var n
  i._locale._eraYearOrdinalRegex &&
    (n = e.match(i._locale._eraYearOrdinalRegex)),
    i._locale.eraYearOrdinalParse
      ? (t[pi] = i._locale.eraYearOrdinalParse(e, n))
      : (t[pi] = parseInt(e, 10))
})
function _V(e, t) {
  var i,
    s,
    n,
    r = this._eras || Ys('en')._eras
  for (i = 0, s = r.length; i < s; ++i) {
    switch (typeof r[i].since) {
      case 'string':
        ;(n = Re(r[i].since).startOf('day')), (r[i].since = n.valueOf())
        break
    }
    switch (typeof r[i].until) {
      case 'undefined':
        r[i].until = 1 / 0
        break
      case 'string':
        ;(n = Re(r[i].until).startOf('day').valueOf()),
          (r[i].until = n.valueOf())
        break
    }
  }
  return r
}
function WV(e, t, i) {
  var s,
    n,
    r = this.eras(),
    o,
    a,
    l
  for (e = e.toUpperCase(), s = 0, n = r.length; s < n; ++s)
    if (
      ((o = r[s].name.toUpperCase()),
      (a = r[s].abbr.toUpperCase()),
      (l = r[s].narrow.toUpperCase()),
      i)
    )
      switch (t) {
        case 'N':
        case 'NN':
        case 'NNN':
          if (a === e) return r[s]
          break
        case 'NNNN':
          if (o === e) return r[s]
          break
        case 'NNNNN':
          if (l === e) return r[s]
          break
      }
    else if ([o, a, l].indexOf(e) >= 0) return r[s]
}
function $V(e, t) {
  var i = e.since <= e.until ? 1 : -1
  return t === void 0
    ? Re(e.since).year()
    : Re(e.since).year() + (t - e.offset) * i
}
function zV() {
  var e,
    t,
    i,
    s = this.localeData().eras()
  for (e = 0, t = s.length; e < t; ++e)
    if (
      ((i = this.clone().startOf('day').valueOf()),
      (s[e].since <= i && i <= s[e].until) ||
        (s[e].until <= i && i <= s[e].since))
    )
      return s[e].name
  return ''
}
function UV() {
  var e,
    t,
    i,
    s = this.localeData().eras()
  for (e = 0, t = s.length; e < t; ++e)
    if (
      ((i = this.clone().startOf('day').valueOf()),
      (s[e].since <= i && i <= s[e].until) ||
        (s[e].until <= i && i <= s[e].since))
    )
      return s[e].narrow
  return ''
}
function jV() {
  var e,
    t,
    i,
    s = this.localeData().eras()
  for (e = 0, t = s.length; e < t; ++e)
    if (
      ((i = this.clone().startOf('day').valueOf()),
      (s[e].since <= i && i <= s[e].until) ||
        (s[e].until <= i && i <= s[e].since))
    )
      return s[e].abbr
  return ''
}
function YV() {
  var e,
    t,
    i,
    s,
    n = this.localeData().eras()
  for (e = 0, t = n.length; e < t; ++e)
    if (
      ((i = n[e].since <= n[e].until ? 1 : -1),
      (s = this.clone().startOf('day').valueOf()),
      (n[e].since <= s && s <= n[e].until) ||
        (n[e].until <= s && s <= n[e].since))
    )
      return (this.year() - Re(n[e].since).year()) * i + n[e].offset
  return this.year()
}
function KV(e) {
  return (
    gt(this, '_erasNameRegex') || sh.call(this),
    e ? this._erasNameRegex : this._erasRegex
  )
}
function qV(e) {
  return (
    gt(this, '_erasAbbrRegex') || sh.call(this),
    e ? this._erasAbbrRegex : this._erasRegex
  )
}
function QV(e) {
  return (
    gt(this, '_erasNarrowRegex') || sh.call(this),
    e ? this._erasNarrowRegex : this._erasRegex
  )
}
function ih(e, t) {
  return t.erasAbbrRegex(e)
}
function XV(e, t) {
  return t.erasNameRegex(e)
}
function JV(e, t) {
  return t.erasNarrowRegex(e)
}
function ZV(e, t) {
  return t._eraYearOrdinalRegex || kr
}
function sh() {
  var e = [],
    t = [],
    i = [],
    s = [],
    n,
    r,
    o,
    a,
    l,
    c = this.eras()
  for (n = 0, r = c.length; n < r; ++n)
    (o = ks(c[n].name)),
      (a = ks(c[n].abbr)),
      (l = ks(c[n].narrow)),
      t.push(o),
      e.push(a),
      i.push(l),
      s.push(o),
      s.push(a),
      s.push(l)
  ;(this._erasRegex = new RegExp('^(' + s.join('|') + ')', 'i')),
    (this._erasNameRegex = new RegExp('^(' + t.join('|') + ')', 'i')),
    (this._erasAbbrRegex = new RegExp('^(' + e.join('|') + ')', 'i')),
    (this._erasNarrowRegex = new RegExp('^(' + i.join('|') + ')', 'i'))
}
Ve(0, ['gg', 2], 0, function () {
  return this.weekYear() % 100
})
Ve(0, ['GG', 2], 0, function () {
  return this.isoWeekYear() % 100
})
function Tl(e, t) {
  Ve(0, [e, e.length], 0, t)
}
Tl('gggg', 'weekYear')
Tl('ggggg', 'weekYear')
Tl('GGGG', 'isoWeekYear')
Tl('GGGGG', 'isoWeekYear')
Pe('G', Pl)
Pe('g', Pl)
Pe('GG', Dt, Gi)
Pe('gg', Dt, Gi)
Pe('GGGG', zd, $d)
Pe('gggg', zd, $d)
Pe('GGGGG', El, Rl)
Pe('ggggg', El, Rl)
$o(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (e, t, i, s) {
  t[s.substr(0, 2)] = lt(e)
})
$o(['gg', 'GG'], function (e, t, i, s) {
  t[s] = Re.parseTwoDigitYear(e)
})
function e_(e) {
  return eS.call(
    this,
    e,
    this.week(),
    this.weekday() + this.localeData()._week.dow,
    this.localeData()._week.dow,
    this.localeData()._week.doy,
  )
}
function t_(e) {
  return eS.call(this, e, this.isoWeek(), this.isoWeekday(), 1, 4)
}
function i_() {
  return Hs(this.year(), 1, 4)
}
function s_() {
  return Hs(this.isoWeekYear(), 1, 4)
}
function n_() {
  var e = this.localeData()._week
  return Hs(this.year(), e.dow, e.doy)
}
function r_() {
  var e = this.localeData()._week
  return Hs(this.weekYear(), e.dow, e.doy)
}
function eS(e, t, i, s, n) {
  var r
  return e == null
    ? Eo(this, s, n).year
    : ((r = Hs(e, s, n)), t > r && (t = r), o_.call(this, e, t, i, s, n))
}
function o_(e, t, i, s, n) {
  var r = OC(e, t, i, s, n),
    o = Fo(r.year, 0, r.dayOfYear)
  return (
    this.year(o.getUTCFullYear()),
    this.month(o.getUTCMonth()),
    this.date(o.getUTCDate()),
    this
  )
}
Ve('Q', 0, 'Qo', 'quarter')
Pe('Q', bC)
wt('Q', function (e, t) {
  t[Ms] = (lt(e) - 1) * 3
})
function a_(e) {
  return e == null
    ? Math.ceil((this.month() + 1) / 3)
    : this.month((e - 1) * 3 + (this.month() % 3))
}
Ve('D', ['DD', 2], 'Do', 'date')
Pe('D', Dt, Hr)
Pe('DD', Dt, Gi)
Pe('Do', function (e, t) {
  return e
    ? t._dayOfMonthOrdinalParse || t._ordinalParse
    : t._dayOfMonthOrdinalParseLenient
})
wt(['D', 'DD'], ds)
wt('Do', function (e, t) {
  t[ds] = lt(e.match(Dt)[0])
})
var tS = Nr('Date', !0)
Ve('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear')
Pe('DDD', Fl)
Pe('DDDD', RC)
wt(['DDD', 'DDDD'], function (e, t, i) {
  i._dayOfYear = lt(e)
})
function l_(e) {
  var t =
    Math.round(
      (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5,
    ) + 1
  return e == null ? t : this.add(e - t, 'd')
}
Ve('m', ['mm', 2], 0, 'minute')
Pe('m', Dt, Ud)
Pe('mm', Dt, Gi)
wt(['m', 'mm'], Ji)
var c_ = Nr('Minutes', !1)
Ve('s', ['ss', 2], 0, 'second')
Pe('s', Dt, Ud)
Pe('ss', Dt, Gi)
wt(['s', 'ss'], Is)
var u_ = Nr('Seconds', !1)
Ve('S', 0, 0, function () {
  return ~~(this.millisecond() / 100)
})
Ve(0, ['SS', 2], 0, function () {
  return ~~(this.millisecond() / 10)
})
Ve(0, ['SSS', 3], 0, 'millisecond')
Ve(0, ['SSSS', 4], 0, function () {
  return this.millisecond() * 10
})
Ve(0, ['SSSSS', 5], 0, function () {
  return this.millisecond() * 100
})
Ve(0, ['SSSSSS', 6], 0, function () {
  return this.millisecond() * 1e3
})
Ve(0, ['SSSSSSS', 7], 0, function () {
  return this.millisecond() * 1e4
})
Ve(0, ['SSSSSSSS', 8], 0, function () {
  return this.millisecond() * 1e5
})
Ve(0, ['SSSSSSSSS', 9], 0, function () {
  return this.millisecond() * 1e6
})
Pe('S', Fl, bC)
Pe('SS', Fl, Gi)
Pe('SSS', Fl, RC)
var nn, iS
for (nn = 'SSSS'; nn.length <= 9; nn += 'S') Pe(nn, kr)
function d_(e, t) {
  t[xn] = lt(('0.' + e) * 1e3)
}
for (nn = 'S'; nn.length <= 9; nn += 'S') wt(nn, d_)
iS = Nr('Milliseconds', !1)
Ve('z', 0, 0, 'zoneAbbr')
Ve('zz', 0, 0, 'zoneName')
function h_() {
  return this._isUTC ? 'UTC' : ''
}
function g_() {
  return this._isUTC ? 'Coordinated Universal Time' : ''
}
var he = _o.prototype
he.add = rV
he.calendar = hV
he.clone = gV
he.diff = wV
he.endOf = IV
he.format = FV
he.from = EV
he.fromNow = PV
he.to = xV
he.toNow = DV
he.get = RG
he.invalidAt = BV
he.isAfter = fV
he.isBefore = pV
he.isBetween = mV
he.isSame = vV
he.isSameOrAfter = CV
he.isSameOrBefore = SV
he.isValid = NV
he.lang = qC
he.locale = KC
he.localeData = QC
he.max = NB
he.min = HB
he.parsingFlags = GV
he.set = FG
he.startOf = MV
he.subtract = oV
he.toArray = LV
he.toObject = kV
he.toDate = OV
he.toISOString = bV
he.inspect = RV
typeof Symbol < 'u' &&
  Symbol.for != null &&
  (he[Symbol.for('nodejs.util.inspect.custom')] = function () {
    return 'Moment<' + this.format() + '>'
  })
he.toJSON = HV
he.toString = yV
he.unix = AV
he.valueOf = TV
he.creationData = VV
he.eraName = zV
he.eraNarrow = UV
he.eraAbbr = jV
he.eraYear = YV
he.year = PC
he.isLeapYear = bG
he.weekYear = e_
he.isoWeekYear = t_
he.quarter = he.quarters = a_
he.month = TC
he.daysInMonth = OG
he.week = he.weeks = _G
he.isoWeek = he.isoWeeks = WG
he.weeksInYear = n_
he.weeksInWeekYear = r_
he.isoWeeksInYear = i_
he.isoWeeksInISOWeekYear = s_
he.date = tS
he.day = he.days = tB
he.weekday = iB
he.isoWeekday = sB
he.dayOfYear = l_
he.hour = he.hours = uB
he.minute = he.minutes = c_
he.second = he.seconds = u_
he.millisecond = he.milliseconds = iS
he.utcOffset = jB
he.utc = KB
he.local = qB
he.parseZone = QB
he.hasAlignedHourOffset = XB
he.isDST = JB
he.isLocal = eV
he.isUtcOffset = tV
he.isUtc = zC
he.isUTC = zC
he.zoneAbbr = h_
he.zoneName = g_
he.dates = Ui('dates accessor is deprecated. Use date instead.', tS)
he.months = Ui('months accessor is deprecated. Use month instead', TC)
he.years = Ui('years accessor is deprecated. Use year instead', PC)
he.zone = Ui(
  'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
  YB,
)
he.isDSTShifted = Ui(
  'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
  ZB,
)
function f_(e) {
  return xt(e * 1e3)
}
function p_() {
  return xt.apply(null, arguments).parseZone()
}
function sS(e) {
  return e
}
var ft = Vd.prototype
ft.calendar = eG
ft.longDateFormat = nG
ft.invalidDate = oG
ft.ordinal = cG
ft.preparse = sS
ft.postformat = sS
ft.relativeTime = dG
ft.pastFuture = hG
ft.set = JN
ft.eras = _V
ft.erasParse = WV
ft.erasConvertYear = $V
ft.erasAbbrRegex = qV
ft.erasNameRegex = KV
ft.erasNarrowRegex = QV
ft.months = MG
ft.monthsShort = IG
ft.monthsParse = AG
ft.monthsRegex = kG
ft.monthsShortRegex = LG
ft.week = NG
ft.firstDayOfYear = VG
ft.firstDayOfWeek = BG
ft.weekdays = QG
ft.weekdaysMin = JG
ft.weekdaysShort = XG
ft.weekdaysParse = eB
ft.weekdaysRegex = nB
ft.weekdaysShortRegex = rB
ft.weekdaysMinRegex = oB
ft.isPM = lB
ft.meridiem = dB
function Ka(e, t, i, s) {
  var n = Ys(),
    r = Ss().set(s, t)
  return n[i](r, e)
}
function nS(e, t, i) {
  if ((Ws(e) && ((t = e), (e = void 0)), (e = e || ''), t != null))
    return Ka(e, t, i, 'month')
  var s,
    n = []
  for (s = 0; s < 12; s++) n[s] = Ka(e, s, i, 'month')
  return n
}
function nh(e, t, i, s) {
  typeof e == 'boolean'
    ? (Ws(t) && ((i = t), (t = void 0)), (t = t || ''))
    : ((t = e),
      (i = t),
      (e = !1),
      Ws(t) && ((i = t), (t = void 0)),
      (t = t || ''))
  var n = Ys(),
    r = e ? n._week.dow : 0,
    o,
    a = []
  if (i != null) return Ka(t, (i + r) % 7, s, 'day')
  for (o = 0; o < 7; o++) a[o] = Ka(t, (o + r) % 7, s, 'day')
  return a
}
function m_(e, t) {
  return nS(e, t, 'months')
}
function v_(e, t) {
  return nS(e, t, 'monthsShort')
}
function C_(e, t, i) {
  return nh(e, t, i, 'weekdays')
}
function S_(e, t, i) {
  return nh(e, t, i, 'weekdaysShort')
}
function w_(e, t, i) {
  return nh(e, t, i, 'weekdaysMin')
}
an('en', {
  eras: [
    {
      since: '0001-01-01',
      until: 1 / 0,
      offset: 1,
      name: 'Anno Domini',
      narrow: 'AD',
      abbr: 'AD',
    },
    {
      since: '0000-12-31',
      until: -1 / 0,
      offset: 1,
      name: 'Before Christ',
      narrow: 'BC',
      abbr: 'BC',
    },
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function (e) {
    var t = e % 10,
      i =
        lt((e % 100) / 10) === 1
          ? 'th'
          : t === 1
            ? 'st'
            : t === 2
              ? 'nd'
              : t === 3
                ? 'rd'
                : 'th'
    return e + i
  },
})
Re.lang = Ui('moment.lang is deprecated. Use moment.locale instead.', an)
Re.langData = Ui(
  'moment.langData is deprecated. Use moment.localeData instead.',
  Ys,
)
var Es = Math.abs
function y_() {
  var e = this._data
  return (
    (this._milliseconds = Es(this._milliseconds)),
    (this._days = Es(this._days)),
    (this._months = Es(this._months)),
    (e.milliseconds = Es(e.milliseconds)),
    (e.seconds = Es(e.seconds)),
    (e.minutes = Es(e.minutes)),
    (e.hours = Es(e.hours)),
    (e.months = Es(e.months)),
    (e.years = Es(e.years)),
    this
  )
}
function rS(e, t, i, s) {
  var n = rs(t, i)
  return (
    (e._milliseconds += s * n._milliseconds),
    (e._days += s * n._days),
    (e._months += s * n._months),
    e._bubble()
  )
}
function b_(e, t) {
  return rS(this, e, t, 1)
}
function R_(e, t) {
  return rS(this, e, t, -1)
}
function Kg(e) {
  return e < 0 ? Math.floor(e) : Math.ceil(e)
}
function F_() {
  var e = this._milliseconds,
    t = this._days,
    i = this._months,
    s = this._data,
    n,
    r,
    o,
    a,
    l
  return (
    (e >= 0 && t >= 0 && i >= 0) ||
      (e <= 0 && t <= 0 && i <= 0) ||
      ((e += Kg(mu(i) + t) * 864e5), (t = 0), (i = 0)),
    (s.milliseconds = e % 1e3),
    (n = Vi(e / 1e3)),
    (s.seconds = n % 60),
    (r = Vi(n / 60)),
    (s.minutes = r % 60),
    (o = Vi(r / 60)),
    (s.hours = o % 24),
    (t += Vi(o / 24)),
    (l = Vi(oS(t))),
    (i += l),
    (t -= Kg(mu(l))),
    (a = Vi(i / 12)),
    (i %= 12),
    (s.days = t),
    (s.months = i),
    (s.years = a),
    this
  )
}
function oS(e) {
  return (e * 4800) / 146097
}
function mu(e) {
  return (e * 146097) / 4800
}
function E_(e) {
  if (!this.isValid()) return NaN
  var t,
    i,
    s = this._milliseconds
  if (((e = ji(e)), e === 'month' || e === 'quarter' || e === 'year'))
    switch (((t = this._days + s / 864e5), (i = this._months + oS(t)), e)) {
      case 'month':
        return i
      case 'quarter':
        return i / 3
      case 'year':
        return i / 12
    }
  else
    switch (((t = this._days + Math.round(mu(this._months))), e)) {
      case 'week':
        return t / 7 + s / 6048e5
      case 'day':
        return t + s / 864e5
      case 'hour':
        return t * 24 + s / 36e5
      case 'minute':
        return t * 1440 + s / 6e4
      case 'second':
        return t * 86400 + s / 1e3
      case 'millisecond':
        return Math.floor(t * 864e5) + s
      default:
        throw new Error('Unknown unit ' + e)
    }
}
function Ks(e) {
  return function () {
    return this.as(e)
  }
}
var aS = Ks('ms'),
  P_ = Ks('s'),
  x_ = Ks('m'),
  D_ = Ks('h'),
  M_ = Ks('d'),
  I_ = Ks('w'),
  T_ = Ks('M'),
  A_ = Ks('Q'),
  O_ = Ks('y'),
  L_ = aS
function k_() {
  return rs(this)
}
function H_(e) {
  return (e = ji(e)), this.isValid() ? this[e + 's']() : NaN
}
function qn(e) {
  return function () {
    return this.isValid() ? this._data[e] : NaN
  }
}
var N_ = qn('milliseconds'),
  G_ = qn('seconds'),
  B_ = qn('minutes'),
  V_ = qn('hours'),
  __ = qn('days'),
  W_ = qn('months'),
  $_ = qn('years')
function z_() {
  return Vi(this.days() / 7)
}
var Ps = Math.round,
  rr = { ss: 44, s: 45, m: 45, h: 22, d: 26, w: null, M: 11 }
function U_(e, t, i, s, n) {
  return n.relativeTime(t || 1, !!i, e, s)
}
function j_(e, t, i, s) {
  var n = rs(e).abs(),
    r = Ps(n.as('s')),
    o = Ps(n.as('m')),
    a = Ps(n.as('h')),
    l = Ps(n.as('d')),
    c = Ps(n.as('M')),
    u = Ps(n.as('w')),
    h = Ps(n.as('y')),
    g =
      (r <= i.ss && ['s', r]) ||
      (r < i.s && ['ss', r]) ||
      (o <= 1 && ['m']) ||
      (o < i.m && ['mm', o]) ||
      (a <= 1 && ['h']) ||
      (a < i.h && ['hh', a]) ||
      (l <= 1 && ['d']) ||
      (l < i.d && ['dd', l])
  return (
    i.w != null && (g = g || (u <= 1 && ['w']) || (u < i.w && ['ww', u])),
    (g = g ||
      (c <= 1 && ['M']) ||
      (c < i.M && ['MM', c]) ||
      (h <= 1 && ['y']) || ['yy', h]),
    (g[2] = t),
    (g[3] = +e > 0),
    (g[4] = s),
    U_.apply(null, g)
  )
}
function Y_(e) {
  return e === void 0 ? Ps : typeof e == 'function' ? ((Ps = e), !0) : !1
}
function K_(e, t) {
  return rr[e] === void 0
    ? !1
    : t === void 0
      ? rr[e]
      : ((rr[e] = t), e === 's' && (rr.ss = t - 1), !0)
}
function q_(e, t) {
  if (!this.isValid()) return this.localeData().invalidDate()
  var i = !1,
    s = rr,
    n,
    r
  return (
    typeof e == 'object' && ((t = e), (e = !1)),
    typeof e == 'boolean' && (i = e),
    typeof t == 'object' &&
      ((s = Object.assign({}, rr, t)),
      t.s != null && t.ss == null && (s.ss = t.s - 1)),
    (n = this.localeData()),
    (r = j_(this, !i, s, n)),
    i && (r = n.pastFuture(+this, r)),
    n.postformat(r)
  )
}
var Fc = Math.abs
function tr(e) {
  return (e > 0) - (e < 0) || +e
}
function Al() {
  if (!this.isValid()) return this.localeData().invalidDate()
  var e = Fc(this._milliseconds) / 1e3,
    t = Fc(this._days),
    i = Fc(this._months),
    s,
    n,
    r,
    o,
    a = this.asSeconds(),
    l,
    c,
    u,
    h
  return a
    ? ((s = Vi(e / 60)),
      (n = Vi(s / 60)),
      (e %= 60),
      (s %= 60),
      (r = Vi(i / 12)),
      (i %= 12),
      (o = e ? e.toFixed(3).replace(/\.?0+$/, '') : ''),
      (l = a < 0 ? '-' : ''),
      (c = tr(this._months) !== tr(a) ? '-' : ''),
      (u = tr(this._days) !== tr(a) ? '-' : ''),
      (h = tr(this._milliseconds) !== tr(a) ? '-' : ''),
      l +
        'P' +
        (r ? c + r + 'Y' : '') +
        (i ? c + i + 'M' : '') +
        (t ? u + t + 'D' : '') +
        (n || s || e ? 'T' : '') +
        (n ? h + n + 'H' : '') +
        (s ? h + s + 'M' : '') +
        (e ? h + o + 'S' : ''))
    : 'P0D'
}
var ct = Il.prototype
ct.isValid = WB
ct.abs = y_
ct.add = b_
ct.subtract = R_
ct.as = E_
ct.asMilliseconds = aS
ct.asSeconds = P_
ct.asMinutes = x_
ct.asHours = D_
ct.asDays = M_
ct.asWeeks = I_
ct.asMonths = T_
ct.asQuarters = A_
ct.asYears = O_
ct.valueOf = L_
ct._bubble = F_
ct.clone = k_
ct.get = H_
ct.milliseconds = N_
ct.seconds = G_
ct.minutes = B_
ct.hours = V_
ct.days = __
ct.weeks = z_
ct.months = W_
ct.years = $_
ct.humanize = q_
ct.toISOString = Al
ct.toString = Al
ct.toJSON = Al
ct.locale = KC
ct.localeData = QC
ct.toIsoString = Ui(
  'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
  Al,
)
ct.lang = qC
Ve('X', 0, 0, 'unix')
Ve('x', 0, 0, 'valueOf')
Pe('x', Pl)
Pe('X', mG)
wt('X', function (e, t, i) {
  i._d = new Date(parseFloat(e) * 1e3)
})
wt('x', function (e, t, i) {
  i._d = new Date(lt(e))
}) //! moment.js
Re.version = '2.30.1'
QN(xt)
Re.fn = he
Re.min = GB
Re.max = BB
Re.now = VB
Re.utc = Ss
Re.unix = f_
Re.months = m_
Re.isDate = Vo
Re.locale = an
Re.invalid = bl
Re.duration = rs
Re.isMoment = is
Re.weekdays = C_
Re.parseZone = p_
Re.localeData = Ys
Re.isDuration = va
Re.monthsShort = v_
Re.weekdaysMin = w_
Re.defineLocale = Qd
Re.updateLocale = pB
Re.locales = mB
Re.weekdaysShort = S_
Re.normalizeUnits = ji
Re.relativeTimeRounding = Y_
Re.relativeTimeThreshold = K_
Re.calendarFormat = dV
Re.prototype = he
Re.HTML5_FMT = {
  DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
  DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
  DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
  DATE: 'YYYY-MM-DD',
  TIME: 'HH:mm',
  TIME_SECONDS: 'HH:mm:ss',
  TIME_MS: 'HH:mm:ss.SSS',
  WEEK: 'GGGG-[W]WW',
  MONTH: 'YYYY-MM',
}
const Q_ = ({ status: e }) => {
    let t, i
    switch (e) {
      case 3059001:
        ;(t = 'green'), (i = 'Official')
        break
      case 3059002:
        ;(t = 'geekblue'), (i = 'Seasonal')
        break
      default:
        ;(t = 'default'), (i = 'Default ')
        break
    }
    return Oe.jsx(zp, { color: t, children: i })
  },
  X_ = [
    { headerCheckboxSelection: !0, checkboxSelection: !0 },
    {
      headerName: 'STT',
      valueGetter: 'node.rowIndex + 1',
      sortable: !1,
      filter: !1,
      width: 100,
    },
    { field: 'EmpFamilyName', headerName: 'H', sortable: !0, filter: !0 },
    { field: 'EmpFirstName', headerName: 'Tn', sortable: !0, filter: !0 },
    { field: 'EmpName', headerName: 'H v Tn', sortable: !0, filter: !0 },
    { field: 'EmpID', headerName: 'M nhn vin', sortable: !0, filter: !0 },
    { field: 'ResidID', headerName: 'ResidID', sortable: !0, filter: !0 },
    {
      field: 'EntDate',
      headerName: 'Ngy gia nhp',
      sortable: !0,
      filter: !0,
      valueFormatter: (e) =>
        e.value ? Re(e.value, 'YYYYMMDD').format('DD-MM-YYYY') : '',
    },
    {
      field: 'UMEmpType',
      headerName: 'Loi nhn vin',
      sortable: !0,
      filter: !0,
      cellRenderer: (e) => Oe.jsx(Q_, { status: e.value }),
    },
    {
      field: 'BirthDate',
      headerName: 'Ngy sinh',
      sortable: !0,
      filter: !0,
      valueFormatter: (e) =>
        e.value ? Re(e.value, 'YYYYMMDD').format('DD-MM-YYYY') : '',
    },
    {
      field: 'EmpEngFirstName',
      headerName: 'EmpEngFirstName',
      sortable: !0,
      filter: !0,
    },
    {
      field: 'EmpEngLastName',
      headerName: 'EmpEngLastName',
      sortable: !0,
      filter: !0,
    },
    { field: 'Remark', headerName: 'Ghi ch', sortable: !0, filter: !0 },
  ]
function J_({ data: e, loading: t }) {
  const [i, s] = d.useState(null),
    [n, r] = d.useState(null),
    o = (c) => {
      s(c.api), r(c.columnApi)
    },
    a = (c) => {
      console.log('Thng tin hng:', c.data)
    },
    l = d.useMemo(() => ({ resizable: !0, flex: 1, minWidth: 100 }), [])
  return Oe.jsx('div', {
    className: 'ag-theme-quartz h-full',
    children: Oe.jsx(qN, {
      rowData: e,
      columnDefs: X_,
      defaultColDef: l,
      onGridReady: o,
      onRowClicked: a,
      rowSelection: 'multiple',
      pagination: !0,
      paginationPageSize: 1e3,
    }),
  })
}
const Z_ = (e) => `
    <ROOT>
        <DataBlock1>
            <WorkingTag>${e.workingTag}</WorkingTag>
            <IDX_NO>${e.idx_no}</IDX_NO>
            <Status>${e.status}</Status>
            <DataSeq>${e.dataSeq}</DataSeq>
            <Selected>${e.selected}</Selected>
            <TABLE_NAME>DataBlock1</TABLE_NAME>
            <IsChangedMst>${e.isChangedMst}</IsChangedMst>
            <FrEntDate>${e.frEntDate}</FrEntDate>
            <ToEntDate>${e.toEntDate}</ToEntDate>
            <UMEmpType>${e.umEmpType}</UMEmpType>
            <EmpSeq>${e.empSeq}</EmpSeq>
        </DataBlock1>
    </ROOT>`,
  eW = {
    xmlFlags: 2,
    serviceSeq: 1613,
    workingTag: '',
    companySeq: 1,
    languageSeq: 6,
    userSeq: 18770,
    pgmSeq: 1791,
  },
  tW = (e) => {
    const t = { ...eW, ...e },
      s = {
        xmlDocument: Z_(t),
        xmlFlags: t.xmlFlags,
        serviceSeq: t.serviceSeq,
        workingTag: t.workingTag,
        companySeq: t.companySeq,
        languageSeq: t.languageSeq,
        userSeq: t.userSeq,
        pgmSeq: t.pgmSeq,
      }
    return Wt.post(`${no}/mssql/users/SHREmpInQuery`, s, {
      headers: { 'Content-Type': 'application/json' },
    })
      .then((n) => {
        if (n.status === 200 || n.status === 201) return n.data
        throw new Error('Error from API: ' + n.data.message)
      })
      .catch((n) => {
        const r = n.response
          ? n.response.data.message || 'Error from API'
          : 'Unknown error occurred'
        throw new Error(r)
      })
  },
  { Content: iW } = uf,
  sW = d.lazy(() =>
    US(() => import('./sheetUsers-BH1xEubn.js'), __vite__mapDeps([0, 1, 2, 3])),
  )
function nW({ permissions: e, isMobile: t }) {
  const { t: i } = cf(),
    [s, n] = d.useState(!1),
    [r, o] = d.useState('Table'),
    [a, l] = d.useState(!0),
    [c, u] = d.useState(!1),
    [h, g] = d.useState(''),
    [f, p] = d.useState(''),
    [v, m] = d.useState([]),
    [C, w] = d.useState(!1),
    [S, y] = d.useState(0),
    [F, R] = d.useState([null, null]),
    [b, x] = d.useState(!1),
    [D, O] =
      Array.isArray(F) && F.length === 2
        ? F.map((I, P) =>
            I ? I.format('YYYYMMDD') : P === 0 ? '20240101' : '',
          )
        : [null, null],
    M = d.useCallback(() => {
      s || n(!0)
    }, [s]),
    L = {
      workingTag: 'A',
      idx_no: '1',
      status: '0',
      dataSeq: '1',
      selected: '1',
      isChangedMst: '0',
      umEmpType: S,
      empSeq: '',
      frEntDate: D,
      toEntDate: O,
    }
  d.useEffect(() => {
    l(!0)
    const I = setTimeout(() => {
      tW(L)
        .then((P) => {
          m(P.data), l(!1)
        })
        .catch((P) => {
          l(!1)
        })
    }, 100)
    return () => clearTimeout(I)
  }, [S, D, O]),
    d.useEffect(() => {
      M()
    }, [M])
  const V = async () => {
      u(!0), g('')
      try {
        ;(await nx(f)).success && x(!0)
      } catch (I) {
        g(
          'Error from API: ' +
            (I.response ? I.response.data.message : I.message),
        )
      } finally {
        u(!1)
      }
    },
    A = d.useMemo(
      () =>
        a
          ? Oe.jsx(oh, {})
          : r === 'Table'
            ? Oe.jsx(J_, {
                isDrawerVisible: C,
                data: v,
                loading: a,
                setIsDrawerVisible: w,
              })
            : s &&
              Oe.jsx(d.Suspense, {
                fallback: Oe.jsx(oh, {}),
                children: Oe.jsx(sW, { data: v, loading: a }),
              }),
      [r, v, a, s, C],
    )
  return Oe.jsxs('div', {
    className: 'w-full h-screen flex flex-col bg-slate-50',
    children: [
      Oe.jsx(zS, {
        children: Oe.jsxs('title', {
          children: ['ITM - ', i('NG K THNH VIN MI')],
        }),
      }),
      Oe.jsxs('div', {
        className: 'p-2 flex flex-col',
        children: [
          Oe.jsx('h1', {
            className: 'text-base font-bold text-gray-900',
            children: i('NG K THNH VIN MI'),
          }),
          Oe.jsx(ox, {
            setValue: o,
            value: r,
            setIsDrawerVisible: w,
            isDrawerVisible: C,
            setUmEmpType: y,
            setDateRange: R,
            dateRange: F,
            handleSearch: V,
            loadingCodeHelp: c,
            setKeyword: p,
            keyword: f,
          }),
        ],
      }),
      Oe.jsx(uf, {
        className: 'p-2 bg-slate-50',
        children: Oe.jsx(iW, {
          className: 'flex-1 h-screen overflow-auto bg-slate-50',
          children: A,
        }),
      }),
    ],
  })
}
const cW = Object.freeze(
  Object.defineProperty({ __proto__: null, default: nW }, Symbol.toStringTag, {
    value: 'Module',
  }),
)
export { Re as h, cW as u }
